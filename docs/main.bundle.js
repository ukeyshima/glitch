/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 71);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(33)('wks');
var uid = __webpack_require__(21);
var Symbol = __webpack_require__(0).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 2 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.3' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(0);
var core = __webpack_require__(2);
var ctx = __webpack_require__(13);
var hide = __webpack_require__(9);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(7);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 5 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(4);
var IE8_DOM_DEFINE = __webpack_require__(43);
var toPrimitive = __webpack_require__(28);
var dP = Object.defineProperty;

exports.f = __webpack_require__(8) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(14)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(6);
var createDesc = __webpack_require__(18);
module.exports = __webpack_require__(8) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 10 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(50);
var defined = __webpack_require__(30);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(17);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 16 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(49);
var enumBugKeys = __webpack_require__(34);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 21 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(6).f;
var has = __webpack_require__(10);
var TAG = __webpack_require__(1)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 23 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(103);
} else {
  module.exports = __webpack_require__(104);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(7);
var document = __webpack_require__(0).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(7);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 29 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 30 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(4);
var dPs = __webpack_require__(80);
var enumBugKeys = __webpack_require__(34);
var IE_PROTO = __webpack_require__(32)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(27)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(52).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(33)('keys');
var uid = __webpack_require__(21);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(0);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),
/* 34 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(1);


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(0);
var core = __webpack_require__(2);
var LIBRARY = __webpack_require__(19);
var wksExt = __webpack_require__(35);
var defineProperty = __webpack_require__(6).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 37 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(12);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(17);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(73);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(8) && !__webpack_require__(14)(function () {
  return Object.defineProperty(__webpack_require__(27)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__(45);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(76);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(87);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(78)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(47)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(19);
var $export = __webpack_require__(3);
var redefine = __webpack_require__(48);
var hide = __webpack_require__(9);
var has = __webpack_require__(10);
var Iterators = __webpack_require__(15);
var $iterCreate = __webpack_require__(79);
var setToStringTag = __webpack_require__(22);
var getPrototypeOf = __webpack_require__(83);
var ITERATOR = __webpack_require__(1)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = (!BUGGY && $native) || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(9);


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(10);
var toIObject = __webpack_require__(11);
var arrayIndexOf = __webpack_require__(81)(false);
var IE_PROTO = __webpack_require__(32)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(16);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(29);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(0).document;
module.exports = document && document.documentElement;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(30);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(84);
var global = __webpack_require__(0);
var hide = __webpack_require__(9);
var Iterators = __webpack_require__(15);
var TO_STRING_TAG = __webpack_require__(1)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(49);
var hiddenKeys = __webpack_require__(34).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(23);
var createDesc = __webpack_require__(18);
var toIObject = __webpack_require__(11);
var toPrimitive = __webpack_require__(28);
var has = __webpack_require__(10);
var IE8_DOM_DEFINE = __webpack_require__(43);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(8) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 57 */
/***/ (function(module, exports) {



/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _setPrototypeOf = __webpack_require__(96);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(100);

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__(45);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(38);
  var warning = __webpack_require__(39);
  var ReactPropTypesSecret = __webpack_require__(105);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(16);
var TAG = __webpack_require__(1)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(4);
var aFunction = __webpack_require__(17);
var SPECIES = __webpack_require__(1)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(13);
var invoke = __webpack_require__(124);
var html = __webpack_require__(52);
var cel = __webpack_require__(27);
var global = __webpack_require__(0);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(16)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(4);
var isObject = __webpack_require__(7);
var newPromiseCapability = __webpack_require__(40);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(12);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */
function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = __webpack_require__(141);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(72);


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck2 = __webpack_require__(41);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(42);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(44);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(58);

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(24);

var _react2 = _interopRequireDefault(_react);

var _createCanvas = __webpack_require__(106);

var _createCanvas2 = _interopRequireDefault(_createCanvas);

__webpack_require__(134);

var _reactDom = __webpack_require__(139);

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Glitch = function (_React$Component) {
  (0, _inherits3.default)(Glitch, _React$Component);

  function Glitch(props) {
    (0, _classCallCheck3.default)(this, Glitch);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Glitch.__proto__ || Object.getPrototypeOf(Glitch)).call(this, props));

    _this.state = {
      width: window.innerWidth,
      height: window.innerHeight
    };
    return _this;
  }

  (0, _createClass3.default)(Glitch, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      document.body.style.overflow = "hidden";
      this.tempHandleResize = this.handleResize.bind(this);
      window.addEventListener("resize", this.tempHandleResize);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener("resize", this.tempHandleResize);
    }
  }, {
    key: "handleResize",
    value: function handleResize(e) {
      var width = e.target.innerWidth;
      var height = e.target.innerHeight;
      this.refs.createCanvas.handleResize(width, height);
      this.setState({
        width: width,
        height: height
      });
    }
  }, {
    key: "render",
    value: function render() {
      return _react2.default.createElement(
        _react2.default.Fragment,
        null,
        _react2.default.createElement(_createCanvas2.default, {
          ref: "createCanvas",
          style: {
            width: this.state.width,
            height: this.state.height
          }
        }),
        _react2.default.createElement(
          "p",
          {
            id: "title",
            style: {
              position: "absolute",
              bottom: "20px",
              left: "20px",
              fontSize: "100px",
              margin: 0
            }
          },
          location.hash.split("/")[1]
        )
      );
    }
  }]);
  return Glitch;
}(_react2.default.Component);

_reactDom2.default.render(_react2.default.createElement(Glitch, null), document.getElementById("root"));

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(74), __esModule: true };

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(75);
var $Object = __webpack_require__(2).Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(3);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(8), 'Object', { defineProperty: __webpack_require__(6).f });


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(77), __esModule: true };

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(46);
__webpack_require__(54);
module.exports = __webpack_require__(35).f('iterator');


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(29);
var defined = __webpack_require__(30);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(31);
var descriptor = __webpack_require__(18);
var setToStringTag = __webpack_require__(22);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(9)(IteratorPrototype, __webpack_require__(1)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(6);
var anObject = __webpack_require__(4);
var getKeys = __webpack_require__(20);

module.exports = __webpack_require__(8) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(11);
var toLength = __webpack_require__(51);
var toAbsoluteIndex = __webpack_require__(82);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(29);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(10);
var toObject = __webpack_require__(53);
var IE_PROTO = __webpack_require__(32)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(85);
var step = __webpack_require__(86);
var Iterators = __webpack_require__(15);
var toIObject = __webpack_require__(11);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(47)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 85 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(88), __esModule: true };

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(89);
__webpack_require__(57);
__webpack_require__(94);
__webpack_require__(95);
module.exports = __webpack_require__(2).Symbol;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(0);
var has = __webpack_require__(10);
var DESCRIPTORS = __webpack_require__(8);
var $export = __webpack_require__(3);
var redefine = __webpack_require__(48);
var META = __webpack_require__(90).KEY;
var $fails = __webpack_require__(14);
var shared = __webpack_require__(33);
var setToStringTag = __webpack_require__(22);
var uid = __webpack_require__(21);
var wks = __webpack_require__(1);
var wksExt = __webpack_require__(35);
var wksDefine = __webpack_require__(36);
var enumKeys = __webpack_require__(91);
var isArray = __webpack_require__(92);
var anObject = __webpack_require__(4);
var isObject = __webpack_require__(7);
var toIObject = __webpack_require__(11);
var toPrimitive = __webpack_require__(28);
var createDesc = __webpack_require__(18);
var _create = __webpack_require__(31);
var gOPNExt = __webpack_require__(93);
var $GOPD = __webpack_require__(56);
var $DP = __webpack_require__(6);
var $keys = __webpack_require__(20);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(55).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(23).f = $propertyIsEnumerable;
  __webpack_require__(37).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(19)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(9)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(21)('meta');
var isObject = __webpack_require__(7);
var has = __webpack_require__(10);
var setDesc = __webpack_require__(6).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(14)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(20);
var gOPS = __webpack_require__(37);
var pIE = __webpack_require__(23);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(16);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(11);
var gOPN = __webpack_require__(55).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(36)('asyncIterator');


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(36)('observable');


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(97), __esModule: true };

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(98);
module.exports = __webpack_require__(2).Object.setPrototypeOf;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(3);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(99).set });


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(7);
var anObject = __webpack_require__(4);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(13)(Function.call, __webpack_require__(56).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(101), __esModule: true };

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(102);
var $Object = __webpack_require__(2).Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(3);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(31) });


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var m=__webpack_require__(25),n=__webpack_require__(26),p=__webpack_require__(12),q="function"===typeof Symbol&&Symbol["for"],r=q?Symbol["for"]("react.element"):60103,t=q?Symbol["for"]("react.call"):60104,u=q?Symbol["for"]("react.return"):60105,v=q?Symbol["for"]("react.portal"):60106,w=q?Symbol["for"]("react.fragment"):60107,x="function"===typeof Symbol&&Symbol.iterator;
function y(a){for(var b=arguments.length-1,e="Minified React error #"+a+"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d"+a,c=0;c<b;c++)e+="\x26args[]\x3d"+encodeURIComponent(arguments[c+1]);b=Error(e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name="Invariant Violation";b.framesToPop=1;throw b;}
var z={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}};function A(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}A.prototype.isReactComponent={};A.prototype.setState=function(a,b){"object"!==typeof a&&"function"!==typeof a&&null!=a?y("85"):void 0;this.updater.enqueueSetState(this,a,b,"setState")};A.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};
function B(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}function C(){}C.prototype=A.prototype;var D=B.prototype=new C;D.constructor=B;m(D,A.prototype);D.isPureReactComponent=!0;function E(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}var F=E.prototype=new C;F.constructor=E;m(F,A.prototype);F.unstable_isAsyncReactComponent=!0;F.render=function(){return this.props.children};var G={current:null},H=Object.prototype.hasOwnProperty,I={key:!0,ref:!0,__self:!0,__source:!0};
function J(a,b,e){var c,d={},g=null,k=null;if(null!=b)for(c in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b)H.call(b,c)&&!I.hasOwnProperty(c)&&(d[c]=b[c]);var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){for(var h=Array(f),l=0;l<f;l++)h[l]=arguments[l+2];d.children=h}if(a&&a.defaultProps)for(c in f=a.defaultProps,f)void 0===d[c]&&(d[c]=f[c]);return{$$typeof:r,type:a,key:g,ref:k,props:d,_owner:G.current}}function K(a){return"object"===typeof a&&null!==a&&a.$$typeof===r}
function escape(a){var b={"\x3d":"\x3d0",":":"\x3d2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var L=/\/+/g,M=[];function N(a,b,e,c){if(M.length){var d=M.pop();d.result=a;d.keyPrefix=b;d.func=e;d.context=c;d.count=0;return d}return{result:a,keyPrefix:b,func:e,context:c,count:0}}function O(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>M.length&&M.push(a)}
function P(a,b,e,c){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case r:case t:case u:case v:g=!0}}if(g)return e(c,a,""===b?"."+Q(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){d=a[k];var f=b+Q(d,k);g+=P(d,f,e,c)}else if(null===a||"undefined"===typeof a?f=null:(f=x&&a[x]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=
f.call(a),k=0;!(d=a.next()).done;)d=d.value,f=b+Q(d,k++),g+=P(d,f,e,c);else"object"===d&&(e=""+a,y("31","[object Object]"===e?"object with keys {"+Object.keys(a).join(", ")+"}":e,""));return g}function Q(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function R(a,b){a.func.call(a.context,b,a.count++)}
function S(a,b,e){var c=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?T(a,c,e,p.thatReturnsArgument):null!=a&&(K(a)&&(b=d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(L,"$\x26/")+"/")+e,a={$$typeof:r,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}),c.push(a))}function T(a,b,e,c,d){var g="";null!=e&&(g=(""+e).replace(L,"$\x26/")+"/");b=N(b,g,c,d);null==a||P(a,"",S,b);O(b)}
var U={Children:{map:function(a,b,e){if(null==a)return a;var c=[];T(a,c,null,b,e);return c},forEach:function(a,b,e){if(null==a)return a;b=N(null,null,b,e);null==a||P(a,"",R,b);O(b)},count:function(a){return null==a?0:P(a,"",p.thatReturnsNull,null)},toArray:function(a){var b=[];T(a,b,null,p.thatReturnsArgument);return b},only:function(a){K(a)?void 0:y("143");return a}},Component:A,PureComponent:B,unstable_AsyncComponent:E,Fragment:w,createElement:J,cloneElement:function(a,b,e){var c=m({},a.props),
d=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=G.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var f=a.type.defaultProps;for(h in b)H.call(b,h)&&!I.hasOwnProperty(h)&&(c[h]=void 0===b[h]&&void 0!==f?f[h]:b[h])}var h=arguments.length-2;if(1===h)c.children=e;else if(1<h){f=Array(h);for(var l=0;l<h;l++)f[l]=arguments[l+2];c.children=f}return{$$typeof:r,type:a.type,key:d,ref:g,props:c,_owner:k}},createFactory:function(a){var b=J.bind(null,a);b.type=a;return b},
isValidElement:K,version:"16.2.0",__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentOwner:G,assign:m}},V=Object.freeze({default:U}),W=V&&U||V;module.exports=W["default"]?W["default"]:W;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

var _assign = __webpack_require__(25);
var emptyObject = __webpack_require__(26);
var invariant = __webpack_require__(38);
var warning = __webpack_require__(39);
var emptyFunction = __webpack_require__(12);
var checkPropTypes = __webpack_require__(59);

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.2.0';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable === 'undefined') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var constructor = publicInstance.constructor;
    var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
    var warningKey = componentName + '.' + callerName;
    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }
    warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

/**
 * Base class helpers for the updating state of a component.
 */
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
Component.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
        return undefined;
      }
    });
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

/**
 * Base class helpers for the updating state of a component.
 */
function PureComponent(props, context, updater) {
  // Duplicated from Component.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;
var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent;
// Avoid an extra prototype jump for these methods.
_assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = true;

function AsyncComponent(props, context, updater) {
  // Duplicated from Component.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
asyncComponentPrototype.constructor = AsyncComponent;
// Avoid an extra prototype jump for these methods.
_assign(asyncComponentPrototype, Component.prototype);
asyncComponentPrototype.unstable_isAsyncReactComponent = true;
asyncComponentPrototype.render = function () {
  return this.props.children;
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var hasOwnProperty = Object.prototype.hasOwnProperty;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown;
var specialPropRefWarningShown;

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    });
    // self and source are DEV only properties.
    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    });
    // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.
    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */
function createElement(type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}

/**
 * Return a function that produces ReactElements of a given type.
 * See https://reactjs.org/docs/react-api.html#createfactory
 */


function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
}

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */
function cloneElement(element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}

/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var ReactDebugCurrentFrame = {};

{
  // Component that is being worked on
  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var impl = ReactDebugCurrentFrame.getCurrentStack;
    if (impl) {
      return impl();
    }
    return null;
  };
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */
function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

var POOL_SIZE = 10;
var traverseContextPool = [];
function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
  if (traverseContextPool.length) {
    var traverseContext = traverseContextPool.pop();
    traverseContext.result = mapResult;
    traverseContext.keyPrefix = keyPrefix;
    traverseContext.func = mapFunction;
    traverseContext.context = mapContext;
    traverseContext.count = 0;
    return traverseContext;
  } else {
    return {
      result: mapResult,
      keyPrefix: keyPrefix,
      func: mapFunction,
      context: mapContext,
      count: 0
    };
  }
}

function releaseTraverseContext(traverseContext) {
  traverseContext.result = null;
  traverseContext.keyPrefix = null;
  traverseContext.func = null;
  traverseContext.context = null;
  traverseContext.count = 0;
  if (traverseContextPool.length < POOL_SIZE) {
    traverseContextPool.push(traverseContext);
  }
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;
      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_CALL_TYPE:
          case REACT_RETURN_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }
    }
  }

  if (invokeCallback) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (typeof iteratorFn === 'function') {
      {
        // Warn about using Maps as children
        if (iteratorFn === children.entries) {
          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(children);
      var step;
      var ii = 0;
      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getComponentKey(child, ii++);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else if (type === 'object') {
      var addendum = '';
      {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
      }
      var childrenString = '' + children;
      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof component === 'object' && component !== null && component.key != null) {
    // Explicit key
    return escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  releaseTraverseContext(traverseContext);
}

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  releaseTraverseContext(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
  return children;
}

var describeComponentFrame = function (name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
};

function getComponentName(fiber) {
  var type = fiber.type;

  if (typeof type === 'string') {
    return type;
  }
  if (typeof type === 'function') {
    return type.displayName || type.name;
  }
  return null;
}

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

{
  var currentlyValidatingElement = null;

  var propTypesMisspellWarningShown = false;

  var getDisplayName = function (element) {
    if (element == null) {
      return '#empty';
    } else if (typeof element === 'string' || typeof element === 'number') {
      return '#text';
    } else if (typeof element.type === 'string') {
      return element.type;
    } else if (element.type === REACT_FRAGMENT_TYPE) {
      return 'React.Fragment';
    } else {
      return element.type.displayName || element.type.name || 'Unknown';
    }
  };

  var getStackAddendum = function () {
    var stack = '';
    if (currentlyValidatingElement) {
      var name = getDisplayName(currentlyValidatingElement);
      var owner = currentlyValidatingElement._owner;
      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
    }
    stack += ReactDebugCurrentFrame.getStackAddendum() || '';
    return stack;
  };

  var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current);
    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = '\n\nCheck the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
  }

  currentlyValidatingElement = element;
  {
    warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
  }
  currentlyValidatingElement = null;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  var propTypes = componentClass.propTypes;
  if (propTypes) {
    currentlyValidatingElement = element;
    checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
    currentlyValidatingElement = null;
  } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {
    propTypesMisspellWarningShown = true;
    warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
  }
}

/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */
function validateFragmentProps(fragment) {
  currentlyValidatingElement = fragment;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      if (!VALID_FRAGMENT_PROPS.has(key)) {
        warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
        break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (fragment.ref !== null) {
    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
  }

  currentlyValidatingElement = null;
}

function createElementWithValidation(type, props, children) {
  var validType = typeof type === 'string' || typeof type === 'function' || typeof type === 'symbol' || typeof type === 'number';
  // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.
  if (!validType) {
    var info = '';
    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendum(props);
    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    info += getStackAddendum() || '';

    warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info);
  }

  var element = createElement.apply(this, arguments);

  // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.
  if (element == null) {
    return element;
  }

  // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)
  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (typeof type === 'symbol' && type === REACT_FRAGMENT_TYPE) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}

function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  // Legacy hook TODO: Warn if this is accessed
  validatedFactory.type = type;

  {
    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}

function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);
  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }
  validatePropTypes(newElement);
  return newElement;
}

var React = {
  Children: {
    map: mapChildren,
    forEach: forEachChildren,
    count: countChildren,
    toArray: toArray,
    only: onlyChild
  },

  Component: Component,
  PureComponent: PureComponent,
  unstable_AsyncComponent: AsyncComponent,

  Fragment: REACT_FRAGMENT_TYPE,

  createElement: createElementWithValidation,
  cloneElement: cloneElementWithValidation,
  createFactory: createFactoryWithValidation,
  isValidElement: isValidElement,

  version: ReactVersion,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    ReactCurrentOwner: ReactCurrentOwner,
    // Used by renderers to avoid bundling object-assign twice in UMD bundles:
    assign: _assign
  }
};

{
  _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
    // These should not be included in production.
    ReactDebugCurrentFrame: ReactDebugCurrentFrame,
    // Shim for React DOM 16.0.0 which still destructured (but not used) this.
    // TODO: remove in React 17.0.
    ReactComponentTreeHook: {}
  });
}



var React$2 = Object.freeze({
	default: React
});

var React$3 = ( React$2 && React ) || React$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var react = React$3['default'] ? React$3['default'] : React$3;

module.exports = react;
  })();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(107);

var _extends3 = _interopRequireDefault(_extends2);

var _regenerator = __webpack_require__(112);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(115);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(41);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(42);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(44);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(58);

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = __webpack_require__(24);

var _react2 = _interopRequireDefault(_react);

var _vertexShader = __webpack_require__(131);

var _vertexShader2 = _interopRequireDefault(_vertexShader);

var _fragmentShader = __webpack_require__(132);

var _fragmentShader2 = _interopRequireDefault(_fragmentShader);

var _texture = __webpack_require__(133);

var _texture2 = _interopRequireDefault(_texture);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var webGLStart = function webGLStart(canvas, gl, vs, fs) {
  var create_program = function create_program(vs, fs) {
    var program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
      gl.useProgram(program);
      return program;
    } else {
      return null;
    }
  };
  var create_shader = function create_shader(text, type) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, text);
    gl.compileShader(shader);
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      return shader;
    } else {
      alert(gl.getShaderInfoLog(shader));
      console.log(gl.getShaderInfoLog(shader));
    }
  };
  var create_vbo = function create_vbo(data) {
    var vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.DYNAMIC_COPY);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return vbo;
  };
  var create_ibo = function create_ibo(data) {
    var ibo = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    return ibo;
  };
  var set_attribute = function set_attribute(vbo, attL, attS) {
    vbo.forEach(function (e, i, a) {
      gl.bindBuffer(gl.ARRAY_BUFFER, e);
      gl.enableVertexAttribArray(attL[i]);
      gl.vertexAttribPointer(attL[i], attS[i], gl.FLOAT, false, 0, 0);
    });
  };
  var texture = void 0;
  var create_texture = function create_texture() {
    var img = new Image();
    img.src = _texture2.default;
    img.onload = function () {
      var tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.bindTexture(gl.TEXTURE_2D, null);
      texture = tex;
    };
  };
  var prg = create_program(create_shader(vs, gl.VERTEX_SHADER), create_shader(fs, gl.FRAGMENT_SHADER));
  var uniLocation = [];
  uniLocation[0] = gl.getUniformLocation(prg, "time");
  uniLocation[1] = gl.getUniformLocation(prg, "resolution");
  uniLocation[2] = gl.getUniformLocation(prg, "tex");

  var position = [-1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0];

  var vPosition = create_vbo(position, gl);
  var attLocation = new Array();
  attLocation[0] = gl.getAttribLocation(prg, "position");
  var attStride = new Array();
  attStride[0] = 3;
  set_attribute([vPosition], attLocation, attStride, gl);
  var index = [0, 2, 1, 1, 2, 3];
  var vIndex = create_ibo(index);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vIndex);
  gl.activeTexture(gl.TEXTURE0);
  create_texture();
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  var startTime = new Date().getTime();
  var render = function render() {
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.uniform1f(uniLocation[0], (new Date().getTime() - startTime) * 0.001);
    gl.uniform2fv(uniLocation[1], [canvas.width, canvas.height]);
    gl.uniform1i(uniLocation[2], 0);
    gl.drawElements(gl.TRIANGLES, index.length, gl.UNSIGNED_SHORT, 0);
    gl.flush();
  };
  return render;
};

var CreateCanvas = function (_React$Component) {
  (0, _inherits3.default)(CreateCanvas, _React$Component);

  function CreateCanvas(props) {
    (0, _classCallCheck3.default)(this, CreateCanvas);

    var _this = (0, _possibleConstructorReturn3.default)(this, (CreateCanvas.__proto__ || Object.getPrototypeOf(CreateCanvas)).call(this, props));

    _this.requestId = 0;
    return _this;
  }

  (0, _createClass3.default)(CreateCanvas, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateCanvas();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      cancelAnimationFrame(this.requestId);
    }
  }, {
    key: "updateCanvas",
    value: function () {
      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
        var _this2 = this;

        var render, loop;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.canvas.width = this.props.style.width;
                this.canvas.height = this.props.style.height;
                this.gl = this.canvas.getContext("webgl2");
                render = webGLStart(this.canvas, this.gl, (0, _vertexShader2.default)(), (0, _fragmentShader2.default)());

                loop = function loop() {
                  render();
                  _this2.requestId = requestAnimationFrame(loop);
                };

                loop();

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function updateCanvas() {
        return _ref.apply(this, arguments);
      }

      return updateCanvas;
    }()
  }, {
    key: "handleResize",
    value: function handleResize(w, h) {
      this.canvas.width = w;
      this.canvas.height = h;
      this.gl.viewport(0, 0, w, h);
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      return _react2.default.createElement("canvas", (0, _extends3.default)({}, this.props, {
        ref: function ref(e) {
          _this3.canvas = e;
        }
      }));
    }
  }]);
  return CreateCanvas;
}(_react2.default.Component);

exports.default = CreateCanvas;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__(108);

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(109), __esModule: true };

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(110);
module.exports = __webpack_require__(2).Object.assign;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(3);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(111) });


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(20);
var gOPS = __webpack_require__(37);
var pIE = __webpack_require__(23);
var toObject = __webpack_require__(53);
var IObject = __webpack_require__(50);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(14)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(113);


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(114);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 114 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _promise = __webpack_require__(116);

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(117), __esModule: true };

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(57);
__webpack_require__(46);
__webpack_require__(54);
__webpack_require__(118);
__webpack_require__(129);
__webpack_require__(130);
module.exports = __webpack_require__(2).Promise;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(19);
var global = __webpack_require__(0);
var ctx = __webpack_require__(13);
var classof = __webpack_require__(60);
var $export = __webpack_require__(3);
var isObject = __webpack_require__(7);
var aFunction = __webpack_require__(17);
var anInstance = __webpack_require__(119);
var forOf = __webpack_require__(120);
var speciesConstructor = __webpack_require__(61);
var task = __webpack_require__(62).set;
var microtask = __webpack_require__(125)();
var newPromiseCapabilityModule = __webpack_require__(40);
var perform = __webpack_require__(63);
var promiseResolve = __webpack_require__(64);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(1)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(126)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(22)($Promise, PROMISE);
__webpack_require__(127)(PROMISE);
Wrapper = __webpack_require__(2)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(128)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 119 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(13);
var call = __webpack_require__(121);
var isArrayIter = __webpack_require__(122);
var anObject = __webpack_require__(4);
var toLength = __webpack_require__(51);
var getIterFn = __webpack_require__(123);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(4);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(15);
var ITERATOR = __webpack_require__(1)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(60);
var ITERATOR = __webpack_require__(1)('iterator');
var Iterators = __webpack_require__(15);
module.exports = __webpack_require__(2).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 124 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(0);
var macrotask = __webpack_require__(62).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(16)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(9);
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(0);
var core = __webpack_require__(2);
var dP = __webpack_require__(6);
var DESCRIPTORS = __webpack_require__(8);
var SPECIES = __webpack_require__(1)('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(1)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(3);
var core = __webpack_require__(2);
var global = __webpack_require__(0);
var speciesConstructor = __webpack_require__(61);
var promiseResolve = __webpack_require__(64);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(3);
var newPromiseCapability = __webpack_require__(40);
var perform = __webpack_require__(63);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 131 */
/***/ (function(module, exports) {

module.exports = function(){return(['#version 300 es','in vec3 position;','void main(void){','    gl_Position = vec4(position, 1.0);','}'].join('\n'))}

/***/ }),
/* 132 */
/***/ (function(module, exports) {

module.exports = function(){return(['#version 300 es','precision highp float;','uniform float time;','uniform vec2 resolution;','uniform sampler2D tex;','out vec4 outColor;','#define PI 3.141592','float random(vec2 p){','    float q = dot(p,vec2(127.1,311.7));','    return fract(sin(q)*437.53);','}','vec4 glitch(vec2 p){','    float b=0.5;','    vec4 c=texture(tex,p);','   float t=time-mod(time,0.3);','    vec2 q=p-mod(p,b);','    for(float i=0.0;i<15.0;i++){','       if(random(q)>0.3){','           q=p-mod(p,b);','       }else{','           break;','       }','        b*=random(vec2(mod(time,1.5)))<0.3?1.0:clamp(sin(t/10.0-5.5),0.65-random(vec2(t/10.0-5.5)),0.65+random(vec2(t/10.0-5.5)));','      // b*=0.65;','    }','    c.a-=random(vec2(mod(time,1.5)))<0.3?0.0:0.3*random(q);','    c.rgb+=random(vec2(mod(time,1.5)))<0.3?vec3(0.0):vec3(random(q),random(vec2(q.y,0.0)),random(vec2(0.0,q.x)));','    c.rgb-=random(vec2(mod(time,1.5)))<0.3 && random(q)<0.01 ? vec3(0.0):texture(tex,p+vec2(random(q),0.0)).rgb;','    c.xyz-=random(vec2(mod(time,1.5)))<0.3?vec3(0.0):vec3(0.3*random(vec2(0.0,p.y+time/10.0)));','    c.xyz-=random(vec2(0.0,p.y-time/5.0-mod(p.y-time/5.0,0.02)))>0.9?texture(tex,p+vec2(0.0,random(q))).rgb:vec3(0.0);','    return c;','}','void main(void){','    vec2 p=vec2(gl_FragCoord.x/resolution.x,-gl_FragCoord.y/resolution.y);','    vec4 color=glitch(p);','    outColor = color;','}'].join('\n'))}

/***/ }),
/* 133 */
/***/ (function(module, exports) {

module.exports = "data:image/jpeg;base64,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"

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(135);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(137)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {
	module.hot.accept("!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./style.scss", function() {
		var newContent = require("!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./style.scss");

		if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(136)(false);
// imports


// module
exports.push([module.i, "body {\n  margin: 0;\n  padding: 0; }\n\n#root {\n  font-size: 0; }\n", ""]);

// exports


/***/ }),
/* 136 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target) {
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(138);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 138 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (process.env.NODE_ENV === 'production') {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(140);
} else {
  module.exports = __webpack_require__(143);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react-dom.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
var aa=__webpack_require__(24),l=__webpack_require__(65),B=__webpack_require__(25),C=__webpack_require__(12),ba=__webpack_require__(66),da=__webpack_require__(67),ea=__webpack_require__(68),fa=__webpack_require__(69),ia=__webpack_require__(70),D=__webpack_require__(26);
function E(a){for(var b=arguments.length-1,c="Minified React error #"+a+"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d"+a,d=0;d<b;d++)c+="\x26args[]\x3d"+encodeURIComponent(arguments[d+1]);b=Error(c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name="Invariant Violation";b.framesToPop=1;throw b;}aa?void 0:E("227");
var oa={children:!0,dangerouslySetInnerHTML:!0,defaultValue:!0,defaultChecked:!0,innerHTML:!0,suppressContentEditableWarning:!0,suppressHydrationWarning:!0,style:!0};function pa(a,b){return(a&b)===b}
var ta={MUST_USE_PROPERTY:1,HAS_BOOLEAN_VALUE:4,HAS_NUMERIC_VALUE:8,HAS_POSITIVE_NUMERIC_VALUE:24,HAS_OVERLOADED_BOOLEAN_VALUE:32,HAS_STRING_BOOLEAN_VALUE:64,injectDOMPropertyConfig:function(a){var b=ta,c=a.Properties||{},d=a.DOMAttributeNamespaces||{},e=a.DOMAttributeNames||{};a=a.DOMMutationMethods||{};for(var f in c){ua.hasOwnProperty(f)?E("48",f):void 0;var g=f.toLowerCase(),h=c[f];g={attributeName:g,attributeNamespace:null,propertyName:f,mutationMethod:null,mustUseProperty:pa(h,b.MUST_USE_PROPERTY),
hasBooleanValue:pa(h,b.HAS_BOOLEAN_VALUE),hasNumericValue:pa(h,b.HAS_NUMERIC_VALUE),hasPositiveNumericValue:pa(h,b.HAS_POSITIVE_NUMERIC_VALUE),hasOverloadedBooleanValue:pa(h,b.HAS_OVERLOADED_BOOLEAN_VALUE),hasStringBooleanValue:pa(h,b.HAS_STRING_BOOLEAN_VALUE)};1>=g.hasBooleanValue+g.hasNumericValue+g.hasOverloadedBooleanValue?void 0:E("50",f);e.hasOwnProperty(f)&&(g.attributeName=e[f]);d.hasOwnProperty(f)&&(g.attributeNamespace=d[f]);a.hasOwnProperty(f)&&(g.mutationMethod=a[f]);ua[f]=g}}},ua={};
function va(a,b){if(oa.hasOwnProperty(a)||2<a.length&&("o"===a[0]||"O"===a[0])&&("n"===a[1]||"N"===a[1]))return!1;if(null===b)return!0;switch(typeof b){case "boolean":return oa.hasOwnProperty(a)?a=!0:(b=wa(a))?a=b.hasBooleanValue||b.hasStringBooleanValue||b.hasOverloadedBooleanValue:(a=a.toLowerCase().slice(0,5),a="data-"===a||"aria-"===a),a;case "undefined":case "number":case "string":case "object":return!0;default:return!1}}function wa(a){return ua.hasOwnProperty(a)?ua[a]:null}
var xa=ta,ya=xa.MUST_USE_PROPERTY,K=xa.HAS_BOOLEAN_VALUE,za=xa.HAS_NUMERIC_VALUE,Aa=xa.HAS_POSITIVE_NUMERIC_VALUE,Ba=xa.HAS_OVERLOADED_BOOLEAN_VALUE,Ca=xa.HAS_STRING_BOOLEAN_VALUE,Da={Properties:{allowFullScreen:K,async:K,autoFocus:K,autoPlay:K,capture:Ba,checked:ya|K,cols:Aa,contentEditable:Ca,controls:K,"default":K,defer:K,disabled:K,download:Ba,draggable:Ca,formNoValidate:K,hidden:K,loop:K,multiple:ya|K,muted:ya|K,noValidate:K,open:K,playsInline:K,readOnly:K,required:K,reversed:K,rows:Aa,rowSpan:za,
scoped:K,seamless:K,selected:ya|K,size:Aa,start:za,span:Aa,spellCheck:Ca,style:0,tabIndex:0,itemScope:K,acceptCharset:0,className:0,htmlFor:0,httpEquiv:0,value:Ca},DOMAttributeNames:{acceptCharset:"accept-charset",className:"class",htmlFor:"for",httpEquiv:"http-equiv"},DOMMutationMethods:{value:function(a,b){if(null==b)return a.removeAttribute("value");"number"!==a.type||!1===a.hasAttribute("value")?a.setAttribute("value",""+b):a.validity&&!a.validity.badInput&&a.ownerDocument.activeElement!==a&&
a.setAttribute("value",""+b)}}},Ea=xa.HAS_STRING_BOOLEAN_VALUE,M={xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace"},Ga={Properties:{autoReverse:Ea,externalResourcesRequired:Ea,preserveAlpha:Ea},DOMAttributeNames:{autoReverse:"autoReverse",externalResourcesRequired:"externalResourcesRequired",preserveAlpha:"preserveAlpha"},DOMAttributeNamespaces:{xlinkActuate:M.xlink,xlinkArcrole:M.xlink,xlinkHref:M.xlink,xlinkRole:M.xlink,xlinkShow:M.xlink,xlinkTitle:M.xlink,xlinkType:M.xlink,
xmlBase:M.xml,xmlLang:M.xml,xmlSpace:M.xml}},Ha=/[\-\:]([a-z])/g;function Ia(a){return a[1].toUpperCase()}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space".split(" ").forEach(function(a){var b=a.replace(Ha,
Ia);Ga.Properties[b]=0;Ga.DOMAttributeNames[b]=a});xa.injectDOMPropertyConfig(Da);xa.injectDOMPropertyConfig(Ga);
var P={_caughtError:null,_hasCaughtError:!1,_rethrowError:null,_hasRethrowError:!1,injection:{injectErrorUtils:function(a){"function"!==typeof a.invokeGuardedCallback?E("197"):void 0;Ja=a.invokeGuardedCallback}},invokeGuardedCallback:function(a,b,c,d,e,f,g,h,k){Ja.apply(P,arguments)},invokeGuardedCallbackAndCatchFirstError:function(a,b,c,d,e,f,g,h,k){P.invokeGuardedCallback.apply(this,arguments);if(P.hasCaughtError()){var q=P.clearCaughtError();P._hasRethrowError||(P._hasRethrowError=!0,P._rethrowError=
q)}},rethrowCaughtError:function(){return Ka.apply(P,arguments)},hasCaughtError:function(){return P._hasCaughtError},clearCaughtError:function(){if(P._hasCaughtError){var a=P._caughtError;P._caughtError=null;P._hasCaughtError=!1;return a}E("198")}};function Ja(a,b,c,d,e,f,g,h,k){P._hasCaughtError=!1;P._caughtError=null;var q=Array.prototype.slice.call(arguments,3);try{b.apply(c,q)}catch(v){P._caughtError=v,P._hasCaughtError=!0}}
function Ka(){if(P._hasRethrowError){var a=P._rethrowError;P._rethrowError=null;P._hasRethrowError=!1;throw a;}}var La=null,Ma={};
function Na(){if(La)for(var a in Ma){var b=Ma[a],c=La.indexOf(a);-1<c?void 0:E("96",a);if(!Oa[c]){b.extractEvents?void 0:E("97",a);Oa[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;Pa.hasOwnProperty(h)?E("99",h):void 0;Pa[h]=f;var k=f.phasedRegistrationNames;if(k){for(e in k)k.hasOwnProperty(e)&&Qa(k[e],g,h);e=!0}else f.registrationName?(Qa(f.registrationName,g,h),e=!0):e=!1;e?void 0:E("98",d,a)}}}}
function Qa(a,b,c){Ra[a]?E("100",a):void 0;Ra[a]=b;Sa[a]=b.eventTypes[c].dependencies}var Oa=[],Pa={},Ra={},Sa={};function Ta(a){La?E("101"):void 0;La=Array.prototype.slice.call(a);Na()}function Ua(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];Ma.hasOwnProperty(c)&&Ma[c]===d||(Ma[c]?E("102",c):void 0,Ma[c]=d,b=!0)}b&&Na()}
var Va=Object.freeze({plugins:Oa,eventNameDispatchConfigs:Pa,registrationNameModules:Ra,registrationNameDependencies:Sa,possibleRegistrationNames:null,injectEventPluginOrder:Ta,injectEventPluginsByName:Ua}),Wa=null,Xa=null,Ya=null;function Za(a,b,c,d){b=a.type||"unknown-event";a.currentTarget=Ya(d);P.invokeGuardedCallbackAndCatchFirstError(b,c,void 0,a);a.currentTarget=null}
function $a(a,b){null==b?E("30"):void 0;if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function ab(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}var bb=null;
function cb(a,b){if(a){var c=a._dispatchListeners,d=a._dispatchInstances;if(Array.isArray(c))for(var e=0;e<c.length&&!a.isPropagationStopped();e++)Za(a,b,c[e],d[e]);else c&&Za(a,b,c,d);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}}function db(a){return cb(a,!0)}function gb(a){return cb(a,!1)}var hb={injectEventPluginOrder:Ta,injectEventPluginsByName:Ua};
function ib(a,b){var c=a.stateNode;if(!c)return null;var d=Wa(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;c&&"function"!==typeof c?E("231",b,typeof c):void 0;
return c}function jb(a,b,c,d){for(var e,f=0;f<Oa.length;f++){var g=Oa[f];g&&(g=g.extractEvents(a,b,c,d))&&(e=$a(e,g))}return e}function kb(a){a&&(bb=$a(bb,a))}function lb(a){var b=bb;bb=null;b&&(a?ab(b,db):ab(b,gb),bb?E("95"):void 0,P.rethrowCaughtError())}var mb=Object.freeze({injection:hb,getListener:ib,extractEvents:jb,enqueueEvents:kb,processEventQueue:lb}),nb=Math.random().toString(36).slice(2),Q="__reactInternalInstance$"+nb,ob="__reactEventHandlers$"+nb;
function pb(a){if(a[Q])return a[Q];for(var b=[];!a[Q];)if(b.push(a),a.parentNode)a=a.parentNode;else return null;var c=void 0,d=a[Q];if(5===d.tag||6===d.tag)return d;for(;a&&(d=a[Q]);a=b.pop())c=d;return c}function qb(a){if(5===a.tag||6===a.tag)return a.stateNode;E("33")}function rb(a){return a[ob]||null}
var sb=Object.freeze({precacheFiberNode:function(a,b){b[Q]=a},getClosestInstanceFromNode:pb,getInstanceFromNode:function(a){a=a[Q];return!a||5!==a.tag&&6!==a.tag?null:a},getNodeFromInstance:qb,getFiberCurrentPropsFromNode:rb,updateFiberProps:function(a,b){a[ob]=b}});function tb(a){do a=a["return"];while(a&&5!==a.tag);return a?a:null}function ub(a,b,c){for(var d=[];a;)d.push(a),a=tb(a);for(a=d.length;0<a--;)b(d[a],"captured",c);for(a=0;a<d.length;a++)b(d[a],"bubbled",c)}
function vb(a,b,c){if(b=ib(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=$a(c._dispatchListeners,b),c._dispatchInstances=$a(c._dispatchInstances,a)}function wb(a){a&&a.dispatchConfig.phasedRegistrationNames&&ub(a._targetInst,vb,a)}function xb(a){if(a&&a.dispatchConfig.phasedRegistrationNames){var b=a._targetInst;b=b?tb(b):null;ub(b,vb,a)}}
function yb(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=ib(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=$a(c._dispatchListeners,b),c._dispatchInstances=$a(c._dispatchInstances,a))}function zb(a){a&&a.dispatchConfig.registrationName&&yb(a._targetInst,null,a)}function Ab(a){ab(a,wb)}
function Bb(a,b,c,d){if(c&&d)a:{var e=c;for(var f=d,g=0,h=e;h;h=tb(h))g++;h=0;for(var k=f;k;k=tb(k))h++;for(;0<g-h;)e=tb(e),g--;for(;0<h-g;)f=tb(f),h--;for(;g--;){if(e===f||e===f.alternate)break a;e=tb(e);f=tb(f)}e=null}else e=null;f=e;for(e=[];c&&c!==f;){g=c.alternate;if(null!==g&&g===f)break;e.push(c);c=tb(c)}for(c=[];d&&d!==f;){g=d.alternate;if(null!==g&&g===f)break;c.push(d);d=tb(d)}for(d=0;d<e.length;d++)yb(e[d],"bubbled",a);for(a=c.length;0<a--;)yb(c[a],"captured",b)}
var Cb=Object.freeze({accumulateTwoPhaseDispatches:Ab,accumulateTwoPhaseDispatchesSkipTarget:function(a){ab(a,xb)},accumulateEnterLeaveDispatches:Bb,accumulateDirectDispatches:function(a){ab(a,zb)}}),Db=null;function Eb(){!Db&&l.canUseDOM&&(Db="textContent"in document.documentElement?"textContent":"innerText");return Db}var S={_root:null,_startText:null,_fallbackText:null};
function Fb(){if(S._fallbackText)return S._fallbackText;var a,b=S._startText,c=b.length,d,e=Gb(),f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);S._fallbackText=e.slice(a,1<d?1-d:void 0);return S._fallbackText}function Gb(){return"value"in S._root?S._root.value:S._root[Eb()]}
var Hb="dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),Ib={type:null,target:null,currentTarget:C.thatReturnsNull,eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};
function T(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?C.thatReturnsTrue:C.thatReturnsFalse;this.isPropagationStopped=C.thatReturnsFalse;return this}
B(T.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=C.thatReturnsTrue)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=C.thatReturnsTrue)},persist:function(){this.isPersistent=C.thatReturnsTrue},isPersistent:C.thatReturnsFalse,
destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;for(a=0;a<Hb.length;a++)this[Hb[a]]=null}});T.Interface=Ib;T.augmentClass=function(a,b){function c(){}c.prototype=this.prototype;var d=new c;B(d,a.prototype);a.prototype=d;a.prototype.constructor=a;a.Interface=B({},this.Interface,b);a.augmentClass=this.augmentClass;Jb(a)};Jb(T);function Kb(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}
function Lb(a){a instanceof this?void 0:E("223");a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function Jb(a){a.eventPool=[];a.getPooled=Kb;a.release=Lb}function Mb(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Mb,{data:null});function Nb(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Nb,{data:null});var Pb=[9,13,27,32],Vb=l.canUseDOM&&"CompositionEvent"in window,Wb=null;l.canUseDOM&&"documentMode"in document&&(Wb=document.documentMode);var Xb;
if(Xb=l.canUseDOM&&"TextEvent"in window&&!Wb){var Yb=window.opera;Xb=!("object"===typeof Yb&&"function"===typeof Yb.version&&12>=parseInt(Yb.version(),10))}
var Zb=Xb,$b=l.canUseDOM&&(!Vb||Wb&&8<Wb&&11>=Wb),ac=String.fromCharCode(32),bc={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["topCompositionEnd","topKeyPress","topTextInput","topPaste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",
captured:"onCompositionStartCapture"},dependencies:"topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")}},cc=!1;
function dc(a,b){switch(a){case "topKeyUp":return-1!==Pb.indexOf(b.keyCode);case "topKeyDown":return 229!==b.keyCode;case "topKeyPress":case "topMouseDown":case "topBlur":return!0;default:return!1}}function ec(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var fc=!1;function gc(a,b){switch(a){case "topCompositionEnd":return ec(b);case "topKeyPress":if(32!==b.which)return null;cc=!0;return ac;case "topTextInput":return a=b.data,a===ac&&cc?null:a;default:return null}}
function hc(a,b){if(fc)return"topCompositionEnd"===a||!Vb&&dc(a,b)?(a=Fb(),S._root=null,S._startText=null,S._fallbackText=null,fc=!1,a):null;switch(a){case "topPaste":return null;case "topKeyPress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "topCompositionEnd":return $b?null:b.data;default:return null}}
var ic={eventTypes:bc,extractEvents:function(a,b,c,d){var e;if(Vb)b:{switch(a){case "topCompositionStart":var f=bc.compositionStart;break b;case "topCompositionEnd":f=bc.compositionEnd;break b;case "topCompositionUpdate":f=bc.compositionUpdate;break b}f=void 0}else fc?dc(a,c)&&(f=bc.compositionEnd):"topKeyDown"===a&&229===c.keyCode&&(f=bc.compositionStart);f?($b&&(fc||f!==bc.compositionStart?f===bc.compositionEnd&&fc&&(e=Fb()):(S._root=d,S._startText=Gb(),fc=!0)),f=Mb.getPooled(f,b,c,d),e?f.data=
e:(e=ec(c),null!==e&&(f.data=e)),Ab(f),e=f):e=null;(a=Zb?gc(a,c):hc(a,c))?(b=Nb.getPooled(bc.beforeInput,b,c,d),b.data=a,Ab(b)):b=null;return[e,b]}},jc=null,kc=null,lc=null;function mc(a){if(a=Xa(a)){jc&&"function"===typeof jc.restoreControlledState?void 0:E("194");var b=Wa(a.stateNode);jc.restoreControlledState(a.stateNode,a.type,b)}}var nc={injectFiberControlledHostComponent:function(a){jc=a}};function oc(a){kc?lc?lc.push(a):lc=[a]:kc=a}
function pc(){if(kc){var a=kc,b=lc;lc=kc=null;mc(a);if(b)for(a=0;a<b.length;a++)mc(b[a])}}var qc=Object.freeze({injection:nc,enqueueStateRestore:oc,restoreStateIfNeeded:pc});function rc(a,b){return a(b)}var sc=!1;function tc(a,b){if(sc)return rc(a,b);sc=!0;try{return rc(a,b)}finally{sc=!1,pc()}}var uc={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};
function vc(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!uc[a.type]:"textarea"===b?!0:!1}function wc(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var xc;l.canUseDOM&&(xc=document.implementation&&document.implementation.hasFeature&&!0!==document.implementation.hasFeature("",""));
function yc(a,b){if(!l.canUseDOM||b&&!("addEventListener"in document))return!1;b="on"+a;var c=b in document;c||(c=document.createElement("div"),c.setAttribute(b,"return;"),c="function"===typeof c[b]);!c&&xc&&"wheel"===a&&(c=document.implementation.hasFeature("Events.wheel","3.0"));return c}function zc(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
function Ac(a){var b=zc(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"function"===typeof c.get&&"function"===typeof c.set)return Object.defineProperty(a,b,{enumerable:c.enumerable,configurable:!0,get:function(){return c.get.call(this)},set:function(a){d=""+a;c.set.call(this,a)}}),{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}
function Bc(a){a._valueTracker||(a._valueTracker=Ac(a))}function Cc(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=zc(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}var Dc={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ")}};
function Ec(a,b,c){a=T.getPooled(Dc.change,a,b,c);a.type="change";oc(c);Ab(a);return a}var Fc=null,Gc=null;function Hc(a){kb(a);lb(!1)}function Ic(a){var b=qb(a);if(Cc(b))return a}function Jc(a,b){if("topChange"===a)return b}var Kc=!1;l.canUseDOM&&(Kc=yc("input")&&(!document.documentMode||9<document.documentMode));function Lc(){Fc&&(Fc.detachEvent("onpropertychange",Mc),Gc=Fc=null)}function Mc(a){"value"===a.propertyName&&Ic(Gc)&&(a=Ec(Gc,a,wc(a)),tc(Hc,a))}
function Nc(a,b,c){"topFocus"===a?(Lc(),Fc=b,Gc=c,Fc.attachEvent("onpropertychange",Mc)):"topBlur"===a&&Lc()}function Oc(a){if("topSelectionChange"===a||"topKeyUp"===a||"topKeyDown"===a)return Ic(Gc)}function Pc(a,b){if("topClick"===a)return Ic(b)}function $c(a,b){if("topInput"===a||"topChange"===a)return Ic(b)}
var ad={eventTypes:Dc,_isInputEventSupported:Kc,extractEvents:function(a,b,c,d){var e=b?qb(b):window,f=e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Jc;else if(vc(e))if(Kc)g=$c;else{g=Oc;var h=Nc}else f=e.nodeName,!f||"input"!==f.toLowerCase()||"checkbox"!==e.type&&"radio"!==e.type||(g=Pc);if(g&&(g=g(a,b)))return Ec(g,c,d);h&&h(a,e,b);"topBlur"===a&&null!=b&&(a=b._wrapperState||e._wrapperState)&&a.controlled&&"number"===e.type&&(a=""+e.value,e.getAttribute("value")!==
a&&e.setAttribute("value",a))}};function bd(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(bd,{view:null,detail:null});var cd={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function dd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=cd[a])?!!b[a]:!1}function ed(){return dd}function fd(a,b,c,d){return T.call(this,a,b,c,d)}
bd.augmentClass(fd,{screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:ed,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)}});
var gd={mouseEnter:{registrationName:"onMouseEnter",dependencies:["topMouseOut","topMouseOver"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["topMouseOut","topMouseOver"]}},hd={eventTypes:gd,extractEvents:function(a,b,c,d){if("topMouseOver"===a&&(c.relatedTarget||c.fromElement)||"topMouseOut"!==a&&"topMouseOver"!==a)return null;var e=d.window===d?d:(e=d.ownerDocument)?e.defaultView||e.parentWindow:window;"topMouseOut"===a?(a=b,b=(b=c.relatedTarget||c.toElement)?pb(b):null):a=null;if(a===
b)return null;var f=null==a?e:qb(a);e=null==b?e:qb(b);var g=fd.getPooled(gd.mouseLeave,a,c,d);g.type="mouseleave";g.target=f;g.relatedTarget=e;c=fd.getPooled(gd.mouseEnter,b,c,d);c.type="mouseenter";c.target=e;c.relatedTarget=f;Bb(g,c,a,b);return[g,c]}},id=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;function jd(a){a=a.type;return"string"===typeof a?a:"function"===typeof a?a.displayName||a.name:null}
function kd(a){var b=a;if(a.alternate)for(;b["return"];)b=b["return"];else{if(0!==(b.effectTag&2))return 1;for(;b["return"];)if(b=b["return"],0!==(b.effectTag&2))return 1}return 3===b.tag?2:3}function ld(a){return(a=a._reactInternalFiber)?2===kd(a):!1}function md(a){2!==kd(a)?E("188"):void 0}
function nd(a){var b=a.alternate;if(!b)return b=kd(a),3===b?E("188"):void 0,1===b?null:a;for(var c=a,d=b;;){var e=c["return"],f=e?e.alternate:null;if(!e||!f)break;if(e.child===f.child){for(var g=e.child;g;){if(g===c)return md(e),a;if(g===d)return md(e),b;g=g.sibling}E("188")}if(c["return"]!==d["return"])c=e,d=f;else{g=!1;for(var h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}g?
void 0:E("189")}}c.alternate!==d?E("190"):void 0}3!==c.tag?E("188"):void 0;return c.stateNode.current===c?a:b}function od(a){a=nd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b["return"]||b["return"]===a)return null;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}}return null}
function pd(a){a=nd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child&&4!==b.tag)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b["return"]||b["return"]===a)return null;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}}return null}var qd=[];
function rd(a){var b=a.targetInst;do{if(!b){a.ancestors.push(b);break}var c;for(c=b;c["return"];)c=c["return"];c=3!==c.tag?null:c.stateNode.containerInfo;if(!c)break;a.ancestors.push(b);b=pb(c)}while(b);for(c=0;c<a.ancestors.length;c++)b=a.ancestors[c],sd(a.topLevelType,b,a.nativeEvent,wc(a.nativeEvent))}var td=!0,sd=void 0;function ud(a){td=!!a}function U(a,b,c){return c?ba.listen(c,b,vd.bind(null,a)):null}function wd(a,b,c){return c?ba.capture(c,b,vd.bind(null,a)):null}
function vd(a,b){if(td){var c=wc(b);c=pb(c);null===c||"number"!==typeof c.tag||2===kd(c)||(c=null);if(qd.length){var d=qd.pop();d.topLevelType=a;d.nativeEvent=b;d.targetInst=c;a=d}else a={topLevelType:a,nativeEvent:b,targetInst:c,ancestors:[]};try{tc(rd,a)}finally{a.topLevelType=null,a.nativeEvent=null,a.targetInst=null,a.ancestors.length=0,10>qd.length&&qd.push(a)}}}
var xd=Object.freeze({get _enabled(){return td},get _handleTopLevel(){return sd},setHandleTopLevel:function(a){sd=a},setEnabled:ud,isEnabled:function(){return td},trapBubbledEvent:U,trapCapturedEvent:wd,dispatchEvent:vd});function yd(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;c["ms"+a]="MS"+b;c["O"+a]="o"+b.toLowerCase();return c}
var zd={animationend:yd("Animation","AnimationEnd"),animationiteration:yd("Animation","AnimationIteration"),animationstart:yd("Animation","AnimationStart"),transitionend:yd("Transition","TransitionEnd")},Ad={},Bd={};l.canUseDOM&&(Bd=document.createElement("div").style,"AnimationEvent"in window||(delete zd.animationend.animation,delete zd.animationiteration.animation,delete zd.animationstart.animation),"TransitionEvent"in window||delete zd.transitionend.transition);
function Cd(a){if(Ad[a])return Ad[a];if(!zd[a])return a;var b=zd[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Bd)return Ad[a]=b[c];return""}
var Dd={topAbort:"abort",topAnimationEnd:Cd("animationend")||"animationend",topAnimationIteration:Cd("animationiteration")||"animationiteration",topAnimationStart:Cd("animationstart")||"animationstart",topBlur:"blur",topCancel:"cancel",topCanPlay:"canplay",topCanPlayThrough:"canplaythrough",topChange:"change",topClick:"click",topClose:"close",topCompositionEnd:"compositionend",topCompositionStart:"compositionstart",topCompositionUpdate:"compositionupdate",topContextMenu:"contextmenu",topCopy:"copy",
topCut:"cut",topDoubleClick:"dblclick",topDrag:"drag",topDragEnd:"dragend",topDragEnter:"dragenter",topDragExit:"dragexit",topDragLeave:"dragleave",topDragOver:"dragover",topDragStart:"dragstart",topDrop:"drop",topDurationChange:"durationchange",topEmptied:"emptied",topEncrypted:"encrypted",topEnded:"ended",topError:"error",topFocus:"focus",topInput:"input",topKeyDown:"keydown",topKeyPress:"keypress",topKeyUp:"keyup",topLoadedData:"loadeddata",topLoad:"load",topLoadedMetadata:"loadedmetadata",topLoadStart:"loadstart",
topMouseDown:"mousedown",topMouseMove:"mousemove",topMouseOut:"mouseout",topMouseOver:"mouseover",topMouseUp:"mouseup",topPaste:"paste",topPause:"pause",topPlay:"play",topPlaying:"playing",topProgress:"progress",topRateChange:"ratechange",topScroll:"scroll",topSeeked:"seeked",topSeeking:"seeking",topSelectionChange:"selectionchange",topStalled:"stalled",topSuspend:"suspend",topTextInput:"textInput",topTimeUpdate:"timeupdate",topToggle:"toggle",topTouchCancel:"touchcancel",topTouchEnd:"touchend",topTouchMove:"touchmove",
topTouchStart:"touchstart",topTransitionEnd:Cd("transitionend")||"transitionend",topVolumeChange:"volumechange",topWaiting:"waiting",topWheel:"wheel"},Ed={},Fd=0,Gd="_reactListenersID"+(""+Math.random()).slice(2);function Hd(a){Object.prototype.hasOwnProperty.call(a,Gd)||(a[Gd]=Fd++,Ed[a[Gd]]={});return Ed[a[Gd]]}function Id(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
function Jd(a,b){var c=Id(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Id(c)}}function Kd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&"text"===a.type||"textarea"===b||"true"===a.contentEditable)}
var Ld=l.canUseDOM&&"documentMode"in document&&11>=document.documentMode,Md={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ")}},Nd=null,Od=null,Pd=null,Qd=!1;
function Rd(a,b){if(Qd||null==Nd||Nd!==da())return null;var c=Nd;"selectionStart"in c&&Kd(c)?c={start:c.selectionStart,end:c.selectionEnd}:window.getSelection?(c=window.getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset}):c=void 0;return Pd&&ea(Pd,c)?null:(Pd=c,a=T.getPooled(Md.select,Od,a,b),a.type="select",a.target=Nd,Ab(a),a)}
var Sd={eventTypes:Md,extractEvents:function(a,b,c,d){var e=d.window===d?d.document:9===d.nodeType?d:d.ownerDocument,f;if(!(f=!e)){a:{e=Hd(e);f=Sa.onSelect;for(var g=0;g<f.length;g++){var h=f[g];if(!e.hasOwnProperty(h)||!e[h]){e=!1;break a}}e=!0}f=!e}if(f)return null;e=b?qb(b):window;switch(a){case "topFocus":if(vc(e)||"true"===e.contentEditable)Nd=e,Od=b,Pd=null;break;case "topBlur":Pd=Od=Nd=null;break;case "topMouseDown":Qd=!0;break;case "topContextMenu":case "topMouseUp":return Qd=!1,Rd(c,d);case "topSelectionChange":if(Ld)break;
case "topKeyDown":case "topKeyUp":return Rd(c,d)}return null}};function Td(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Td,{animationName:null,elapsedTime:null,pseudoElement:null});function Ud(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Ud,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}});function Vd(a,b,c,d){return T.call(this,a,b,c,d)}bd.augmentClass(Vd,{relatedTarget:null});
function Wd(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;return 32<=a||13===a?a:0}
var Xd={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Yd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",
116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"};function Zd(a,b,c,d){return T.call(this,a,b,c,d)}
bd.augmentClass(Zd,{key:function(a){if(a.key){var b=Xd[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Wd(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Yd[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:ed,charCode:function(a){return"keypress"===a.type?Wd(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Wd(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}});function $d(a,b,c,d){return T.call(this,a,b,c,d)}fd.augmentClass($d,{dataTransfer:null});function ae(a,b,c,d){return T.call(this,a,b,c,d)}bd.augmentClass(ae,{touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:ed});function be(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(be,{propertyName:null,elapsedTime:null,pseudoElement:null});
function ce(a,b,c,d){return T.call(this,a,b,c,d)}fd.augmentClass(ce,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null});var de={},ee={};
"abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel".split(" ").forEach(function(a){var b=a[0].toUpperCase()+
a.slice(1),c="on"+b;b="top"+b;c={phasedRegistrationNames:{bubbled:c,captured:c+"Capture"},dependencies:[b]};de[a]=c;ee[b]=c});
var fe={eventTypes:de,extractEvents:function(a,b,c,d){var e=ee[a];if(!e)return null;switch(a){case "topKeyPress":if(0===Wd(c))return null;case "topKeyDown":case "topKeyUp":a=Zd;break;case "topBlur":case "topFocus":a=Vd;break;case "topClick":if(2===c.button)return null;case "topDoubleClick":case "topMouseDown":case "topMouseMove":case "topMouseUp":case "topMouseOut":case "topMouseOver":case "topContextMenu":a=fd;break;case "topDrag":case "topDragEnd":case "topDragEnter":case "topDragExit":case "topDragLeave":case "topDragOver":case "topDragStart":case "topDrop":a=
$d;break;case "topTouchCancel":case "topTouchEnd":case "topTouchMove":case "topTouchStart":a=ae;break;case "topAnimationEnd":case "topAnimationIteration":case "topAnimationStart":a=Td;break;case "topTransitionEnd":a=be;break;case "topScroll":a=bd;break;case "topWheel":a=ce;break;case "topCopy":case "topCut":case "topPaste":a=Ud;break;default:a=T}b=a.getPooled(e,b,c,d);Ab(b);return b}};sd=function(a,b,c,d){a=jb(a,b,c,d);kb(a);lb(!1)};hb.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
Wa=sb.getFiberCurrentPropsFromNode;Xa=sb.getInstanceFromNode;Ya=sb.getNodeFromInstance;hb.injectEventPluginsByName({SimpleEventPlugin:fe,EnterLeaveEventPlugin:hd,ChangeEventPlugin:ad,SelectEventPlugin:Sd,BeforeInputEventPlugin:ic});var ge=[],he=-1;function V(a){0>he||(a.current=ge[he],ge[he]=null,he--)}function W(a,b){he++;ge[he]=a.current;a.current=b}new Set;var ie={current:D},X={current:!1},je=D;function ke(a){return le(a)?je:ie.current}
function me(a,b){var c=a.type.contextTypes;if(!c)return D;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function le(a){return 2===a.tag&&null!=a.type.childContextTypes}function ne(a){le(a)&&(V(X,a),V(ie,a))}
function oe(a,b,c){null!=ie.cursor?E("168"):void 0;W(ie,b,a);W(X,c,a)}function pe(a,b){var c=a.stateNode,d=a.type.childContextTypes;if("function"!==typeof c.getChildContext)return b;c=c.getChildContext();for(var e in c)e in d?void 0:E("108",jd(a)||"Unknown",e);return B({},b,c)}function qe(a){if(!le(a))return!1;var b=a.stateNode;b=b&&b.__reactInternalMemoizedMergedChildContext||D;je=ie.current;W(ie,b,a);W(X,X.current,a);return!0}
function re(a,b){var c=a.stateNode;c?void 0:E("169");if(b){var d=pe(a,je);c.__reactInternalMemoizedMergedChildContext=d;V(X,a);V(ie,a);W(ie,d,a)}else V(X,a);W(X,b,a)}
function Y(a,b,c){this.tag=a;this.key=b;this.stateNode=this.type=null;this.sibling=this.child=this["return"]=null;this.index=0;this.memoizedState=this.updateQueue=this.memoizedProps=this.pendingProps=this.ref=null;this.internalContextTag=c;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.expirationTime=0;this.alternate=null}
function se(a,b,c){var d=a.alternate;null===d?(d=new Y(a.tag,a.key,a.internalContextTag),d.type=a.type,d.stateNode=a.stateNode,d.alternate=a,a.alternate=d):(d.effectTag=0,d.nextEffect=null,d.firstEffect=null,d.lastEffect=null);d.expirationTime=c;d.pendingProps=b;d.child=a.child;d.memoizedProps=a.memoizedProps;d.memoizedState=a.memoizedState;d.updateQueue=a.updateQueue;d.sibling=a.sibling;d.index=a.index;d.ref=a.ref;return d}
function te(a,b,c){var d=void 0,e=a.type,f=a.key;"function"===typeof e?(d=e.prototype&&e.prototype.isReactComponent?new Y(2,f,b):new Y(0,f,b),d.type=e,d.pendingProps=a.props):"string"===typeof e?(d=new Y(5,f,b),d.type=e,d.pendingProps=a.props):"object"===typeof e&&null!==e&&"number"===typeof e.tag?(d=e,d.pendingProps=a.props):E("130",null==e?e:typeof e,"");d.expirationTime=c;return d}function ue(a,b,c,d){b=new Y(10,d,b);b.pendingProps=a;b.expirationTime=c;return b}
function ve(a,b,c){b=new Y(6,null,b);b.pendingProps=a;b.expirationTime=c;return b}function we(a,b,c){b=new Y(7,a.key,b);b.type=a.handler;b.pendingProps=a;b.expirationTime=c;return b}function xe(a,b,c){a=new Y(9,null,b);a.expirationTime=c;return a}function ye(a,b,c){b=new Y(4,a.key,b);b.pendingProps=a.children||[];b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}var ze=null,Ae=null;
function Be(a){return function(b){try{return a(b)}catch(c){}}}function Ce(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=b.inject(a);ze=Be(function(a){return b.onCommitFiberRoot(c,a)});Ae=Be(function(a){return b.onCommitFiberUnmount(c,a)})}catch(d){}return!0}function De(a){"function"===typeof ze&&ze(a)}function Ee(a){"function"===typeof Ae&&Ae(a)}
function Fe(a){return{baseState:a,expirationTime:0,first:null,last:null,callbackList:null,hasForceUpdate:!1,isInitialized:!1}}function Ge(a,b){null===a.last?a.first=a.last=b:(a.last.next=b,a.last=b);if(0===a.expirationTime||a.expirationTime>b.expirationTime)a.expirationTime=b.expirationTime}
function He(a,b){var c=a.alternate,d=a.updateQueue;null===d&&(d=a.updateQueue=Fe(null));null!==c?(a=c.updateQueue,null===a&&(a=c.updateQueue=Fe(null))):a=null;a=a!==d?a:null;null===a?Ge(d,b):null===d.last||null===a.last?(Ge(d,b),Ge(a,b)):(Ge(d,b),a.last=b)}function Ie(a,b,c,d){a=a.partialState;return"function"===typeof a?a.call(b,c,d):a}
function Je(a,b,c,d,e,f){null!==a&&a.updateQueue===c&&(c=b.updateQueue={baseState:c.baseState,expirationTime:c.expirationTime,first:c.first,last:c.last,isInitialized:c.isInitialized,callbackList:null,hasForceUpdate:!1});c.expirationTime=0;c.isInitialized?a=c.baseState:(a=c.baseState=b.memoizedState,c.isInitialized=!0);for(var g=!0,h=c.first,k=!1;null!==h;){var q=h.expirationTime;if(q>f){var v=c.expirationTime;if(0===v||v>q)c.expirationTime=q;k||(k=!0,c.baseState=a)}else{k||(c.first=h.next,null===
c.first&&(c.last=null));if(h.isReplace)a=Ie(h,d,a,e),g=!0;else if(q=Ie(h,d,a,e))a=g?B({},a,q):B(a,q),g=!1;h.isForced&&(c.hasForceUpdate=!0);null!==h.callback&&(q=c.callbackList,null===q&&(q=c.callbackList=[]),q.push(h))}h=h.next}null!==c.callbackList?b.effectTag|=32:null!==c.first||c.hasForceUpdate||(b.updateQueue=null);k||(c.baseState=a);return a}
function Ke(a,b){var c=a.callbackList;if(null!==c)for(a.callbackList=null,a=0;a<c.length;a++){var d=c[a],e=d.callback;d.callback=null;"function"!==typeof e?E("191",e):void 0;e.call(b)}}
function Le(a,b,c,d){function e(a,b){b.updater=f;a.stateNode=b;b._reactInternalFiber=a}var f={isMounted:ld,enqueueSetState:function(c,d,e){c=c._reactInternalFiber;e=void 0===e?null:e;var g=b(c);He(c,{expirationTime:g,partialState:d,callback:e,isReplace:!1,isForced:!1,nextCallback:null,next:null});a(c,g)},enqueueReplaceState:function(c,d,e){c=c._reactInternalFiber;e=void 0===e?null:e;var g=b(c);He(c,{expirationTime:g,partialState:d,callback:e,isReplace:!0,isForced:!1,nextCallback:null,next:null});
a(c,g)},enqueueForceUpdate:function(c,d){c=c._reactInternalFiber;d=void 0===d?null:d;var e=b(c);He(c,{expirationTime:e,partialState:null,callback:d,isReplace:!1,isForced:!0,nextCallback:null,next:null});a(c,e)}};return{adoptClassInstance:e,constructClassInstance:function(a,b){var c=a.type,d=ke(a),f=2===a.tag&&null!=a.type.contextTypes,g=f?me(a,d):D;b=new c(b,g);e(a,b);f&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=d,a.__reactInternalMemoizedMaskedChildContext=g);return b},mountClassInstance:function(a,
b){var c=a.alternate,d=a.stateNode,e=d.state||null,g=a.pendingProps;g?void 0:E("158");var h=ke(a);d.props=g;d.state=a.memoizedState=e;d.refs=D;d.context=me(a,h);null!=a.type&&null!=a.type.prototype&&!0===a.type.prototype.unstable_isAsyncReactComponent&&(a.internalContextTag|=1);"function"===typeof d.componentWillMount&&(e=d.state,d.componentWillMount(),e!==d.state&&f.enqueueReplaceState(d,d.state,null),e=a.updateQueue,null!==e&&(d.state=Je(c,a,e,d,g,b)));"function"===typeof d.componentDidMount&&(a.effectTag|=
4)},updateClassInstance:function(a,b,e){var g=b.stateNode;g.props=b.memoizedProps;g.state=b.memoizedState;var h=b.memoizedProps,k=b.pendingProps;k||(k=h,null==k?E("159"):void 0);var u=g.context,z=ke(b);z=me(b,z);"function"!==typeof g.componentWillReceiveProps||h===k&&u===z||(u=g.state,g.componentWillReceiveProps(k,z),g.state!==u&&f.enqueueReplaceState(g,g.state,null));u=b.memoizedState;e=null!==b.updateQueue?Je(a,b,b.updateQueue,g,k,e):u;if(!(h!==k||u!==e||X.current||null!==b.updateQueue&&b.updateQueue.hasForceUpdate))return"function"!==
typeof g.componentDidUpdate||h===a.memoizedProps&&u===a.memoizedState||(b.effectTag|=4),!1;var G=k;if(null===h||null!==b.updateQueue&&b.updateQueue.hasForceUpdate)G=!0;else{var I=b.stateNode,L=b.type;G="function"===typeof I.shouldComponentUpdate?I.shouldComponentUpdate(G,e,z):L.prototype&&L.prototype.isPureReactComponent?!ea(h,G)||!ea(u,e):!0}G?("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(k,e,z),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4)):("function"!==typeof g.componentDidUpdate||
h===a.memoizedProps&&u===a.memoizedState||(b.effectTag|=4),c(b,k),d(b,e));g.props=k;g.state=e;g.context=z;return G}}}var Qe="function"===typeof Symbol&&Symbol["for"],Re=Qe?Symbol["for"]("react.element"):60103,Se=Qe?Symbol["for"]("react.call"):60104,Te=Qe?Symbol["for"]("react.return"):60105,Ue=Qe?Symbol["for"]("react.portal"):60106,Ve=Qe?Symbol["for"]("react.fragment"):60107,We="function"===typeof Symbol&&Symbol.iterator;
function Xe(a){if(null===a||"undefined"===typeof a)return null;a=We&&a[We]||a["@@iterator"];return"function"===typeof a?a:null}var Ye=Array.isArray;
function Ze(a,b){var c=b.ref;if(null!==c&&"function"!==typeof c){if(b._owner){b=b._owner;var d=void 0;b&&(2!==b.tag?E("110"):void 0,d=b.stateNode);d?void 0:E("147",c);var e=""+c;if(null!==a&&null!==a.ref&&a.ref._stringRef===e)return a.ref;a=function(a){var b=d.refs===D?d.refs={}:d.refs;null===a?delete b[e]:b[e]=a};a._stringRef=e;return a}"string"!==typeof c?E("148"):void 0;b._owner?void 0:E("149",c)}return c}
function $e(a,b){"textarea"!==a.type&&E("31","[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,"")}
function af(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b,c){a=se(a,b,c);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=
2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=ve(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c,d);b["return"]=a;return b}function k(a,b,c,d){if(null!==b&&b.type===c.type)return d=e(b,c.props,d),d.ref=Ze(b,c),d["return"]=a,d;d=te(c,a.internalContextTag,d);d.ref=Ze(b,c);d["return"]=a;return d}function q(a,b,c,d){if(null===b||7!==b.tag)return b=we(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c,d);
b["return"]=a;return b}function v(a,b,c,d){if(null===b||9!==b.tag)return b=xe(c,a.internalContextTag,d),b.type=c.value,b["return"]=a,b;b=e(b,null,d);b.type=c.value;b["return"]=a;return b}function y(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=ye(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c.children||[],d);b["return"]=a;return b}function u(a,b,c,d,f){if(null===b||10!==b.tag)return b=ue(c,a.internalContextTag,
d,f),b["return"]=a,b;b=e(b,c,d);b["return"]=a;return b}function z(a,b,c){if("string"===typeof b||"number"===typeof b)return b=ve(""+b,a.internalContextTag,c),b["return"]=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case Re:if(b.type===Ve)return b=ue(b.props.children,a.internalContextTag,c,b.key),b["return"]=a,b;c=te(b,a.internalContextTag,c);c.ref=Ze(null,b);c["return"]=a;return c;case Se:return b=we(b,a.internalContextTag,c),b["return"]=a,b;case Te:return c=xe(b,a.internalContextTag,
c),c.type=b.value,c["return"]=a,c;case Ue:return b=ye(b,a.internalContextTag,c),b["return"]=a,b}if(Ye(b)||Xe(b))return b=ue(b,a.internalContextTag,c,null),b["return"]=a,b;$e(a,b)}return null}function G(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Re:return c.key===e?c.type===Ve?u(a,b,c.props.children,d,e):k(a,b,c,d):null;case Se:return c.key===e?q(a,b,c,d):null;case Te:return null===
e?v(a,b,c,d):null;case Ue:return c.key===e?y(a,b,c,d):null}if(Ye(c)||Xe(c))return null!==e?null:u(a,b,c,d,null);$e(a,c)}return null}function I(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Re:return a=a.get(null===d.key?c:d.key)||null,d.type===Ve?u(b,a,d.props.children,e,d.key):k(b,a,d,e);case Se:return a=a.get(null===d.key?c:d.key)||null,q(b,a,d,e);case Te:return a=a.get(c)||null,v(b,a,d,e);case Ue:return a=
a.get(null===d.key?c:d.key)||null,y(b,a,d,e)}if(Ye(d)||Xe(d))return a=a.get(c)||null,u(b,a,d,e,null);$e(b,d)}return null}function L(e,g,m,A){for(var h=null,r=null,n=g,w=g=0,k=null;null!==n&&w<m.length;w++){n.index>w?(k=n,n=null):k=n.sibling;var x=G(e,n,m[w],A);if(null===x){null===n&&(n=k);break}a&&n&&null===x.alternate&&b(e,n);g=f(x,g,w);null===r?h=x:r.sibling=x;r=x;n=k}if(w===m.length)return c(e,n),h;if(null===n){for(;w<m.length;w++)if(n=z(e,m[w],A))g=f(n,g,w),null===r?h=n:r.sibling=n,r=n;return h}for(n=
d(e,n);w<m.length;w++)if(k=I(n,e,w,m[w],A)){if(a&&null!==k.alternate)n["delete"](null===k.key?w:k.key);g=f(k,g,w);null===r?h=k:r.sibling=k;r=k}a&&n.forEach(function(a){return b(e,a)});return h}function N(e,g,m,A){var h=Xe(m);"function"!==typeof h?E("150"):void 0;m=h.call(m);null==m?E("151"):void 0;for(var r=h=null,n=g,w=g=0,k=null,x=m.next();null!==n&&!x.done;w++,x=m.next()){n.index>w?(k=n,n=null):k=n.sibling;var J=G(e,n,x.value,A);if(null===J){n||(n=k);break}a&&n&&null===J.alternate&&b(e,n);g=f(J,
g,w);null===r?h=J:r.sibling=J;r=J;n=k}if(x.done)return c(e,n),h;if(null===n){for(;!x.done;w++,x=m.next())x=z(e,x.value,A),null!==x&&(g=f(x,g,w),null===r?h=x:r.sibling=x,r=x);return h}for(n=d(e,n);!x.done;w++,x=m.next())if(x=I(n,e,w,x.value,A),null!==x){if(a&&null!==x.alternate)n["delete"](null===x.key?w:x.key);g=f(x,g,w);null===r?h=x:r.sibling=x;r=x}a&&n.forEach(function(a){return b(e,a)});return h}return function(a,d,f,h){"object"===typeof f&&null!==f&&f.type===Ve&&null===f.key&&(f=f.props.children);
var m="object"===typeof f&&null!==f;if(m)switch(f.$$typeof){case Re:a:{var r=f.key;for(m=d;null!==m;){if(m.key===r)if(10===m.tag?f.type===Ve:m.type===f.type){c(a,m.sibling);d=e(m,f.type===Ve?f.props.children:f.props,h);d.ref=Ze(m,f);d["return"]=a;a=d;break a}else{c(a,m);break}else b(a,m);m=m.sibling}f.type===Ve?(d=ue(f.props.children,a.internalContextTag,h,f.key),d["return"]=a,a=d):(h=te(f,a.internalContextTag,h),h.ref=Ze(d,f),h["return"]=a,a=h)}return g(a);case Se:a:{for(m=f.key;null!==d;){if(d.key===
m)if(7===d.tag){c(a,d.sibling);d=e(d,f,h);d["return"]=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=we(f,a.internalContextTag,h);d["return"]=a;a=d}return g(a);case Te:a:{if(null!==d)if(9===d.tag){c(a,d.sibling);d=e(d,null,h);d.type=f.value;d["return"]=a;a=d;break a}else c(a,d);d=xe(f,a.internalContextTag,h);d.type=f.value;d["return"]=a;a=d}return g(a);case Ue:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===
f.implementation){c(a,d.sibling);d=e(d,f.children||[],h);d["return"]=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=ye(f,a.internalContextTag,h);d["return"]=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f,h)):(c(a,d),d=ve(f,a.internalContextTag,h)),d["return"]=a,a=d,g(a);if(Ye(f))return L(a,d,f,h);if(Xe(f))return N(a,d,f,h);m&&$e(a,f);if("undefined"===typeof f)switch(a.tag){case 2:case 1:h=a.type,E("152",h.displayName||
h.name||"Component")}return c(a,d)}}var bf=af(!0),cf=af(!1);
function df(a,b,c,d,e){function f(a,b,c){var d=b.expirationTime;b.child=null===a?cf(b,null,c,d):bf(b,a.child,c,d)}function g(a,b){var c=b.ref;null===c||a&&a.ref===c||(b.effectTag|=128)}function h(a,b,c,d){g(a,b);if(!c)return d&&re(b,!1),q(a,b);c=b.stateNode;id.current=b;var e=c.render();b.effectTag|=1;f(a,b,e);b.memoizedState=c.state;b.memoizedProps=c.props;d&&re(b,!0);return b.child}function k(a){var b=a.stateNode;b.pendingContext?oe(a,b.pendingContext,b.pendingContext!==b.context):b.context&&oe(a,
b.context,!1);I(a,b.containerInfo)}function q(a,b){null!==a&&b.child!==a.child?E("153"):void 0;if(null!==b.child){a=b.child;var c=se(a,a.pendingProps,a.expirationTime);b.child=c;for(c["return"]=b;null!==a.sibling;)a=a.sibling,c=c.sibling=se(a,a.pendingProps,a.expirationTime),c["return"]=b;c.sibling=null}return b.child}function v(a,b){switch(b.tag){case 3:k(b);break;case 2:qe(b);break;case 4:I(b,b.stateNode.containerInfo)}return null}var y=a.shouldSetTextContent,u=a.useSyncScheduling,z=a.shouldDeprioritizeSubtree,
G=b.pushHostContext,I=b.pushHostContainer,L=c.enterHydrationState,N=c.resetHydrationState,J=c.tryToClaimNextHydratableInstance;a=Le(d,e,function(a,b){a.memoizedProps=b},function(a,b){a.memoizedState=b});var w=a.adoptClassInstance,m=a.constructClassInstance,A=a.mountClassInstance,Ob=a.updateClassInstance;return{beginWork:function(a,b,c){if(0===b.expirationTime||b.expirationTime>c)return v(a,b);switch(b.tag){case 0:null!==a?E("155"):void 0;var d=b.type,e=b.pendingProps,r=ke(b);r=me(b,r);d=d(e,r);b.effectTag|=
1;"object"===typeof d&&null!==d&&"function"===typeof d.render?(b.tag=2,e=qe(b),w(b,d),A(b,c),b=h(a,b,!0,e)):(b.tag=1,f(a,b,d),b.memoizedProps=e,b=b.child);return b;case 1:a:{e=b.type;c=b.pendingProps;d=b.memoizedProps;if(X.current)null===c&&(c=d);else if(null===c||d===c){b=q(a,b);break a}d=ke(b);d=me(b,d);e=e(c,d);b.effectTag|=1;f(a,b,e);b.memoizedProps=c;b=b.child}return b;case 2:return e=qe(b),d=void 0,null===a?b.stateNode?E("153"):(m(b,b.pendingProps),A(b,c),d=!0):d=Ob(a,b,c),h(a,b,d,e);case 3:return k(b),
e=b.updateQueue,null!==e?(d=b.memoizedState,e=Je(a,b,e,null,null,c),d===e?(N(),b=q(a,b)):(d=e.element,r=b.stateNode,(null===a||null===a.child)&&r.hydrate&&L(b)?(b.effectTag|=2,b.child=cf(b,null,d,c)):(N(),f(a,b,d)),b.memoizedState=e,b=b.child)):(N(),b=q(a,b)),b;case 5:G(b);null===a&&J(b);e=b.type;var n=b.memoizedProps;d=b.pendingProps;null===d&&(d=n,null===d?E("154"):void 0);r=null!==a?a.memoizedProps:null;X.current||null!==d&&n!==d?(n=d.children,y(e,d)?n=null:r&&y(e,r)&&(b.effectTag|=16),g(a,b),
2147483647!==c&&!u&&z(e,d)?(b.expirationTime=2147483647,b=null):(f(a,b,n),b.memoizedProps=d,b=b.child)):b=q(a,b);return b;case 6:return null===a&&J(b),a=b.pendingProps,null===a&&(a=b.memoizedProps),b.memoizedProps=a,null;case 8:b.tag=7;case 7:e=b.pendingProps;if(X.current)null===e&&(e=a&&a.memoizedProps,null===e?E("154"):void 0);else if(null===e||b.memoizedProps===e)e=b.memoizedProps;d=e.children;b.stateNode=null===a?cf(b,b.stateNode,d,c):bf(b,b.stateNode,d,c);b.memoizedProps=e;return b.stateNode;
case 9:return null;case 4:a:{I(b,b.stateNode.containerInfo);e=b.pendingProps;if(X.current)null===e&&(e=a&&a.memoizedProps,null==e?E("154"):void 0);else if(null===e||b.memoizedProps===e){b=q(a,b);break a}null===a?b.child=bf(b,null,e,c):f(a,b,e);b.memoizedProps=e;b=b.child}return b;case 10:a:{c=b.pendingProps;if(X.current)null===c&&(c=b.memoizedProps);else if(null===c||b.memoizedProps===c){b=q(a,b);break a}f(a,b,c);b.memoizedProps=c;b=b.child}return b;default:E("156")}},beginFailedWork:function(a,b,
c){switch(b.tag){case 2:qe(b);break;case 3:k(b);break;default:E("157")}b.effectTag|=64;null===a?b.child=null:b.child!==a.child&&(b.child=a.child);if(0===b.expirationTime||b.expirationTime>c)return v(a,b);b.firstEffect=null;b.lastEffect=null;b.child=null===a?cf(b,null,null,c):bf(b,a.child,null,c);2===b.tag&&(a=b.stateNode,b.memoizedProps=a.props,b.memoizedState=a.state);return b.child}}}
function ef(a,b,c){function d(a){a.effectTag|=4}var e=a.createInstance,f=a.createTextInstance,g=a.appendInitialChild,h=a.finalizeInitialChildren,k=a.prepareUpdate,q=a.persistence,v=b.getRootHostContainer,y=b.popHostContext,u=b.getHostContext,z=b.popHostContainer,G=c.prepareToHydrateHostInstance,I=c.prepareToHydrateHostTextInstance,L=c.popHydrationState,N=void 0,J=void 0,w=void 0;a.mutation?(N=function(){},J=function(a,b,c){(b.updateQueue=c)&&d(b)},w=function(a,b,c,e){c!==e&&d(b)}):q?E("235"):E("236");
return{completeWork:function(a,b,c){var m=b.pendingProps;if(null===m)m=b.memoizedProps;else if(2147483647!==b.expirationTime||2147483647===c)b.pendingProps=null;switch(b.tag){case 1:return null;case 2:return ne(b),null;case 3:z(b);V(X,b);V(ie,b);m=b.stateNode;m.pendingContext&&(m.context=m.pendingContext,m.pendingContext=null);if(null===a||null===a.child)L(b),b.effectTag&=-3;N(b);return null;case 5:y(b);c=v();var A=b.type;if(null!==a&&null!=b.stateNode){var p=a.memoizedProps,q=b.stateNode,x=u();q=
k(q,A,p,m,c,x);J(a,b,q,A,p,m,c);a.ref!==b.ref&&(b.effectTag|=128)}else{if(!m)return null===b.stateNode?E("166"):void 0,null;a=u();if(L(b))G(b,c,a)&&d(b);else{a=e(A,m,c,a,b);a:for(p=b.child;null!==p;){if(5===p.tag||6===p.tag)g(a,p.stateNode);else if(4!==p.tag&&null!==p.child){p.child["return"]=p;p=p.child;continue}if(p===b)break;for(;null===p.sibling;){if(null===p["return"]||p["return"]===b)break a;p=p["return"]}p.sibling["return"]=p["return"];p=p.sibling}h(a,A,m,c)&&d(b);b.stateNode=a}null!==b.ref&&
(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)w(a,b,a.memoizedProps,m);else{if("string"!==typeof m)return null===b.stateNode?E("166"):void 0,null;a=v();c=u();L(b)?I(b)&&d(b):b.stateNode=f(m,a,c,b)}return null;case 7:(m=b.memoizedProps)?void 0:E("165");b.tag=8;A=[];a:for((p=b.stateNode)&&(p["return"]=b);null!==p;){if(5===p.tag||6===p.tag||4===p.tag)E("247");else if(9===p.tag)A.push(p.type);else if(null!==p.child){p.child["return"]=p;p=p.child;continue}for(;null===p.sibling;){if(null===
p["return"]||p["return"]===b)break a;p=p["return"]}p.sibling["return"]=p["return"];p=p.sibling}p=m.handler;m=p(m.props,A);b.child=bf(b,null!==a?a.child:null,m,c);return b.child;case 8:return b.tag=7,null;case 9:return null;case 10:return null;case 4:return z(b),N(b),null;case 0:E("167");default:E("156")}}}}
function ff(a,b){function c(a){var c=a.ref;if(null!==c)try{c(null)}catch(A){b(a,A)}}function d(a){"function"===typeof Ee&&Ee(a);switch(a.tag){case 2:c(a);var d=a.stateNode;if("function"===typeof d.componentWillUnmount)try{d.props=a.memoizedProps,d.state=a.memoizedState,d.componentWillUnmount()}catch(A){b(a,A)}break;case 5:c(a);break;case 7:e(a.stateNode);break;case 4:k&&g(a)}}function e(a){for(var b=a;;)if(d(b),null===b.child||k&&4===b.tag){if(b===a)break;for(;null===b.sibling;){if(null===b["return"]||
b["return"]===a)return;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}else b.child["return"]=b,b=b.child}function f(a){return 5===a.tag||3===a.tag||4===a.tag}function g(a){for(var b=a,c=!1,f=void 0,g=void 0;;){if(!c){c=b["return"];a:for(;;){null===c?E("160"):void 0;switch(c.tag){case 5:f=c.stateNode;g=!1;break a;case 3:f=c.stateNode.containerInfo;g=!0;break a;case 4:f=c.stateNode.containerInfo;g=!0;break a}c=c["return"]}c=!0}if(5===b.tag||6===b.tag)e(b),g?J(f,b.stateNode):N(f,b.stateNode);
else if(4===b.tag?f=b.stateNode.containerInfo:d(b),null!==b.child){b.child["return"]=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b["return"]||b["return"]===a)return;b=b["return"];4===b.tag&&(c=!1)}b.sibling["return"]=b["return"];b=b.sibling}}var h=a.getPublicInstance,k=a.mutation;a=a.persistence;k||(a?E("235"):E("236"));var q=k.commitMount,v=k.commitUpdate,y=k.resetTextContent,u=k.commitTextUpdate,z=k.appendChild,G=k.appendChildToContainer,I=k.insertBefore,L=k.insertInContainerBefore,
N=k.removeChild,J=k.removeChildFromContainer;return{commitResetTextContent:function(a){y(a.stateNode)},commitPlacement:function(a){a:{for(var b=a["return"];null!==b;){if(f(b)){var c=b;break a}b=b["return"]}E("160");c=void 0}var d=b=void 0;switch(c.tag){case 5:b=c.stateNode;d=!1;break;case 3:b=c.stateNode.containerInfo;d=!0;break;case 4:b=c.stateNode.containerInfo;d=!0;break;default:E("161")}c.effectTag&16&&(y(b),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c["return"]||f(c["return"])){c=
null;break a}c=c["return"]}c.sibling["return"]=c["return"];for(c=c.sibling;5!==c.tag&&6!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;else c.child["return"]=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}for(var e=a;;){if(5===e.tag||6===e.tag)c?d?L(b,e.stateNode,c):I(b,e.stateNode,c):d?G(b,e.stateNode):z(b,e.stateNode);else if(4!==e.tag&&null!==e.child){e.child["return"]=e;e=e.child;continue}if(e===a)break;for(;null===e.sibling;){if(null===e["return"]||e["return"]===
a)return;e=e["return"]}e.sibling["return"]=e["return"];e=e.sibling}},commitDeletion:function(a){g(a);a["return"]=null;a.child=null;a.alternate&&(a.alternate.child=null,a.alternate["return"]=null)},commitWork:function(a,b){switch(b.tag){case 2:break;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps;a=null!==a?a.memoizedProps:d;var e=b.type,f=b.updateQueue;b.updateQueue=null;null!==f&&v(c,f,e,a,d,b)}break;case 6:null===b.stateNode?E("162"):void 0;c=b.memoizedProps;u(b.stateNode,null!==a?a.memoizedProps:
c,c);break;case 3:break;default:E("163")}},commitLifeCycles:function(a,b){switch(b.tag){case 2:var c=b.stateNode;if(b.effectTag&4)if(null===a)c.props=b.memoizedProps,c.state=b.memoizedState,c.componentDidMount();else{var d=a.memoizedProps;a=a.memoizedState;c.props=b.memoizedProps;c.state=b.memoizedState;c.componentDidUpdate(d,a)}b=b.updateQueue;null!==b&&Ke(b,c);break;case 3:c=b.updateQueue;null!==c&&Ke(c,null!==b.child?b.child.stateNode:null);break;case 5:c=b.stateNode;null===a&&b.effectTag&4&&q(c,
b.type,b.memoizedProps,b);break;case 6:break;case 4:break;default:E("163")}},commitAttachRef:function(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:b(h(c));break;default:b(c)}}},commitDetachRef:function(a){a=a.ref;null!==a&&a(null)}}}var gf={};
function hf(a){function b(a){a===gf?E("174"):void 0;return a}var c=a.getChildHostContext,d=a.getRootHostContext,e={current:gf},f={current:gf},g={current:gf};return{getHostContext:function(){return b(e.current)},getRootHostContainer:function(){return b(g.current)},popHostContainer:function(a){V(e,a);V(f,a);V(g,a)},popHostContext:function(a){f.current===a&&(V(e,a),V(f,a))},pushHostContainer:function(a,b){W(g,b,a);b=d(b);W(f,a,a);W(e,b,a)},pushHostContext:function(a){var d=b(g.current),h=b(e.current);
d=c(h,a.type,d);h!==d&&(W(f,a,a),W(e,d,a))},resetHostContainer:function(){e.current=gf;g.current=gf}}}
function jf(a){function b(a,b){var c=new Y(5,null,0);c.type="DELETED";c.stateNode=b;c["return"]=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function c(a,b){switch(a.tag){case 5:return b=f(b,a.type,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;case 6:return b=g(b,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;default:return!1}}function d(a){for(a=a["return"];null!==a&&5!==a.tag&&3!==a.tag;)a=a["return"];y=a}var e=a.shouldSetTextContent;
a=a.hydration;if(!a)return{enterHydrationState:function(){return!1},resetHydrationState:function(){},tryToClaimNextHydratableInstance:function(){},prepareToHydrateHostInstance:function(){E("175")},prepareToHydrateHostTextInstance:function(){E("176")},popHydrationState:function(){return!1}};var f=a.canHydrateInstance,g=a.canHydrateTextInstance,h=a.getNextHydratableSibling,k=a.getFirstHydratableChild,q=a.hydrateInstance,v=a.hydrateTextInstance,y=null,u=null,z=!1;return{enterHydrationState:function(a){u=
k(a.stateNode.containerInfo);y=a;return z=!0},resetHydrationState:function(){u=y=null;z=!1},tryToClaimNextHydratableInstance:function(a){if(z){var d=u;if(d){if(!c(a,d)){d=h(d);if(!d||!c(a,d)){a.effectTag|=2;z=!1;y=a;return}b(y,u)}y=a;u=k(d)}else a.effectTag|=2,z=!1,y=a}},prepareToHydrateHostInstance:function(a,b,c){b=q(a.stateNode,a.type,a.memoizedProps,b,c,a);a.updateQueue=b;return null!==b?!0:!1},prepareToHydrateHostTextInstance:function(a){return v(a.stateNode,a.memoizedProps,a)},popHydrationState:function(a){if(a!==
y)return!1;if(!z)return d(a),z=!0,!1;var c=a.type;if(5!==a.tag||"head"!==c&&"body"!==c&&!e(c,a.memoizedProps))for(c=u;c;)b(a,c),c=h(c);d(a);u=y?h(a.stateNode):null;return!0}}}
function kf(a){function b(a){Qb=ja=!0;var b=a.stateNode;b.current===a?E("177"):void 0;b.isReadyForCommit=!1;id.current=null;if(1<a.effectTag)if(null!==a.lastEffect){a.lastEffect.nextEffect=a;var c=a.firstEffect}else c=a;else c=a.firstEffect;yg();for(t=c;null!==t;){var d=!1,e=void 0;try{for(;null!==t;){var f=t.effectTag;f&16&&zg(t);if(f&128){var g=t.alternate;null!==g&&Ag(g)}switch(f&-242){case 2:Ne(t);t.effectTag&=-3;break;case 6:Ne(t);t.effectTag&=-3;Oe(t.alternate,t);break;case 4:Oe(t.alternate,
t);break;case 8:Sc=!0,Bg(t),Sc=!1}t=t.nextEffect}}catch(Tc){d=!0,e=Tc}d&&(null===t?E("178"):void 0,h(t,e),null!==t&&(t=t.nextEffect))}Cg();b.current=a;for(t=c;null!==t;){c=!1;d=void 0;try{for(;null!==t;){var k=t.effectTag;k&36&&Dg(t.alternate,t);k&128&&Eg(t);if(k&64)switch(e=t,f=void 0,null!==R&&(f=R.get(e),R["delete"](e),null==f&&null!==e.alternate&&(e=e.alternate,f=R.get(e),R["delete"](e))),null==f?E("184"):void 0,e.tag){case 2:e.stateNode.componentDidCatch(f.error,{componentStack:f.componentStack});
break;case 3:null===ca&&(ca=f.error);break;default:E("157")}var Qc=t.nextEffect;t.nextEffect=null;t=Qc}}catch(Tc){c=!0,d=Tc}c&&(null===t?E("178"):void 0,h(t,d),null!==t&&(t=t.nextEffect))}ja=Qb=!1;"function"===typeof De&&De(a.stateNode);ha&&(ha.forEach(G),ha=null);null!==ca&&(a=ca,ca=null,Ob(a));b=b.current.expirationTime;0===b&&(qa=R=null);return b}function c(a){for(;;){var b=Fg(a.alternate,a,H),c=a["return"],d=a.sibling;var e=a;if(2147483647===H||2147483647!==e.expirationTime){if(2!==e.tag&&3!==
e.tag)var f=0;else f=e.updateQueue,f=null===f?0:f.expirationTime;for(var g=e.child;null!==g;)0!==g.expirationTime&&(0===f||f>g.expirationTime)&&(f=g.expirationTime),g=g.sibling;e.expirationTime=f}if(null!==b)return b;null!==c&&(null===c.firstEffect&&(c.firstEffect=a.firstEffect),null!==a.lastEffect&&(null!==c.lastEffect&&(c.lastEffect.nextEffect=a.firstEffect),c.lastEffect=a.lastEffect),1<a.effectTag&&(null!==c.lastEffect?c.lastEffect.nextEffect=a:c.firstEffect=a,c.lastEffect=a));if(null!==d)return d;
if(null!==c)a=c;else{a.stateNode.isReadyForCommit=!0;break}}return null}function d(a){var b=rg(a.alternate,a,H);null===b&&(b=c(a));id.current=null;return b}function e(a){var b=Gg(a.alternate,a,H);null===b&&(b=c(a));id.current=null;return b}function f(a){if(null!==R){if(!(0===H||H>a))if(H<=Uc)for(;null!==F;)F=k(F)?e(F):d(F);else for(;null!==F&&!A();)F=k(F)?e(F):d(F)}else if(!(0===H||H>a))if(H<=Uc)for(;null!==F;)F=d(F);else for(;null!==F&&!A();)F=d(F)}function g(a,b){ja?E("243"):void 0;ja=!0;a.isReadyForCommit=
!1;if(a!==ra||b!==H||null===F){for(;-1<he;)ge[he]=null,he--;je=D;ie.current=D;X.current=!1;x();ra=a;H=b;F=se(ra.current,null,b)}var c=!1,d=null;try{f(b)}catch(Rc){c=!0,d=Rc}for(;c;){if(eb){ca=d;break}var g=F;if(null===g)eb=!0;else{var k=h(g,d);null===k?E("183"):void 0;if(!eb){try{c=k;d=b;for(k=c;null!==g;){switch(g.tag){case 2:ne(g);break;case 5:qg(g);break;case 3:p(g);break;case 4:p(g)}if(g===k||g.alternate===k)break;g=g["return"]}F=e(c);f(d)}catch(Rc){c=!0;d=Rc;continue}break}}}b=ca;eb=ja=!1;ca=
null;null!==b&&Ob(b);return a.isReadyForCommit?a.current.alternate:null}function h(a,b){var c=id.current=null,d=!1,e=!1,f=null;if(3===a.tag)c=a,q(a)&&(eb=!0);else for(var g=a["return"];null!==g&&null===c;){2===g.tag?"function"===typeof g.stateNode.componentDidCatch&&(d=!0,f=jd(g),c=g,e=!0):3===g.tag&&(c=g);if(q(g)){if(Sc||null!==ha&&(ha.has(g)||null!==g.alternate&&ha.has(g.alternate)))return null;c=null;e=!1}g=g["return"]}if(null!==c){null===qa&&(qa=new Set);qa.add(c);var h="";g=a;do{a:switch(g.tag){case 0:case 1:case 2:case 5:var k=
g._debugOwner,Qc=g._debugSource;var m=jd(g);var n=null;k&&(n=jd(k));k=Qc;m="\n    in "+(m||"Unknown")+(k?" (at "+k.fileName.replace(/^.*[\\\/]/,"")+":"+k.lineNumber+")":n?" (created by "+n+")":"");break a;default:m=""}h+=m;g=g["return"]}while(g);g=h;a=jd(a);null===R&&(R=new Map);b={componentName:a,componentStack:g,error:b,errorBoundary:d?c.stateNode:null,errorBoundaryFound:d,errorBoundaryName:f,willRetry:e};R.set(c,b);try{var p=b.error;p&&p.suppressReactErrorLogging||console.error(p)}catch(Vc){Vc&&
Vc.suppressReactErrorLogging||console.error(Vc)}Qb?(null===ha&&(ha=new Set),ha.add(c)):G(c);return c}null===ca&&(ca=b);return null}function k(a){return null!==R&&(R.has(a)||null!==a.alternate&&R.has(a.alternate))}function q(a){return null!==qa&&(qa.has(a)||null!==a.alternate&&qa.has(a.alternate))}function v(){return 20*(((I()+100)/20|0)+1)}function y(a){return 0!==ka?ka:ja?Qb?1:H:!Hg||a.internalContextTag&1?v():1}function u(a,b){return z(a,b,!1)}function z(a,b){for(;null!==a;){if(0===a.expirationTime||
a.expirationTime>b)a.expirationTime=b;null!==a.alternate&&(0===a.alternate.expirationTime||a.alternate.expirationTime>b)&&(a.alternate.expirationTime=b);if(null===a["return"])if(3===a.tag){var c=a.stateNode;!ja&&c===ra&&b<H&&(F=ra=null,H=0);var d=c,e=b;Rb>Ig&&E("185");if(null===d.nextScheduledRoot)d.remainingExpirationTime=e,null===O?(sa=O=d,d.nextScheduledRoot=d):(O=O.nextScheduledRoot=d,O.nextScheduledRoot=sa);else{var f=d.remainingExpirationTime;if(0===f||e<f)d.remainingExpirationTime=e}Fa||(la?
Sb&&(ma=d,na=1,m(ma,na)):1===e?w(1,null):L(e));!ja&&c===ra&&b<H&&(F=ra=null,H=0)}else break;a=a["return"]}}function G(a){z(a,1,!0)}function I(){return Uc=((Wc()-Pe)/10|0)+2}function L(a){if(0!==Tb){if(a>Tb)return;Jg(Xc)}var b=Wc()-Pe;Tb=a;Xc=Kg(J,{timeout:10*(a-2)-b})}function N(){var a=0,b=null;if(null!==O)for(var c=O,d=sa;null!==d;){var e=d.remainingExpirationTime;if(0===e){null===c||null===O?E("244"):void 0;if(d===d.nextScheduledRoot){sa=O=d.nextScheduledRoot=null;break}else if(d===sa)sa=e=d.nextScheduledRoot,
O.nextScheduledRoot=e,d.nextScheduledRoot=null;else if(d===O){O=c;O.nextScheduledRoot=sa;d.nextScheduledRoot=null;break}else c.nextScheduledRoot=d.nextScheduledRoot,d.nextScheduledRoot=null;d=c.nextScheduledRoot}else{if(0===a||e<a)a=e,b=d;if(d===O)break;c=d;d=d.nextScheduledRoot}}c=ma;null!==c&&c===b?Rb++:Rb=0;ma=b;na=a}function J(a){w(0,a)}function w(a,b){fb=b;for(N();null!==ma&&0!==na&&(0===a||na<=a)&&!Yc;)m(ma,na),N();null!==fb&&(Tb=0,Xc=-1);0!==na&&L(na);fb=null;Yc=!1;Rb=0;if(Ub)throw a=Zc,Zc=
null,Ub=!1,a;}function m(a,c){Fa?E("245"):void 0;Fa=!0;if(c<=I()){var d=a.finishedWork;null!==d?(a.finishedWork=null,a.remainingExpirationTime=b(d)):(a.finishedWork=null,d=g(a,c),null!==d&&(a.remainingExpirationTime=b(d)))}else d=a.finishedWork,null!==d?(a.finishedWork=null,a.remainingExpirationTime=b(d)):(a.finishedWork=null,d=g(a,c),null!==d&&(A()?a.finishedWork=d:a.remainingExpirationTime=b(d)));Fa=!1}function A(){return null===fb||fb.timeRemaining()>Lg?!1:Yc=!0}function Ob(a){null===ma?E("246"):
void 0;ma.remainingExpirationTime=0;Ub||(Ub=!0,Zc=a)}var r=hf(a),n=jf(a),p=r.popHostContainer,qg=r.popHostContext,x=r.resetHostContainer,Me=df(a,r,n,u,y),rg=Me.beginWork,Gg=Me.beginFailedWork,Fg=ef(a,r,n).completeWork;r=ff(a,h);var zg=r.commitResetTextContent,Ne=r.commitPlacement,Bg=r.commitDeletion,Oe=r.commitWork,Dg=r.commitLifeCycles,Eg=r.commitAttachRef,Ag=r.commitDetachRef,Wc=a.now,Kg=a.scheduleDeferredCallback,Jg=a.cancelDeferredCallback,Hg=a.useSyncScheduling,yg=a.prepareForCommit,Cg=a.resetAfterCommit,
Pe=Wc(),Uc=2,ka=0,ja=!1,F=null,ra=null,H=0,t=null,R=null,qa=null,ha=null,ca=null,eb=!1,Qb=!1,Sc=!1,sa=null,O=null,Tb=0,Xc=-1,Fa=!1,ma=null,na=0,Yc=!1,Ub=!1,Zc=null,fb=null,la=!1,Sb=!1,Ig=1E3,Rb=0,Lg=1;return{computeAsyncExpiration:v,computeExpirationForFiber:y,scheduleWork:u,batchedUpdates:function(a,b){var c=la;la=!0;try{return a(b)}finally{(la=c)||Fa||w(1,null)}},unbatchedUpdates:function(a){if(la&&!Sb){Sb=!0;try{return a()}finally{Sb=!1}}return a()},flushSync:function(a){var b=la;la=!0;try{a:{var c=
ka;ka=1;try{var d=a();break a}finally{ka=c}d=void 0}return d}finally{la=b,Fa?E("187"):void 0,w(1,null)}},deferredUpdates:function(a){var b=ka;ka=v();try{return a()}finally{ka=b}}}}
function lf(a){function b(a){a=od(a);return null===a?null:a.stateNode}var c=a.getPublicInstance;a=kf(a);var d=a.computeAsyncExpiration,e=a.computeExpirationForFiber,f=a.scheduleWork;return{createContainer:function(a,b){var c=new Y(3,null,0);a={current:c,containerInfo:a,pendingChildren:null,remainingExpirationTime:0,isReadyForCommit:!1,finishedWork:null,context:null,pendingContext:null,hydrate:b,nextScheduledRoot:null};return c.stateNode=a},updateContainer:function(a,b,c,q){var g=b.current;if(c){c=
c._reactInternalFiber;var h;b:{2===kd(c)&&2===c.tag?void 0:E("170");for(h=c;3!==h.tag;){if(le(h)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}(h=h["return"])?void 0:E("171")}h=h.stateNode.context}c=le(c)?pe(c,h):h}else c=D;null===b.context?b.context=c:b.pendingContext=c;b=q;b=void 0===b?null:b;q=null!=a&&null!=a.type&&null!=a.type.prototype&&!0===a.type.prototype.unstable_isAsyncReactComponent?d():e(g);He(g,{expirationTime:q,partialState:{element:a},callback:b,isReplace:!1,isForced:!1,
nextCallback:null,next:null});f(g,q)},batchedUpdates:a.batchedUpdates,unbatchedUpdates:a.unbatchedUpdates,deferredUpdates:a.deferredUpdates,flushSync:a.flushSync,getPublicRootInstance:function(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return c(a.child.stateNode);default:return a.child.stateNode}},findHostInstance:b,findHostInstanceWithNoPortals:function(a){a=pd(a);return null===a?null:a.stateNode},injectIntoDevTools:function(a){var c=a.findFiberByHostInstance;return Ce(B({},
a,{findHostInstanceByFiber:function(a){return b(a)},findFiberByHostInstance:function(a){return c?c(a):null}}))}}}var mf=Object.freeze({default:lf}),nf=mf&&lf||mf,of=nf["default"]?nf["default"]:nf;function pf(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:Ue,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}var qf="object"===typeof performance&&"function"===typeof performance.now,rf=void 0;rf=qf?function(){return performance.now()}:function(){return Date.now()};
var sf=void 0,tf=void 0;
if(l.canUseDOM)if("function"!==typeof requestIdleCallback||"function"!==typeof cancelIdleCallback){var uf=null,vf=!1,wf=-1,xf=!1,yf=0,zf=33,Af=33,Bf;Bf=qf?{didTimeout:!1,timeRemaining:function(){var a=yf-performance.now();return 0<a?a:0}}:{didTimeout:!1,timeRemaining:function(){var a=yf-Date.now();return 0<a?a:0}};var Cf="__reactIdleCallback$"+Math.random().toString(36).slice(2);window.addEventListener("message",function(a){if(a.source===window&&a.data===Cf){vf=!1;a=rf();if(0>=yf-a)if(-1!==wf&&wf<=
a)Bf.didTimeout=!0;else{xf||(xf=!0,requestAnimationFrame(Df));return}else Bf.didTimeout=!1;wf=-1;a=uf;uf=null;null!==a&&a(Bf)}},!1);var Df=function(a){xf=!1;var b=a-yf+Af;b<Af&&zf<Af?(8>b&&(b=8),Af=b<zf?zf:b):zf=b;yf=a+Af;vf||(vf=!0,window.postMessage(Cf,"*"))};sf=function(a,b){uf=a;null!=b&&"number"===typeof b.timeout&&(wf=rf()+b.timeout);xf||(xf=!0,requestAnimationFrame(Df));return 0};tf=function(){uf=null;vf=!1;wf=-1}}else sf=window.requestIdleCallback,tf=window.cancelIdleCallback;else sf=function(a){return setTimeout(function(){a({timeRemaining:function(){return Infinity}})})},
tf=function(a){clearTimeout(a)};var Ef=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Ff={},Gf={};
function Hf(a){if(Gf.hasOwnProperty(a))return!0;if(Ff.hasOwnProperty(a))return!1;if(Ef.test(a))return Gf[a]=!0;Ff[a]=!0;return!1}
function If(a,b,c){var d=wa(b);if(d&&va(b,c)){var e=d.mutationMethod;e?e(a,c):null==c||d.hasBooleanValue&&!c||d.hasNumericValue&&isNaN(c)||d.hasPositiveNumericValue&&1>c||d.hasOverloadedBooleanValue&&!1===c?Jf(a,b):d.mustUseProperty?a[d.propertyName]=c:(b=d.attributeName,(e=d.attributeNamespace)?a.setAttributeNS(e,b,""+c):d.hasBooleanValue||d.hasOverloadedBooleanValue&&!0===c?a.setAttribute(b,""):a.setAttribute(b,""+c))}else Kf(a,b,va(b,c)?c:null)}
function Kf(a,b,c){Hf(b)&&(null==c?a.removeAttribute(b):a.setAttribute(b,""+c))}function Jf(a,b){var c=wa(b);c?(b=c.mutationMethod)?b(a,void 0):c.mustUseProperty?a[c.propertyName]=c.hasBooleanValue?!1:"":a.removeAttribute(c.attributeName):a.removeAttribute(b)}
function Lf(a,b){var c=b.value,d=b.checked;return B({type:void 0,step:void 0,min:void 0,max:void 0},b,{defaultChecked:void 0,defaultValue:void 0,value:null!=c?c:a._wrapperState.initialValue,checked:null!=d?d:a._wrapperState.initialChecked})}function Mf(a,b){var c=b.defaultValue;a._wrapperState={initialChecked:null!=b.checked?b.checked:b.defaultChecked,initialValue:null!=b.value?b.value:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}
function Nf(a,b){b=b.checked;null!=b&&If(a,"checked",b)}function Of(a,b){Nf(a,b);var c=b.value;if(null!=c)if(0===c&&""===a.value)a.value="0";else if("number"===b.type){if(b=parseFloat(a.value)||0,c!=b||c==b&&a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else null==b.value&&null!=b.defaultValue&&a.defaultValue!==""+b.defaultValue&&(a.defaultValue=""+b.defaultValue),null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}
function Pf(a,b){switch(b.type){case "submit":case "reset":break;case "color":case "date":case "datetime":case "datetime-local":case "month":case "time":case "week":a.value="";a.value=a.defaultValue;break;default:a.value=a.value}b=a.name;""!==b&&(a.name="");a.defaultChecked=!a.defaultChecked;a.defaultChecked=!a.defaultChecked;""!==b&&(a.name=b)}function Qf(a){var b="";aa.Children.forEach(a,function(a){null==a||"string"!==typeof a&&"number"!==typeof a||(b+=a)});return b}
function Rf(a,b){a=B({children:void 0},b);if(b=Qf(b.children))a.children=b;return a}function Sf(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+c;b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}
function Tf(a,b){var c=b.value;a._wrapperState={initialValue:null!=c?c:b.defaultValue,wasMultiple:!!b.multiple}}function Uf(a,b){null!=b.dangerouslySetInnerHTML?E("91"):void 0;return B({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function Vf(a,b){var c=b.value;null==c&&(c=b.defaultValue,b=b.children,null!=b&&(null!=c?E("92"):void 0,Array.isArray(b)&&(1>=b.length?void 0:E("93"),b=b[0]),c=""+b),null==c&&(c=""));a._wrapperState={initialValue:""+c}}
function Wf(a,b){var c=b.value;null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&(a.defaultValue=c));null!=b.defaultValue&&(a.defaultValue=b.defaultValue)}function Xf(a){var b=a.textContent;b===a._wrapperState.initialValue&&(a.value=b)}var Yf={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};
function Zf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function $f(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Zf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
var ag=void 0,bg=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==Yf.svg||"innerHTML"in a)a.innerHTML=b;else{ag=ag||document.createElement("div");ag.innerHTML="\x3csvg\x3e"+b+"\x3c/svg\x3e";for(b=ag.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});
function cg(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}
var dg={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,
stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},eg=["Webkit","ms","Moz","O"];Object.keys(dg).forEach(function(a){eg.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);dg[b]=dg[a]})});
function fg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--");var e=c;var f=b[c];e=null==f||"boolean"===typeof f||""===f?"":d||"number"!==typeof f||0===f||dg.hasOwnProperty(e)&&dg[e]?(""+f).trim():f+"px";"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var gg=B({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
function hg(a,b,c){b&&(gg[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML?E("137",a,c()):void 0),null!=b.dangerouslySetInnerHTML&&(null!=b.children?E("60"):void 0,"object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML?void 0:E("61")),null!=b.style&&"object"!==typeof b.style?E("62",c()):void 0)}
function ig(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}var jg=Yf.html,kg=C.thatReturns("");
function lg(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Hd(a);b=Sa[b];for(var d=0;d<b.length;d++){var e=b[d];c.hasOwnProperty(e)&&c[e]||("topScroll"===e?wd("topScroll","scroll",a):"topFocus"===e||"topBlur"===e?(wd("topFocus","focus",a),wd("topBlur","blur",a),c.topBlur=!0,c.topFocus=!0):"topCancel"===e?(yc("cancel",!0)&&wd("topCancel","cancel",a),c.topCancel=!0):"topClose"===e?(yc("close",!0)&&wd("topClose","close",a),c.topClose=!0):Dd.hasOwnProperty(e)&&U(e,Dd[e],a),c[e]=!0)}}
var mg={topAbort:"abort",topCanPlay:"canplay",topCanPlayThrough:"canplaythrough",topDurationChange:"durationchange",topEmptied:"emptied",topEncrypted:"encrypted",topEnded:"ended",topError:"error",topLoadedData:"loadeddata",topLoadedMetadata:"loadedmetadata",topLoadStart:"loadstart",topPause:"pause",topPlay:"play",topPlaying:"playing",topProgress:"progress",topRateChange:"ratechange",topSeeked:"seeked",topSeeking:"seeking",topStalled:"stalled",topSuspend:"suspend",topTimeUpdate:"timeupdate",topVolumeChange:"volumechange",
topWaiting:"waiting"};function ng(a,b,c,d){c=9===c.nodeType?c:c.ownerDocument;d===jg&&(d=Zf(a));d===jg?"script"===a?(a=c.createElement("div"),a.innerHTML="\x3cscript\x3e\x3c/script\x3e",a=a.removeChild(a.firstChild)):a="string"===typeof b.is?c.createElement(a,{is:b.is}):c.createElement(a):a=c.createElementNS(d,a);return a}function og(a,b){return(9===b.nodeType?b:b.ownerDocument).createTextNode(a)}
function pg(a,b,c,d){var e=ig(b,c);switch(b){case "iframe":case "object":U("topLoad","load",a);var f=c;break;case "video":case "audio":for(f in mg)mg.hasOwnProperty(f)&&U(f,mg[f],a);f=c;break;case "source":U("topError","error",a);f=c;break;case "img":case "image":U("topError","error",a);U("topLoad","load",a);f=c;break;case "form":U("topReset","reset",a);U("topSubmit","submit",a);f=c;break;case "details":U("topToggle","toggle",a);f=c;break;case "input":Mf(a,c);f=Lf(a,c);U("topInvalid","invalid",a);
lg(d,"onChange");break;case "option":f=Rf(a,c);break;case "select":Tf(a,c);f=B({},c,{value:void 0});U("topInvalid","invalid",a);lg(d,"onChange");break;case "textarea":Vf(a,c);f=Uf(a,c);U("topInvalid","invalid",a);lg(d,"onChange");break;default:f=c}hg(b,f,kg);var g=f,h;for(h in g)if(g.hasOwnProperty(h)){var k=g[h];"style"===h?fg(a,k,kg):"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,null!=k&&bg(a,k)):"children"===h?"string"===typeof k?("textarea"!==b||""!==k)&&cg(a,k):"number"===typeof k&&cg(a,
""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(Ra.hasOwnProperty(h)?null!=k&&lg(d,h):e?Kf(a,h,k):null!=k&&If(a,h,k))}switch(b){case "input":Bc(a);Pf(a,c);break;case "textarea":Bc(a);Xf(a,c);break;case "option":null!=c.value&&a.setAttribute("value",c.value);break;case "select":a.multiple=!!c.multiple;b=c.value;null!=b?Sf(a,!!c.multiple,b,!1):null!=c.defaultValue&&Sf(a,!!c.multiple,c.defaultValue,!0);break;default:"function"===typeof f.onClick&&(a.onclick=
C)}}
function sg(a,b,c,d,e){var f=null;switch(b){case "input":c=Lf(a,c);d=Lf(a,d);f=[];break;case "option":c=Rf(a,c);d=Rf(a,d);f=[];break;case "select":c=B({},c,{value:void 0});d=B({},d,{value:void 0});f=[];break;case "textarea":c=Uf(a,c);d=Uf(a,d);f=[];break;default:"function"!==typeof c.onClick&&"function"===typeof d.onClick&&(a.onclick=C)}hg(b,d,kg);var g,h;a=null;for(g in c)if(!d.hasOwnProperty(g)&&c.hasOwnProperty(g)&&null!=c[g])if("style"===g)for(h in b=c[g],b)b.hasOwnProperty(h)&&(a||(a={}),a[h]=
"");else"dangerouslySetInnerHTML"!==g&&"children"!==g&&"suppressContentEditableWarning"!==g&&"suppressHydrationWarning"!==g&&"autoFocus"!==g&&(Ra.hasOwnProperty(g)?f||(f=[]):(f=f||[]).push(g,null));for(g in d){var k=d[g];b=null!=c?c[g]:void 0;if(d.hasOwnProperty(g)&&k!==b&&(null!=k||null!=b))if("style"===g)if(b){for(h in b)!b.hasOwnProperty(h)||k&&k.hasOwnProperty(h)||(a||(a={}),a[h]="");for(h in k)k.hasOwnProperty(h)&&b[h]!==k[h]&&(a||(a={}),a[h]=k[h])}else a||(f||(f=[]),f.push(g,a)),a=k;else"dangerouslySetInnerHTML"===
g?(k=k?k.__html:void 0,b=b?b.__html:void 0,null!=k&&b!==k&&(f=f||[]).push(g,""+k)):"children"===g?b===k||"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(g,""+k):"suppressContentEditableWarning"!==g&&"suppressHydrationWarning"!==g&&(Ra.hasOwnProperty(g)?(null!=k&&lg(e,g),f||b===k||(f=[])):(f=f||[]).push(g,k))}a&&(f=f||[]).push("style",a);return f}
function tg(a,b,c,d,e){"input"===c&&"radio"===e.type&&null!=e.name&&Nf(a,e);ig(c,d);d=ig(c,e);for(var f=0;f<b.length;f+=2){var g=b[f],h=b[f+1];"style"===g?fg(a,h,kg):"dangerouslySetInnerHTML"===g?bg(a,h):"children"===g?cg(a,h):d?null!=h?Kf(a,g,h):a.removeAttribute(g):null!=h?If(a,g,h):Jf(a,g)}switch(c){case "input":Of(a,e);break;case "textarea":Wf(a,e);break;case "select":a._wrapperState.initialValue=void 0,b=a._wrapperState.wasMultiple,a._wrapperState.wasMultiple=!!e.multiple,c=e.value,null!=c?Sf(a,
!!e.multiple,c,!1):b!==!!e.multiple&&(null!=e.defaultValue?Sf(a,!!e.multiple,e.defaultValue,!0):Sf(a,!!e.multiple,e.multiple?[]:"",!1))}}
function ug(a,b,c,d,e){switch(b){case "iframe":case "object":U("topLoad","load",a);break;case "video":case "audio":for(var f in mg)mg.hasOwnProperty(f)&&U(f,mg[f],a);break;case "source":U("topError","error",a);break;case "img":case "image":U("topError","error",a);U("topLoad","load",a);break;case "form":U("topReset","reset",a);U("topSubmit","submit",a);break;case "details":U("topToggle","toggle",a);break;case "input":Mf(a,c);U("topInvalid","invalid",a);lg(e,"onChange");break;case "select":Tf(a,c);
U("topInvalid","invalid",a);lg(e,"onChange");break;case "textarea":Vf(a,c),U("topInvalid","invalid",a),lg(e,"onChange")}hg(b,c,kg);d=null;for(var g in c)c.hasOwnProperty(g)&&(f=c[g],"children"===g?"string"===typeof f?a.textContent!==f&&(d=["children",f]):"number"===typeof f&&a.textContent!==""+f&&(d=["children",""+f]):Ra.hasOwnProperty(g)&&null!=f&&lg(e,g));switch(b){case "input":Bc(a);Pf(a,c);break;case "textarea":Bc(a);Xf(a,c);break;case "select":case "option":break;default:"function"===typeof c.onClick&&
(a.onclick=C)}return d}function vg(a,b){return a.nodeValue!==b}
var wg=Object.freeze({createElement:ng,createTextNode:og,setInitialProperties:pg,diffProperties:sg,updateProperties:tg,diffHydratedProperties:ug,diffHydratedText:vg,warnForUnmatchedText:function(){},warnForDeletedHydratableElement:function(){},warnForDeletedHydratableText:function(){},warnForInsertedHydratedElement:function(){},warnForInsertedHydratedText:function(){},restoreControlledState:function(a,b,c){switch(b){case "input":Of(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=
c.parentNode;c=c.querySelectorAll("input[name\x3d"+JSON.stringify(""+b)+'][type\x3d"radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=rb(d);e?void 0:E("90");Cc(d);Of(d,e)}}}break;case "textarea":Wf(a,c);break;case "select":b=c.value,null!=b&&Sf(a,!!c.multiple,b,!1)}}});nc.injectFiberControlledHostComponent(wg);var xg=null,Mg=null;function Ng(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}
function Og(a){a=a?9===a.nodeType?a.documentElement:a.firstChild:null;return!(!a||1!==a.nodeType||!a.hasAttribute("data-reactroot"))}
var Z=of({getRootHostContext:function(a){var b=a.nodeType;switch(b){case 9:case 11:a=(a=a.documentElement)?a.namespaceURI:$f(null,"");break;default:b=8===b?a.parentNode:a,a=b.namespaceURI||null,b=b.tagName,a=$f(a,b)}return a},getChildHostContext:function(a,b){return $f(a,b)},getPublicInstance:function(a){return a},prepareForCommit:function(){xg=td;var a=da();if(Kd(a)){if("selectionStart"in a)var b={start:a.selectionStart,end:a.selectionEnd};else a:{var c=window.getSelection&&window.getSelection();
if(c&&0!==c.rangeCount){b=c.anchorNode;var d=c.anchorOffset,e=c.focusNode;c=c.focusOffset;try{b.nodeType,e.nodeType}catch(z){b=null;break a}var f=0,g=-1,h=-1,k=0,q=0,v=a,y=null;b:for(;;){for(var u;;){v!==b||0!==d&&3!==v.nodeType||(g=f+d);v!==e||0!==c&&3!==v.nodeType||(h=f+c);3===v.nodeType&&(f+=v.nodeValue.length);if(null===(u=v.firstChild))break;y=v;v=u}for(;;){if(v===a)break b;y===b&&++k===d&&(g=f);y===e&&++q===c&&(h=f);if(null!==(u=v.nextSibling))break;v=y;y=v.parentNode}v=u}b=-1===g||-1===h?null:
{start:g,end:h}}else b=null}b=b||{start:0,end:0}}else b=null;Mg={focusedElem:a,selectionRange:b};ud(!1)},resetAfterCommit:function(){var a=Mg,b=da(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&fa(document.documentElement,c)){if(Kd(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(window.getSelection){b=window.getSelection();var e=c[Eb()].length;a=Math.min(d.start,e);d=void 0===d.end?a:Math.min(d.end,e);!b.extend&&a>
d&&(e=d,d=a,a=e);e=Jd(c,a);var f=Jd(c,d);if(e&&f&&(1!==b.rangeCount||b.anchorNode!==e.node||b.anchorOffset!==e.offset||b.focusNode!==f.node||b.focusOffset!==f.offset)){var g=document.createRange();g.setStart(e.node,e.offset);b.removeAllRanges();a>d?(b.addRange(g),b.extend(f.node,f.offset)):(g.setEnd(f.node,f.offset),b.addRange(g))}}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});ia(c);for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=
a.top}Mg=null;ud(xg);xg=null},createInstance:function(a,b,c,d,e){a=ng(a,b,c,d);a[Q]=e;a[ob]=b;return a},appendInitialChild:function(a,b){a.appendChild(b)},finalizeInitialChildren:function(a,b,c,d){pg(a,b,c,d);a:{switch(b){case "button":case "input":case "select":case "textarea":a=!!c.autoFocus;break a}a=!1}return a},prepareUpdate:function(a,b,c,d,e){return sg(a,b,c,d,e)},shouldSetTextContent:function(a,b){return"textarea"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===
typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&"string"===typeof b.dangerouslySetInnerHTML.__html},shouldDeprioritizeSubtree:function(a,b){return!!b.hidden},createTextInstance:function(a,b,c,d){a=og(a,b);a[Q]=d;return a},now:rf,mutation:{commitMount:function(a){a.focus()},commitUpdate:function(a,b,c,d,e){a[ob]=e;tg(a,b,c,d,e)},resetTextContent:function(a){a.textContent=""},commitTextUpdate:function(a,b,c){a.nodeValue=c},appendChild:function(a,b){a.appendChild(b)},appendChildToContainer:function(a,
b){8===a.nodeType?a.parentNode.insertBefore(b,a):a.appendChild(b)},insertBefore:function(a,b,c){a.insertBefore(b,c)},insertInContainerBefore:function(a,b,c){8===a.nodeType?a.parentNode.insertBefore(b,c):a.insertBefore(b,c)},removeChild:function(a,b){a.removeChild(b)},removeChildFromContainer:function(a,b){8===a.nodeType?a.parentNode.removeChild(b):a.removeChild(b)}},hydration:{canHydrateInstance:function(a,b){return 1!==a.nodeType||b.toLowerCase()!==a.nodeName.toLowerCase()?null:a},canHydrateTextInstance:function(a,
b){return""===b||3!==a.nodeType?null:a},getNextHydratableSibling:function(a){for(a=a.nextSibling;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a},getFirstHydratableChild:function(a){for(a=a.firstChild;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a},hydrateInstance:function(a,b,c,d,e,f){a[Q]=f;a[ob]=c;return ug(a,b,c,e,d)},hydrateTextInstance:function(a,b,c){a[Q]=c;return vg(a,b)},didNotMatchHydratedContainerTextInstance:function(){},didNotMatchHydratedTextInstance:function(){},
didNotHydrateContainerInstance:function(){},didNotHydrateInstance:function(){},didNotFindHydratableContainerInstance:function(){},didNotFindHydratableContainerTextInstance:function(){},didNotFindHydratableInstance:function(){},didNotFindHydratableTextInstance:function(){}},scheduleDeferredCallback:sf,cancelDeferredCallback:tf,useSyncScheduling:!0});rc=Z.batchedUpdates;
function Pg(a,b,c,d,e){Ng(c)?void 0:E("200");var f=c._reactRootContainer;if(f)Z.updateContainer(b,f,a,e);else{d=d||Og(c);if(!d)for(f=void 0;f=c.lastChild;)c.removeChild(f);var g=Z.createContainer(c,d);f=c._reactRootContainer=g;Z.unbatchedUpdates(function(){Z.updateContainer(b,g,a,e)})}return Z.getPublicRootInstance(f)}function Qg(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;Ng(b)?void 0:E("200");return pf(a,b,null,c)}
function Rg(a,b){this._reactRootContainer=Z.createContainer(a,b)}Rg.prototype.render=function(a,b){Z.updateContainer(a,this._reactRootContainer,null,b)};Rg.prototype.unmount=function(a){Z.updateContainer(null,this._reactRootContainer,null,a)};
var Sg={createPortal:Qg,findDOMNode:function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(b)return Z.findHostInstance(b);"function"===typeof a.render?E("188"):E("213",Object.keys(a))},hydrate:function(a,b,c){return Pg(null,a,b,!0,c)},render:function(a,b,c){return Pg(null,a,b,!1,c)},unstable_renderSubtreeIntoContainer:function(a,b,c,d){null==a||void 0===a._reactInternalFiber?E("38"):void 0;return Pg(a,b,c,!1,d)},unmountComponentAtNode:function(a){Ng(a)?void 0:
E("40");return a._reactRootContainer?(Z.unbatchedUpdates(function(){Pg(null,null,a,!1,function(){a._reactRootContainer=null})}),!0):!1},unstable_createPortal:Qg,unstable_batchedUpdates:tc,unstable_deferredUpdates:Z.deferredUpdates,flushSync:Z.flushSync,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{EventPluginHub:mb,EventPluginRegistry:Va,EventPropagators:Cb,ReactControlledComponent:qc,ReactDOMComponentTree:sb,ReactDOMEventListener:xd}};
Z.injectIntoDevTools({findFiberByHostInstance:pb,bundleType:0,version:"16.2.0",rendererPackageName:"react-dom"});var Tg=Object.freeze({default:Sg}),Ug=Tg&&Sg||Tg;module.exports=Ug["default"]?Ug["default"]:Ug;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = __webpack_require__(142);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react-dom.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

var React = __webpack_require__(24);
var invariant = __webpack_require__(38);
var warning = __webpack_require__(39);
var ExecutionEnvironment = __webpack_require__(65);
var _assign = __webpack_require__(25);
var emptyFunction = __webpack_require__(12);
var EventListener = __webpack_require__(66);
var getActiveElement = __webpack_require__(67);
var shallowEqual = __webpack_require__(68);
var containsNode = __webpack_require__(69);
var focusNode = __webpack_require__(70);
var emptyObject = __webpack_require__(26);
var checkPropTypes = __webpack_require__(59);
var hyphenateStyleName = __webpack_require__(144);
var camelizeStyleName = __webpack_require__(146);

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;

// These attributes should be all lowercase to allow for
// case insensitive checks
var RESERVED_PROPS = {
  children: true,
  dangerouslySetInnerHTML: true,
  defaultValue: true,
  defaultChecked: true,
  innerHTML: true,
  suppressContentEditableWarning: true,
  suppressHydrationWarning: true,
  style: true
};

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
  HAS_STRING_BOOLEAN_VALUE: 0x40,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    for (var propName in Properties) {
      !!properties.hasOwnProperty(propName) ? invariant(false, "injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.", propName) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE),
        hasStringBooleanValue: checkMask(propConfig, Injection.HAS_STRING_BOOLEAN_VALUE)
      };
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? invariant(false, "DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s", propName) : void 0;

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];

        propertyInfo.attributeName = attributeName;
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      // Downcase references to whitelist properties to check for membership
      // without case-sensitivity. This allows the whitelist to pick up
      // `allowfullscreen`, which should be written using the property configuration
      // for `allowFullscreen`
      properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
/* eslint-enable max-len */
var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";


var ROOT_ATTRIBUTE_NAME = 'data-reactroot';

/**
 * Map from property "standard name" to an object with info about how to set
 * the property in the DOM. Each object contains:
 *
 * attributeName:
 *   Used when rendering markup or with `*Attribute()`.
 * attributeNamespace
 * propertyName:
 *   Used on DOM node instances. (This includes properties that mutate due to
 *   external factors.)
 * mutationMethod:
 *   If non-null, used instead of the property or `setAttribute()` after
 *   initial render.
 * mustUseProperty:
 *   Whether the property must be accessed and mutated as an object property.
 * hasBooleanValue:
 *   Whether the property should be removed when set to a falsey value.
 * hasNumericValue:
 *   Whether the property must be numeric or parse as a numeric and should be
 *   removed when set to a falsey value.
 * hasPositiveNumericValue:
 *   Whether the property must be positive numeric or parse as a positive
 *   numeric and should be removed when set to a falsey value.
 * hasOverloadedBooleanValue:
 *   Whether the property can be used as a flag as well as with a value.
 *   Removed when strictly equal to false; present without a value when
 *   strictly equal to true; present with a value otherwise.
 */
var properties = {};

/**
 * Checks whether a property name is a writeable attribute.
 * @method
 */
function shouldSetAttribute(name, value) {
  if (isReservedProp(name)) {
    return false;
  }
  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
    return false;
  }
  if (value === null) {
    return true;
  }
  switch (typeof value) {
    case 'boolean':
      return shouldAttributeAcceptBooleanValue(name);
    case 'undefined':
    case 'number':
    case 'string':
    case 'object':
      return true;
    default:
      // function, symbol
      return false;
  }
}

function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function shouldAttributeAcceptBooleanValue(name) {
  if (isReservedProp(name)) {
    return true;
  }
  var propertyInfo = getPropertyInfo(name);
  if (propertyInfo) {
    return propertyInfo.hasBooleanValue || propertyInfo.hasStringBooleanValue || propertyInfo.hasOverloadedBooleanValue;
  }
  var prefix = name.toLowerCase().slice(0, 5);
  return prefix === 'data-' || prefix === 'aria-';
}

/**
 * Checks to see if a property name is within the list of properties
 * reserved for internal React operations. These properties should
 * not be set on an HTML element.
 *
 * @private
 * @param {string} name
 * @return {boolean} If the name is within reserved props
 */
function isReservedProp(name) {
  return RESERVED_PROPS.hasOwnProperty(name);
}

var injection = DOMPropertyInjection;

var MUST_USE_PROPERTY = injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = injection.HAS_BOOLEAN_VALUE;
var HAS_NUMERIC_VALUE = injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = injection.HAS_OVERLOADED_BOOLEAN_VALUE;
var HAS_STRING_BOOLEAN_VALUE = injection.HAS_STRING_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig = {
  // When adding attributes to this list, be sure to also add them to
  // the `possibleStandardNames` module to ensure casing and incorrect
  // name warnings.
  Properties: {
    allowFullScreen: HAS_BOOLEAN_VALUE,
    // specifies target context for links with `preload` type
    async: HAS_BOOLEAN_VALUE,
    // Note: there is a special case that prevents it from being written to the DOM
    // on the client side because the browsers are inconsistent. Instead we call focus().
    autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_OVERLOADED_BOOLEAN_VALUE,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    contentEditable: HAS_STRING_BOOLEAN_VALUE,
    controls: HAS_BOOLEAN_VALUE,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: HAS_STRING_BOOLEAN_VALUE,
    formNoValidate: HAS_BOOLEAN_VALUE,
    hidden: HAS_BOOLEAN_VALUE,
    loop: HAS_BOOLEAN_VALUE,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    playsInline: HAS_BOOLEAN_VALUE,
    readOnly: HAS_BOOLEAN_VALUE,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    scoped: HAS_BOOLEAN_VALUE,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    start: HAS_NUMERIC_VALUE,
    // support for projecting regular DOM Elements via V1 named slots ( shadow dom )
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: HAS_STRING_BOOLEAN_VALUE,
    // Style must be explicitly set in the attribute list. React components
    // expect a style object
    style: 0,
    // Keep it in the whitelist because it is case-sensitive for SVG.
    tabIndex: 0,
    // itemScope is for for Microdata support.
    // See http://schema.org/docs/gs.html
    itemScope: HAS_BOOLEAN_VALUE,
    // These attributes must stay in the white-list because they have
    // different attribute names (see DOMAttributeNames below)
    acceptCharset: 0,
    className: 0,
    htmlFor: 0,
    httpEquiv: 0,
    // Attributes with mutation methods must be specified in the whitelist
    // Set the string boolean flag to allow the behavior
    value: HAS_STRING_BOOLEAN_VALUE
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMMutationMethods: {
    value: function (node, value) {
      if (value == null) {
        return node.removeAttribute('value');
      }

      // Number inputs get special treatment due to some edge cases in
      // Chrome. Let everything else assign the value attribute as normal.
      // https://github.com/facebook/react/issues/7253#issuecomment-236074326
      if (node.type !== 'number' || node.hasAttribute('value') === false) {
        node.setAttribute('value', '' + value);
      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
        // Don't assign an attribute if validation reports bad
        // input. Chrome will clear the value. Additionally, don't
        // operate on inputs that have focus, otherwise Chrome might
        // strip off trailing decimal places and cause the user's
        // cursor position to jump to the beginning of the input.
        //
        // In ReactDOMInput, we have an onBlur event that will trigger
        // this function again when focus is lost.
        node.setAttribute('value', '' + value);
      }
    }
  }
};

var HAS_STRING_BOOLEAN_VALUE$1 = injection.HAS_STRING_BOOLEAN_VALUE;


var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

/**
 * This is a list of all SVG attributes that need special casing,
 * namespacing, or boolean value assignment.
 *
 * When adding attributes to this list, be sure to also add them to
 * the `possibleStandardNames` module to ensure casing and incorrect
 * name warnings.
 *
 * SVG Attributes List:
 * https://www.w3.org/TR/SVG/attindex.html
 * SMIL Spec:
 * https://www.w3.org/TR/smil
 */
var ATTRS = ['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'x-height', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xmlns:xlink', 'xml:lang', 'xml:space'];

var SVGDOMPropertyConfig = {
  Properties: {
    autoReverse: HAS_STRING_BOOLEAN_VALUE$1,
    externalResourcesRequired: HAS_STRING_BOOLEAN_VALUE$1,
    preserveAlpha: HAS_STRING_BOOLEAN_VALUE$1
  },
  DOMAttributeNames: {
    autoReverse: 'autoReverse',
    externalResourcesRequired: 'externalResourcesRequired',
    preserveAlpha: 'preserveAlpha'
  },
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  }
};

var CAMELIZE = /[\-\:]([a-z])/g;
var capitalize = function (token) {
  return token[1].toUpperCase();
};

ATTRS.forEach(function (original) {
  var reactName = original.replace(CAMELIZE, capitalize);

  SVGDOMPropertyConfig.Properties[reactName] = 0;
  SVGDOMPropertyConfig.DOMAttributeNames[reactName] = original;
});

injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);

var ReactErrorUtils = {
  // Used by Fiber to simulate a try-catch.
  _caughtError: null,
  _hasCaughtError: false,

  // Used by event system to capture/rethrow the first error.
  _rethrowError: null,
  _hasRethrowError: false,

  injection: {
    injectErrorUtils: function (injectedErrorUtils) {
      !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;
      invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;
    }
  },

  /**
   * Call a function while guarding against errors that happens within it.
   * Returns an error if it throws, otherwise null.
   *
   * In production, this is implemented using a try-catch. The reason we don't
   * use a try-catch directly is so that we can swap out a different
   * implementation in DEV mode.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */
  invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {
    invokeGuardedCallback.apply(ReactErrorUtils, arguments);
  },

  /**
   * Same as invokeGuardedCallback, but instead of returning an error, it stores
   * it in a global so it can be rethrown by `rethrowCaughtError` later.
   * TODO: See if _caughtError and _rethrowError can be unified.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */
  invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {
    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);
    if (ReactErrorUtils.hasCaughtError()) {
      var error = ReactErrorUtils.clearCaughtError();
      if (!ReactErrorUtils._hasRethrowError) {
        ReactErrorUtils._hasRethrowError = true;
        ReactErrorUtils._rethrowError = error;
      }
    }
  },

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    return rethrowCaughtError.apply(ReactErrorUtils, arguments);
  },

  hasCaughtError: function () {
    return ReactErrorUtils._hasCaughtError;
  },

  clearCaughtError: function () {
    if (ReactErrorUtils._hasCaughtError) {
      var error = ReactErrorUtils._caughtError;
      ReactErrorUtils._caughtError = null;
      ReactErrorUtils._hasCaughtError = false;
      return error;
    } else {
      invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');
    }
  }
};

var invokeGuardedCallback = function (name, func, context, a, b, c, d, e, f) {
  ReactErrorUtils._hasCaughtError = false;
  ReactErrorUtils._caughtError = null;
  var funcArgs = Array.prototype.slice.call(arguments, 3);
  try {
    func.apply(context, funcArgs);
  } catch (error) {
    ReactErrorUtils._caughtError = error;
    ReactErrorUtils._hasCaughtError = true;
  }
};

{
  // In DEV mode, we swap out invokeGuardedCallback for a special version
  // that plays more nicely with the browser's DevTools. The idea is to preserve
  // "Pause on exceptions" behavior. Because React wraps all user-provided
  // functions in invokeGuardedCallback, and the production version of
  // invokeGuardedCallback uses a try-catch, all user exceptions are treated
  // like caught exceptions, and the DevTools won't pause unless the developer
  // takes the extra step of enabling pause on caught exceptions. This is
  // untintuitive, though, because even though React has caught the error, from
  // the developer's perspective, the error is uncaught.
  //
  // To preserve the expected "Pause on exceptions" behavior, we don't use a
  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
  // DOM node, and call the user-provided callback from inside an event handler
  // for that fake event. If the callback throws, the error is "captured" using
  // a global event handler. But because the error happens in a different
  // event loop context, it does not interrupt the normal program flow.
  // Effectively, this gives us try-catch behavior without actually using
  // try-catch. Neat!

  // Check that the browser supports the APIs we need to implement our special
  // DEV version of invokeGuardedCallback
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');

    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {
      // Keeps track of whether the user-provided callback threw an error. We
      // set this to true at the beginning, then set it to false right after
      // calling the function. If the function errors, `didError` will never be
      // set to false. This strategy works even if the browser is flaky and
      // fails to call our global error handler, because it doesn't rely on
      // the error event at all.
      var didError = true;

      // Create an event handler for our fake event. We will synchronously
      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
      // call the user-provided callback.
      var funcArgs = Array.prototype.slice.call(arguments, 3);
      function callCallback() {
        // We immediately remove the callback from event listeners so that
        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
        // nested call would trigger the fake event handlers of any call higher
        // in the stack.
        fakeNode.removeEventListener(evtType, callCallback, false);
        func.apply(context, funcArgs);
        didError = false;
      }

      // Create a global error event handler. We use this to capture the value
      // that was thrown. It's possible that this error handler will fire more
      // than once; for example, if non-React code also calls `dispatchEvent`
      // and a handler for that event throws. We should be resilient to most of
      // those cases. Even if our error event handler fires more than once, the
      // last error event is always used. If the callback actually does error,
      // we know that the last error event is the correct one, because it's not
      // possible for anything else to have happened in between our callback
      // erroring and the code that follows the `dispatchEvent` call below. If
      // the callback doesn't error, but the error event was fired, we know to
      // ignore it because `didError` will be false, as described above.
      var error = void 0;
      // Use this to track whether the error event is ever called.
      var didSetError = false;
      var isCrossOriginError = false;

      function onError(event) {
        error = event.error;
        didSetError = true;
        if (error === null && event.colno === 0 && event.lineno === 0) {
          isCrossOriginError = true;
        }
      }

      // Create a fake event type.
      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');

      // Attach our event handlers
      window.addEventListener('error', onError);
      fakeNode.addEventListener(evtType, callCallback, false);

      // Synchronously dispatch our fake event. If the user-provided function
      // errors, it will trigger our global error handler.
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);

      if (didError) {
        if (!didSetError) {
          // The callback errored, but the error event never fired.
          error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
        } else if (isCrossOriginError) {
          error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');
        }
        ReactErrorUtils._hasCaughtError = true;
        ReactErrorUtils._caughtError = error;
      } else {
        ReactErrorUtils._hasCaughtError = false;
        ReactErrorUtils._caughtError = null;
      }

      // Remove our event listeners
      window.removeEventListener('error', onError);
    };

    invokeGuardedCallback = invokeGuardedCallbackDev;
  }
}

var rethrowCaughtError = function () {
  if (ReactErrorUtils._hasRethrowError) {
    var error = ReactErrorUtils._rethrowError;
    ReactErrorUtils._rethrowError = null;
    ReactErrorUtils._hasRethrowError = false;
    throw error;
  }
};

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;
    if (plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;
    plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;
  eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;
  registrationNameModules[registrationName] = pluginModule;
  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  {
    var lowerCasedName = registrationName.toLowerCase();
    possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */

/**
 * Ordered list of injected plugins.
 */
var plugins = [];

/**
 * Mapping from event name to dispatch config
 */
var eventNameDispatchConfigs = {};

/**
 * Mapping from registration name to plugin module
 */
var registrationNameModules = {};

/**
 * Mapping from registration name to event name
 */
var registrationNameDependencies = {};

/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */
var possibleRegistrationNames = {};
// Trust the developer to only use possibleRegistrationNames in true

/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */
function injectEventPluginOrder(injectedEventPluginOrder) {
  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;
  // Clone the ordering so it cannot be dynamically mutated.
  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
  recomputePluginOrdering();
}

/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */
function injectEventPluginsByName(injectedNamesToPlugins) {
  var isOrderingDirty = false;
  for (var pluginName in injectedNamesToPlugins) {
    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
      continue;
    }
    var pluginModule = injectedNamesToPlugins[pluginName];
    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;
      namesToPlugins[pluginName] = pluginModule;
      isOrderingDirty = true;
    }
  }
  if (isOrderingDirty) {
    recomputePluginOrdering();
  }
}

var EventPluginRegistry = Object.freeze({
	plugins: plugins,
	eventNameDispatchConfigs: eventNameDispatchConfigs,
	registrationNameModules: registrationNameModules,
	registrationNameDependencies: registrationNameDependencies,
	possibleRegistrationNames: possibleRegistrationNames,
	injectEventPluginOrder: injectEventPluginOrder,
	injectEventPluginsByName: injectEventPluginsByName
});

var getFiberCurrentPropsFromNode = null;
var getInstanceFromNode = null;
var getNodeFromInstance = null;

var injection$2 = {
  injectComponentTree: function (Injected) {
    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;
    getInstanceFromNode = Injected.getInstanceFromNode;
    getNodeFromInstance = Injected.getNodeFromInstance;

    {
      warning(getNodeFromInstance && getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');
    }
  }
};






var validateEventDispatches;
{
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = getNodeFromInstance(inst);
  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */


/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */


/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */
function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */

/**
 * Methods for injecting dependencies.
 */
var injection$1 = {
  /**
   * @param {array} InjectedEventPluginOrder
   * @public
   */
  injectEventPluginOrder: injectEventPluginOrder,

  /**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */
  injectEventPluginsByName: injectEventPluginsByName
};

/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */
function getListener(inst, registrationName) {
  var listener;

  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
  // live here; needs to be moved to a better place soon
  var stateNode = inst.stateNode;
  if (!stateNode) {
    // Work in progress (ex: onload events in incremental mode).
    return null;
  }
  var props = getFiberCurrentPropsFromNode(stateNode);
  if (!props) {
    // Work in progress.
    return null;
  }
  listener = props[registrationName];
  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    return null;
  }
  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;
  return listener;
}

/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */
function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  for (var i = 0; i < plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
}

/**
 * Enqueues a synthetic event that should be dispatched when
 * `processEventQueue` is invoked.
 *
 * @param {*} events An accumulation of synthetic events.
 * @internal
 */
function enqueueEvents(events) {
  if (events) {
    eventQueue = accumulateInto(eventQueue, events);
  }
}

/**
 * Dispatches all synthetic events on the event queue.
 *
 * @internal
 */
function processEventQueue(simulated) {
  // Set `eventQueue` to null before processing it so that we can tell if more
  // events get enqueued while processing.
  var processingEventQueue = eventQueue;
  eventQueue = null;

  if (!processingEventQueue) {
    return;
  }

  if (simulated) {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
  } else {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
  }
  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;
  // This would be a good time to rethrow if any of the event handlers threw.
  ReactErrorUtils.rethrowCaughtError();
}

var EventPluginHub = Object.freeze({
	injection: injection$1,
	getListener: getListener,
	extractEvents: extractEvents,
	enqueueEvents: enqueueEvents,
	processEventQueue: processEventQueue
});

var IndeterminateComponent = 0; // Before we know whether it is functional or class
var FunctionalComponent = 1;
var ClassComponent = 2;
var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
var HostComponent = 5;
var HostText = 6;
var CallComponent = 7;
var CallHandlerPhase = 8;
var ReturnComponent = 9;
var Fragment = 10;

var randomKey = Math.random().toString(36).slice(2);
var internalInstanceKey = '__reactInternalInstance$' + randomKey;
var internalEventHandlersKey = '__reactEventHandlers$' + randomKey;

function precacheFiberNode$1(hostInst, node) {
  node[internalInstanceKey] = hostInst;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest = void 0;
  var inst = node[internalInstanceKey];
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber, this will always be the deepest root.
    return inst;
  }
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode$1(node) {
  var inst = node[internalInstanceKey];
  if (inst) {
    if (inst.tag === HostComponent || inst.tag === HostText) {
      return inst;
    } else {
      return null;
    }
  }
  return null;
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance$1(inst) {
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber this, is just the state node right now. We assume it will be
    // a host component or host text.
    return inst.stateNode;
  }

  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  invariant(false, 'getNodeFromInstance: Invalid argument.');
}

function getFiberCurrentPropsFromNode$1(node) {
  return node[internalEventHandlersKey] || null;
}

function updateFiberProps$1(node, props) {
  node[internalEventHandlersKey] = props;
}

var ReactDOMComponentTree = Object.freeze({
	precacheFiberNode: precacheFiberNode$1,
	getClosestInstanceFromNode: getClosestInstanceFromNode,
	getInstanceFromNode: getInstanceFromNode$1,
	getNodeFromInstance: getNodeFromInstance$1,
	getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,
	updateFiberProps: updateFiberProps$1
});

function getParent(inst) {
  do {
    inst = inst['return'];
    // TODO: If this is a HostRoot we might want to bail out.
    // That is depending on if we want nested subtrees (layers) to bubble
    // events to their parent. We could also go through parentNode on the
    // host node but that wouldn't work for React Native and doesn't let us
    // do the portal feature.
  } while (inst && inst.tag !== HostComponent);
  if (inst) {
    return inst;
  }
  return null;
}

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  var depthA = 0;
  for (var tempA = instA; tempA; tempA = getParent(tempA)) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = getParent(tempB)) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = getParent(instA);
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = getParent(instB);
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB || instA === instB.alternate) {
      return instA;
    }
    instA = getParent(instA);
    instB = getParent(instB);
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */


/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  return getParent(inst);
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = getParent(inst);
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (true) {
    if (!from) {
      break;
    }
    if (from === common) {
      break;
    }
    var alternate = from.alternate;
    if (alternate !== null && alternate === common) {
      break;
    }
    pathFrom.push(from);
    from = getParent(from);
  }
  var pathTo = [];
  while (true) {
    if (!to) {
      break;
    }
    if (to === common) {
      break;
    }
    var _alternate = to.alternate;
    if (_alternate !== null && _alternate === common) {
      break;
    }
    pathTo.push(to);
    to = getParent(to);
  }
  for (var i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (var _i = pathTo.length; _i-- > 0;) {
    fn(pathTo[_i], 'captured', argTo);
  }
}

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 */

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  {
    warning(inst, 'Dispatching inst must not be null');
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? getParentInstance(targetInst) : null;
    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (inst && event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

var EventPropagators = Object.freeze({
	accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,
	accumulateDirectDispatches: accumulateDirectDispatches
});

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

/**
 * This helper object stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */
var compositionState = {
  _root: null,
  _startText: null,
  _fallbackText: null
};

function initialize(nativeEventTarget) {
  compositionState._root = nativeEventTarget;
  compositionState._startText = getText();
  return true;
}

function reset() {
  compositionState._root = null;
  compositionState._startText = null;
  compositionState._fallbackText = null;
}

function getData() {
  if (compositionState._fallbackText) {
    return compositionState._fallbackText;
  }

  var start;
  var startValue = compositionState._startText;
  var startLength = startValue.length;
  var end;
  var endValue = getText();
  var endLength = endValue.length;

  for (start = 0; start < startLength; start++) {
    if (startValue[start] !== endValue[start]) {
      break;
    }
  }

  var minEnd = startLength - start;
  for (end = 1; end <= minEnd; end++) {
    if (startValue[startLength - end] !== endValue[endLength - end]) {
      break;
    }
  }

  var sliceTail = end > 1 ? 1 - end : undefined;
  compositionState._fallbackText = endValue.slice(start, sliceTail);
  return compositionState._fallbackText;
}

function getText() {
  if ('value' in compositionState._root) {
    return compositionState._root.value;
  }
  return compositionState._root[getTextContentAccessor()];
}

/* eslint valid-typeof: 0 */

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';
var EVENT_POOL_SIZE = 10;

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {
  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
    {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
    }
  }
});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;
  addEventPoolingTo(Class);
};

/** Proxying after everything set on SyntheticEvent
 * to resolve Proxy issue on some WebKit browsers
 * in which some Event properties are set to undefined (GH#10010)
 */
{
  if (isProxySupported) {
    /*eslint-disable no-func-assign */
    SyntheticEvent = new Proxy(SyntheticEvent, {
      construct: function (target, args) {
        return this.apply(target, Object.create(target.prototype), args);
      },
      apply: function (constructor, that, args) {
        return new Proxy(constructor.apply(that, args), {
          set: function (target, prop, value) {
            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
              warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.');
              didWarnForAddedNewProperty = true;
            }
            target[prop] = value;
            return true;
          }
        });
      }
    });
    /*eslint-enable no-func-assign */
  }
}

addEventPoolingTo(SyntheticEvent);

/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);
  }
}

function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
  var EventConstructor = this;
  if (EventConstructor.eventPool.length) {
    var instance = EventConstructor.eventPool.pop();
    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
    return instance;
  }
  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
}

function releasePooledEvent(event) {
  var EventConstructor = this;
  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;
  event.destructor();
  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
    EventConstructor.eventPool.push(event);
  }
}

function addEventPoolingTo(EventConstructor) {
  EventConstructor.eventPool = [];
  EventConstructor.getPooled = getPooledEvent;
  EventConstructor.release = releasePooledEvent;
}

var SyntheticEvent$1 = SyntheticEvent;

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticInputEvent, InputEventInterface);

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case 'topCompositionStart':
      return eventTypes.compositionStart;
    case 'topCompositionEnd':
      return eventTypes.compositionEnd;
    case 'topCompositionUpdate':
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topKeyUp':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case 'topKeyDown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case 'topKeyPress':
    case 'topMouseDown':
    case 'topBlur':
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition status, if any.
var isComposing = false;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!isComposing) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!isComposing && eventType === eventTypes.compositionStart) {
      isComposing = initialize(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (isComposing) {
        fallbackData = getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topCompositionEnd':
      return getDataFromCustomEvent(nativeEvent);
    case 'topKeyPress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'topTextInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (isComposing) {
    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = getData();
      reset();
      isComposing = false;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case 'topPaste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case 'topKeyPress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (!isKeypressCommand(nativeEvent)) {
        // IE fires the `keypress` event when a user types an emoji via
        // Touch keyboard of Windows.  In such a case, the `char` property
        // holds an emoji character like `\uD83D\uDE0A`.  Because its length
        // is 2, the property `which` does not represent an emoji correctly.
        // In such a case, we directly return the `char` property instead of
        // using `which`.
        if (nativeEvent.char && nativeEvent.char.length > 1) {
          return nativeEvent.char;
        } else if (nativeEvent.which) {
          return String.fromCharCode(nativeEvent.which);
        }
      }
      return null;
    case 'topCompositionEnd':
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

// Use to restore controlled state after a change event has fired.

var fiberHostComponent = null;

var ReactControlledComponentInjection = {
  injectFiberControlledHostComponent: function (hostComponentImpl) {
    // The fiber implementation doesn't use dynamic dispatch so we need to
    // inject the implementation.
    fiberHostComponent = hostComponentImpl;
  }
};

var restoreTarget = null;
var restoreQueue = null;

function restoreStateOfTarget(target) {
  // We perform this translation at the end of the event loop so that we
  // always receive the correct fiber here
  var internalInstance = getInstanceFromNode(target);
  if (!internalInstance) {
    // Unmounted
    return;
  }
  !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
  fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);
}

var injection$3 = ReactControlledComponentInjection;

function enqueueStateRestore(target) {
  if (restoreTarget) {
    if (restoreQueue) {
      restoreQueue.push(target);
    } else {
      restoreQueue = [target];
    }
  } else {
    restoreTarget = target;
  }
}

function restoreStateIfNeeded() {
  if (!restoreTarget) {
    return;
  }
  var target = restoreTarget;
  var queuedTargets = restoreQueue;
  restoreTarget = null;
  restoreQueue = null;

  restoreStateOfTarget(target);
  if (queuedTargets) {
    for (var i = 0; i < queuedTargets.length; i++) {
      restoreStateOfTarget(queuedTargets[i]);
    }
  }
}

var ReactControlledComponent = Object.freeze({
	injection: injection$3,
	enqueueStateRestore: enqueueStateRestore,
	restoreStateIfNeeded: restoreStateIfNeeded
});

// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.

// Defaults
var fiberBatchedUpdates = function (fn, bookkeeping) {
  return fn(bookkeeping);
};

var isNestingBatched = false;
function batchedUpdates(fn, bookkeeping) {
  if (isNestingBatched) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state. Therefore, we add the target to
    // a queue of work.
    return fiberBatchedUpdates(fn, bookkeeping);
  }
  isNestingBatched = true;
  try {
    return fiberBatchedUpdates(fn, bookkeeping);
  } finally {
    // Here we wait until all updates have propagated, which is important
    // when using controlled components within layers:
    // https://github.com/facebook/react/issues/1698
    // Then we restore state of any controlled component.
    isNestingBatched = false;
    restoreStateIfNeeded();
  }
}

var ReactGenericBatchingInjection = {
  injectFiberBatchedUpdates: function (_batchedUpdates) {
    fiberBatchedUpdates = _batchedUpdates;
  }
};

var injection$4 = ReactGenericBatchingInjection;

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  'datetime-local': true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

/**
 * HTML nodeType values that represent the type of the node
 */

var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === TEXT_NODE ? target.parentNode : target;
}

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

function isCheckable(elem) {
  var type = elem.type;
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
}

function getTracker(node) {
  return node._valueTracker;
}

function detachTracker(node) {
  node._valueTracker = null;
}

function getValueFromNode(node) {
  var value = '';
  if (!node) {
    return value;
  }

  if (isCheckable(node)) {
    value = node.checked ? 'true' : 'false';
  } else {
    value = node.value;
  }

  return value;
}

function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? 'checked' : 'value';
  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);

  var currentValue = '' + node[valueField];

  // if someone has already defined a value or Safari, then bail
  // and don't track value will cause over reporting of changes,
  // but it's better then a hard failure
  // (needed for certain tests that spyOn input values and Safari)
  if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
    return;
  }

  Object.defineProperty(node, valueField, {
    enumerable: descriptor.enumerable,
    configurable: true,
    get: function () {
      return descriptor.get.call(this);
    },
    set: function (value) {
      currentValue = '' + value;
      descriptor.set.call(this, value);
    }
  });

  var tracker = {
    getValue: function () {
      return currentValue;
    },
    setValue: function (value) {
      currentValue = '' + value;
    },
    stopTracking: function () {
      detachTracker(node);
      delete node[valueField];
    }
  };
  return tracker;
}

function track(node) {
  if (getTracker(node)) {
    return;
  }

  // TODO: Once it's just Fiber we can move this to node._wrapperState
  node._valueTracker = trackValueOnNode(node);
}

function updateValueIfChanged(node) {
  if (!node) {
    return false;
  }

  var tracker = getTracker(node);
  // if there is no tracker at this point it's unlikely
  // that trying again will succeed
  if (!tracker) {
    return true;
  }

  var lastValue = tracker.getValue();
  var nextValue = getValueFromNode(node);
  if (nextValue !== lastValue) {
    tracker.setValue(nextValue);
    return true;
  }
  return false;
}

var eventTypes$1 = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
  }
};

function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
  var event = SyntheticEvent$1.getPooled(eventTypes$1.change, inst, nativeEvent, target);
  event.type = 'change';
  // Flag this event loop as needing state restore.
  enqueueStateRestore(target);
  accumulateTwoPhaseDispatches(event);
  return event;
}
/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  enqueueEvents(event);
  processEventQueue(false);
}

function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance$1(targetInst);
  if (updateValueIfChanged(targetNode)) {
    return targetInst;
  }
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topChange') {
    return targetInst;
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
}

/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onpropertychange', handlePropertyChange);
  activeElement = null;
  activeElementInst = null;
}

/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  if (getInstIfValueChanged(activeElementInst)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}

function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {
  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    return getInstIfValueChanged(activeElementInst);
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst) {
  if (topLevelType === 'topClick') {
    return getInstIfValueChanged(targetInst);
  }
}

function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topInput' || topLevelType === 'topChange') {
    return getInstIfValueChanged(targetInst);
  }
}

function handleControlledInputBlur(inst, node) {
  // TODO: In IE, inst is occasionally null. Why?
  if (inst == null) {
    return;
  }

  // Fiber and ReactDOM keep wrapper state in separate places
  var state = inst._wrapperState || node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  // If controlled, assign the value attribute to the current value on blur
  var value = '' + node.value;
  if (node.getAttribute('value') !== value) {
    node.setAttribute('value', value);
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {
  eventTypes: eventTypes$1,

  _isInputEventSupported: isInputEventSupported,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForChangeEvent;
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventPolyfill;
        handleEventFunc = handleEventsForInputEventPolyfill;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst);
      if (inst) {
        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }

    // When blurring, set the value attribute for number inputs
    if (topLevelType === 'topBlur') {
      handleControlledInputBlur(targetInst, targetNode);
    }
  }
};

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: null,
  detail: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticUIEvent, UIEventInterface);

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  Alt: 'altKey',
  Control: 'ctrlKey',
  Meta: 'metaKey',
  Shift: 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  pageX: null,
  pageY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: null,
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

var eventTypes$2 = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: ['topMouseOut', 'topMouseOver']
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: ['topMouseOut', 'topMouseOver']
  }
};

var EnterLeaveEventPlugin = {
  eventTypes: eventTypes$2,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === 'topMouseOut') {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : getNodeFromInstance$1(from);
    var toNode = to == null ? win : getNodeFromInstance$1(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }
};

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */

/**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */


function get(key) {
  return key._reactInternalFiber;
}

function has(key) {
  return key._reactInternalFiber !== undefined;
}

function set(key, value) {
  key._reactInternalFiber = value;
}

var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

var ReactCurrentOwner = ReactInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;

function getComponentName(fiber) {
  var type = fiber.type;

  if (typeof type === 'string') {
    return type;
  }
  if (typeof type === 'function') {
    return type.displayName || type.name;
  }
  return null;
}

// Don't change these two values:
var NoEffect = 0; //           0b00000000
var PerformedWork = 1; //      0b00000001

// You can change the rest (and add more).
var Placement = 2; //          0b00000010
var Update = 4; //             0b00000100
var PlacementAndUpdate = 6; // 0b00000110
var Deletion = 8; //           0b00001000
var ContentReset = 16; //      0b00010000
var Callback = 32; //          0b00100000
var Err = 64; //               0b01000000
var Ref = 128; //              0b10000000

var MOUNTING = 1;
var MOUNTED = 2;
var UNMOUNTED = 3;

function isFiberMountedImpl(fiber) {
  var node = fiber;
  if (!fiber.alternate) {
    // If there is no alternate, this might be a new tree that isn't inserted
    // yet. If it is, then it will have a pending insertion effect on it.
    if ((node.effectTag & Placement) !== NoEffect) {
      return MOUNTING;
    }
    while (node['return']) {
      node = node['return'];
      if ((node.effectTag & Placement) !== NoEffect) {
        return MOUNTING;
      }
    }
  } else {
    while (node['return']) {
      node = node['return'];
    }
  }
  if (node.tag === HostRoot) {
    // TODO: Check if this was a nested HostRoot when used with
    // renderContainerIntoSubtree.
    return MOUNTED;
  }
  // If we didn't hit the root, that means that we're in an disconnected tree
  // that has been unmounted.
  return UNMOUNTED;
}

function isFiberMounted(fiber) {
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function isMounted(component) {
  {
    var owner = ReactCurrentOwner.current;
    if (owner !== null && owner.tag === ClassComponent) {
      var ownerFiber = owner;
      var instance = ownerFiber.stateNode;
      warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');
      instance._warnedAboutRefsInRender = true;
    }
  }

  var fiber = get(component);
  if (!fiber) {
    return false;
  }
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function assertIsMounted(fiber) {
  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
}

function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    // If there is no alternate, then we only need to check if it is mounted.
    var state = isFiberMountedImpl(fiber);
    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
    if (state === MOUNTING) {
      return null;
    }
    return fiber;
  }
  // If we have two possible branches, we'll walk backwards up to the root
  // to see what path the root points to. On the way we may hit one of the
  // special cases and we'll deal with them.
  var a = fiber;
  var b = alternate;
  while (true) {
    var parentA = a['return'];
    var parentB = parentA ? parentA.alternate : null;
    if (!parentA || !parentB) {
      // We're at the root.
      break;
    }

    // If both copies of the parent fiber point to the same child, we can
    // assume that the child is current. This happens when we bailout on low
    // priority: the bailed out fiber's child reuses the current child.
    if (parentA.child === parentB.child) {
      var child = parentA.child;
      while (child) {
        if (child === a) {
          // We've determined that A is the current branch.
          assertIsMounted(parentA);
          return fiber;
        }
        if (child === b) {
          // We've determined that B is the current branch.
          assertIsMounted(parentA);
          return alternate;
        }
        child = child.sibling;
      }
      // We should never have an alternate for any mounting node. So the only
      // way this could possibly happen is if this was unmounted, if at all.
      invariant(false, 'Unable to find node on an unmounted component.');
    }

    if (a['return'] !== b['return']) {
      // The return pointer of A and the return pointer of B point to different
      // fibers. We assume that return pointers never criss-cross, so A must
      // belong to the child set of A.return, and B must belong to the child
      // set of B.return.
      a = parentA;
      b = parentB;
    } else {
      // The return pointers point to the same fiber. We'll have to use the
      // default, slow path: scan the child sets of each parent alternate to see
      // which child belongs to which set.
      //
      // Search parent A's child set
      var didFindChild = false;
      var _child = parentA.child;
      while (_child) {
        if (_child === a) {
          didFindChild = true;
          a = parentA;
          b = parentB;
          break;
        }
        if (_child === b) {
          didFindChild = true;
          b = parentA;
          a = parentB;
          break;
        }
        _child = _child.sibling;
      }
      if (!didFindChild) {
        // Search parent B's child set
        _child = parentB.child;
        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentB;
            b = parentA;
            break;
          }
          if (_child === b) {
            didFindChild = true;
            b = parentB;
            a = parentA;
            break;
          }
          _child = _child.sibling;
        }
        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;
      }
    }

    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  }
  // If the root is not a host container, we're in a disconnected tree. I.e.
  // unmounted.
  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
  if (a.stateNode.current === a) {
    // We've determined that A is the current branch.
    return fiber;
  }
  // Otherwise B has to be current branch.
  return alternate;
}

function findCurrentHostFiber(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child) {
      node.child['return'] = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node['return'] || node['return'] === currentParent) {
        return null;
      }
      node = node['return'];
    }
    node.sibling['return'] = node['return'];
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

function findCurrentHostFiberWithNoPortals(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child && node.tag !== HostPortal) {
      node.child['return'] = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node['return'] || node['return'] === currentParent) {
        return null;
      }
      node = node['return'];
    }
    node.sibling['return'] = node['return'];
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

var CALLBACK_BOOKKEEPING_POOL_SIZE = 10;
var callbackBookkeepingPool = [];

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findRootContainerNode(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst['return']) {
    inst = inst['return'];
  }
  if (inst.tag !== HostRoot) {
    // This can happen if we're in a detached tree.
    return null;
  }
  return inst.stateNode.containerInfo;
}

// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {
  if (callbackBookkeepingPool.length) {
    var instance = callbackBookkeepingPool.pop();
    instance.topLevelType = topLevelType;
    instance.nativeEvent = nativeEvent;
    instance.targetInst = targetInst;
    return instance;
  }
  return {
    topLevelType: topLevelType,
    nativeEvent: nativeEvent,
    targetInst: targetInst,
    ancestors: []
  };
}

function releaseTopLevelCallbackBookKeeping(instance) {
  instance.topLevelType = null;
  instance.nativeEvent = null;
  instance.targetInst = null;
  instance.ancestors.length = 0;
  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {
    callbackBookkeepingPool.push(instance);
  }
}

function handleTopLevelImpl(bookKeeping) {
  var targetInst = bookKeeping.targetInst;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    if (!ancestor) {
      bookKeeping.ancestors.push(ancestor);
      break;
    }
    var root = findRootContainerNode(ancestor);
    if (!root) {
      break;
    }
    bookKeeping.ancestors.push(ancestor);
    ancestor = getClosestInstanceFromNode(root);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    _handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

// TODO: can we stop exporting these?
var _enabled = true;
var _handleTopLevel = void 0;

function setHandleTopLevel(handleTopLevel) {
  _handleTopLevel = handleTopLevel;
}

function setEnabled(enabled) {
  _enabled = !!enabled;
}

function isEnabled() {
  return _enabled;
}

/**
 * Traps top-level events by using event bubbling.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapBubbledEvent(topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.listen(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
}

/**
 * Traps a top-level event by using event capturing.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapCapturedEvent(topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.capture(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
}

function dispatchEvent(topLevelType, nativeEvent) {
  if (!_enabled) {
    return;
  }

  var nativeEventTarget = getEventTarget(nativeEvent);
  var targetInst = getClosestInstanceFromNode(nativeEventTarget);
  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {
    // If we get an event (ex: img onload) before committing that
    // component's mount, ignore it for now (that is, treat it as if it was an
    // event on a non-React tree). We might also consider queueing events and
    // dispatching them after the mount.
    targetInst = null;
  }

  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);

  try {
    // Event queue being processed in the same cycle allows
    // `preventDefault`.
    batchedUpdates(handleTopLevelImpl, bookKeeping);
  } finally {
    releaseTopLevelCallbackBookKeeping(bookKeeping);
  }
}

var ReactDOMEventListener = Object.freeze({
	get _enabled () { return _enabled; },
	get _handleTopLevel () { return _handleTopLevel; },
	setHandleTopLevel: setHandleTopLevel,
	setEnabled: setEnabled,
	isEnabled: isEnabled,
	trapBubbledEvent: trapBubbledEvent,
	trapCapturedEvent: trapCapturedEvent,
	dispatchEvent: dispatchEvent
});

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

/**
 * Types of raw signals from the browser caught at the top level.
 *
 * For events like 'submit' which don't consistently bubble (which we
 * trap at a lower node than `document`), binding at `document` would
 * cause duplicate events so we don't include them here.
 */
var topLevelTypes$1 = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCancel: 'cancel',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topClose: 'close',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoad: 'load',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topToggle: 'toggle',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

var BrowserEventConstants = {
  topLevelTypes: topLevelTypes$1
};

function runEventQueueInBatch(events) {
  enqueueEvents(events);
  processEventQueue(false);
}

/**
 * Streams a fired top-level event to `EventPluginHub` where plugins have the
 * opportunity to create `ReactEvent`s to be dispatched.
 */
function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
  runEventQueueInBatch(events);
}

var topLevelTypes = BrowserEventConstants.topLevelTypes;

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var reactTopListenersCounter = 0;

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} contentDocumentHandle Document which owns the container
 */
function listenTo(registrationName, contentDocumentHandle) {
  var mountAt = contentDocumentHandle;
  var isListening = getListeningForDocument(mountAt);
  var dependencies = registrationNameDependencies[registrationName];

  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      if (dependency === 'topScroll') {
        trapCapturedEvent('topScroll', 'scroll', mountAt);
      } else if (dependency === 'topFocus' || dependency === 'topBlur') {
        trapCapturedEvent('topFocus', 'focus', mountAt);
        trapCapturedEvent('topBlur', 'blur', mountAt);

        // to make sure blur and focus event listeners are only attached once
        isListening.topBlur = true;
        isListening.topFocus = true;
      } else if (dependency === 'topCancel') {
        if (isEventSupported('cancel', true)) {
          trapCapturedEvent('topCancel', 'cancel', mountAt);
        }
        isListening.topCancel = true;
      } else if (dependency === 'topClose') {
        if (isEventSupported('close', true)) {
          trapCapturedEvent('topClose', 'close', mountAt);
        }
        isListening.topClose = true;
      } else if (topLevelTypes.hasOwnProperty(dependency)) {
        trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);
      }

      isListening[dependency] = true;
    }
  }
}

function isListeningToAllDependencies(registrationName, mountAt) {
  var isListening = getListeningForDocument(mountAt);
  var dependencies = registrationNameDependencies[registrationName];
  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      return false;
    }
  }
  return true;
}

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === TEXT_NODE) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */
function getOffsets(outerNode) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode,
      anchorOffset = selection.anchorOffset,
      focusNode$$1 = selection.focusNode,
      focusOffset = selection.focusOffset;

  // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
  // up/down buttons on an <input type="number">. Anonymous divs do not seem to
  // expose properties, triggering a "Permission denied error" if any of its
  // properties are accessed. The only seemingly possible way to avoid erroring
  // is to access a property that typically works for non-anonymous divs and
  // catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427

  try {
    /* eslint-disable no-unused-expressions */
    anchorNode.nodeType;
    focusNode$$1.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset);
}

/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */
function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset) {
  var length = 0;
  var start = -1;
  var end = -1;
  var indexWithinAnchor = 0;
  var indexWithinFocus = 0;
  var node = outerNode;
  var parentNode = null;

  outer: while (true) {
    var next = null;

    while (true) {
      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
        start = length + anchorOffset;
      }
      if (node === focusNode$$1 && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
        end = length + focusOffset;
      }

      if (node.nodeType === TEXT_NODE) {
        length += node.nodeValue.length;
      }

      if ((next = node.firstChild) === null) {
        break;
      }
      // Moving from `node` to its first child `next`.
      parentNode = node;
      node = next;
    }

    while (true) {
      if (node === outerNode) {
        // If `outerNode` has children, this is always the second time visiting
        // it. If it has no children, this is still the first loop, and the only
        // valid selection is anchorNode and focusNode both equal to this node
        // and both offsets 0, in which case we will have handled above.
        break outer;
      }
      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
        start = length;
      }
      if (parentNode === focusNode$$1 && ++indexWithinFocus === focusOffset) {
        end = length;
      }
      if ((next = node.nextSibling) !== null) {
        break;
      }
      node = parentNode;
      parentNode = node.parentNode;
    }

    // Moving from `node` to its next sibling `next`.
    node = next;
  }

  if (start === -1 || end === -1) {
    // This should never happen. (Would happen if the anchor/focus nodes aren't
    // actually inside the passed-in node.)
    return null;
  }

  return {
    start: start,
    end: end
  };
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
      return;
    }
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */

function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
}

function getSelectionInformation() {
  var focusedElem = getActiveElement();
  return {
    focusedElem: focusedElem,
    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null
  };
}

/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */
function restoreSelection(priorSelectionInformation) {
  var curFocusedElem = getActiveElement();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;
  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
    if (hasSelectionCapabilities(priorFocusedElem)) {
      setSelection(priorFocusedElem, priorSelectionRange);
    }

    // Focusing a node can change the scroll position, which is undesirable
    var ancestors = [];
    var ancestor = priorFocusedElem;
    while (ancestor = ancestor.parentNode) {
      if (ancestor.nodeType === ELEMENT_NODE) {
        ancestors.push({
          element: ancestor,
          left: ancestor.scrollLeft,
          top: ancestor.scrollTop
        });
      }
    }

    focusNode(priorFocusedElem);

    for (var i = 0; i < ancestors.length; i++) {
      var info = ancestors[i];
      info.element.scrollLeft = info.left;
      info.element.scrollTop = info.top;
    }
  }
}

/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */
function getSelection$1(input) {
  var selection = void 0;

  if ('selectionStart' in input) {
    // Modern browser with input or textarea.
    selection = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } else {
    // Content editable or old IE textarea.
    selection = getOffsets(input);
  }

  return selection || { start: 0, end: 0 };
}

/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */
function setSelection(input, offsets) {
  var start = offsets.start,
      end = offsets.end;

  if (end === undefined) {
    end = start;
  }

  if ('selectionStart' in input) {
    input.selectionStart = start;
    input.selectionEnd = Math.min(end, input.value.length);
  } else {
    setOffsets(input, offsets);
  }
}

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes$3 = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
  }
};

var activeElement$1 = null;
var activeElementInst$1 = null;
var lastSelection = null;
var mouseDown = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement$1);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent$1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement$1;

    accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {
  eventTypes: eventTypes$3,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE ? nativeEventTarget : nativeEventTarget.ownerDocument;
    // Track whether all listeners exists for this plugin. If none exist, we do
    // not extract events. See #3639.
    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {
      return null;
    }

    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case 'topFocus':
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement$1 = targetNode;
          activeElementInst$1 = targetInst;
          lastSelection = null;
        }
        break;
      case 'topBlur':
        activeElement$1 = null;
        activeElementInst$1 = null;
        lastSelection = null;
        break;
      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case 'topMouseDown':
        mouseDown = true;
        break;
      case 'topContextMenu':
      case 'topMouseUp':
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);
      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case 'topSelectionChange':
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case 'topKeyDown':
      case 'topKeyUp':
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  }
};

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  '8': 'Backspace',
  '9': 'Tab',
  '12': 'Clear',
  '13': 'Enter',
  '16': 'Shift',
  '17': 'Control',
  '18': 'Alt',
  '19': 'Pause',
  '20': 'CapsLock',
  '27': 'Escape',
  '32': ' ',
  '33': 'PageUp',
  '34': 'PageDown',
  '35': 'End',
  '36': 'Home',
  '37': 'ArrowLeft',
  '38': 'ArrowUp',
  '39': 'ArrowRight',
  '40': 'ArrowDown',
  '45': 'Insert',
  '46': 'Delete',
  '112': 'F1',
  '113': 'F2',
  '114': 'F3',
  '115': 'F4',
  '116': 'F5',
  '117': 'F6',
  '118': 'F7',
  '119': 'F8',
  '120': 'F9',
  '121': 'F10',
  '122': 'F11',
  '123': 'F12',
  '144': 'NumLock',
  '145': 'ScrollLock',
  '224': 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */
var eventTypes$4 = {};
var topLevelEventsToDispatchConfig = {};
['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'cancel', 'canPlay', 'canPlayThrough', 'click', 'close', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'toggle', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;
  var topEvent = 'top' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent]
  };
  eventTypes$4[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
});

// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes = ['topAbort', 'topCancel', 'topCanPlay', 'topCanPlayThrough', 'topClose', 'topDurationChange', 'topEmptied', 'topEncrypted', 'topEnded', 'topError', 'topInput', 'topInvalid', 'topLoad', 'topLoadedData', 'topLoadedMetadata', 'topLoadStart', 'topPause', 'topPlay', 'topPlaying', 'topProgress', 'topRateChange', 'topReset', 'topSeeked', 'topSeeking', 'topStalled', 'topSubmit', 'topSuspend', 'topTimeUpdate', 'topToggle', 'topVolumeChange', 'topWaiting'];

var SimpleEventPlugin = {
  eventTypes: eventTypes$4,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case 'topKeyPress':
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case 'topKeyDown':
      case 'topKeyUp':
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      case 'topClick':
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case 'topDoubleClick':
      case 'topMouseDown':
      case 'topMouseMove':
      case 'topMouseUp':
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case 'topMouseOut':
      case 'topMouseOver':
      case 'topContextMenu':
        EventConstructor = SyntheticMouseEvent;
        break;
      case 'topDrag':
      case 'topDragEnd':
      case 'topDragEnter':
      case 'topDragExit':
      case 'topDragLeave':
      case 'topDragOver':
      case 'topDragStart':
      case 'topDrop':
        EventConstructor = SyntheticDragEvent;
        break;
      case 'topTouchCancel':
      case 'topTouchEnd':
      case 'topTouchMove':
      case 'topTouchStart':
        EventConstructor = SyntheticTouchEvent;
        break;
      case 'topAnimationEnd':
      case 'topAnimationIteration':
      case 'topAnimationStart':
        EventConstructor = SyntheticAnimationEvent;
        break;
      case 'topTransitionEnd':
        EventConstructor = SyntheticTransitionEvent;
        break;
      case 'topScroll':
        EventConstructor = SyntheticUIEvent;
        break;
      case 'topWheel':
        EventConstructor = SyntheticWheelEvent;
        break;
      case 'topCopy':
      case 'topCut':
      case 'topPaste':
        EventConstructor = SyntheticClipboardEvent;
        break;
      default:
        {
          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {
            warning(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);
          }
        }
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent$1;
        break;
    }
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    accumulateTwoPhaseDispatches(event);
    return event;
  }
};

setHandleTopLevel(handleTopLevel);

/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */
injection$1.injectEventPluginOrder(DOMEventPluginOrder);
injection$2.injectComponentTree(ReactDOMComponentTree);

/**
 * Some important event plugins included by default (without having to require
 * them).
 */
injection$1.injectEventPluginsByName({
  SimpleEventPlugin: SimpleEventPlugin,
  EnterLeaveEventPlugin: EnterLeaveEventPlugin,
  ChangeEventPlugin: ChangeEventPlugin,
  SelectEventPlugin: SelectEventPlugin,
  BeforeInputEventPlugin: BeforeInputEventPlugin
});

var enableAsyncSubtreeAPI = true;
var enableAsyncSchedulingByDefaultInReactDOM = false;
// Exports ReactDOM.createRoot
var enableCreateRoot = false;
var enableUserTimingAPI = true;

// Mutating mode (React DOM, React ART, React Native):
var enableMutatingReconciler = true;
// Experimental noop mode (currently unused):
var enableNoopReconciler = false;
// Experimental persistent mode (CS):
var enablePersistentReconciler = false;

// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
var debugRenderPhaseSideEffects = false;

// Only used in www builds.

var valueStack = [];

{
  var fiberStack = [];
}

var index = -1;

function createCursor(defaultValue) {
  return {
    current: defaultValue
  };
}



function pop(cursor, fiber) {
  if (index < 0) {
    {
      warning(false, 'Unexpected pop.');
    }
    return;
  }

  {
    if (fiber !== fiberStack[index]) {
      warning(false, 'Unexpected Fiber popped.');
    }
  }

  cursor.current = valueStack[index];

  valueStack[index] = null;

  {
    fiberStack[index] = null;
  }

  index--;
}

function push(cursor, value, fiber) {
  index++;

  valueStack[index] = cursor.current;

  {
    fiberStack[index] = fiber;
  }

  cursor.current = value;
}

function reset$1() {
  while (index > -1) {
    valueStack[index] = null;

    {
      fiberStack[index] = null;
    }

    index--;
  }
}

var describeComponentFrame = function (name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
};

function describeFiber(fiber) {
  switch (fiber.tag) {
    case IndeterminateComponent:
    case FunctionalComponent:
    case ClassComponent:
    case HostComponent:
      var owner = fiber._debugOwner;
      var source = fiber._debugSource;
      var name = getComponentName(fiber);
      var ownerName = null;
      if (owner) {
        ownerName = getComponentName(owner);
      }
      return describeComponentFrame(name, source, ownerName);
    default:
      return '';
  }
}

// This function can only be called with a work-in-progress fiber and
// only during begin or complete phase. Do not call it under any other
// circumstances.
function getStackAddendumByWorkInProgressFiber(workInProgress) {
  var info = '';
  var node = workInProgress;
  do {
    info += describeFiber(node);
    // Otherwise this return pointer might point to the wrong tree:
    node = node['return'];
  } while (node);
  return info;
}

function getCurrentFiberOwnerName() {
  {
    var fiber = ReactDebugCurrentFiber.current;
    if (fiber === null) {
      return null;
    }
    var owner = fiber._debugOwner;
    if (owner !== null && typeof owner !== 'undefined') {
      return getComponentName(owner);
    }
  }
  return null;
}

function getCurrentFiberStackAddendum() {
  {
    var fiber = ReactDebugCurrentFiber.current;
    if (fiber === null) {
      return null;
    }
    // Safe because if current fiber exists, we are reconciling,
    // and it is guaranteed to be the work-in-progress version.
    return getStackAddendumByWorkInProgressFiber(fiber);
  }
  return null;
}

function resetCurrentFiber() {
  ReactDebugCurrentFrame.getCurrentStack = null;
  ReactDebugCurrentFiber.current = null;
  ReactDebugCurrentFiber.phase = null;
}

function setCurrentFiber(fiber) {
  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;
  ReactDebugCurrentFiber.current = fiber;
  ReactDebugCurrentFiber.phase = null;
}

function setCurrentPhase(phase) {
  ReactDebugCurrentFiber.phase = phase;
}

var ReactDebugCurrentFiber = {
  current: null,
  phase: null,
  resetCurrentFiber: resetCurrentFiber,
  setCurrentFiber: setCurrentFiber,
  setCurrentPhase: setCurrentPhase,
  getCurrentFiberOwnerName: getCurrentFiberOwnerName,
  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum
};

// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji = '\u269B';
var warningEmoji = '\u26D4';
var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber = null;
// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase = null;
var currentPhaseFiber = null;
// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting = false;
var hasScheduledUpdateInCurrentCommit = false;
var hasScheduledUpdateInCurrentPhase = false;
var commitCountInCurrentWorkLoop = 0;
var effectCountInCurrentCommit = 0;
var isWaitingForCallback = false;
// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit = new Set();

var formatMarkName = function (markName) {
  return reactEmoji + ' ' + markName;
};

var formatLabel = function (label, warning$$1) {
  var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';
  var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';
  return '' + prefix + label + suffix;
};

var beginMark = function (markName) {
  performance.mark(formatMarkName(markName));
};

var clearMark = function (markName) {
  performance.clearMarks(formatMarkName(markName));
};

var endMark = function (label, markName, warning$$1) {
  var formattedMarkName = formatMarkName(markName);
  var formattedLabel = formatLabel(label, warning$$1);
  try {
    performance.measure(formattedLabel, formattedMarkName);
  } catch (err) {}
  // If previous mark was missing for some reason, this will throw.
  // This could only happen if React crashed in an unexpected place earlier.
  // Don't pile on with more errors.

  // Clear marks immediately to avoid growing buffer.
  performance.clearMarks(formattedMarkName);
  performance.clearMeasures(formattedLabel);
};

var getFiberMarkName = function (label, debugID) {
  return label + ' (#' + debugID + ')';
};

var getFiberLabel = function (componentName, isMounted, phase) {
  if (phase === null) {
    // These are composite component total time measurements.
    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';
  } else {
    // Composite component methods.
    return componentName + '.' + phase;
  }
};

var beginFiberMark = function (fiber, phase) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);

  if (isCommitting && labelsInCurrentCommit.has(label)) {
    // During the commit phase, we don't show duplicate labels because
    // there is a fixed overhead for every measurement, and we don't
    // want to stretch the commit phase beyond necessary.
    return false;
  }
  labelsInCurrentCommit.add(label);

  var markName = getFiberMarkName(label, debugID);
  beginMark(markName);
  return true;
};

var clearFiberMark = function (fiber, phase) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  clearMark(markName);
};

var endFiberMark = function (fiber, phase, warning$$1) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  endMark(label, markName, warning$$1);
};

var shouldIgnoreFiber = function (fiber) {
  // Host components should be skipped in the timeline.
  // We could check typeof fiber.type, but does this work with RN?
  switch (fiber.tag) {
    case HostRoot:
    case HostComponent:
    case HostText:
    case HostPortal:
    case ReturnComponent:
    case Fragment:
      return true;
    default:
      return false;
  }
};

var clearPendingPhaseMeasurement = function () {
  if (currentPhase !== null && currentPhaseFiber !== null) {
    clearFiberMark(currentPhaseFiber, currentPhase);
  }
  currentPhaseFiber = null;
  currentPhase = null;
  hasScheduledUpdateInCurrentPhase = false;
};

var pauseTimers = function () {
  // Stops all currently active measurements so that they can be resumed
  // if we continue in a later deferred loop from the same unit of work.
  var fiber = currentFiber;
  while (fiber) {
    if (fiber._debugIsCurrentlyTiming) {
      endFiberMark(fiber, null, null);
    }
    fiber = fiber['return'];
  }
};

var resumeTimersRecursively = function (fiber) {
  if (fiber['return'] !== null) {
    resumeTimersRecursively(fiber['return']);
  }
  if (fiber._debugIsCurrentlyTiming) {
    beginFiberMark(fiber, null);
  }
};

var resumeTimers = function () {
  // Resumes all measurements that were active during the last deferred loop.
  if (currentFiber !== null) {
    resumeTimersRecursively(currentFiber);
  }
};

function recordEffect() {
  if (enableUserTimingAPI) {
    effectCountInCurrentCommit++;
  }
}

function recordScheduleUpdate() {
  if (enableUserTimingAPI) {
    if (isCommitting) {
      hasScheduledUpdateInCurrentCommit = true;
    }
    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {
      hasScheduledUpdateInCurrentPhase = true;
    }
  }
}

function startRequestCallbackTimer() {
  if (enableUserTimingAPI) {
    if (supportsUserTiming && !isWaitingForCallback) {
      isWaitingForCallback = true;
      beginMark('(Waiting for async callback...)');
    }
  }
}

function stopRequestCallbackTimer(didExpire) {
  if (enableUserTimingAPI) {
    if (supportsUserTiming) {
      isWaitingForCallback = false;
      var warning$$1 = didExpire ? 'React was blocked by main thread' : null;
      endMark('(Waiting for async callback...)', '(Waiting for async callback...)', warning$$1);
    }
  }
}

function startWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, this is the fiber to unwind from.
    currentFiber = fiber;
    if (!beginFiberMark(fiber, null)) {
      return;
    }
    fiber._debugIsCurrentlyTiming = true;
  }
}

function cancelWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // Remember we shouldn't complete measurement for this fiber.
    // Otherwise flamechart will be deep even for small updates.
    fiber._debugIsCurrentlyTiming = false;
    clearFiberMark(fiber, null);
  }
}

function stopWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber['return'];
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    endFiberMark(fiber, null, null);
  }
}

function stopFailedWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber['return'];
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    var warning$$1 = 'An error was thrown inside this error boundary';
    endFiberMark(fiber, null, warning$$1);
  }
}

function startPhaseTimer(fiber, phase) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    clearPendingPhaseMeasurement();
    if (!beginFiberMark(fiber, phase)) {
      return;
    }
    currentPhaseFiber = fiber;
    currentPhase = phase;
  }
}

function stopPhaseTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    if (currentPhase !== null && currentPhaseFiber !== null) {
      var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;
      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);
    }
    currentPhase = null;
    currentPhaseFiber = null;
  }
}

function startWorkLoopTimer(nextUnitOfWork) {
  if (enableUserTimingAPI) {
    currentFiber = nextUnitOfWork;
    if (!supportsUserTiming) {
      return;
    }
    commitCountInCurrentWorkLoop = 0;
    // This is top level call.
    // Any other measurements are performed within.
    beginMark('(React Tree Reconciliation)');
    // Resume any measurements that were in progress during the last loop.
    resumeTimers();
  }
}

function stopWorkLoopTimer(interruptedBy) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var warning$$1 = null;
    if (interruptedBy !== null) {
      if (interruptedBy.tag === HostRoot) {
        warning$$1 = 'A top-level update interrupted the previous render';
      } else {
        var componentName = getComponentName(interruptedBy) || 'Unknown';
        warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';
      }
    } else if (commitCountInCurrentWorkLoop > 1) {
      warning$$1 = 'There were cascading updates';
    }
    commitCountInCurrentWorkLoop = 0;
    // Pause any measurements until the next loop.
    pauseTimers();
    endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);
  }
}

function startCommitTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    isCommitting = true;
    hasScheduledUpdateInCurrentCommit = false;
    labelsInCurrentCommit.clear();
    beginMark('(Committing Changes)');
  }
}

function stopCommitTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }

    var warning$$1 = null;
    if (hasScheduledUpdateInCurrentCommit) {
      warning$$1 = 'Lifecycle hook scheduled a cascading update';
    } else if (commitCountInCurrentWorkLoop > 0) {
      warning$$1 = 'Caused by a cascading update in earlier commit';
    }
    hasScheduledUpdateInCurrentCommit = false;
    commitCountInCurrentWorkLoop++;
    isCommitting = false;
    labelsInCurrentCommit.clear();

    endMark('(Committing Changes)', '(Committing Changes)', warning$$1);
  }
}

function startCommitHostEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Committing Host Effects)');
  }
}

function stopCommitHostEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);
  }
}

function startCommitLifeCyclesTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Calling Lifecycle Methods)');
  }
}

function stopCommitLifeCyclesTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);
  }
}

{
  var warnedAboutMissingGetChildContext = {};
}

// A cursor to the current merged context object on the stack.
var contextStackCursor = createCursor(emptyObject);
// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor = createCursor(false);
// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext = emptyObject;

function getUnmaskedContext(workInProgress) {
  var hasOwnContext = isContextProvider(workInProgress);
  if (hasOwnContext) {
    // If the fiber is a context provider itself, when we read its context
    // we have already pushed its own child context on the stack. A context
    // provider should not "see" its own child context. Therefore we read the
    // previous (parent) context instead for a context provider.
    return previousContext;
  }
  return contextStackCursor.current;
}

function cacheContext(workInProgress, unmaskedContext, maskedContext) {
  var instance = workInProgress.stateNode;
  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
}

function getMaskedContext(workInProgress, unmaskedContext) {
  var type = workInProgress.type;
  var contextTypes = type.contextTypes;
  if (!contextTypes) {
    return emptyObject;
  }

  // Avoid recreating masked context unless unmasked context has changed.
  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
  // This may trigger infinite loops if componentWillReceiveProps calls setState.
  var instance = workInProgress.stateNode;
  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
    return instance.__reactInternalMemoizedMaskedChildContext;
  }

  var context = {};
  for (var key in contextTypes) {
    context[key] = unmaskedContext[key];
  }

  {
    var name = getComponentName(workInProgress) || 'Unknown';
    checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
  }

  // Cache unmasked context so we can avoid recreating masked context unless necessary.
  // Context is created before the class component is instantiated so check for instance.
  if (instance) {
    cacheContext(workInProgress, unmaskedContext, context);
  }

  return context;
}

function hasContextChanged() {
  return didPerformWorkStackCursor.current;
}

function isContextConsumer(fiber) {
  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;
}

function isContextProvider(fiber) {
  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;
}

function popContextProvider(fiber) {
  if (!isContextProvider(fiber)) {
    return;
  }

  pop(didPerformWorkStackCursor, fiber);
  pop(contextStackCursor, fiber);
}

function popTopLevelContextObject(fiber) {
  pop(didPerformWorkStackCursor, fiber);
  pop(contextStackCursor, fiber);
}

function pushTopLevelContextObject(fiber, context, didChange) {
  !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  push(contextStackCursor, context, fiber);
  push(didPerformWorkStackCursor, didChange, fiber);
}

function processChildContext(fiber, parentContext) {
  var instance = fiber.stateNode;
  var childContextTypes = fiber.type.childContextTypes;

  // TODO (bvaughn) Replace this behavior with an invariant() in the future.
  // It has only been added in Fiber to match the (unintentional) behavior in Stack.
  if (typeof instance.getChildContext !== 'function') {
    {
      var componentName = getComponentName(fiber) || 'Unknown';

      if (!warnedAboutMissingGetChildContext[componentName]) {
        warnedAboutMissingGetChildContext[componentName] = true;
        warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
      }
    }
    return parentContext;
  }

  var childContext = void 0;
  {
    ReactDebugCurrentFiber.setCurrentPhase('getChildContext');
  }
  startPhaseTimer(fiber, 'getChildContext');
  childContext = instance.getChildContext();
  stopPhaseTimer();
  {
    ReactDebugCurrentFiber.setCurrentPhase(null);
  }
  for (var contextKey in childContext) {
    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;
  }
  {
    var name = getComponentName(fiber) || 'Unknown';
    checkPropTypes(childContextTypes, childContext, 'child context', name,
    // In practice, there is one case in which we won't get a stack. It's when
    // somebody calls unstable_renderSubtreeIntoContainer() and we process
    // context from the parent component instance. The stack will be missing
    // because it's outside of the reconciliation, and so the pointer has not
    // been set. This is rare and doesn't matter. We'll also remove that API.
    ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
  }

  return _assign({}, parentContext, childContext);
}

function pushContextProvider(workInProgress) {
  if (!isContextProvider(workInProgress)) {
    return false;
  }

  var instance = workInProgress.stateNode;
  // We push the context as early as possible to ensure stack integrity.
  // If the instance does not exist yet, we will push null at first,
  // and replace it on the stack later when invalidating the context.
  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;

  // Remember the parent context so we can merge with it later.
  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
  previousContext = contextStackCursor.current;
  push(contextStackCursor, memoizedMergedChildContext, workInProgress);
  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);

  return true;
}

function invalidateContextProvider(workInProgress, didChange) {
  var instance = workInProgress.stateNode;
  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  if (didChange) {
    // Merge parent and own context.
    // Skip this if we're not updating due to sCU.
    // This avoids unnecessarily recomputing memoized values.
    var mergedContext = processChildContext(workInProgress, previousContext);
    instance.__reactInternalMemoizedMergedChildContext = mergedContext;

    // Replace the old (or empty) context with the new one.
    // It is important to unwind the context in the reverse order.
    pop(didPerformWorkStackCursor, workInProgress);
    pop(contextStackCursor, workInProgress);
    // Now push the new context and mark that it has changed.
    push(contextStackCursor, mergedContext, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  } else {
    pop(didPerformWorkStackCursor, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  }
}

function resetContext() {
  previousContext = emptyObject;
  contextStackCursor.current = emptyObject;
  didPerformWorkStackCursor.current = false;
}

function findCurrentUnmaskedContext(fiber) {
  // Currently this is only used with renderSubtreeIntoContainer; not sure if it
  // makes sense elsewhere
  !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  var node = fiber;
  while (node.tag !== HostRoot) {
    if (isContextProvider(node)) {
      return node.stateNode.__reactInternalMemoizedMergedChildContext;
    }
    var parent = node['return'];
    !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    node = parent;
  }
  return node.stateNode.context;
}

var NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax

var Sync = 1;
var Never = 2147483647; // Max int32: Math.pow(2, 31) - 1

var UNIT_SIZE = 10;
var MAGIC_NUMBER_OFFSET = 2;

// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms) {
  // Always add an offset so that we don't clash with the magic number for NoWork.
  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;
}

function expirationTimeToMs(expirationTime) {
  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
}

function ceiling(num, precision) {
  return ((num / precision | 0) + 1) * precision;
}

function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
  return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
}

var NoContext = 0;
var AsyncUpdates = 1;

{
  var hasBadMapPolyfill = false;
  try {
    var nonExtensibleObject = Object.preventExtensions({});
    /* eslint-disable no-new */
    
    /* eslint-enable no-new */
  } catch (e) {
    // TODO: Consider warning about bad polyfills
    hasBadMapPolyfill = true;
  }
}

// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.


{
  var debugCounter = 1;
}

function FiberNode(tag, key, internalContextTag) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this['return'] = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  this.pendingProps = null;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.internalContextTag = internalContextTag;

  // Effects
  this.effectTag = NoEffect;
  this.nextEffect = null;

  this.firstEffect = null;
  this.lastEffect = null;

  this.expirationTime = NoWork;

  this.alternate = null;

  {
    this._debugID = debugCounter++;
    this._debugSource = null;
    this._debugOwner = null;
    this._debugIsCurrentlyTiming = false;
    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
      Object.preventExtensions(this);
    }
  }
}

// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber = function (tag, key, internalContextTag) {
  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag, key, internalContextTag);
};

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current, pendingProps, expirationTime) {
  var workInProgress = current.alternate;
  if (workInProgress === null) {
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    workInProgress = createFiber(current.tag, current.key, current.internalContextTag);
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;

    {
      // DEV-only fields
      workInProgress._debugID = current._debugID;
      workInProgress._debugSource = current._debugSource;
      workInProgress._debugOwner = current._debugOwner;
    }

    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // We already have an alternate.
    // Reset the effect tag.
    workInProgress.effectTag = NoEffect;

    // The effect list is no longer valid.
    workInProgress.nextEffect = null;
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;
  }

  workInProgress.expirationTime = expirationTime;
  workInProgress.pendingProps = pendingProps;

  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;

  // These will be overridden during the parent's reconciliation
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  return workInProgress;
}

function createHostRootFiber() {
  var fiber = createFiber(HostRoot, null, NoContext);
  return fiber;
}

function createFiberFromElement(element, internalContextTag, expirationTime) {
  var owner = null;
  {
    owner = element._owner;
  }

  var fiber = void 0;
  var type = element.type,
      key = element.key;

  if (typeof type === 'function') {
    fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);
    fiber.type = type;
    fiber.pendingProps = element.props;
  } else if (typeof type === 'string') {
    fiber = createFiber(HostComponent, key, internalContextTag);
    fiber.type = type;
    fiber.pendingProps = element.props;
  } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {
    // Currently assumed to be a continuation and therefore is a fiber already.
    // TODO: The yield system is currently broken for updates in some cases.
    // The reified yield stores a fiber, but we don't know which fiber that is;
    // the current or a workInProgress? When the continuation gets rendered here
    // we don't know if we can reuse that fiber or if we need to clone it.
    // There is probably a clever way to restructure this.
    fiber = type;
    fiber.pendingProps = element.props;
  } else {
    var info = '';
    {
      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }
      var ownerName = owner ? getComponentName(owner) : null;
      if (ownerName) {
        info += '\n\nCheck the render method of `' + ownerName + '`.';
      }
    }
    invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);
  }

  {
    fiber._debugSource = element._source;
    fiber._debugOwner = element._owner;
  }

  fiber.expirationTime = expirationTime;

  return fiber;
}

function createFiberFromFragment(elements, internalContextTag, expirationTime, key) {
  var fiber = createFiber(Fragment, key, internalContextTag);
  fiber.pendingProps = elements;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromText(content, internalContextTag, expirationTime) {
  var fiber = createFiber(HostText, null, internalContextTag);
  fiber.pendingProps = content;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromHostInstanceForDeletion() {
  var fiber = createFiber(HostComponent, null, NoContext);
  fiber.type = 'DELETED';
  return fiber;
}

function createFiberFromCall(call, internalContextTag, expirationTime) {
  var fiber = createFiber(CallComponent, call.key, internalContextTag);
  fiber.type = call.handler;
  fiber.pendingProps = call;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromReturn(returnNode, internalContextTag, expirationTime) {
  var fiber = createFiber(ReturnComponent, null, internalContextTag);
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromPortal(portal, internalContextTag, expirationTime) {
  var fiber = createFiber(HostPortal, portal.key, internalContextTag);
  fiber.pendingProps = portal.children || [];
  fiber.expirationTime = expirationTime;
  fiber.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null, // Used by persistent updates
    implementation: portal.implementation
  };
  return fiber;
}

function createFiberRoot(containerInfo, hydrate) {
  // Cyclic construction. This cheats the type system right now because
  // stateNode is any.
  var uninitializedFiber = createHostRootFiber();
  var root = {
    current: uninitializedFiber,
    containerInfo: containerInfo,
    pendingChildren: null,
    remainingExpirationTime: NoWork,
    isReadyForCommit: false,
    finishedWork: null,
    context: null,
    pendingContext: null,
    hydrate: hydrate,
    nextScheduledRoot: null
  };
  uninitializedFiber.stateNode = root;
  return root;
}

var onCommitFiberRoot = null;
var onCommitFiberUnmount = null;
var hasLoggedError = false;

function catchErrors(fn) {
  return function (arg) {
    try {
      return fn(arg);
    } catch (err) {
      if (true && !hasLoggedError) {
        hasLoggedError = true;
        warning(false, 'React DevTools encountered an error: %s', err);
      }
    }
  };
}

function injectInternals(internals) {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
    // No DevTools
    return false;
  }
  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (hook.isDisabled) {
    // This isn't a real property on the hook, but it can be set to opt out
    // of DevTools integration and associated warnings and logs.
    // https://github.com/facebook/react/issues/3877
    return true;
  }
  if (!hook.supportsFiber) {
    {
      warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');
    }
    // DevTools exists, even though it doesn't support Fiber.
    return true;
  }
  try {
    var rendererID = hook.inject(internals);
    // We have successfully injected, so now it is safe to set up hooks.
    onCommitFiberRoot = catchErrors(function (root) {
      return hook.onCommitFiberRoot(rendererID, root);
    });
    onCommitFiberUnmount = catchErrors(function (fiber) {
      return hook.onCommitFiberUnmount(rendererID, fiber);
    });
  } catch (err) {
    // Catch all errors because it is unsafe to throw during initialization.
    {
      warning(false, 'React DevTools encountered an error: %s.', err);
    }
  }
  // DevTools exists
  return true;
}

function onCommitRoot(root) {
  if (typeof onCommitFiberRoot === 'function') {
    onCommitFiberRoot(root);
  }
}

function onCommitUnmount(fiber) {
  if (typeof onCommitFiberUnmount === 'function') {
    onCommitFiberUnmount(fiber);
  }
}

{
  var didWarnUpdateInsideUpdate = false;
}

// Callbacks are not validated until invocation


// Singly linked-list of updates. When an update is scheduled, it is added to
// the queue of the current fiber and the work-in-progress fiber. The two queues
// are separate but they share a persistent structure.
//
// During reconciliation, updates are removed from the work-in-progress fiber,
// but they remain on the current fiber. That ensures that if a work-in-progress
// is aborted, the aborted updates are recovered by cloning from current.
//
// The work-in-progress queue is always a subset of the current queue.
//
// When the tree is committed, the work-in-progress becomes the current.


function createUpdateQueue(baseState) {
  var queue = {
    baseState: baseState,
    expirationTime: NoWork,
    first: null,
    last: null,
    callbackList: null,
    hasForceUpdate: false,
    isInitialized: false
  };
  {
    queue.isProcessing = false;
  }
  return queue;
}

function insertUpdateIntoQueue(queue, update) {
  // Append the update to the end of the list.
  if (queue.last === null) {
    // Queue is empty
    queue.first = queue.last = update;
  } else {
    queue.last.next = update;
    queue.last = update;
  }
  if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {
    queue.expirationTime = update.expirationTime;
  }
}

function insertUpdateIntoFiber(fiber, update) {
  // We'll have at least one and at most two distinct update queues.
  var alternateFiber = fiber.alternate;
  var queue1 = fiber.updateQueue;
  if (queue1 === null) {
    // TODO: We don't know what the base state will be until we begin work.
    // It depends on which fiber is the next current. Initialize with an empty
    // base state, then set to the memoizedState when rendering. Not super
    // happy with this approach.
    queue1 = fiber.updateQueue = createUpdateQueue(null);
  }

  var queue2 = void 0;
  if (alternateFiber !== null) {
    queue2 = alternateFiber.updateQueue;
    if (queue2 === null) {
      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);
    }
  } else {
    queue2 = null;
  }
  queue2 = queue2 !== queue1 ? queue2 : null;

  // Warn if an update is scheduled from inside an updater function.
  {
    if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {
      warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');
      didWarnUpdateInsideUpdate = true;
    }
  }

  // If there's only one queue, add the update to that queue and exit.
  if (queue2 === null) {
    insertUpdateIntoQueue(queue1, update);
    return;
  }

  // If either queue is empty, we need to add to both queues.
  if (queue1.last === null || queue2.last === null) {
    insertUpdateIntoQueue(queue1, update);
    insertUpdateIntoQueue(queue2, update);
    return;
  }

  // If both lists are not empty, the last update is the same for both lists
  // because of structural sharing. So, we should only append to one of
  // the lists.
  insertUpdateIntoQueue(queue1, update);
  // But we still need to update the `last` pointer of queue2.
  queue2.last = update;
}

function getUpdateExpirationTime(fiber) {
  if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {
    return NoWork;
  }
  var updateQueue = fiber.updateQueue;
  if (updateQueue === null) {
    return NoWork;
  }
  return updateQueue.expirationTime;
}

function getStateFromUpdate(update, instance, prevState, props) {
  var partialState = update.partialState;
  if (typeof partialState === 'function') {
    var updateFn = partialState;

    // Invoke setState callback an extra time to help detect side-effects.
    if (debugRenderPhaseSideEffects) {
      updateFn.call(instance, prevState, props);
    }

    return updateFn.call(instance, prevState, props);
  } else {
    return partialState;
  }
}

function processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {
  if (current !== null && current.updateQueue === queue) {
    // We need to create a work-in-progress queue, by cloning the current queue.
    var currentQueue = queue;
    queue = workInProgress.updateQueue = {
      baseState: currentQueue.baseState,
      expirationTime: currentQueue.expirationTime,
      first: currentQueue.first,
      last: currentQueue.last,
      isInitialized: currentQueue.isInitialized,
      // These fields are no longer valid because they were already committed.
      // Reset them.
      callbackList: null,
      hasForceUpdate: false
    };
  }

  {
    // Set this flag so we can warn if setState is called inside the update
    // function of another setState.
    queue.isProcessing = true;
  }

  // Reset the remaining expiration time. If we skip over any updates, we'll
  // increase this accordingly.
  queue.expirationTime = NoWork;

  // TODO: We don't know what the base state will be until we begin work.
  // It depends on which fiber is the next current. Initialize with an empty
  // base state, then set to the memoizedState when rendering. Not super
  // happy with this approach.
  var state = void 0;
  if (queue.isInitialized) {
    state = queue.baseState;
  } else {
    state = queue.baseState = workInProgress.memoizedState;
    queue.isInitialized = true;
  }
  var dontMutatePrevState = true;
  var update = queue.first;
  var didSkip = false;
  while (update !== null) {
    var updateExpirationTime = update.expirationTime;
    if (updateExpirationTime > renderExpirationTime) {
      // This update does not have sufficient priority. Skip it.
      var remainingExpirationTime = queue.expirationTime;
      if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {
        // Update the remaining expiration time.
        queue.expirationTime = updateExpirationTime;
      }
      if (!didSkip) {
        didSkip = true;
        queue.baseState = state;
      }
      // Continue to the next update.
      update = update.next;
      continue;
    }

    // This update does have sufficient priority.

    // If no previous updates were skipped, drop this update from the queue by
    // advancing the head of the list.
    if (!didSkip) {
      queue.first = update.next;
      if (queue.first === null) {
        queue.last = null;
      }
    }

    // Process the update
    var _partialState = void 0;
    if (update.isReplace) {
      state = getStateFromUpdate(update, instance, state, props);
      dontMutatePrevState = true;
    } else {
      _partialState = getStateFromUpdate(update, instance, state, props);
      if (_partialState) {
        if (dontMutatePrevState) {
          // $FlowFixMe: Idk how to type this properly.
          state = _assign({}, state, _partialState);
        } else {
          state = _assign(state, _partialState);
        }
        dontMutatePrevState = false;
      }
    }
    if (update.isForced) {
      queue.hasForceUpdate = true;
    }
    if (update.callback !== null) {
      // Append to list of callbacks.
      var _callbackList = queue.callbackList;
      if (_callbackList === null) {
        _callbackList = queue.callbackList = [];
      }
      _callbackList.push(update);
    }
    update = update.next;
  }

  if (queue.callbackList !== null) {
    workInProgress.effectTag |= Callback;
  } else if (queue.first === null && !queue.hasForceUpdate) {
    // The queue is empty. We can reset it.
    workInProgress.updateQueue = null;
  }

  if (!didSkip) {
    didSkip = true;
    queue.baseState = state;
  }

  {
    // No longer processing.
    queue.isProcessing = false;
  }

  return state;
}

function commitCallbacks(queue, context) {
  var callbackList = queue.callbackList;
  if (callbackList === null) {
    return;
  }
  // Set the list to null to make sure they don't get called more than once.
  queue.callbackList = null;
  for (var i = 0; i < callbackList.length; i++) {
    var update = callbackList[i];
    var _callback = update.callback;
    // This update might be processed again. Clear the callback so it's only
    // called once.
    update.callback = null;
    !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;
    _callback.call(context);
  }
}

var fakeInternalInstance = {};
var isArray = Array.isArray;

{
  var didWarnAboutStateAssignmentForComponent = {};

  var warnOnInvalidCallback = function (callback, callerName) {
    warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
  };

  // This is so gross but it's at least non-critical and can be removed if
  // it causes problems. This is meant to give a nicer error message for
  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
  // ...)) which otherwise throws a "_processChildContext is not a function"
  // exception.
  Object.defineProperty(fakeInternalInstance, '_processChildContext', {
    enumerable: false,
    value: function () {
      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');
    }
  });
  Object.freeze(fakeInternalInstance);
}

var ReactFiberClassComponent = function (scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {
  // Class component state updater
  var updater = {
    isMounted: isMounted,
    enqueueSetState: function (instance, partialState, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'setState');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: partialState,
        callback: callback,
        isReplace: false,
        isForced: false,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    },
    enqueueReplaceState: function (instance, state, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'replaceState');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: state,
        callback: callback,
        isReplace: true,
        isForced: false,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    },
    enqueueForceUpdate: function (instance, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'forceUpdate');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: null,
        callback: callback,
        isReplace: false,
        isForced: true,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    }
  };

  function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {
    if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {
      // If the workInProgress already has an Update effect, return true
      return true;
    }

    var instance = workInProgress.stateNode;
    var type = workInProgress.type;
    if (typeof instance.shouldComponentUpdate === 'function') {
      startPhaseTimer(workInProgress, 'shouldComponentUpdate');
      var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);
      stopPhaseTimer();

      // Simulate an async bailout/interruption by invoking lifecycle twice.
      if (debugRenderPhaseSideEffects) {
        instance.shouldComponentUpdate(newProps, newState, newContext);
      }

      {
        warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');
      }

      return shouldUpdate;
    }

    if (type.prototype && type.prototype.isPureReactComponent) {
      return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
    }

    return true;
  }

  function checkClassInstance(workInProgress) {
    var instance = workInProgress.stateNode;
    var type = workInProgress.type;
    {
      var name = getComponentName(workInProgress);
      var renderPresent = instance.render;

      if (!renderPresent) {
        if (type.prototype && typeof type.prototype.render === 'function') {
          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
        } else {
          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
        }
      }

      var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
      warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);
      var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
      warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);
      var noInstancePropTypes = !instance.propTypes;
      warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);
      var noInstanceContextTypes = !instance.contextTypes;
      warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);
      var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';
      warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);
      if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
        warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');
      }
      var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';
      warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);
      var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';
      warning(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);
      var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';
      warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);
      var hasMutatedProps = instance.props !== workInProgress.pendingProps;
      warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name);
      var noInstanceDefaultProps = !instance.defaultProps;
      warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);
    }

    var state = instance.state;
    if (state && (typeof state !== 'object' || isArray(state))) {
      warning(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));
    }
    if (typeof instance.getChildContext === 'function') {
      warning(typeof workInProgress.type.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', getComponentName(workInProgress));
    }
  }

  function resetInputPointers(workInProgress, instance) {
    instance.props = workInProgress.memoizedProps;
    instance.state = workInProgress.memoizedState;
  }

  function adoptClassInstance(workInProgress, instance) {
    instance.updater = updater;
    workInProgress.stateNode = instance;
    // The instance needs access to the fiber so that it can schedule updates
    set(instance, workInProgress);
    {
      instance._reactInternalInstance = fakeInternalInstance;
    }
  }

  function constructClassInstance(workInProgress, props) {
    var ctor = workInProgress.type;
    var unmaskedContext = getUnmaskedContext(workInProgress);
    var needsContext = isContextConsumer(workInProgress);
    var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;
    var instance = new ctor(props, context);
    adoptClassInstance(workInProgress, instance);

    // Cache unmasked context so we can avoid recreating masked context unless necessary.
    // ReactFiberContext usually updates this cache but can't for newly-created instances.
    if (needsContext) {
      cacheContext(workInProgress, unmaskedContext, context);
    }

    return instance;
  }

  function callComponentWillMount(workInProgress, instance) {
    startPhaseTimer(workInProgress, 'componentWillMount');
    var oldState = instance.state;
    instance.componentWillMount();
    stopPhaseTimer();

    // Simulate an async bailout/interruption by invoking lifecycle twice.
    if (debugRenderPhaseSideEffects) {
      instance.componentWillMount();
    }

    if (oldState !== instance.state) {
      {
        warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentName(workInProgress));
      }
      updater.enqueueReplaceState(instance, instance.state, null);
    }
  }

  function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {
    startPhaseTimer(workInProgress, 'componentWillReceiveProps');
    var oldState = instance.state;
    instance.componentWillReceiveProps(newProps, newContext);
    stopPhaseTimer();

    // Simulate an async bailout/interruption by invoking lifecycle twice.
    if (debugRenderPhaseSideEffects) {
      instance.componentWillReceiveProps(newProps, newContext);
    }

    if (instance.state !== oldState) {
      {
        var componentName = getComponentName(workInProgress) || 'Component';
        if (!didWarnAboutStateAssignmentForComponent[componentName]) {
          warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
          didWarnAboutStateAssignmentForComponent[componentName] = true;
        }
      }
      updater.enqueueReplaceState(instance, instance.state, null);
    }
  }

  // Invokes the mount life-cycles on a previously never rendered instance.
  function mountClassInstance(workInProgress, renderExpirationTime) {
    var current = workInProgress.alternate;

    {
      checkClassInstance(workInProgress);
    }

    var instance = workInProgress.stateNode;
    var state = instance.state || null;

    var props = workInProgress.pendingProps;
    !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    var unmaskedContext = getUnmaskedContext(workInProgress);

    instance.props = props;
    instance.state = workInProgress.memoizedState = state;
    instance.refs = emptyObject;
    instance.context = getMaskedContext(workInProgress, unmaskedContext);

    if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {
      workInProgress.internalContextTag |= AsyncUpdates;
    }

    if (typeof instance.componentWillMount === 'function') {
      callComponentWillMount(workInProgress, instance);
      // If we had additional state updates during this life-cycle, let's
      // process them now.
      var updateQueue = workInProgress.updateQueue;
      if (updateQueue !== null) {
        instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);
      }
    }
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.effectTag |= Update;
    }
  }

  // Called on a preexisting class instance. Returns false if a resumed render
  // could be reused.
  // function resumeMountClassInstance(
  //   workInProgress: Fiber,
  //   priorityLevel: PriorityLevel,
  // ): boolean {
  //   const instance = workInProgress.stateNode;
  //   resetInputPointers(workInProgress, instance);

  //   let newState = workInProgress.memoizedState;
  //   let newProps = workInProgress.pendingProps;
  //   if (!newProps) {
  //     // If there isn't any new props, then we'll reuse the memoized props.
  //     // This could be from already completed work.
  //     newProps = workInProgress.memoizedProps;
  //     invariant(
  //       newProps != null,
  //       'There should always be pending or memoized props. This error is ' +
  //         'likely caused by a bug in React. Please file an issue.',
  //     );
  //   }
  //   const newUnmaskedContext = getUnmaskedContext(workInProgress);
  //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);

  //   const oldContext = instance.context;
  //   const oldProps = workInProgress.memoizedProps;

  //   if (
  //     typeof instance.componentWillReceiveProps === 'function' &&
  //     (oldProps !== newProps || oldContext !== newContext)
  //   ) {
  //     callComponentWillReceiveProps(
  //       workInProgress,
  //       instance,
  //       newProps,
  //       newContext,
  //     );
  //   }

  //   // Process the update queue before calling shouldComponentUpdate
  //   const updateQueue = workInProgress.updateQueue;
  //   if (updateQueue !== null) {
  //     newState = processUpdateQueue(
  //       workInProgress,
  //       updateQueue,
  //       instance,
  //       newState,
  //       newProps,
  //       priorityLevel,
  //     );
  //   }

  //   // TODO: Should we deal with a setState that happened after the last
  //   // componentWillMount and before this componentWillMount? Probably
  //   // unsupported anyway.

  //   if (
  //     !checkShouldComponentUpdate(
  //       workInProgress,
  //       workInProgress.memoizedProps,
  //       newProps,
  //       workInProgress.memoizedState,
  //       newState,
  //       newContext,
  //     )
  //   ) {
  //     // Update the existing instance's state, props, and context pointers even
  //     // though we're bailing out.
  //     instance.props = newProps;
  //     instance.state = newState;
  //     instance.context = newContext;
  //     return false;
  //   }

  //   // Update the input pointers now so that they are correct when we call
  //   // componentWillMount
  //   instance.props = newProps;
  //   instance.state = newState;
  //   instance.context = newContext;

  //   if (typeof instance.componentWillMount === 'function') {
  //     callComponentWillMount(workInProgress, instance);
  //     // componentWillMount may have called setState. Process the update queue.
  //     const newUpdateQueue = workInProgress.updateQueue;
  //     if (newUpdateQueue !== null) {
  //       newState = processUpdateQueue(
  //         workInProgress,
  //         newUpdateQueue,
  //         instance,
  //         newState,
  //         newProps,
  //         priorityLevel,
  //       );
  //     }
  //   }

  //   if (typeof instance.componentDidMount === 'function') {
  //     workInProgress.effectTag |= Update;
  //   }

  //   instance.state = newState;

  //   return true;
  // }

  // Invokes the update life-cycles and returns false if it shouldn't rerender.
  function updateClassInstance(current, workInProgress, renderExpirationTime) {
    var instance = workInProgress.stateNode;
    resetInputPointers(workInProgress, instance);

    var oldProps = workInProgress.memoizedProps;
    var newProps = workInProgress.pendingProps;
    if (!newProps) {
      // If there aren't any new props, then we'll reuse the memoized props.
      // This could be from already completed work.
      newProps = oldProps;
      !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    }
    var oldContext = instance.context;
    var newUnmaskedContext = getUnmaskedContext(workInProgress);
    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);

    // Note: During these life-cycles, instance.props/instance.state are what
    // ever the previously attempted to render - not the "current". However,
    // during componentDidUpdate we pass the "current" props.

    if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);
    }

    // Compute the next state using the memoized state and the update queue.
    var oldState = workInProgress.memoizedState;
    // TODO: Previous state can be null.
    var newState = void 0;
    if (workInProgress.updateQueue !== null) {
      newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);
    } else {
      newState = oldState;
    }

    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {
      // If an update was already in progress, we should schedule an Update
      // effect even though we're bailing out, so that cWU/cDU are called.
      if (typeof instance.componentDidUpdate === 'function') {
        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
          workInProgress.effectTag |= Update;
        }
      }
      return false;
    }

    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);

    if (shouldUpdate) {
      if (typeof instance.componentWillUpdate === 'function') {
        startPhaseTimer(workInProgress, 'componentWillUpdate');
        instance.componentWillUpdate(newProps, newState, newContext);
        stopPhaseTimer();

        // Simulate an async bailout/interruption by invoking lifecycle twice.
        if (debugRenderPhaseSideEffects) {
          instance.componentWillUpdate(newProps, newState, newContext);
        }
      }
      if (typeof instance.componentDidUpdate === 'function') {
        workInProgress.effectTag |= Update;
      }
    } else {
      // If an update was already in progress, we should schedule an Update
      // effect even though we're bailing out, so that cWU/cDU are called.
      if (typeof instance.componentDidUpdate === 'function') {
        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
          workInProgress.effectTag |= Update;
        }
      }

      // If shouldComponentUpdate returned false, we should still update the
      // memoized props/state to indicate that this work can be reused.
      memoizeProps(workInProgress, newProps);
      memoizeState(workInProgress, newState);
    }

    // Update the existing instance's state, props, and context pointers even
    // if shouldComponentUpdate returns false.
    instance.props = newProps;
    instance.state = newState;
    instance.context = newContext;

    return shouldUpdate;
  }

  return {
    adoptClassInstance: adoptClassInstance,
    constructClassInstance: constructClassInstance,
    mountClassInstance: mountClassInstance,
    // resumeMountClassInstance,
    updateClassInstance: updateClassInstance
  };
};

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable === 'undefined') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

var getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;


{
  var didWarnAboutMaps = false;
  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */
  var ownerHasKeyUseWarning = {};
  var ownerHasFunctionTypeWarning = {};

  var warnForMissingKey = function (child) {
    if (child === null || typeof child !== 'object') {
      return;
    }
    if (!child._store || child._store.validated || child.key != null) {
      return;
    }
    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    child._store.validated = true;

    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');
    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }
    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

    warning(false, 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());
  };
}

var isArray$1 = Array.isArray;

function coerceRef(current, element) {
  var mixedRef = element.ref;
  if (mixedRef !== null && typeof mixedRef !== 'function') {
    if (element._owner) {
      var owner = element._owner;
      var inst = void 0;
      if (owner) {
        var ownerFiber = owner;
        !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;
        inst = ownerFiber.stateNode;
      }
      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;
      var stringRef = '' + mixedRef;
      // Check if previous string ref matches new string ref
      if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {
        return current.ref;
      }
      var ref = function (value) {
        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
        if (value === null) {
          delete refs[stringRef];
        } else {
          refs[stringRef] = value;
        }
      };
      ref._stringRef = stringRef;
      return ref;
    } else {
      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;
      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;
    }
  }
  return mixedRef;
}

function throwOnInvalidObjectType(returnFiber, newChild) {
  if (returnFiber.type !== 'textarea') {
    var addendum = '';
    {
      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');
    }
    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);
  }
}

function warnOnFunctionType() {
  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');

  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;

  warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');
}

// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return;
    }
    // Deletions are added in reversed order so we add it to the front.
    // At this point, the return fiber's effect list is empty except for
    // deletions, so we can just append the deletion to the list. The remaining
    // effects aren't added until the complete phase. Once we implement
    // resuming, this may not be true.
    var last = returnFiber.lastEffect;
    if (last !== null) {
      last.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
    childToDelete.nextEffect = null;
    childToDelete.effectTag = Deletion;
  }

  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return null;
    }

    // TODO: For the shouldClone case, this could be micro-optimized a bit by
    // assuming that after the first child we've already added everything.
    var childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }

  function mapRemainingChildren(returnFiber, currentFirstChild) {
    // Add the remaining children to a temporary map so that we can find them by
    // keys quickly. Implicit (null) keys get added to this set with their index
    var existingChildren = new Map();

    var existingChild = currentFirstChild;
    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }
      existingChild = existingChild.sibling;
    }
    return existingChildren;
  }

  function useFiber(fiber, pendingProps, expirationTime) {
    // We currently set sibling to null and index to 0 here because it is easy
    // to forget to do before returning it. E.g. for the single child case.
    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }

  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects) {
      // Noop.
      return lastPlacedIndex;
    }
    var current = newFiber.alternate;
    if (current !== null) {
      var oldIndex = current.index;
      if (oldIndex < lastPlacedIndex) {
        // This is a move.
        newFiber.effectTag = Placement;
        return lastPlacedIndex;
      } else {
        // This item can stay in place.
        return oldIndex;
      }
    } else {
      // This is an insertion.
      newFiber.effectTag = Placement;
      return lastPlacedIndex;
    }
  }

  function placeSingleChild(newFiber) {
    // This is simpler for the single child case. We only need to do a
    // placement for inserting new children.
    if (shouldTrackSideEffects && newFiber.alternate === null) {
      newFiber.effectTag = Placement;
    }
    return newFiber;
  }

  function updateTextNode(returnFiber, current, textContent, expirationTime) {
    if (current === null || current.tag !== HostText) {
      // Insert
      var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, textContent, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateElement(returnFiber, current, element, expirationTime) {
    if (current !== null && current.type === element.type) {
      // Move based on index
      var existing = useFiber(current, element.props, expirationTime);
      existing.ref = coerceRef(current, element);
      existing['return'] = returnFiber;
      {
        existing._debugSource = element._source;
        existing._debugOwner = element._owner;
      }
      return existing;
    } else {
      // Insert
      var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
      created.ref = coerceRef(current, element);
      created['return'] = returnFiber;
      return created;
    }
  }

  function updateCall(returnFiber, current, call, expirationTime) {
    // TODO: Should this also compare handler to determine whether to reuse?
    if (current === null || current.tag !== CallComponent) {
      // Insert
      var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Move based on index
      var existing = useFiber(current, call, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateReturn(returnFiber, current, returnNode, expirationTime) {
    if (current === null || current.tag !== ReturnComponent) {
      // Insert
      var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
      created.type = returnNode.value;
      created['return'] = returnFiber;
      return created;
    } else {
      // Move based on index
      var existing = useFiber(current, null, expirationTime);
      existing.type = returnNode.value;
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updatePortal(returnFiber, current, portal, expirationTime) {
    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
      // Insert
      var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, portal.children || [], expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateFragment(returnFiber, current, fragment, expirationTime, key) {
    if (current === null || current.tag !== Fragment) {
      // Insert
      var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, fragment, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function createChild(returnFiber, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);
              _created['return'] = returnFiber;
              return _created;
            } else {
              var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);
              _created2.ref = coerceRef(null, newChild);
              _created2['return'] = returnFiber;
              return _created2;
            }
          }

        case REACT_CALL_TYPE:
          {
            var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);
            _created3['return'] = returnFiber;
            return _created3;
          }

        case REACT_RETURN_TYPE:
          {
            var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);
            _created4.type = newChild.value;
            _created4['return'] = returnFiber;
            return _created4;
          }

        case REACT_PORTAL_TYPE:
          {
            var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);
            _created5['return'] = returnFiber;
            return _created5;
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);
        _created6['return'] = returnFiber;
        return _created6;
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
    // Update the fiber if the keys match, otherwise return null.

    var key = oldFiber !== null ? oldFiber.key : null;

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      if (key !== null) {
        return null;
      }
      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.key === key) {
              if (newChild.type === REACT_FRAGMENT_TYPE) {
                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
              }
              return updateElement(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_CALL_TYPE:
          {
            if (newChild.key === key) {
              return updateCall(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_RETURN_TYPE:
          {
            // Returns don't have keys. If the previous node is implicitly keyed
            // we can continue to replace it without aborting even if it is not a
            // yield.
            if (key === null) {
              return updateReturn(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_PORTAL_TYPE:
          {
            if (newChild.key === key) {
              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        if (key !== null) {
          return null;
        }

        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys, so we neither have to check the old nor
      // new node for the key. If both are text nodes, they match.
      var matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
            }
            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
          }

        case REACT_CALL_TYPE:
          {
            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);
          }

        case REACT_RETURN_TYPE:
          {
            // Returns don't have keys, so we neither have to check the old nor
            // new node for the key. If both are returns, they match.
            var _matchedFiber3 = existingChildren.get(newIdx) || null;
            return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);
          }

        case REACT_PORTAL_TYPE:
          {
            var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _matchedFiber5 = existingChildren.get(newIdx) || null;
        return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  /**
   * Warns if there is a duplicate or missing key
   */
  function warnOnInvalidKey(child, knownKeys) {
    {
      if (typeof child !== 'object' || child === null) {
        return knownKeys;
      }
      switch (child.$$typeof) {
        case REACT_ELEMENT_TYPE:
        case REACT_CALL_TYPE:
        case REACT_PORTAL_TYPE:
          warnForMissingKey(child);
          var key = child.key;
          if (typeof key !== 'string') {
            break;
          }
          if (knownKeys === null) {
            knownKeys = new Set();
            knownKeys.add(key);
            break;
          }
          if (!knownKeys.has(key)) {
            knownKeys.add(key);
            break;
          }
          warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());
          break;
        default:
          break;
      }
    }
    return knownKeys;
  }

  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
    // This algorithm can't optimize by searching from boths ends since we
    // don't have backpointers on fibers. I'm trying to see how far we can get
    // with that model. If it ends up not being worth the tradeoffs, we can
    // add it later.

    // Even with a two ended optimization, we'd want to optimize for the case
    // where there are few changes and brute force the comparison instead of
    // going for the Map. It'd like to explore hitting that path first in
    // forward-only mode and only go for the Map once we notice that we need
    // lots of look ahead. This doesn't handle reversal as well as two ended
    // search but that's unusual. Besides, for the two ended optimization to
    // work on Iterables, we'd need to copy the whole set.

    // In this first iteration, we'll just live with hitting the bad case
    // (adding everything to a Map) in for every insert/move.

    // If you change this code, also update reconcileChildrenIterator() which
    // uses the same algorithm.

    {
      // First, validate keys.
      var knownKeys = null;
      for (var i = 0; i < newChildren.length; i++) {
        var child = newChildren[i];
        knownKeys = warnOnInvalidKey(child, knownKeys);
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; newIdx < newChildren.length; newIdx++) {
        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);
        if (!_newFiber) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber;
        } else {
          previousNewFiber.sibling = _newFiber;
        }
        previousNewFiber = _newFiber;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; newIdx < newChildren.length; newIdx++) {
      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);
      if (_newFiber2) {
        if (shouldTrackSideEffects) {
          if (_newFiber2.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber2;
        } else {
          previousNewFiber.sibling = _newFiber2;
        }
        previousNewFiber = _newFiber2;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
    // This is the same implementation as reconcileChildrenArray(),
    // but using the iterator instead.

    var iteratorFn = getIteratorFn(newChildrenIterable);
    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    {
      // Warn about using Maps as children
      if (typeof newChildrenIterable.entries === 'function') {
        var possibleMap = newChildrenIterable;
        if (possibleMap.entries === iteratorFn) {
          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());
          didWarnAboutMaps = true;
        }
      }

      // First, validate keys.
      // We'll get a different iterator later for the main pass.
      var _newChildren = iteratorFn.call(newChildrenIterable);
      if (_newChildren) {
        var knownKeys = null;
        var _step = _newChildren.next();
        for (; !_step.done; _step = _newChildren.next()) {
          var child = _step.value;
          knownKeys = warnOnInvalidKey(child, knownKeys);
        }
      }
    }

    var newChildren = iteratorFn.call(newChildrenIterable);
    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;

    var step = newChildren.next();
    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (!oldFiber) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (step.done) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; !step.done; newIdx++, step = newChildren.next()) {
        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
        if (_newFiber3 === null) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber3;
        } else {
          previousNewFiber.sibling = _newFiber3;
        }
        previousNewFiber = _newFiber3;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; !step.done; newIdx++, step = newChildren.next()) {
      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);
      if (_newFiber4 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber4.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber4;
        } else {
          previousNewFiber.sibling = _newFiber4;
        }
        previousNewFiber = _newFiber4;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
    // There's no need to check for keys on text nodes since we don't have a
    // way to define them.
    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
      // We already have an existing node so let's just update it and delete
      // the rest.
      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
      var existing = useFiber(currentFirstChild, textContent, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
    // The existing first child is not a text node so we need to create one
    // and delete the existing ones.
    deleteRemainingChildren(returnFiber, currentFirstChild);
    var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
    var key = element.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
          existing.ref = coerceRef(child, element);
          existing['return'] = returnFiber;
          {
            existing._debugSource = element._source;
            existing._debugOwner = element._owner;
          }
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);
      created['return'] = returnFiber;
      return created;
    } else {
      var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
      _created7.ref = coerceRef(currentFirstChild, element);
      _created7['return'] = returnFiber;
      return _created7;
    }
  }

  function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {
    var key = call.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === CallComponent) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, call, expirationTime);
          existing['return'] = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {
    // There's no need to check for keys on yields since they're stateless.
    var child = currentFirstChild;
    if (child !== null) {
      if (child.tag === ReturnComponent) {
        deleteRemainingChildren(returnFiber, child.sibling);
        var existing = useFiber(child, null, expirationTime);
        existing.type = returnNode.value;
        existing['return'] = returnFiber;
        return existing;
      } else {
        deleteRemainingChildren(returnFiber, child);
      }
    }

    var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
    created.type = returnNode.value;
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
    var key = portal.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, portal.children || [], expirationTime);
          existing['return'] = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  // This API will tag the children with the side-effect of the reconciliation
  // itself. They will be added to the side-effect list as we pass through the
  // children and the parent.
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
    // This function is not recursive.
    // If the top level item is an array, we treat it as a set of children,
    // not as a fragment. Nested arrays on the other hand will be treated as
    // fragment nodes. Recursion happens at the normal flow.

    // Handle top level unkeyed fragments as if they were arrays.
    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
    // We treat the ambiguous cases above the same.
    if (typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {
      newChild = newChild.props.children;
    }

    // Handle object types
    var isObject = typeof newChild === 'object' && newChild !== null;

    if (isObject) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));

        case REACT_CALL_TYPE:
          return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));
        case REACT_RETURN_TYPE:
          return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));
        case REACT_PORTAL_TYPE:
          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
      }
    }

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));
    }

    if (isArray$1(newChild)) {
      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (isObject) {
      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }
    if (typeof newChild === 'undefined') {
      // If the new child is undefined, and the return fiber is a composite
      // component, throw an error. If Fiber return types are disabled,
      // we already threw above.
      switch (returnFiber.tag) {
        case ClassComponent:
          {
            {
              var instance = returnFiber.stateNode;
              if (instance.render._isMockFunction) {
                // We allow auto-mocks to proceed as if they're returning null.
                break;
              }
            }
          }
        // Intentionally fall through to the next case, which handles both
        // functions and classes
        // eslint-disable-next-lined no-fallthrough
        case FunctionalComponent:
          {
            var Component = returnFiber.type;
            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');
          }
      }
    }

    // Remaining cases are all treated as empty.
    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }

  return reconcileChildFibers;
}

var reconcileChildFibers = ChildReconciler(true);
var mountChildFibers = ChildReconciler(false);

function cloneChildFibers(current, workInProgress) {
  !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;

  if (workInProgress.child === null) {
    return;
  }

  var currentChild = workInProgress.child;
  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
  workInProgress.child = newChild;

  newChild['return'] = workInProgress;
  while (currentChild.sibling !== null) {
    currentChild = currentChild.sibling;
    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
    newChild['return'] = workInProgress;
  }
  newChild.sibling = null;
}

{
  var warnedAboutStatelessRefs = {};
}

var ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {
  var shouldSetTextContent = config.shouldSetTextContent,
      useSyncScheduling = config.useSyncScheduling,
      shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;
  var pushHostContext = hostContext.pushHostContext,
      pushHostContainer = hostContext.pushHostContainer;
  var enterHydrationState = hydrationContext.enterHydrationState,
      resetHydrationState = hydrationContext.resetHydrationState,
      tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;

  var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),
      adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,
      constructClassInstance = _ReactFiberClassCompo.constructClassInstance,
      mountClassInstance = _ReactFiberClassCompo.mountClassInstance,
      updateClassInstance = _ReactFiberClassCompo.updateClassInstance;

  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.


  function reconcileChildren(current, workInProgress, nextChildren) {
    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);
  }

  function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {
    if (current === null) {
      // If this is a fresh new component that hasn't been rendered yet, we
      // won't update its child set by applying minimal side-effects. Instead,
      // we will add them all to the child before it gets rendered. That means
      // we can optimize this reconciliation pass by not tracking side-effects.
      workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
    } else {
      // If the current child is the same as the work in progress, it means that
      // we haven't yet started any work on these children. Therefore, we use
      // the clone algorithm to create a copy of all the current children.

      // If we had any progressed work already, that is invalid at this point so
      // let's throw it out.
      workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);
    }
  }

  function updateFragment(current, workInProgress) {
    var nextChildren = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextChildren === null) {
        nextChildren = workInProgress.memoizedProps;
      }
    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }
    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextChildren);
    return workInProgress.child;
  }

  function markRef(current, workInProgress) {
    var ref = workInProgress.ref;
    if (ref !== null && (!current || current.ref !== ref)) {
      // Schedule a Ref effect
      workInProgress.effectTag |= Ref;
    }
  }

  function updateFunctionalComponent(current, workInProgress) {
    var fn = workInProgress.type;
    var nextProps = workInProgress.pendingProps;

    var memoizedProps = workInProgress.memoizedProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextProps === null) {
        nextProps = memoizedProps;
      }
    } else {
      if (nextProps === null || memoizedProps === nextProps) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }
      // TODO: consider bringing fn.shouldComponentUpdate() back.
      // It used to be here.
    }

    var unmaskedContext = getUnmaskedContext(workInProgress);
    var context = getMaskedContext(workInProgress, unmaskedContext);

    var nextChildren;

    {
      ReactCurrentOwner.current = workInProgress;
      ReactDebugCurrentFiber.setCurrentPhase('render');
      nextChildren = fn(nextProps, context);
      ReactDebugCurrentFiber.setCurrentPhase(null);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;
    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextProps);
    return workInProgress.child;
  }

  function updateClassComponent(current, workInProgress, renderExpirationTime) {
    // Push context providers early to prevent context stack mismatches.
    // During mounting we don't know the child context yet as the instance doesn't exist.
    // We will invalidate the child context in finishClassComponent() right after rendering.
    var hasContext = pushContextProvider(workInProgress);

    var shouldUpdate = void 0;
    if (current === null) {
      if (!workInProgress.stateNode) {
        // In the initial pass we might need to construct the instance.
        constructClassInstance(workInProgress, workInProgress.pendingProps);
        mountClassInstance(workInProgress, renderExpirationTime);
        shouldUpdate = true;
      } else {
        invariant(false, 'Resuming work not yet implemented.');
        // In a resume, we'll already have an instance we can reuse.
        // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
      }
    } else {
      shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);
    }
    return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);
  }

  function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {
    // Refs should update even if shouldComponentUpdate returns false
    markRef(current, workInProgress);

    if (!shouldUpdate) {
      // Context providers should defer to sCU for rendering
      if (hasContext) {
        invalidateContextProvider(workInProgress, false);
      }

      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var instance = workInProgress.stateNode;

    // Rerender
    ReactCurrentOwner.current = workInProgress;
    var nextChildren = void 0;
    {
      ReactDebugCurrentFiber.setCurrentPhase('render');
      nextChildren = instance.render();
      if (debugRenderPhaseSideEffects) {
        instance.render();
      }
      ReactDebugCurrentFiber.setCurrentPhase(null);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;
    reconcileChildren(current, workInProgress, nextChildren);
    // Memoize props and state using the values we just used to render.
    // TODO: Restructure so we never read values from the instance.
    memoizeState(workInProgress, instance.state);
    memoizeProps(workInProgress, instance.props);

    // The context might have changed so we need to recalculate it.
    if (hasContext) {
      invalidateContextProvider(workInProgress, true);
    }

    return workInProgress.child;
  }

  function pushHostRootContext(workInProgress) {
    var root = workInProgress.stateNode;
    if (root.pendingContext) {
      pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
    } else if (root.context) {
      // Should always be set
      pushTopLevelContextObject(workInProgress, root.context, false);
    }
    pushHostContainer(workInProgress, root.containerInfo);
  }

  function updateHostRoot(current, workInProgress, renderExpirationTime) {
    pushHostRootContext(workInProgress);
    var updateQueue = workInProgress.updateQueue;
    if (updateQueue !== null) {
      var prevState = workInProgress.memoizedState;
      var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);
      if (prevState === state) {
        // If the state is the same as before, that's a bailout because we had
        // no work that expires at this time.
        resetHydrationState();
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }
      var element = state.element;
      var root = workInProgress.stateNode;
      if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
        // If we don't have any current children this might be the first pass.
        // We always try to hydrate. If this isn't a hydration pass there won't
        // be any children to hydrate which is effectively the same thing as
        // not hydrating.

        // This is a bit of a hack. We track the host root as a placement to
        // know that we're currently in a mounting state. That way isMounted
        // works as expected. We must reset this before committing.
        // TODO: Delete this when we delete isMounted and findDOMNode.
        workInProgress.effectTag |= Placement;

        // Ensure that children mount into this root without tracking
        // side-effects. This ensures that we don't store Placement effects on
        // nodes that will be hydrated.
        workInProgress.child = mountChildFibers(workInProgress, null, element, renderExpirationTime);
      } else {
        // Otherwise reset hydration state in case we aborted and resumed another
        // root.
        resetHydrationState();
        reconcileChildren(current, workInProgress, element);
      }
      memoizeState(workInProgress, state);
      return workInProgress.child;
    }
    resetHydrationState();
    // If there is no update queue, that's a bailout because the root has no props.
    return bailoutOnAlreadyFinishedWork(current, workInProgress);
  }

  function updateHostComponent(current, workInProgress, renderExpirationTime) {
    pushHostContext(workInProgress);

    if (current === null) {
      tryToClaimNextHydratableInstance(workInProgress);
    }

    var type = workInProgress.type;
    var memoizedProps = workInProgress.memoizedProps;
    var nextProps = workInProgress.pendingProps;
    if (nextProps === null) {
      nextProps = memoizedProps;
      !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    }
    var prevProps = current !== null ? current.memoizedProps : null;

    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
    } else if (nextProps === null || memoizedProps === nextProps) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var nextChildren = nextProps.children;
    var isDirectTextChild = shouldSetTextContent(type, nextProps);

    if (isDirectTextChild) {
      // We special case a direct text child of a host node. This is a common
      // case. We won't handle it as a reified child. We will instead handle
      // this in the host environment that also have access to this prop. That
      // avoids allocating another HostText fiber and traversing it.
      nextChildren = null;
    } else if (prevProps && shouldSetTextContent(type, prevProps)) {
      // If we're switching from a direct text child to a normal child, or to
      // empty, we need to schedule the text content to be reset.
      workInProgress.effectTag |= ContentReset;
    }

    markRef(current, workInProgress);

    // Check the host config to see if the children are offscreen/hidden.
    if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {
      // Down-prioritize the children.
      workInProgress.expirationTime = Never;
      // Bailout and come back to this fiber later.
      return null;
    }

    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextProps);
    return workInProgress.child;
  }

  function updateHostText(current, workInProgress) {
    if (current === null) {
      tryToClaimNextHydratableInstance(workInProgress);
    }
    var nextProps = workInProgress.pendingProps;
    if (nextProps === null) {
      nextProps = workInProgress.memoizedProps;
    }
    memoizeProps(workInProgress, nextProps);
    // Nothing to do here. This is terminal. We'll do the completion step
    // immediately after.
    return null;
  }

  function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {
    !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    var fn = workInProgress.type;
    var props = workInProgress.pendingProps;
    var unmaskedContext = getUnmaskedContext(workInProgress);
    var context = getMaskedContext(workInProgress, unmaskedContext);

    var value;

    {
      if (fn.prototype && typeof fn.prototype.render === 'function') {
        var componentName = getComponentName(workInProgress);
        warning(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);
      }
      ReactCurrentOwner.current = workInProgress;
      value = fn(props, context);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;

    if (typeof value === 'object' && value !== null && typeof value.render === 'function') {
      // Proceed under the assumption that this is a class instance
      workInProgress.tag = ClassComponent;

      // Push context providers early to prevent context stack mismatches.
      // During mounting we don't know the child context yet as the instance doesn't exist.
      // We will invalidate the child context in finishClassComponent() right after rendering.
      var hasContext = pushContextProvider(workInProgress);
      adoptClassInstance(workInProgress, value);
      mountClassInstance(workInProgress, renderExpirationTime);
      return finishClassComponent(current, workInProgress, true, hasContext);
    } else {
      // Proceed under the assumption that this is a functional component
      workInProgress.tag = FunctionalComponent;
      {
        var Component = workInProgress.type;

        if (Component) {
          warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');
        }
        if (workInProgress.ref !== null) {
          var info = '';
          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();
          if (ownerName) {
            info += '\n\nCheck the render method of `' + ownerName + '`.';
          }

          var warningKey = ownerName || workInProgress._debugID || '';
          var debugSource = workInProgress._debugSource;
          if (debugSource) {
            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
          }
          if (!warnedAboutStatelessRefs[warningKey]) {
            warnedAboutStatelessRefs[warningKey] = true;
            warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());
          }
        }
      }
      reconcileChildren(current, workInProgress, value);
      memoizeProps(workInProgress, props);
      return workInProgress.child;
    }
  }

  function updateCallComponent(current, workInProgress, renderExpirationTime) {
    var nextCall = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextCall === null) {
        nextCall = current && current.memoizedProps;
        !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      }
    } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {
      nextCall = workInProgress.memoizedProps;
      // TODO: When bailing out, we might need to return the stateNode instead
      // of the child. To check it for work.
      // return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var nextChildren = nextCall.children;

    // The following is a fork of reconcileChildrenAtExpirationTime but using
    // stateNode to store the child.
    if (current === null) {
      workInProgress.stateNode = mountChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
    } else {
      workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
    }

    memoizeProps(workInProgress, nextCall);
    // This doesn't take arbitrary time so we could synchronously just begin
    // eagerly do the work of workInProgress.child as an optimization.
    return workInProgress.stateNode;
  }

  function updatePortalComponent(current, workInProgress, renderExpirationTime) {
    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
    var nextChildren = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextChildren === null) {
        nextChildren = current && current.memoizedProps;
        !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      }
    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    if (current === null) {
      // Portals are special because we don't append the children during mount
      // but at commit. Therefore we need to track insertions which the normal
      // flow doesn't do during mount. This doesn't happen at the root because
      // the root always starts with a "current" with a null child.
      // TODO: Consider unifying this with how the root works.
      workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
      memoizeProps(workInProgress, nextChildren);
    } else {
      reconcileChildren(current, workInProgress, nextChildren);
      memoizeProps(workInProgress, nextChildren);
    }
    return workInProgress.child;
  }

  /*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */

  function bailoutOnAlreadyFinishedWork(current, workInProgress) {
    cancelWorkTimer(workInProgress);

    // TODO: We should ideally be able to bail out early if the children have no
    // more work to do. However, since we don't have a separation of this
    // Fiber's priority and its children yet - we don't know without doing lots
    // of the same work we do anyway. Once we have that separation we can just
    // bail out here if the children has no more work at this priority level.
    // if (workInProgress.priorityOfChildren <= priorityLevel) {
    //   // If there are side-effects in these children that have not yet been
    //   // committed we need to ensure that they get properly transferred up.
    //   if (current && current.child !== workInProgress.child) {
    //     reuseChildrenEffects(workInProgress, child);
    //   }
    //   return null;
    // }

    cloneChildFibers(current, workInProgress);
    return workInProgress.child;
  }

  function bailoutOnLowPriority(current, workInProgress) {
    cancelWorkTimer(workInProgress);

    // TODO: Handle HostComponent tags here as well and call pushHostContext()?
    // See PR 8590 discussion for context
    switch (workInProgress.tag) {
      case HostRoot:
        pushHostRootContext(workInProgress);
        break;
      case ClassComponent:
        pushContextProvider(workInProgress);
        break;
      case HostPortal:
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        break;
    }
    // TODO: What if this is currently in progress?
    // How can that happen? How is this not being cloned?
    return null;
  }

  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead
  function memoizeProps(workInProgress, nextProps) {
    workInProgress.memoizedProps = nextProps;
  }

  function memoizeState(workInProgress, nextState) {
    workInProgress.memoizedState = nextState;
    // Don't reset the updateQueue, in case there are pending updates. Resetting
    // is handled by processUpdateQueue.
  }

  function beginWork(current, workInProgress, renderExpirationTime) {
    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
      return bailoutOnLowPriority(current, workInProgress);
    }

    switch (workInProgress.tag) {
      case IndeterminateComponent:
        return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);
      case FunctionalComponent:
        return updateFunctionalComponent(current, workInProgress);
      case ClassComponent:
        return updateClassComponent(current, workInProgress, renderExpirationTime);
      case HostRoot:
        return updateHostRoot(current, workInProgress, renderExpirationTime);
      case HostComponent:
        return updateHostComponent(current, workInProgress, renderExpirationTime);
      case HostText:
        return updateHostText(current, workInProgress);
      case CallHandlerPhase:
        // This is a restart. Reset the tag to the initial phase.
        workInProgress.tag = CallComponent;
      // Intentionally fall through since this is now the same.
      case CallComponent:
        return updateCallComponent(current, workInProgress, renderExpirationTime);
      case ReturnComponent:
        // A return component is just a placeholder, we can just run through the
        // next one immediately.
        return null;
      case HostPortal:
        return updatePortalComponent(current, workInProgress, renderExpirationTime);
      case Fragment:
        return updateFragment(current, workInProgress);
      default:
        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  function beginFailedWork(current, workInProgress, renderExpirationTime) {
    // Push context providers here to avoid a push/pop context mismatch.
    switch (workInProgress.tag) {
      case ClassComponent:
        pushContextProvider(workInProgress);
        break;
      case HostRoot:
        pushHostRootContext(workInProgress);
        break;
      default:
        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
    }

    // Add an error effect so we can handle the error during the commit phase
    workInProgress.effectTag |= Err;

    // This is a weird case where we do "resume" work — work that failed on
    // our first attempt. Because we no longer have a notion of "progressed
    // deletions," reset the child to the current child to make sure we delete
    // it again. TODO: Find a better way to handle this, perhaps during a more
    // general overhaul of error handling.
    if (current === null) {
      workInProgress.child = null;
    } else if (workInProgress.child !== current.child) {
      workInProgress.child = current.child;
    }

    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
      return bailoutOnLowPriority(current, workInProgress);
    }

    // If we don't bail out, we're going be recomputing our children so we need
    // to drop our effect list.
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;

    // Unmount the current children as if the component rendered null
    var nextChildren = null;
    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);

    if (workInProgress.tag === ClassComponent) {
      var instance = workInProgress.stateNode;
      workInProgress.memoizedProps = instance.props;
      workInProgress.memoizedState = instance.state;
    }

    return workInProgress.child;
  }

  return {
    beginWork: beginWork,
    beginFailedWork: beginFailedWork
  };
};

var ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {
  var createInstance = config.createInstance,
      createTextInstance = config.createTextInstance,
      appendInitialChild = config.appendInitialChild,
      finalizeInitialChildren = config.finalizeInitialChildren,
      prepareUpdate = config.prepareUpdate,
      mutation = config.mutation,
      persistence = config.persistence;
  var getRootHostContainer = hostContext.getRootHostContainer,
      popHostContext = hostContext.popHostContext,
      getHostContext = hostContext.getHostContext,
      popHostContainer = hostContext.popHostContainer;
  var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,
      prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,
      popHydrationState = hydrationContext.popHydrationState;


  function markUpdate(workInProgress) {
    // Tag the fiber with an update effect. This turns a Placement into
    // an UpdateAndPlacement.
    workInProgress.effectTag |= Update;
  }

  function markRef(workInProgress) {
    workInProgress.effectTag |= Ref;
  }

  function appendAllReturns(returns, workInProgress) {
    var node = workInProgress.stateNode;
    if (node) {
      node['return'] = workInProgress;
    }
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {
        invariant(false, 'A call cannot have host component children.');
      } else if (node.tag === ReturnComponent) {
        returns.push(node.type);
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === workInProgress) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {
    var call = workInProgress.memoizedProps;
    !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    // First step of the call has completed. Now we need to do the second.
    // TODO: It would be nice to have a multi stage call represented by a
    // single component, or at least tail call optimize nested ones. Currently
    // that requires additional fields that we don't want to add to the fiber.
    // So this requires nested handlers.
    // Note: This doesn't mutate the alternate node. I don't think it needs to
    // since this stage is reset for every pass.
    workInProgress.tag = CallHandlerPhase;

    // Build up the returns.
    // TODO: Compare this to a generator or opaque helpers like Children.
    var returns = [];
    appendAllReturns(returns, workInProgress);
    var fn = call.handler;
    var props = call.props;
    var nextChildren = fn(props, returns);

    var currentFirstChild = current !== null ? current.child : null;
    workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);
    return workInProgress.child;
  }

  function appendAllChildren(parent, workInProgress) {
    // We only have the top Fiber that was created but we need recurse down its
    // children to find all the terminal nodes.
    var node = workInProgress.child;
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText) {
        appendInitialChild(parent, node.stateNode);
      } else if (node.tag === HostPortal) {
        // If we have a portal child, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === workInProgress) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === workInProgress) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  var updateHostContainer = void 0;
  var updateHostComponent = void 0;
  var updateHostText = void 0;
  if (mutation) {
    if (enableMutatingReconciler) {
      // Mutation mode
      updateHostContainer = function (workInProgress) {
        // Noop
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // TODO: Type this specific to this type of component.
        workInProgress.updateQueue = updatePayload;
        // If the update payload indicates that there is a change or if there
        // is a new ref we mark this as an update. All the work is done in commitWork.
        if (updatePayload) {
          markUpdate(workInProgress);
        }
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        // If the text differs, mark it as an update. All the work in done in commitWork.
        if (oldText !== newText) {
          markUpdate(workInProgress);
        }
      };
    } else {
      invariant(false, 'Mutating reconciler is disabled.');
    }
  } else if (persistence) {
    if (enablePersistentReconciler) {
      // Persistent host tree mode
      var cloneInstance = persistence.cloneInstance,
          createContainerChildSet = persistence.createContainerChildSet,
          appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,
          finalizeContainerChildren = persistence.finalizeContainerChildren;

      // An unfortunate fork of appendAllChildren because we have two different parent types.

      var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {
        // We only have the top Fiber that was created but we need recurse down its
        // children to find all the terminal nodes.
        var node = workInProgress.child;
        while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
            appendChildToContainerChildSet(containerChildSet, node.stateNode);
          } else if (node.tag === HostPortal) {
            // If we have a portal child, then we don't want to traverse
            // down its children. Instead, we'll get insertions from each child in
            // the portal directly.
          } else if (node.child !== null) {
            node.child['return'] = node;
            node = node.child;
            continue;
          }
          if (node === workInProgress) {
            return;
          }
          while (node.sibling === null) {
            if (node['return'] === null || node['return'] === workInProgress) {
              return;
            }
            node = node['return'];
          }
          node.sibling['return'] = node['return'];
          node = node.sibling;
        }
      };
      updateHostContainer = function (workInProgress) {
        var portalOrRoot = workInProgress.stateNode;
        var childrenUnchanged = workInProgress.firstEffect === null;
        if (childrenUnchanged) {
          // No changes, just reuse the existing instance.
        } else {
          var container = portalOrRoot.containerInfo;
          var newChildSet = createContainerChildSet(container);
          if (finalizeContainerChildren(container, newChildSet)) {
            markUpdate(workInProgress);
          }
          portalOrRoot.pendingChildren = newChildSet;
          // If children might have changed, we have to add them all to the set.
          appendAllChildrenToContainer(newChildSet, workInProgress);
          // Schedule an update on the container to swap out the container.
          markUpdate(workInProgress);
        }
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // If there are no effects associated with this node, then none of our children had any updates.
        // This guarantees that we can reuse all of them.
        var childrenUnchanged = workInProgress.firstEffect === null;
        var currentInstance = current.stateNode;
        if (childrenUnchanged && updatePayload === null) {
          // No changes, just reuse the existing instance.
          // Note that this might release a previous clone.
          workInProgress.stateNode = currentInstance;
        } else {
          var recyclableInstance = workInProgress.stateNode;
          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);
          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {
            markUpdate(workInProgress);
          }
          workInProgress.stateNode = newInstance;
          if (childrenUnchanged) {
            // If there are no other effects in this tree, we need to flag this node as having one.
            // Even though we're not going to use it for anything.
            // Otherwise parents won't know that there are new children to propagate upwards.
            markUpdate(workInProgress);
          } else {
            // If children might have changed, we have to add them all to the set.
            appendAllChildren(newInstance, workInProgress);
          }
        }
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        if (oldText !== newText) {
          // If the text content differs, we'll create a new text instance for it.
          var rootContainerInstance = getRootHostContainer();
          var currentHostContext = getHostContext();
          workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);
          // We'll have to mark it as having an effect, even though we won't use the effect for anything.
          // This lets the parents know that at least one of their children has changed.
          markUpdate(workInProgress);
        }
      };
    } else {
      invariant(false, 'Persistent reconciler is disabled.');
    }
  } else {
    if (enableNoopReconciler) {
      // No host operations
      updateHostContainer = function (workInProgress) {
        // Noop
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // Noop
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        // Noop
      };
    } else {
      invariant(false, 'Noop reconciler is disabled.');
    }
  }

  function completeWork(current, workInProgress, renderExpirationTime) {
    // Get the latest props.
    var newProps = workInProgress.pendingProps;
    if (newProps === null) {
      newProps = workInProgress.memoizedProps;
    } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {
      // Reset the pending props, unless this was a down-prioritization.
      workInProgress.pendingProps = null;
    }

    switch (workInProgress.tag) {
      case FunctionalComponent:
        return null;
      case ClassComponent:
        {
          // We are leaving this subtree, so pop context if any.
          popContextProvider(workInProgress);
          return null;
        }
      case HostRoot:
        {
          popHostContainer(workInProgress);
          popTopLevelContextObject(workInProgress);
          var fiberRoot = workInProgress.stateNode;
          if (fiberRoot.pendingContext) {
            fiberRoot.context = fiberRoot.pendingContext;
            fiberRoot.pendingContext = null;
          }

          if (current === null || current.child === null) {
            // If we hydrated, pop so that we can delete any remaining children
            // that weren't hydrated.
            popHydrationState(workInProgress);
            // This resets the hacky state to fix isMounted before committing.
            // TODO: Delete this when we delete isMounted and findDOMNode.
            workInProgress.effectTag &= ~Placement;
          }
          updateHostContainer(workInProgress);
          return null;
        }
      case HostComponent:
        {
          popHostContext(workInProgress);
          var rootContainerInstance = getRootHostContainer();
          var type = workInProgress.type;
          if (current !== null && workInProgress.stateNode != null) {
            // If we have an alternate, that means this is an update and we need to
            // schedule a side-effect to do the updates.
            var oldProps = current.memoizedProps;
            // If we get updated because one of our children updated, we don't
            // have newProps so we'll have to reuse them.
            // TODO: Split the update API as separate for the props vs. children.
            // Even better would be if children weren't special cased at all tho.
            var instance = workInProgress.stateNode;
            var currentHostContext = getHostContext();
            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);

            updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);

            if (current.ref !== workInProgress.ref) {
              markRef(workInProgress);
            }
          } else {
            if (!newProps) {
              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
              // This can happen when we abort work.
              return null;
            }

            var _currentHostContext = getHostContext();
            // TODO: Move createInstance to beginWork and keep it on a context
            // "stack" as the parent. Then append children as we go in beginWork
            // or completeWork depending on we want to add then top->down or
            // bottom->up. Top->down is faster in IE11.
            var wasHydrated = popHydrationState(workInProgress);
            if (wasHydrated) {
              // TODO: Move this and createInstance step into the beginPhase
              // to consolidate.
              if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {
                // If changes to the hydrated node needs to be applied at the
                // commit-phase we mark this as such.
                markUpdate(workInProgress);
              }
            } else {
              var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);

              appendAllChildren(_instance, workInProgress);

              // Certain renderers require commit-time effects for initial mount.
              // (eg DOM renderer supports auto-focus for certain elements).
              // Make sure such renderers get scheduled for later work.
              if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {
                markUpdate(workInProgress);
              }
              workInProgress.stateNode = _instance;
            }

            if (workInProgress.ref !== null) {
              // If there is a ref on a host node we need to schedule a callback
              markRef(workInProgress);
            }
          }
          return null;
        }
      case HostText:
        {
          var newText = newProps;
          if (current && workInProgress.stateNode != null) {
            var oldText = current.memoizedProps;
            // If we have an alternate, that means this is an update and we need
            // to schedule a side-effect to do the updates.
            updateHostText(current, workInProgress, oldText, newText);
          } else {
            if (typeof newText !== 'string') {
              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
              // This can happen when we abort work.
              return null;
            }
            var _rootContainerInstance = getRootHostContainer();
            var _currentHostContext2 = getHostContext();
            var _wasHydrated = popHydrationState(workInProgress);
            if (_wasHydrated) {
              if (prepareToHydrateHostTextInstance(workInProgress)) {
                markUpdate(workInProgress);
              }
            } else {
              workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);
            }
          }
          return null;
        }
      case CallComponent:
        return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);
      case CallHandlerPhase:
        // Reset the tag to now be a first phase call.
        workInProgress.tag = CallComponent;
        return null;
      case ReturnComponent:
        // Does nothing.
        return null;
      case Fragment:
        return null;
      case HostPortal:
        popHostContainer(workInProgress);
        updateHostContainer(workInProgress);
        return null;
      // Error cases
      case IndeterminateComponent:
        invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');
      // eslint-disable-next-line no-fallthrough
      default:
        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  return {
    completeWork: completeWork
  };
};

var invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;
var hasCaughtError$1 = ReactErrorUtils.hasCaughtError;
var clearCaughtError$1 = ReactErrorUtils.clearCaughtError;


var ReactFiberCommitWork = function (config, captureError) {
  var getPublicInstance = config.getPublicInstance,
      mutation = config.mutation,
      persistence = config.persistence;


  var callComponentWillUnmountWithTimer = function (current, instance) {
    startPhaseTimer(current, 'componentWillUnmount');
    instance.props = current.memoizedProps;
    instance.state = current.memoizedState;
    instance.componentWillUnmount();
    stopPhaseTimer();
  };

  // Capture errors so they don't interrupt unmounting.
  function safelyCallComponentWillUnmount(current, instance) {
    {
      invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);
      if (hasCaughtError$1()) {
        var unmountError = clearCaughtError$1();
        captureError(current, unmountError);
      }
    }
  }

  function safelyDetachRef(current) {
    var ref = current.ref;
    if (ref !== null) {
      {
        invokeGuardedCallback$2(null, ref, null, null);
        if (hasCaughtError$1()) {
          var refError = clearCaughtError$1();
          captureError(current, refError);
        }
      }
    }
  }

  function commitLifeCycles(current, finishedWork) {
    switch (finishedWork.tag) {
      case ClassComponent:
        {
          var instance = finishedWork.stateNode;
          if (finishedWork.effectTag & Update) {
            if (current === null) {
              startPhaseTimer(finishedWork, 'componentDidMount');
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              instance.componentDidMount();
              stopPhaseTimer();
            } else {
              var prevProps = current.memoizedProps;
              var prevState = current.memoizedState;
              startPhaseTimer(finishedWork, 'componentDidUpdate');
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              instance.componentDidUpdate(prevProps, prevState);
              stopPhaseTimer();
            }
          }
          var updateQueue = finishedWork.updateQueue;
          if (updateQueue !== null) {
            commitCallbacks(updateQueue, instance);
          }
          return;
        }
      case HostRoot:
        {
          var _updateQueue = finishedWork.updateQueue;
          if (_updateQueue !== null) {
            var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;
            commitCallbacks(_updateQueue, _instance);
          }
          return;
        }
      case HostComponent:
        {
          var _instance2 = finishedWork.stateNode;

          // Renderers may schedule work to be done after host components are mounted
          // (eg DOM renderer may schedule auto-focus for inputs and form controls).
          // These effects should only be committed when components are first mounted,
          // aka when there is no current/alternate.
          if (current === null && finishedWork.effectTag & Update) {
            var type = finishedWork.type;
            var props = finishedWork.memoizedProps;
            commitMount(_instance2, type, props, finishedWork);
          }

          return;
        }
      case HostText:
        {
          // We have no life-cycles associated with text.
          return;
        }
      case HostPortal:
        {
          // We have no life-cycles associated with portals.
          return;
        }
      default:
        {
          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
        }
    }
  }

  function commitAttachRef(finishedWork) {
    var ref = finishedWork.ref;
    if (ref !== null) {
      var instance = finishedWork.stateNode;
      switch (finishedWork.tag) {
        case HostComponent:
          ref(getPublicInstance(instance));
          break;
        default:
          ref(instance);
      }
    }
  }

  function commitDetachRef(current) {
    var currentRef = current.ref;
    if (currentRef !== null) {
      currentRef(null);
    }
  }

  // User-originating errors (lifecycles and refs) should not interrupt
  // deletion, so don't let them throw. Host-originating errors should
  // interrupt deletion, so it's okay
  function commitUnmount(current) {
    if (typeof onCommitUnmount === 'function') {
      onCommitUnmount(current);
    }

    switch (current.tag) {
      case ClassComponent:
        {
          safelyDetachRef(current);
          var instance = current.stateNode;
          if (typeof instance.componentWillUnmount === 'function') {
            safelyCallComponentWillUnmount(current, instance);
          }
          return;
        }
      case HostComponent:
        {
          safelyDetachRef(current);
          return;
        }
      case CallComponent:
        {
          commitNestedUnmounts(current.stateNode);
          return;
        }
      case HostPortal:
        {
          // TODO: this is recursive.
          // We are also not using this parent because
          // the portal will get pushed immediately.
          if (enableMutatingReconciler && mutation) {
            unmountHostComponents(current);
          } else if (enablePersistentReconciler && persistence) {
            emptyPortalContainer(current);
          }
          return;
        }
    }
  }

  function commitNestedUnmounts(root) {
    // While we're inside a removed host node we don't want to call
    // removeChild on the inner nodes because they're removed by the top
    // call anyway. We also want to call componentWillUnmount on all
    // composites before this host node is removed from the tree. Therefore
    var node = root;
    while (true) {
      commitUnmount(node);
      // Visit children because they may contain more composite or host nodes.
      // Skip portals because commitUnmount() currently visits them recursively.
      if (node.child !== null && (
      // If we use mutation we drill down into portals using commitUnmount above.
      // If we don't use mutation we drill down into portals here instead.
      !mutation || node.tag !== HostPortal)) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === root) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === root) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function detachFiber(current) {
    // Cut off the return pointers to disconnect it from the tree. Ideally, we
    // should clear the child pointer of the parent alternate to let this
    // get GC:ed but we don't know which for sure which parent is the current
    // one so we'll settle for GC:ing the subtree of this child. This child
    // itself will be GC:ed when the parent updates the next time.
    current['return'] = null;
    current.child = null;
    if (current.alternate) {
      current.alternate.child = null;
      current.alternate['return'] = null;
    }
  }

  if (!mutation) {
    var commitContainer = void 0;
    if (persistence) {
      var replaceContainerChildren = persistence.replaceContainerChildren,
          createContainerChildSet = persistence.createContainerChildSet;

      var emptyPortalContainer = function (current) {
        var portal = current.stateNode;
        var containerInfo = portal.containerInfo;

        var emptyChildSet = createContainerChildSet(containerInfo);
        replaceContainerChildren(containerInfo, emptyChildSet);
      };
      commitContainer = function (finishedWork) {
        switch (finishedWork.tag) {
          case ClassComponent:
            {
              return;
            }
          case HostComponent:
            {
              return;
            }
          case HostText:
            {
              return;
            }
          case HostRoot:
          case HostPortal:
            {
              var portalOrRoot = finishedWork.stateNode;
              var containerInfo = portalOrRoot.containerInfo,
                  _pendingChildren = portalOrRoot.pendingChildren;

              replaceContainerChildren(containerInfo, _pendingChildren);
              return;
            }
          default:
            {
              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
            }
        }
      };
    } else {
      commitContainer = function (finishedWork) {
        // Noop
      };
    }
    if (enablePersistentReconciler || enableNoopReconciler) {
      return {
        commitResetTextContent: function (finishedWork) {},
        commitPlacement: function (finishedWork) {},
        commitDeletion: function (current) {
          // Detach refs and call componentWillUnmount() on the whole subtree.
          commitNestedUnmounts(current);
          detachFiber(current);
        },
        commitWork: function (current, finishedWork) {
          commitContainer(finishedWork);
        },

        commitLifeCycles: commitLifeCycles,
        commitAttachRef: commitAttachRef,
        commitDetachRef: commitDetachRef
      };
    } else if (persistence) {
      invariant(false, 'Persistent reconciler is disabled.');
    } else {
      invariant(false, 'Noop reconciler is disabled.');
    }
  }
  var commitMount = mutation.commitMount,
      commitUpdate = mutation.commitUpdate,
      resetTextContent = mutation.resetTextContent,
      commitTextUpdate = mutation.commitTextUpdate,
      appendChild = mutation.appendChild,
      appendChildToContainer = mutation.appendChildToContainer,
      insertBefore = mutation.insertBefore,
      insertInContainerBefore = mutation.insertInContainerBefore,
      removeChild = mutation.removeChild,
      removeChildFromContainer = mutation.removeChildFromContainer;


  function getHostParentFiber(fiber) {
    var parent = fiber['return'];
    while (parent !== null) {
      if (isHostParent(parent)) {
        return parent;
      }
      parent = parent['return'];
    }
    invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');
  }

  function isHostParent(fiber) {
    return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
  }

  function getHostSibling(fiber) {
    // We're going to search forward into the tree until we find a sibling host
    // node. Unfortunately, if multiple insertions are done in a row we have to
    // search past them. This leads to exponential search for the next sibling.
    var node = fiber;
    siblings: while (true) {
      // If we didn't find anything, let's try the next sibling.
      while (node.sibling === null) {
        if (node['return'] === null || isHostParent(node['return'])) {
          // If we pop out of the root or hit the parent the fiber we are the
          // last sibling.
          return null;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
      while (node.tag !== HostComponent && node.tag !== HostText) {
        // If it is not host node and, we might have a host node inside it.
        // Try to search down until we find one.
        if (node.effectTag & Placement) {
          // If we don't have a child, try the siblings instead.
          continue siblings;
        }
        // If we don't have a child, try the siblings instead.
        // We also skip portals because they are not part of this host tree.
        if (node.child === null || node.tag === HostPortal) {
          continue siblings;
        } else {
          node.child['return'] = node;
          node = node.child;
        }
      }
      // Check if this host node is stable or about to be placed.
      if (!(node.effectTag & Placement)) {
        // Found it!
        return node.stateNode;
      }
    }
  }

  function commitPlacement(finishedWork) {
    // Recursively insert all host nodes into the parent.
    var parentFiber = getHostParentFiber(finishedWork);
    var parent = void 0;
    var isContainer = void 0;
    switch (parentFiber.tag) {
      case HostComponent:
        parent = parentFiber.stateNode;
        isContainer = false;
        break;
      case HostRoot:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = true;
        break;
      case HostPortal:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = true;
        break;
      default:
        invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');
    }
    if (parentFiber.effectTag & ContentReset) {
      // Reset the text content of the parent before doing any insertions
      resetTextContent(parent);
      // Clear ContentReset from the effect tag
      parentFiber.effectTag &= ~ContentReset;
    }

    var before = getHostSibling(finishedWork);
    // We only have the top Fiber that was inserted but we need recurse down its
    // children to find all the terminal nodes.
    var node = finishedWork;
    while (true) {
      if (node.tag === HostComponent || node.tag === HostText) {
        if (before) {
          if (isContainer) {
            insertInContainerBefore(parent, node.stateNode, before);
          } else {
            insertBefore(parent, node.stateNode, before);
          }
        } else {
          if (isContainer) {
            appendChildToContainer(parent, node.stateNode);
          } else {
            appendChild(parent, node.stateNode);
          }
        }
      } else if (node.tag === HostPortal) {
        // If the insertion itself is a portal, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === finishedWork) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === finishedWork) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function unmountHostComponents(current) {
    // We only have the top Fiber that was inserted but we need recurse down its
    var node = current;

    // Each iteration, currentParent is populated with node's host parent if not
    // currentParentIsValid.
    var currentParentIsValid = false;
    var currentParent = void 0;
    var currentParentIsContainer = void 0;

    while (true) {
      if (!currentParentIsValid) {
        var parent = node['return'];
        findParent: while (true) {
          !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          switch (parent.tag) {
            case HostComponent:
              currentParent = parent.stateNode;
              currentParentIsContainer = false;
              break findParent;
            case HostRoot:
              currentParent = parent.stateNode.containerInfo;
              currentParentIsContainer = true;
              break findParent;
            case HostPortal:
              currentParent = parent.stateNode.containerInfo;
              currentParentIsContainer = true;
              break findParent;
          }
          parent = parent['return'];
        }
        currentParentIsValid = true;
      }

      if (node.tag === HostComponent || node.tag === HostText) {
        commitNestedUnmounts(node);
        // After all the children have unmounted, it is now safe to remove the
        // node from the tree.
        if (currentParentIsContainer) {
          removeChildFromContainer(currentParent, node.stateNode);
        } else {
          removeChild(currentParent, node.stateNode);
        }
        // Don't visit children because we already visited them.
      } else if (node.tag === HostPortal) {
        // When we go into a portal, it becomes the parent to remove from.
        // We will reassign it back when we pop the portal on the way up.
        currentParent = node.stateNode.containerInfo;
        // Visit children because portals might contain host components.
        if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
      } else {
        commitUnmount(node);
        // Visit children because we may find more host components below.
        if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
      }
      if (node === current) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === current) {
          return;
        }
        node = node['return'];
        if (node.tag === HostPortal) {
          // When we go out of the portal, we need to restore the parent.
          // Since we don't keep a stack of them, we will search for it.
          currentParentIsValid = false;
        }
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function commitDeletion(current) {
    // Recursively delete all host nodes from the parent.
    // Detach refs and call componentWillUnmount() on the whole subtree.
    unmountHostComponents(current);
    detachFiber(current);
  }

  function commitWork(current, finishedWork) {
    switch (finishedWork.tag) {
      case ClassComponent:
        {
          return;
        }
      case HostComponent:
        {
          var instance = finishedWork.stateNode;
          if (instance != null) {
            // Commit the work prepared earlier.
            var newProps = finishedWork.memoizedProps;
            // For hydration we reuse the update path but we treat the oldProps
            // as the newProps. The updatePayload will contain the real change in
            // this case.
            var oldProps = current !== null ? current.memoizedProps : newProps;
            var type = finishedWork.type;
            // TODO: Type the updateQueue to be specific to host components.
            var updatePayload = finishedWork.updateQueue;
            finishedWork.updateQueue = null;
            if (updatePayload !== null) {
              commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
            }
          }
          return;
        }
      case HostText:
        {
          !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          var textInstance = finishedWork.stateNode;
          var newText = finishedWork.memoizedProps;
          // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.
          var oldText = current !== null ? current.memoizedProps : newText;
          commitTextUpdate(textInstance, oldText, newText);
          return;
        }
      case HostRoot:
        {
          return;
        }
      default:
        {
          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
        }
    }
  }

  function commitResetTextContent(current) {
    resetTextContent(current.stateNode);
  }

  if (enableMutatingReconciler) {
    return {
      commitResetTextContent: commitResetTextContent,
      commitPlacement: commitPlacement,
      commitDeletion: commitDeletion,
      commitWork: commitWork,
      commitLifeCycles: commitLifeCycles,
      commitAttachRef: commitAttachRef,
      commitDetachRef: commitDetachRef
    };
  } else {
    invariant(false, 'Mutating reconciler is disabled.');
  }
};

var NO_CONTEXT = {};

var ReactFiberHostContext = function (config) {
  var getChildHostContext = config.getChildHostContext,
      getRootHostContext = config.getRootHostContext;


  var contextStackCursor = createCursor(NO_CONTEXT);
  var contextFiberStackCursor = createCursor(NO_CONTEXT);
  var rootInstanceStackCursor = createCursor(NO_CONTEXT);

  function requiredContext(c) {
    !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    return c;
  }

  function getRootHostContainer() {
    var rootInstance = requiredContext(rootInstanceStackCursor.current);
    return rootInstance;
  }

  function pushHostContainer(fiber, nextRootInstance) {
    // Push current root instance onto the stack;
    // This allows us to reset root when portals are popped.
    push(rootInstanceStackCursor, nextRootInstance, fiber);

    var nextRootContext = getRootHostContext(nextRootInstance);

    // Track the context and the Fiber that provided it.
    // This enables us to pop only Fibers that provide unique contexts.
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor, nextRootContext, fiber);
  }

  function popHostContainer(fiber) {
    pop(contextStackCursor, fiber);
    pop(contextFiberStackCursor, fiber);
    pop(rootInstanceStackCursor, fiber);
  }

  function getHostContext() {
    var context = requiredContext(contextStackCursor.current);
    return context;
  }

  function pushHostContext(fiber) {
    var rootInstance = requiredContext(rootInstanceStackCursor.current);
    var context = requiredContext(contextStackCursor.current);
    var nextContext = getChildHostContext(context, fiber.type, rootInstance);

    // Don't push this Fiber's context unless it's unique.
    if (context === nextContext) {
      return;
    }

    // Track the context and the Fiber that provided it.
    // This enables us to pop only Fibers that provide unique contexts.
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor, nextContext, fiber);
  }

  function popHostContext(fiber) {
    // Do not pop unless this Fiber provided the current context.
    // pushHostContext() only pushes Fibers that provide unique contexts.
    if (contextFiberStackCursor.current !== fiber) {
      return;
    }

    pop(contextStackCursor, fiber);
    pop(contextFiberStackCursor, fiber);
  }

  function resetHostContainer() {
    contextStackCursor.current = NO_CONTEXT;
    rootInstanceStackCursor.current = NO_CONTEXT;
  }

  return {
    getHostContext: getHostContext,
    getRootHostContainer: getRootHostContainer,
    popHostContainer: popHostContainer,
    popHostContext: popHostContext,
    pushHostContainer: pushHostContainer,
    pushHostContext: pushHostContext,
    resetHostContainer: resetHostContainer
  };
};

var ReactFiberHydrationContext = function (config) {
  var shouldSetTextContent = config.shouldSetTextContent,
      hydration = config.hydration;

  // If this doesn't have hydration mode.

  if (!hydration) {
    return {
      enterHydrationState: function () {
        return false;
      },
      resetHydrationState: function () {},
      tryToClaimNextHydratableInstance: function () {},
      prepareToHydrateHostInstance: function () {
        invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
      },
      prepareToHydrateHostTextInstance: function () {
        invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
      },
      popHydrationState: function (fiber) {
        return false;
      }
    };
  }

  var canHydrateInstance = hydration.canHydrateInstance,
      canHydrateTextInstance = hydration.canHydrateTextInstance,
      getNextHydratableSibling = hydration.getNextHydratableSibling,
      getFirstHydratableChild = hydration.getFirstHydratableChild,
      hydrateInstance = hydration.hydrateInstance,
      hydrateTextInstance = hydration.hydrateTextInstance,
      didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,
      didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,
      didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,
      didNotHydrateInstance = hydration.didNotHydrateInstance,
      didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,
      didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,
      didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,
      didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;

  // The deepest Fiber on the stack involved in a hydration context.
  // This may have been an insertion or a hydration.

  var hydrationParentFiber = null;
  var nextHydratableInstance = null;
  var isHydrating = false;

  function enterHydrationState(fiber) {
    var parentInstance = fiber.stateNode.containerInfo;
    nextHydratableInstance = getFirstHydratableChild(parentInstance);
    hydrationParentFiber = fiber;
    isHydrating = true;
    return true;
  }

  function deleteHydratableInstance(returnFiber, instance) {
    {
      switch (returnFiber.tag) {
        case HostRoot:
          didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
          break;
        case HostComponent:
          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
          break;
      }
    }

    var childToDelete = createFiberFromHostInstanceForDeletion();
    childToDelete.stateNode = instance;
    childToDelete['return'] = returnFiber;
    childToDelete.effectTag = Deletion;

    // This might seem like it belongs on progressedFirstDeletion. However,
    // these children are not part of the reconciliation list of children.
    // Even if we abort and rereconcile the children, that will try to hydrate
    // again and the nodes are still in the host tree so these will be
    // recreated.
    if (returnFiber.lastEffect !== null) {
      returnFiber.lastEffect.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
  }

  function insertNonHydratedInstance(returnFiber, fiber) {
    fiber.effectTag |= Placement;
    {
      switch (returnFiber.tag) {
        case HostRoot:
          {
            var parentContainer = returnFiber.stateNode.containerInfo;
            switch (fiber.tag) {
              case HostComponent:
                var type = fiber.type;
                var props = fiber.pendingProps;
                didNotFindHydratableContainerInstance(parentContainer, type, props);
                break;
              case HostText:
                var text = fiber.pendingProps;
                didNotFindHydratableContainerTextInstance(parentContainer, text);
                break;
            }
            break;
          }
        case HostComponent:
          {
            var parentType = returnFiber.type;
            var parentProps = returnFiber.memoizedProps;
            var parentInstance = returnFiber.stateNode;
            switch (fiber.tag) {
              case HostComponent:
                var _type = fiber.type;
                var _props = fiber.pendingProps;
                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                break;
              case HostText:
                var _text = fiber.pendingProps;
                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                break;
            }
            break;
          }
        default:
          return;
      }
    }
  }

  function tryHydrate(fiber, nextInstance) {
    switch (fiber.tag) {
      case HostComponent:
        {
          var type = fiber.type;
          var props = fiber.pendingProps;
          var instance = canHydrateInstance(nextInstance, type, props);
          if (instance !== null) {
            fiber.stateNode = instance;
            return true;
          }
          return false;
        }
      case HostText:
        {
          var text = fiber.pendingProps;
          var textInstance = canHydrateTextInstance(nextInstance, text);
          if (textInstance !== null) {
            fiber.stateNode = textInstance;
            return true;
          }
          return false;
        }
      default:
        return false;
    }
  }

  function tryToClaimNextHydratableInstance(fiber) {
    if (!isHydrating) {
      return;
    }
    var nextInstance = nextHydratableInstance;
    if (!nextInstance) {
      // Nothing to hydrate. Make it an insertion.
      insertNonHydratedInstance(hydrationParentFiber, fiber);
      isHydrating = false;
      hydrationParentFiber = fiber;
      return;
    }
    if (!tryHydrate(fiber, nextInstance)) {
      // If we can't hydrate this instance let's try the next one.
      // We use this as a heuristic. It's based on intuition and not data so it
      // might be flawed or unnecessary.
      nextInstance = getNextHydratableSibling(nextInstance);
      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
        // Nothing to hydrate. Make it an insertion.
        insertNonHydratedInstance(hydrationParentFiber, fiber);
        isHydrating = false;
        hydrationParentFiber = fiber;
        return;
      }
      // We matched the next one, we'll now assume that the first one was
      // superfluous and we'll delete it. Since we can't eagerly delete it
      // we'll have to schedule a deletion. To do that, this node needs a dummy
      // fiber associated with it.
      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);
    }
    hydrationParentFiber = fiber;
    nextHydratableInstance = getFirstHydratableChild(nextInstance);
  }

  function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
    var instance = fiber.stateNode;
    var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
    // TODO: Type this specific to this type of component.
    fiber.updateQueue = updatePayload;
    // If the update payload indicates that there is a change or if there
    // is a new ref we mark this as an update.
    if (updatePayload !== null) {
      return true;
    }
    return false;
  }

  function prepareToHydrateHostTextInstance(fiber) {
    var textInstance = fiber.stateNode;
    var textContent = fiber.memoizedProps;
    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
    {
      if (shouldUpdate) {
        // We assume that prepareToHydrateHostTextInstance is called in a context where the
        // hydration parent is the parent host component of this host text.
        var returnFiber = hydrationParentFiber;
        if (returnFiber !== null) {
          switch (returnFiber.tag) {
            case HostRoot:
              {
                var parentContainer = returnFiber.stateNode.containerInfo;
                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                break;
              }
            case HostComponent:
              {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                break;
              }
          }
        }
      }
    }
    return shouldUpdate;
  }

  function popToNextHostParent(fiber) {
    var parent = fiber['return'];
    while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {
      parent = parent['return'];
    }
    hydrationParentFiber = parent;
  }

  function popHydrationState(fiber) {
    if (fiber !== hydrationParentFiber) {
      // We're deeper than the current hydration context, inside an inserted
      // tree.
      return false;
    }
    if (!isHydrating) {
      // If we're not currently hydrating but we're in a hydration context, then
      // we were an insertion and now need to pop up reenter hydration of our
      // siblings.
      popToNextHostParent(fiber);
      isHydrating = true;
      return false;
    }

    var type = fiber.type;

    // If we have any remaining hydratable nodes, we need to delete them now.
    // We only do this deeper than head and body since they tend to have random
    // other nodes in them. We also ignore components with pure text content in
    // side of them.
    // TODO: Better heuristic.
    if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
      var nextInstance = nextHydratableInstance;
      while (nextInstance) {
        deleteHydratableInstance(fiber, nextInstance);
        nextInstance = getNextHydratableSibling(nextInstance);
      }
    }

    popToNextHostParent(fiber);
    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
    return true;
  }

  function resetHydrationState() {
    hydrationParentFiber = null;
    nextHydratableInstance = null;
    isHydrating = false;
  }

  return {
    enterHydrationState: enterHydrationState,
    resetHydrationState: resetHydrationState,
    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,
    prepareToHydrateHostInstance: prepareToHydrateHostInstance,
    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,
    popHydrationState: popHydrationState
  };
};

// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation = {
  debugTool: null
};

var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;

var defaultShowDialog = function (capturedError) {
  return true;
};

var showDialog = defaultShowDialog;

function logCapturedError(capturedError) {
  var logError = showDialog(capturedError);

  // Allow injected showDialog() to prevent default console.error logging.
  // This enables renderers like ReactNative to better manage redbox behavior.
  if (logError === false) {
    return;
  }

  var error = capturedError.error;
  var suppressLogging = error && error.suppressReactErrorLogging;
  if (suppressLogging) {
    return;
  }

  {
    var componentName = capturedError.componentName,
        componentStack = capturedError.componentStack,
        errorBoundaryName = capturedError.errorBoundaryName,
        errorBoundaryFound = capturedError.errorBoundaryFound,
        willRetry = capturedError.willRetry;


    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';

    var errorBoundaryMessage = void 0;
    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
    if (errorBoundaryFound && errorBoundaryName) {
      if (willRetry) {
        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');
      } else {
        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';
      }
    } else {
      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';
    }
    var combinedMessage = '' + componentNameMessage + componentStack + '\n\n' + ('' + errorBoundaryMessage);

    // In development, we provide our own message with just the component stack.
    // We don't include the original error message and JS stack because the browser
    // has already printed it. Even if the application swallows the error, it is still
    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
    console.error(combinedMessage);
  }
}

var invokeGuardedCallback$1 = ReactErrorUtils.invokeGuardedCallback;
var hasCaughtError = ReactErrorUtils.hasCaughtError;
var clearCaughtError = ReactErrorUtils.clearCaughtError;


{
  var didWarnAboutStateTransition = false;
  var didWarnSetStateChildContext = false;
  var didWarnStateUpdateForUnmountedComponent = {};

  var warnAboutUpdateOnUnmounted = function (fiber) {
    var componentName = getComponentName(fiber) || 'ReactClass';
    if (didWarnStateUpdateForUnmountedComponent[componentName]) {
      return;
    }
    warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease ' + 'check the code for the %s component.', componentName);
    didWarnStateUpdateForUnmountedComponent[componentName] = true;
  };

  var warnAboutInvalidUpdates = function (instance) {
    switch (ReactDebugCurrentFiber.phase) {
      case 'getChildContext':
        if (didWarnSetStateChildContext) {
          return;
        }
        warning(false, 'setState(...): Cannot call setState() inside getChildContext()');
        didWarnSetStateChildContext = true;
        break;
      case 'render':
        if (didWarnAboutStateTransition) {
          return;
        }
        warning(false, 'Cannot update during an existing state transition (such as within ' + "`render` or another component's constructor). Render methods should " + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');
        didWarnAboutStateTransition = true;
        break;
    }
  };
}

var ReactFiberScheduler = function (config) {
  var hostContext = ReactFiberHostContext(config);
  var hydrationContext = ReactFiberHydrationContext(config);
  var popHostContainer = hostContext.popHostContainer,
      popHostContext = hostContext.popHostContext,
      resetHostContainer = hostContext.resetHostContainer;

  var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),
      beginWork = _ReactFiberBeginWork.beginWork,
      beginFailedWork = _ReactFiberBeginWork.beginFailedWork;

  var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),
      completeWork = _ReactFiberCompleteWo.completeWork;

  var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),
      commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,
      commitPlacement = _ReactFiberCommitWork.commitPlacement,
      commitDeletion = _ReactFiberCommitWork.commitDeletion,
      commitWork = _ReactFiberCommitWork.commitWork,
      commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,
      commitAttachRef = _ReactFiberCommitWork.commitAttachRef,
      commitDetachRef = _ReactFiberCommitWork.commitDetachRef;

  var now = config.now,
      scheduleDeferredCallback = config.scheduleDeferredCallback,
      cancelDeferredCallback = config.cancelDeferredCallback,
      useSyncScheduling = config.useSyncScheduling,
      prepareForCommit = config.prepareForCommit,
      resetAfterCommit = config.resetAfterCommit;

  // Represents the current time in ms.

  var startTime = now();
  var mostRecentCurrentTime = msToExpirationTime(0);

  // Represents the expiration time that incoming updates should use. (If this
  // is NoWork, use the default strategy: async updates in async mode, sync
  // updates in sync mode.)
  var expirationContext = NoWork;

  var isWorking = false;

  // The next work in progress fiber that we're currently working on.
  var nextUnitOfWork = null;
  var nextRoot = null;
  // The time at which we're currently rendering work.
  var nextRenderExpirationTime = NoWork;

  // The next fiber with an effect that we're currently committing.
  var nextEffect = null;

  // Keep track of which fibers have captured an error that need to be handled.
  // Work is removed from this collection after componentDidCatch is called.
  var capturedErrors = null;
  // Keep track of which fibers have failed during the current batch of work.
  // This is a different set than capturedErrors, because it is not reset until
  // the end of the batch. This is needed to propagate errors correctly if a
  // subtree fails more than once.
  var failedBoundaries = null;
  // Error boundaries that captured an error during the current commit.
  var commitPhaseBoundaries = null;
  var firstUncaughtError = null;
  var didFatal = false;

  var isCommitting = false;
  var isUnmounting = false;

  // Used for performance tracking.
  var interruptedBy = null;

  function resetContextStack() {
    // Reset the stack
    reset$1();
    // Reset the cursors
    resetContext();
    resetHostContainer();
  }

  function commitAllHostEffects() {
    while (nextEffect !== null) {
      {
        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);
      }
      recordEffect();

      var effectTag = nextEffect.effectTag;
      if (effectTag & ContentReset) {
        commitResetTextContent(nextEffect);
      }

      if (effectTag & Ref) {
        var current = nextEffect.alternate;
        if (current !== null) {
          commitDetachRef(current);
        }
      }

      // The following switch statement is only concerned about placement,
      // updates, and deletions. To avoid needing to add a case for every
      // possible bitmap value, we remove the secondary effects from the
      // effect tag and switch on that value.
      var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);
      switch (primaryEffectTag) {
        case Placement:
          {
            commitPlacement(nextEffect);
            // Clear the "placement" from effect tag so that we know that this is inserted, before
            // any life-cycles like componentDidMount gets called.
            // TODO: findDOMNode doesn't rely on this any more but isMounted
            // does and isMounted is deprecated anyway so we should be able
            // to kill this.
            nextEffect.effectTag &= ~Placement;
            break;
          }
        case PlacementAndUpdate:
          {
            // Placement
            commitPlacement(nextEffect);
            // Clear the "placement" from effect tag so that we know that this is inserted, before
            // any life-cycles like componentDidMount gets called.
            nextEffect.effectTag &= ~Placement;

            // Update
            var _current = nextEffect.alternate;
            commitWork(_current, nextEffect);
            break;
          }
        case Update:
          {
            var _current2 = nextEffect.alternate;
            commitWork(_current2, nextEffect);
            break;
          }
        case Deletion:
          {
            isUnmounting = true;
            commitDeletion(nextEffect);
            isUnmounting = false;
            break;
          }
      }
      nextEffect = nextEffect.nextEffect;
    }

    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
  }

  function commitAllLifeCycles() {
    while (nextEffect !== null) {
      var effectTag = nextEffect.effectTag;

      if (effectTag & (Update | Callback)) {
        recordEffect();
        var current = nextEffect.alternate;
        commitLifeCycles(current, nextEffect);
      }

      if (effectTag & Ref) {
        recordEffect();
        commitAttachRef(nextEffect);
      }

      if (effectTag & Err) {
        recordEffect();
        commitErrorHandling(nextEffect);
      }

      var next = nextEffect.nextEffect;
      // Ensure that we clean these up so that we don't accidentally keep them.
      // I'm not actually sure this matters because we can't reset firstEffect
      // and lastEffect since they're on every node, not just the effectful
      // ones. So we have to clean everything as we reuse nodes anyway.
      nextEffect.nextEffect = null;
      // Ensure that we reset the effectTag here so that we can rely on effect
      // tags to reason about the current life-cycle.
      nextEffect = next;
    }
  }

  function commitRoot(finishedWork) {
    // We keep track of this so that captureError can collect any boundaries
    // that capture an error during the commit phase. The reason these aren't
    // local to this function is because errors that occur during cWU are
    // captured elsewhere, to prevent the unmount from being interrupted.
    isWorking = true;
    isCommitting = true;
    startCommitTimer();

    var root = finishedWork.stateNode;
    !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    root.isReadyForCommit = false;

    // Reset this to null before calling lifecycles
    ReactCurrentOwner.current = null;

    var firstEffect = void 0;
    if (finishedWork.effectTag > PerformedWork) {
      // A fiber's effect list consists only of its children, not itself. So if
      // the root has an effect, we need to add it to the end of the list. The
      // resulting list is the set that would belong to the root's parent, if
      // it had one; that is, all the effects in the tree including the root.
      if (finishedWork.lastEffect !== null) {
        finishedWork.lastEffect.nextEffect = finishedWork;
        firstEffect = finishedWork.firstEffect;
      } else {
        firstEffect = finishedWork;
      }
    } else {
      // There is no effect on the root.
      firstEffect = finishedWork.firstEffect;
    }

    prepareForCommit();

    // Commit all the side-effects within a tree. We'll do this in two passes.
    // The first pass performs all the host insertions, updates, deletions and
    // ref unmounts.
    nextEffect = firstEffect;
    startCommitHostEffectsTimer();
    while (nextEffect !== null) {
      var didError = false;
      var _error = void 0;
      {
        invokeGuardedCallback$1(null, commitAllHostEffects, null);
        if (hasCaughtError()) {
          didError = true;
          _error = clearCaughtError();
        }
      }
      if (didError) {
        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        captureError(nextEffect, _error);
        // Clean-up
        if (nextEffect !== null) {
          nextEffect = nextEffect.nextEffect;
        }
      }
    }
    stopCommitHostEffectsTimer();

    resetAfterCommit();

    // The work-in-progress tree is now the current tree. This must come after
    // the first pass of the commit phase, so that the previous tree is still
    // current during componentWillUnmount, but before the second pass, so that
    // the finished work is current during componentDidMount/Update.
    root.current = finishedWork;

    // In the second pass we'll perform all life-cycles and ref callbacks.
    // Life-cycles happen as a separate pass so that all placements, updates,
    // and deletions in the entire tree have already been invoked.
    // This pass also triggers any renderer-specific initial effects.
    nextEffect = firstEffect;
    startCommitLifeCyclesTimer();
    while (nextEffect !== null) {
      var _didError = false;
      var _error2 = void 0;
      {
        invokeGuardedCallback$1(null, commitAllLifeCycles, null);
        if (hasCaughtError()) {
          _didError = true;
          _error2 = clearCaughtError();
        }
      }
      if (_didError) {
        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        captureError(nextEffect, _error2);
        if (nextEffect !== null) {
          nextEffect = nextEffect.nextEffect;
        }
      }
    }

    isCommitting = false;
    isWorking = false;
    stopCommitLifeCyclesTimer();
    stopCommitTimer();
    if (typeof onCommitRoot === 'function') {
      onCommitRoot(finishedWork.stateNode);
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
    }

    // If we caught any errors during this commit, schedule their boundaries
    // to update.
    if (commitPhaseBoundaries) {
      commitPhaseBoundaries.forEach(scheduleErrorRecovery);
      commitPhaseBoundaries = null;
    }

    if (firstUncaughtError !== null) {
      var _error3 = firstUncaughtError;
      firstUncaughtError = null;
      onUncaughtError(_error3);
    }

    var remainingTime = root.current.expirationTime;

    if (remainingTime === NoWork) {
      capturedErrors = null;
      failedBoundaries = null;
    }

    return remainingTime;
  }

  function resetExpirationTime(workInProgress, renderTime) {
    if (renderTime !== Never && workInProgress.expirationTime === Never) {
      // The children of this component are hidden. Don't bubble their
      // expiration times.
      return;
    }

    // Check for pending updates.
    var newExpirationTime = getUpdateExpirationTime(workInProgress);

    // TODO: Calls need to visit stateNode

    // Bubble up the earliest expiration time.
    var child = workInProgress.child;
    while (child !== null) {
      if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {
        newExpirationTime = child.expirationTime;
      }
      child = child.sibling;
    }
    workInProgress.expirationTime = newExpirationTime;
  }

  function completeUnitOfWork(workInProgress) {
    while (true) {
      // The current, flushed, state of this fiber is the alternate.
      // Ideally nothing should rely on this, but relying on it here
      // means that we don't need an additional field on the work in
      // progress.
      var current = workInProgress.alternate;
      {
        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
      }
      var next = completeWork(current, workInProgress, nextRenderExpirationTime);
      {
        ReactDebugCurrentFiber.resetCurrentFiber();
      }

      var returnFiber = workInProgress['return'];
      var siblingFiber = workInProgress.sibling;

      resetExpirationTime(workInProgress, nextRenderExpirationTime);

      if (next !== null) {
        stopWorkTimer(workInProgress);
        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
        }
        // If completing this work spawned new work, do that next. We'll come
        // back here again.
        return next;
      }

      if (returnFiber !== null) {
        // Append all the effects of the subtree and this fiber onto the effect
        // list of the parent. The completion order of the children affects the
        // side-effect order.
        if (returnFiber.firstEffect === null) {
          returnFiber.firstEffect = workInProgress.firstEffect;
        }
        if (workInProgress.lastEffect !== null) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
          }
          returnFiber.lastEffect = workInProgress.lastEffect;
        }

        // If this fiber had side-effects, we append it AFTER the children's
        // side-effects. We can perform certain side-effects earlier if
        // needed, by doing multiple passes over the effect list. We don't want
        // to schedule our own side-effect on our own list because if end up
        // reusing children we'll schedule this effect onto itself since we're
        // at the end.
        var effectTag = workInProgress.effectTag;
        // Skip both NoWork and PerformedWork tags when creating the effect list.
        // PerformedWork effect is read by React DevTools but shouldn't be committed.
        if (effectTag > PerformedWork) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress;
          } else {
            returnFiber.firstEffect = workInProgress;
          }
          returnFiber.lastEffect = workInProgress;
        }
      }

      stopWorkTimer(workInProgress);
      if (true && ReactFiberInstrumentation_1.debugTool) {
        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
      }

      if (siblingFiber !== null) {
        // If there is more work to do in this returnFiber, do that next.
        return siblingFiber;
      } else if (returnFiber !== null) {
        // If there's no more work in this returnFiber. Complete the returnFiber.
        workInProgress = returnFiber;
        continue;
      } else {
        // We've reached the root.
        var root = workInProgress.stateNode;
        root.isReadyForCommit = true;
        return null;
      }
    }

    // Without this explicit null return Flow complains of invalid return type
    // TODO Remove the above while(true) loop
    // eslint-disable-next-line no-unreachable
    return null;
  }

  function performUnitOfWork(workInProgress) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    var current = workInProgress.alternate;

    // See if beginning this work spawns more work.
    startWorkTimer(workInProgress);
    {
      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
    }

    var next = beginWork(current, workInProgress, nextRenderExpirationTime);
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
    }

    if (next === null) {
      // If this doesn't spawn new work, complete the current work.
      next = completeUnitOfWork(workInProgress);
    }

    ReactCurrentOwner.current = null;

    return next;
  }

  function performFailedUnitOfWork(workInProgress) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    var current = workInProgress.alternate;

    // See if beginning this work spawns more work.
    startWorkTimer(workInProgress);
    {
      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
    }
    var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
    }

    if (next === null) {
      // If this doesn't spawn new work, complete the current work.
      next = completeUnitOfWork(workInProgress);
    }

    ReactCurrentOwner.current = null;

    return next;
  }

  function workLoop(expirationTime) {
    if (capturedErrors !== null) {
      // If there are unhandled errors, switch to the slow work loop.
      // TODO: How to avoid this check in the fast path? Maybe the renderer
      // could keep track of which roots have unhandled errors and call a
      // forked version of renderRoot.
      slowWorkLoopThatChecksForFailedWork(expirationTime);
      return;
    }
    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
      return;
    }

    if (nextRenderExpirationTime <= mostRecentCurrentTime) {
      // Flush all expired work.
      while (nextUnitOfWork !== null) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
    } else {
      // Flush asynchronous work until the deadline runs out of time.
      while (nextUnitOfWork !== null && !shouldYield()) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
    }
  }

  function slowWorkLoopThatChecksForFailedWork(expirationTime) {
    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
      return;
    }

    if (nextRenderExpirationTime <= mostRecentCurrentTime) {
      // Flush all expired work.
      while (nextUnitOfWork !== null) {
        if (hasCapturedError(nextUnitOfWork)) {
          // Use a forked version of performUnitOfWork
          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
        } else {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    } else {
      // Flush asynchronous work until the deadline runs out of time.
      while (nextUnitOfWork !== null && !shouldYield()) {
        if (hasCapturedError(nextUnitOfWork)) {
          // Use a forked version of performUnitOfWork
          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
        } else {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    }
  }

  function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {
    // We're going to restart the error boundary that captured the error.
    // Conceptually, we're unwinding the stack. We need to unwind the
    // context stack, too.
    unwindContexts(failedWork, boundary);

    // Restart the error boundary using a forked version of
    // performUnitOfWork that deletes the boundary's children. The entire
    // failed subree will be unmounted. During the commit phase, a special
    // lifecycle method is called on the error boundary, which triggers
    // a re-render.
    nextUnitOfWork = performFailedUnitOfWork(boundary);

    // Continue working.
    workLoop(expirationTime);
  }

  function renderRoot(root, expirationTime) {
    !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    isWorking = true;

    // We're about to mutate the work-in-progress tree. If the root was pending
    // commit, it no longer is: we'll need to complete it again.
    root.isReadyForCommit = false;

    // Check if we're starting from a fresh stack, or if we're resuming from
    // previously yielded work.
    if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {
      // Reset the stack and start working from the root.
      resetContextStack();
      nextRoot = root;
      nextRenderExpirationTime = expirationTime;
      nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);
    }

    startWorkLoopTimer(nextUnitOfWork);

    var didError = false;
    var error = null;
    {
      invokeGuardedCallback$1(null, workLoop, null, expirationTime);
      if (hasCaughtError()) {
        didError = true;
        error = clearCaughtError();
      }
    }

    // An error was thrown during the render phase.
    while (didError) {
      if (didFatal) {
        // This was a fatal error. Don't attempt to recover from it.
        firstUncaughtError = error;
        break;
      }

      var failedWork = nextUnitOfWork;
      if (failedWork === null) {
        // An error was thrown but there's no current unit of work. This can
        // happen during the commit phase if there's a bug in the renderer.
        didFatal = true;
        continue;
      }

      // "Capture" the error by finding the nearest boundary. If there is no
      // error boundary, we use the root.
      var boundary = captureError(failedWork, error);
      !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;

      if (didFatal) {
        // The error we just captured was a fatal error. This happens
        // when the error propagates to the root more than once.
        continue;
      }

      didError = false;
      error = null;
      {
        invokeGuardedCallback$1(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);
        if (hasCaughtError()) {
          didError = true;
          error = clearCaughtError();
          continue;
        }
      }
      // We're finished working. Exit the error loop.
      break;
    }

    var uncaughtError = firstUncaughtError;

    // We're done performing work. Time to clean up.
    stopWorkLoopTimer(interruptedBy);
    interruptedBy = null;
    isWorking = false;
    didFatal = false;
    firstUncaughtError = null;

    if (uncaughtError !== null) {
      onUncaughtError(uncaughtError);
    }

    return root.isReadyForCommit ? root.current.alternate : null;
  }

  // Returns the boundary that captured the error, or null if the error is ignored
  function captureError(failedWork, error) {
    // It is no longer valid because we exited the user code.
    ReactCurrentOwner.current = null;
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }

    // Search for the nearest error boundary.
    var boundary = null;

    // Passed to logCapturedError()
    var errorBoundaryFound = false;
    var willRetry = false;
    var errorBoundaryName = null;

    // Host containers are a special case. If the failed work itself is a host
    // container, then it acts as its own boundary. In all other cases, we
    // ignore the work itself and only search through the parents.
    if (failedWork.tag === HostRoot) {
      boundary = failedWork;

      if (isFailedBoundary(failedWork)) {
        // If this root already failed, there must have been an error when
        // attempting to unmount it. This is a worst-case scenario and
        // should only be possible if there's a bug in the renderer.
        didFatal = true;
      }
    } else {
      var node = failedWork['return'];
      while (node !== null && boundary === null) {
        if (node.tag === ClassComponent) {
          var instance = node.stateNode;
          if (typeof instance.componentDidCatch === 'function') {
            errorBoundaryFound = true;
            errorBoundaryName = getComponentName(node);

            // Found an error boundary!
            boundary = node;
            willRetry = true;
          }
        } else if (node.tag === HostRoot) {
          // Treat the root like a no-op error boundary
          boundary = node;
        }

        if (isFailedBoundary(node)) {
          // This boundary is already in a failed state.

          // If we're currently unmounting, that means this error was
          // thrown while unmounting a failed subtree. We should ignore
          // the error.
          if (isUnmounting) {
            return null;
          }

          // If we're in the commit phase, we should check to see if
          // this boundary already captured an error during this commit.
          // This case exists because multiple errors can be thrown during
          // a single commit without interruption.
          if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {
            // If so, we should ignore this error.
            return null;
          }

          // The error should propagate to the next boundary -— we keep looking.
          boundary = null;
          willRetry = false;
        }

        node = node['return'];
      }
    }

    if (boundary !== null) {
      // Add to the collection of failed boundaries. This lets us know that
      // subsequent errors in this subtree should propagate to the next boundary.
      if (failedBoundaries === null) {
        failedBoundaries = new Set();
      }
      failedBoundaries.add(boundary);

      // This method is unsafe outside of the begin and complete phases.
      // We might be in the commit phase when an error is captured.
      // The risk is that the return path from this Fiber may not be accurate.
      // That risk is acceptable given the benefit of providing users more context.
      var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);
      var _componentName = getComponentName(failedWork);

      // Add to the collection of captured errors. This is stored as a global
      // map of errors and their component stack location keyed by the boundaries
      // that capture them. We mostly use this Map as a Set; it's a Map only to
      // avoid adding a field to Fiber to store the error.
      if (capturedErrors === null) {
        capturedErrors = new Map();
      }

      var capturedError = {
        componentName: _componentName,
        componentStack: _componentStack,
        error: error,
        errorBoundary: errorBoundaryFound ? boundary.stateNode : null,
        errorBoundaryFound: errorBoundaryFound,
        errorBoundaryName: errorBoundaryName,
        willRetry: willRetry
      };

      capturedErrors.set(boundary, capturedError);

      try {
        logCapturedError(capturedError);
      } catch (e) {
        // Prevent cycle if logCapturedError() throws.
        // A cycle may still occur if logCapturedError renders a component that throws.
        var suppressLogging = e && e.suppressReactErrorLogging;
        if (!suppressLogging) {
          console.error(e);
        }
      }

      // If we're in the commit phase, defer scheduling an update on the
      // boundary until after the commit is complete
      if (isCommitting) {
        if (commitPhaseBoundaries === null) {
          commitPhaseBoundaries = new Set();
        }
        commitPhaseBoundaries.add(boundary);
      } else {
        // Otherwise, schedule an update now.
        // TODO: Is this actually necessary during the render phase? Is it
        // possible to unwind and continue rendering at the same priority,
        // without corrupting internal state?
        scheduleErrorRecovery(boundary);
      }
      return boundary;
    } else if (firstUncaughtError === null) {
      // If no boundary is found, we'll need to throw the error
      firstUncaughtError = error;
    }
    return null;
  }

  function hasCapturedError(fiber) {
    // TODO: capturedErrors should store the boundary instance, to avoid needing
    // to check the alternate.
    return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));
  }

  function isFailedBoundary(fiber) {
    // TODO: failedBoundaries should store the boundary instance, to avoid
    // needing to check the alternate.
    return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));
  }

  function commitErrorHandling(effectfulFiber) {
    var capturedError = void 0;
    if (capturedErrors !== null) {
      capturedError = capturedErrors.get(effectfulFiber);
      capturedErrors['delete'](effectfulFiber);
      if (capturedError == null) {
        if (effectfulFiber.alternate !== null) {
          effectfulFiber = effectfulFiber.alternate;
          capturedError = capturedErrors.get(effectfulFiber);
          capturedErrors['delete'](effectfulFiber);
        }
      }
    }

    !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    switch (effectfulFiber.tag) {
      case ClassComponent:
        var instance = effectfulFiber.stateNode;

        var info = {
          componentStack: capturedError.componentStack
        };

        // Allow the boundary to handle the error, usually by scheduling
        // an update to itself
        instance.componentDidCatch(capturedError.error, info);
        return;
      case HostRoot:
        if (firstUncaughtError === null) {
          firstUncaughtError = capturedError.error;
        }
        return;
      default:
        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  function unwindContexts(from, to) {
    var node = from;
    while (node !== null) {
      switch (node.tag) {
        case ClassComponent:
          popContextProvider(node);
          break;
        case HostComponent:
          popHostContext(node);
          break;
        case HostRoot:
          popHostContainer(node);
          break;
        case HostPortal:
          popHostContainer(node);
          break;
      }
      if (node === to || node.alternate === to) {
        stopFailedWorkTimer(node);
        break;
      } else {
        stopWorkTimer(node);
      }
      node = node['return'];
    }
  }

  function computeAsyncExpiration() {
    // Given the current clock time, returns an expiration time. We use rounding
    // to batch like updates together.
    // Should complete within ~1000ms. 1200ms max.
    var currentTime = recalculateCurrentTime();
    var expirationMs = 1000;
    var bucketSizeMs = 200;
    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);
  }

  function computeExpirationForFiber(fiber) {
    var expirationTime = void 0;
    if (expirationContext !== NoWork) {
      // An explicit expiration context was set;
      expirationTime = expirationContext;
    } else if (isWorking) {
      if (isCommitting) {
        // Updates that occur during the commit phase should have sync priority
        // by default.
        expirationTime = Sync;
      } else {
        // Updates during the render phase should expire at the same time as
        // the work that is being rendered.
        expirationTime = nextRenderExpirationTime;
      }
    } else {
      // No explicit expiration context was set, and we're not currently
      // performing work. Calculate a new expiration time.
      if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {
        // This is a sync update
        expirationTime = Sync;
      } else {
        // This is an async update
        expirationTime = computeAsyncExpiration();
      }
    }
    return expirationTime;
  }

  function scheduleWork(fiber, expirationTime) {
    return scheduleWorkImpl(fiber, expirationTime, false);
  }

  function checkRootNeedsClearing(root, fiber, expirationTime) {
    if (!isWorking && root === nextRoot && expirationTime < nextRenderExpirationTime) {
      // Restart the root from the top.
      if (nextUnitOfWork !== null) {
        // This is an interruption. (Used for performance tracking.)
        interruptedBy = fiber;
      }
      nextRoot = null;
      nextUnitOfWork = null;
      nextRenderExpirationTime = NoWork;
    }
  }

  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {
    recordScheduleUpdate();

    {
      if (!isErrorRecovery && fiber.tag === ClassComponent) {
        var instance = fiber.stateNode;
        warnAboutInvalidUpdates(instance);
      }
    }

    var node = fiber;
    while (node !== null) {
      // Walk the parent path to the root and update each node's
      // expiration time.
      if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {
        node.expirationTime = expirationTime;
      }
      if (node.alternate !== null) {
        if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {
          node.alternate.expirationTime = expirationTime;
        }
      }
      if (node['return'] === null) {
        if (node.tag === HostRoot) {
          var root = node.stateNode;

          checkRootNeedsClearing(root, fiber, expirationTime);
          requestWork(root, expirationTime);
          checkRootNeedsClearing(root, fiber, expirationTime);
        } else {
          {
            if (!isErrorRecovery && fiber.tag === ClassComponent) {
              warnAboutUpdateOnUnmounted(fiber);
            }
          }
          return;
        }
      }
      node = node['return'];
    }
  }

  function scheduleErrorRecovery(fiber) {
    scheduleWorkImpl(fiber, Sync, true);
  }

  function recalculateCurrentTime() {
    // Subtract initial time so it fits inside 32bits
    var ms = now() - startTime;
    mostRecentCurrentTime = msToExpirationTime(ms);
    return mostRecentCurrentTime;
  }

  function deferredUpdates(fn) {
    var previousExpirationContext = expirationContext;
    expirationContext = computeAsyncExpiration();
    try {
      return fn();
    } finally {
      expirationContext = previousExpirationContext;
    }
  }

  function syncUpdates(fn) {
    var previousExpirationContext = expirationContext;
    expirationContext = Sync;
    try {
      return fn();
    } finally {
      expirationContext = previousExpirationContext;
    }
  }

  // TODO: Everything below this is written as if it has been lifted to the
  // renderers. I'll do this in a follow-up.

  // Linked-list of roots
  var firstScheduledRoot = null;
  var lastScheduledRoot = null;

  var callbackExpirationTime = NoWork;
  var callbackID = -1;
  var isRendering = false;
  var nextFlushedRoot = null;
  var nextFlushedExpirationTime = NoWork;
  var deadlineDidExpire = false;
  var hasUnhandledError = false;
  var unhandledError = null;
  var deadline = null;

  var isBatchingUpdates = false;
  var isUnbatchingUpdates = false;

  // Use these to prevent an infinite loop of nested updates
  var NESTED_UPDATE_LIMIT = 1000;
  var nestedUpdateCount = 0;

  var timeHeuristicForUnitOfWork = 1;

  function scheduleCallbackWithExpiration(expirationTime) {
    if (callbackExpirationTime !== NoWork) {
      // A callback is already scheduled. Check its expiration time (timeout).
      if (expirationTime > callbackExpirationTime) {
        // Existing callback has sufficient timeout. Exit.
        return;
      } else {
        // Existing callback has insufficient timeout. Cancel and schedule a
        // new one.
        cancelDeferredCallback(callbackID);
      }
      // The request callback timer is already running. Don't start a new one.
    } else {
      startRequestCallbackTimer();
    }

    // Compute a timeout for the given expiration time.
    var currentMs = now() - startTime;
    var expirationMs = expirationTimeToMs(expirationTime);
    var timeout = expirationMs - currentMs;

    callbackExpirationTime = expirationTime;
    callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });
  }

  // requestWork is called by the scheduler whenever a root receives an update.
  // It's up to the renderer to call renderRoot at some point in the future.
  function requestWork(root, expirationTime) {
    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
      invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');
    }

    // Add the root to the schedule.
    // Check if this root is already part of the schedule.
    if (root.nextScheduledRoot === null) {
      // This root is not already scheduled. Add it.
      root.remainingExpirationTime = expirationTime;
      if (lastScheduledRoot === null) {
        firstScheduledRoot = lastScheduledRoot = root;
        root.nextScheduledRoot = root;
      } else {
        lastScheduledRoot.nextScheduledRoot = root;
        lastScheduledRoot = root;
        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
      }
    } else {
      // This root is already scheduled, but its priority may have increased.
      var remainingExpirationTime = root.remainingExpirationTime;
      if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {
        // Update the priority.
        root.remainingExpirationTime = expirationTime;
      }
    }

    if (isRendering) {
      // Prevent reentrancy. Remaining work will be scheduled at the end of
      // the currently rendering batch.
      return;
    }

    if (isBatchingUpdates) {
      // Flush work at the end of the batch.
      if (isUnbatchingUpdates) {
        // ...unless we're inside unbatchedUpdates, in which case we should
        // flush it now.
        nextFlushedRoot = root;
        nextFlushedExpirationTime = Sync;
        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
      }
      return;
    }

    // TODO: Get rid of Sync and use current time?
    if (expirationTime === Sync) {
      performWork(Sync, null);
    } else {
      scheduleCallbackWithExpiration(expirationTime);
    }
  }

  function findHighestPriorityRoot() {
    var highestPriorityWork = NoWork;
    var highestPriorityRoot = null;

    if (lastScheduledRoot !== null) {
      var previousScheduledRoot = lastScheduledRoot;
      var root = firstScheduledRoot;
      while (root !== null) {
        var remainingExpirationTime = root.remainingExpirationTime;
        if (remainingExpirationTime === NoWork) {
          // This root no longer has work. Remove it from the scheduler.

          // TODO: This check is redudant, but Flow is confused by the branch
          // below where we set lastScheduledRoot to null, even though we break
          // from the loop right after.
          !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          if (root === root.nextScheduledRoot) {
            // This is the only root in the list.
            root.nextScheduledRoot = null;
            firstScheduledRoot = lastScheduledRoot = null;
            break;
          } else if (root === firstScheduledRoot) {
            // This is the first root in the list.
            var next = root.nextScheduledRoot;
            firstScheduledRoot = next;
            lastScheduledRoot.nextScheduledRoot = next;
            root.nextScheduledRoot = null;
          } else if (root === lastScheduledRoot) {
            // This is the last root in the list.
            lastScheduledRoot = previousScheduledRoot;
            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
            root.nextScheduledRoot = null;
            break;
          } else {
            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
            root.nextScheduledRoot = null;
          }
          root = previousScheduledRoot.nextScheduledRoot;
        } else {
          if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {
            // Update the priority, if it's higher
            highestPriorityWork = remainingExpirationTime;
            highestPriorityRoot = root;
          }
          if (root === lastScheduledRoot) {
            break;
          }
          previousScheduledRoot = root;
          root = root.nextScheduledRoot;
        }
      }
    }

    // If the next root is the same as the previous root, this is a nested
    // update. To prevent an infinite loop, increment the nested update count.
    var previousFlushedRoot = nextFlushedRoot;
    if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {
      nestedUpdateCount++;
    } else {
      // Reset whenever we switch roots.
      nestedUpdateCount = 0;
    }
    nextFlushedRoot = highestPriorityRoot;
    nextFlushedExpirationTime = highestPriorityWork;
  }

  function performAsyncWork(dl) {
    performWork(NoWork, dl);
  }

  function performWork(minExpirationTime, dl) {
    deadline = dl;

    // Keep working on roots until there's no more work, or until the we reach
    // the deadline.
    findHighestPriorityRoot();

    if (enableUserTimingAPI && deadline !== null) {
      var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();
      stopRequestCallbackTimer(didExpire);
    }

    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
      // Find the next highest priority work.
      findHighestPriorityRoot();
    }

    // We're done flushing work. Either we ran out of time in this callback,
    // or there's no more work left with sufficient priority.

    // If we're inside a callback, set this to false since we just completed it.
    if (deadline !== null) {
      callbackExpirationTime = NoWork;
      callbackID = -1;
    }
    // If there's work left over, schedule a new callback.
    if (nextFlushedExpirationTime !== NoWork) {
      scheduleCallbackWithExpiration(nextFlushedExpirationTime);
    }

    // Clean-up.
    deadline = null;
    deadlineDidExpire = false;
    nestedUpdateCount = 0;

    if (hasUnhandledError) {
      var _error4 = unhandledError;
      unhandledError = null;
      hasUnhandledError = false;
      throw _error4;
    }
  }

  function performWorkOnRoot(root, expirationTime) {
    !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    isRendering = true;

    // Check if this is async work or sync/expired work.
    // TODO: Pass current time as argument to renderRoot, commitRoot
    if (expirationTime <= recalculateCurrentTime()) {
      // Flush sync work.
      var finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        // This root is already complete. We can commit it.
        root.finishedWork = null;
        root.remainingExpirationTime = commitRoot(finishedWork);
      } else {
        root.finishedWork = null;
        finishedWork = renderRoot(root, expirationTime);
        if (finishedWork !== null) {
          // We've completed the root. Commit it.
          root.remainingExpirationTime = commitRoot(finishedWork);
        }
      }
    } else {
      // Flush async work.
      var _finishedWork = root.finishedWork;
      if (_finishedWork !== null) {
        // This root is already complete. We can commit it.
        root.finishedWork = null;
        root.remainingExpirationTime = commitRoot(_finishedWork);
      } else {
        root.finishedWork = null;
        _finishedWork = renderRoot(root, expirationTime);
        if (_finishedWork !== null) {
          // We've completed the root. Check the deadline one more time
          // before committing.
          if (!shouldYield()) {
            // Still time left. Commit the root.
            root.remainingExpirationTime = commitRoot(_finishedWork);
          } else {
            // There's no time left. Mark this root as complete. We'll come
            // back and commit it later.
            root.finishedWork = _finishedWork;
          }
        }
      }
    }

    isRendering = false;
  }

  // When working on async work, the reconciler asks the renderer if it should
  // yield execution. For DOM, we implement this with requestIdleCallback.
  function shouldYield() {
    if (deadline === null) {
      return false;
    }
    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {
      // Disregard deadline.didTimeout. Only expired work should be flushed
      // during a timeout. This path is only hit for non-expired work.
      return false;
    }
    deadlineDidExpire = true;
    return true;
  }

  // TODO: Not happy about this hook. Conceptually, renderRoot should return a
  // tuple of (isReadyForCommit, didError, error)
  function onUncaughtError(error) {
    !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    // Unschedule this root so we don't work on it again until there's
    // another update.
    nextFlushedRoot.remainingExpirationTime = NoWork;
    if (!hasUnhandledError) {
      hasUnhandledError = true;
      unhandledError = error;
    }
  }

  // TODO: Batching should be implemented at the renderer level, not inside
  // the reconciler.
  function batchedUpdates(fn, a) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = true;
    try {
      return fn(a);
    } finally {
      isBatchingUpdates = previousIsBatchingUpdates;
      if (!isBatchingUpdates && !isRendering) {
        performWork(Sync, null);
      }
    }
  }

  // TODO: Batching should be implemented at the renderer level, not inside
  // the reconciler.
  function unbatchedUpdates(fn) {
    if (isBatchingUpdates && !isUnbatchingUpdates) {
      isUnbatchingUpdates = true;
      try {
        return fn();
      } finally {
        isUnbatchingUpdates = false;
      }
    }
    return fn();
  }

  // TODO: Batching should be implemented at the renderer level, not within
  // the reconciler.
  function flushSync(fn) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = true;
    try {
      return syncUpdates(fn);
    } finally {
      isBatchingUpdates = previousIsBatchingUpdates;
      !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;
      performWork(Sync, null);
    }
  }

  return {
    computeAsyncExpiration: computeAsyncExpiration,
    computeExpirationForFiber: computeExpirationForFiber,
    scheduleWork: scheduleWork,
    batchedUpdates: batchedUpdates,
    unbatchedUpdates: unbatchedUpdates,
    flushSync: flushSync,
    deferredUpdates: deferredUpdates
  };
};

{
  var didWarnAboutNestedUpdates = false;
}

// 0 is PROD, 1 is DEV.
// Might add PROFILE later.


function getContextForSubtree(parentComponent) {
  if (!parentComponent) {
    return emptyObject;
  }

  var fiber = get(parentComponent);
  var parentContext = findCurrentUnmaskedContext(fiber);
  return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;
}

var ReactFiberReconciler$1 = function (config) {
  var getPublicInstance = config.getPublicInstance;

  var _ReactFiberScheduler = ReactFiberScheduler(config),
      computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,
      computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,
      scheduleWork = _ReactFiberScheduler.scheduleWork,
      batchedUpdates = _ReactFiberScheduler.batchedUpdates,
      unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,
      flushSync = _ReactFiberScheduler.flushSync,
      deferredUpdates = _ReactFiberScheduler.deferredUpdates;

  function scheduleTopLevelUpdate(current, element, callback) {
    {
      if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {
        didWarnAboutNestedUpdates = true;
        warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');
      }
    }

    callback = callback === undefined ? null : callback;
    {
      warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);
    }

    var expirationTime = void 0;
    // Check if the top-level element is an async wrapper component. If so,
    // treat updates to the root as async. This is a bit weird but lets us
    // avoid a separate `renderAsync` API.
    if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {
      expirationTime = computeAsyncExpiration();
    } else {
      expirationTime = computeExpirationForFiber(current);
    }

    var update = {
      expirationTime: expirationTime,
      partialState: { element: element },
      callback: callback,
      isReplace: false,
      isForced: false,
      nextCallback: null,
      next: null
    };
    insertUpdateIntoFiber(current, update);
    scheduleWork(current, expirationTime);
  }

  function findHostInstance(fiber) {
    var hostFiber = findCurrentHostFiber(fiber);
    if (hostFiber === null) {
      return null;
    }
    return hostFiber.stateNode;
  }

  return {
    createContainer: function (containerInfo, hydrate) {
      return createFiberRoot(containerInfo, hydrate);
    },
    updateContainer: function (element, container, parentComponent, callback) {
      // TODO: If this is a nested container, this won't be the root.
      var current = container.current;

      {
        if (ReactFiberInstrumentation_1.debugTool) {
          if (current.alternate === null) {
            ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
          } else if (element === null) {
            ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
          } else {
            ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
          }
        }
      }

      var context = getContextForSubtree(parentComponent);
      if (container.context === null) {
        container.context = context;
      } else {
        container.pendingContext = context;
      }

      scheduleTopLevelUpdate(current, element, callback);
    },


    batchedUpdates: batchedUpdates,

    unbatchedUpdates: unbatchedUpdates,

    deferredUpdates: deferredUpdates,

    flushSync: flushSync,

    getPublicRootInstance: function (container) {
      var containerFiber = container.current;
      if (!containerFiber.child) {
        return null;
      }
      switch (containerFiber.child.tag) {
        case HostComponent:
          return getPublicInstance(containerFiber.child.stateNode);
        default:
          return containerFiber.child.stateNode;
      }
    },


    findHostInstance: findHostInstance,

    findHostInstanceWithNoPortals: function (fiber) {
      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
      if (hostFiber === null) {
        return null;
      }
      return hostFiber.stateNode;
    },
    injectIntoDevTools: function (devToolsConfig) {
      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;

      return injectInternals(_assign({}, devToolsConfig, {
        findHostInstanceByFiber: function (fiber) {
          return findHostInstance(fiber);
        },
        findFiberByHostInstance: function (instance) {
          if (!findFiberByHostInstance) {
            // Might not be implemented by the renderer.
            return null;
          }
          return findFiberByHostInstance(instance);
        }
      }));
    }
  };
};

var ReactFiberReconciler$2 = Object.freeze({
	default: ReactFiberReconciler$1
});

var ReactFiberReconciler$3 = ( ReactFiberReconciler$2 && ReactFiberReconciler$1 ) || ReactFiberReconciler$2;

// TODO: bundle Flow types with the package.



// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactReconciler = ReactFiberReconciler$3['default'] ? ReactFiberReconciler$3['default'] : ReactFiberReconciler$3;

function createPortal$1(children, containerInfo,
// TODO: figure out the API for cross-renderer implementation.
implementation) {
  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  return {
    // This tag allow us to uniquely identify this as a React Portal
    $$typeof: REACT_PORTAL_TYPE,
    key: key == null ? null : '' + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.2.0';

// a requestAnimationFrame, storing the time for the start of the frame, then
// scheduling a postMessage which gets scheduled after paint. Within the
// postMessage handler do as much work as possible until time + frame rate.
// By separating the idle call into a separate event tick we ensure that
// layout, paint and other browser work is counted against the available time.
// The frame rate is dynamically adjusted.

{
  if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== 'function') {
    warning(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');
  }
}

var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

var now = void 0;
if (hasNativePerformanceNow) {
  now = function () {
    return performance.now();
  };
} else {
  now = function () {
    return Date.now();
  };
}

// TODO: There's no way to cancel, because Fiber doesn't atm.
var rIC = void 0;
var cIC = void 0;

if (!ExecutionEnvironment.canUseDOM) {
  rIC = function (frameCallback) {
    return setTimeout(function () {
      frameCallback({
        timeRemaining: function () {
          return Infinity;
        }
      });
    });
  };
  cIC = function (timeoutID) {
    clearTimeout(timeoutID);
  };
} else if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {
  // Polyfill requestIdleCallback and cancelIdleCallback

  var scheduledRICCallback = null;
  var isIdleScheduled = false;
  var timeoutTime = -1;

  var isAnimationFrameScheduled = false;

  var frameDeadline = 0;
  // We start out assuming that we run at 30fps but then the heuristic tracking
  // will adjust this value to a faster fps if we get more frequent animation
  // frames.
  var previousFrameTime = 33;
  var activeFrameTime = 33;

  var frameDeadlineObject;
  if (hasNativePerformanceNow) {
    frameDeadlineObject = {
      didTimeout: false,
      timeRemaining: function () {
        // We assume that if we have a performance timer that the rAF callback
        // gets a performance timer value. Not sure if this is always true.
        var remaining = frameDeadline - performance.now();
        return remaining > 0 ? remaining : 0;
      }
    };
  } else {
    frameDeadlineObject = {
      didTimeout: false,
      timeRemaining: function () {
        // Fallback to Date.now()
        var remaining = frameDeadline - Date.now();
        return remaining > 0 ? remaining : 0;
      }
    };
  }

  // We use the postMessage trick to defer idle work until after the repaint.
  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);
  var idleTick = function (event) {
    if (event.source !== window || event.data !== messageKey) {
      return;
    }

    isIdleScheduled = false;

    var currentTime = now();
    if (frameDeadline - currentTime <= 0) {
      // There's no time left in this idle period. Check if the callback has
      // a timeout and whether it's been exceeded.
      if (timeoutTime !== -1 && timeoutTime <= currentTime) {
        // Exceeded the timeout. Invoke the callback even though there's no
        // time left.
        frameDeadlineObject.didTimeout = true;
      } else {
        // No timeout.
        if (!isAnimationFrameScheduled) {
          // Schedule another animation callback so we retry later.
          isAnimationFrameScheduled = true;
          requestAnimationFrame(animationTick);
        }
        // Exit without invoking the callback.
        return;
      }
    } else {
      // There's still time left in this idle period.
      frameDeadlineObject.didTimeout = false;
    }

    timeoutTime = -1;
    var callback = scheduledRICCallback;
    scheduledRICCallback = null;
    if (callback !== null) {
      callback(frameDeadlineObject);
    }
  };
  // Assumes that we have addEventListener in this environment. Might need
  // something better for old IE.
  window.addEventListener('message', idleTick, false);

  var animationTick = function (rafTime) {
    isAnimationFrameScheduled = false;
    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;
    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
      if (nextFrameTime < 8) {
        // Defensive coding. We don't support higher frame rates than 120hz.
        // If we get lower than that, it is probably a bug.
        nextFrameTime = 8;
      }
      // If one frame goes long, then the next one can be short to catch up.
      // If two frames are short in a row, then that's an indication that we
      // actually have a higher frame rate than what we're currently optimizing.
      // We adjust our heuristic dynamically accordingly. For example, if we're
      // running on 120hz display or 90hz VR display.
      // Take the max of the two in case one of them was an anomaly due to
      // missed frame deadlines.
      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;
    } else {
      previousFrameTime = nextFrameTime;
    }
    frameDeadline = rafTime + activeFrameTime;
    if (!isIdleScheduled) {
      isIdleScheduled = true;
      window.postMessage(messageKey, '*');
    }
  };

  rIC = function (callback, options) {
    // This assumes that we only schedule one callback at a time because that's
    // how Fiber uses it.
    scheduledRICCallback = callback;
    if (options != null && typeof options.timeout === 'number') {
      timeoutTime = now() + options.timeout;
    }
    if (!isAnimationFrameScheduled) {
      // If rAF didn't already schedule one, we need to schedule a frame.
      // TODO: If this rAF doesn't materialize because the browser throttles, we
      // might want to still have setTimeout trigger rIC as a backup to ensure
      // that we keep performing work.
      isAnimationFrameScheduled = true;
      requestAnimationFrame(animationTick);
    }
    return 0;
  };

  cIC = function () {
    scheduledRICCallback = null;
    isIdleScheduled = false;
    timeoutTime = -1;
  };
} else {
  rIC = window.requestIdleCallback;
  cIC = window.cancelIdleCallback;
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  {
    warning(false, 'Invalid attribute name: `%s`', attributeName);
  }
  return false;
}

// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */





/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */
function getValueForProperty(node, name, expected) {
  {
    var propertyInfo = getPropertyInfo(name);
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod || propertyInfo.mustUseProperty) {
        return node[propertyInfo.propertyName];
      } else {
        var attributeName = propertyInfo.attributeName;

        var stringValue = null;

        if (propertyInfo.hasOverloadedBooleanValue) {
          if (node.hasAttribute(attributeName)) {
            var value = node.getAttribute(attributeName);
            if (value === '') {
              return true;
            }
            if (shouldIgnoreValue(propertyInfo, expected)) {
              return value;
            }
            if (value === '' + expected) {
              return expected;
            }
            return value;
          }
        } else if (node.hasAttribute(attributeName)) {
          if (shouldIgnoreValue(propertyInfo, expected)) {
            // We had an attribute but shouldn't have had one, so read it
            // for the error message.
            return node.getAttribute(attributeName);
          }
          if (propertyInfo.hasBooleanValue) {
            // If this was a boolean, it doesn't matter what the value is
            // the fact that we have it is the same as the expected.
            return expected;
          }
          // Even if this property uses a namespace we use getAttribute
          // because we assume its namespaced name is the same as our config.
          // To use getAttributeNS we need the local name which we don't have
          // in our config atm.
          stringValue = node.getAttribute(attributeName);
        }

        if (shouldIgnoreValue(propertyInfo, expected)) {
          return stringValue === null ? expected : stringValue;
        } else if (stringValue === '' + expected) {
          return expected;
        } else {
          return stringValue;
        }
      }
    }
  }
}

/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */
function getValueForAttribute(node, name, expected) {
  {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (!node.hasAttribute(name)) {
      return expected === undefined ? undefined : null;
    }
    var value = node.getAttribute(name);
    if (value === '' + expected) {
      return expected;
    }
    return value;
  }
}

/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */
function setValueForProperty(node, name, value) {
  var propertyInfo = getPropertyInfo(name);

  if (propertyInfo && shouldSetAttribute(name, value)) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, value);
    } else if (shouldIgnoreValue(propertyInfo, value)) {
      deleteValueForProperty(node, name);
      return;
    } else if (propertyInfo.mustUseProperty) {
      // Contrary to `setAttribute`, object properties are properly
      // `toString`ed by IE8/9.
      node[propertyInfo.propertyName] = value;
    } else {
      var attributeName = propertyInfo.attributeName;
      var namespace = propertyInfo.attributeNamespace;
      // `setAttribute` with objects becomes only `[object]` in IE8/9,
      // ('' + value) makes it output the correct toString()-value.
      if (namespace) {
        node.setAttributeNS(namespace, attributeName, '' + value);
      } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        node.setAttribute(attributeName, '');
      } else {
        node.setAttribute(attributeName, '' + value);
      }
    }
  } else {
    setValueForAttribute(node, name, shouldSetAttribute(name, value) ? value : null);
    return;
  }

  {
    
  }
}

function setValueForAttribute(node, name, value) {
  if (!isAttributeNameSafe(name)) {
    return;
  }
  if (value == null) {
    node.removeAttribute(name);
  } else {
    node.setAttribute(name, '' + value);
  }

  {
    
  }
}

/**
 * Deletes an attributes from a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */
function deleteValueForAttribute(node, name) {
  node.removeAttribute(name);
}

/**
 * Deletes the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */
function deleteValueForProperty(node, name) {
  var propertyInfo = getPropertyInfo(name);
  if (propertyInfo) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, undefined);
    } else if (propertyInfo.mustUseProperty) {
      var propName = propertyInfo.propertyName;
      if (propertyInfo.hasBooleanValue) {
        node[propName] = false;
      } else {
        node[propName] = '';
      }
    } else {
      node.removeAttribute(propertyInfo.attributeName);
    }
  } else {
    node.removeAttribute(name);
  }
}

var ReactControlledValuePropTypes = {
  checkPropTypes: null
};

{
  var hasReadOnlyValue = {
    button: true,
    checkbox: true,
    image: true,
    hidden: true,
    radio: true,
    reset: true,
    submit: true
  };

  var propTypes = {
    value: function (props, propName, componentName) {
      if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    },
    checked: function (props, propName, componentName) {
      if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }
  };

  /**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */
  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {
    checkPropTypes(propTypes, props, 'prop', tagName, getStack);
  };
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$2 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$3 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */

function getHostProps(element, props) {
  var node = element;
  var value = props.value;
  var checked = props.checked;

  var hostProps = _assign({
    // Make sure we set .type before any other properties (setting .value
    // before .type means .value is lost in IE11 and below)
    type: undefined,
    // Make sure we set .step before .value (setting .value before .step
    // means .value is rounded on mount, based upon step precision)
    step: undefined,
    // Make sure we set .min & .max before .value (to ensure proper order
    // in corner cases such as min or max deriving from value, e.g. Issue #7170)
    min: undefined,
    max: undefined
  }, props, {
    defaultChecked: undefined,
    defaultValue: undefined,
    value: value != null ? value : node._wrapperState.initialValue,
    checked: checked != null ? checked : node._wrapperState.initialChecked
  });

  return hostProps;
}

function initWrapperState(element, props) {
  {
    ReactControlledValuePropTypes.checkPropTypes('input', props, getCurrentFiberStackAddendum$3);

    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
      warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);
      didWarnCheckedDefaultChecked = true;
    }
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);
      didWarnValueDefaultValue = true;
    }
  }

  var defaultValue = props.defaultValue;
  var node = element;
  node._wrapperState = {
    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
    initialValue: props.value != null ? props.value : defaultValue,
    controlled: isControlled(props)
  };
}

function updateChecked(element, props) {
  var node = element;
  var checked = props.checked;
  if (checked != null) {
    setValueForProperty(node, 'checked', checked);
  }
}

function updateWrapper(element, props) {
  var node = element;
  {
    var controlled = isControlled(props);

    if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
      warning(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());
      didWarnUncontrolledToControlled = true;
    }
    if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
      warning(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());
      didWarnControlledToUncontrolled = true;
    }
  }

  updateChecked(element, props);

  var value = props.value;
  if (value != null) {
    if (value === 0 && node.value === '') {
      node.value = '0';
      // Note: IE9 reports a number inputs as 'text', so check props instead.
    } else if (props.type === 'number') {
      // Simulate `input.valueAsNumber`. IE9 does not support it
      var valueAsNumber = parseFloat(node.value) || 0;

      if (
      // eslint-disable-next-line
      value != valueAsNumber ||
      // eslint-disable-next-line
      value == valueAsNumber && node.value != value) {
        // Cast `value` to a string to ensure the value is set correctly. While
        // browsers typically do this as necessary, jsdom doesn't.
        node.value = '' + value;
      }
    } else if (node.value !== '' + value) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      node.value = '' + value;
    }
  } else {
    if (props.value == null && props.defaultValue != null) {
      // In Chrome, assigning defaultValue to certain input types triggers input validation.
      // For number inputs, the display value loses trailing decimal points. For email inputs,
      // Chrome raises "The specified value <x> is not a valid email address".
      //
      // Here we check to see if the defaultValue has actually changed, avoiding these problems
      // when the user is inputting text
      //
      // https://github.com/facebook/react/issues/7253
      if (node.defaultValue !== '' + props.defaultValue) {
        node.defaultValue = '' + props.defaultValue;
      }
    }
    if (props.checked == null && props.defaultChecked != null) {
      node.defaultChecked = !!props.defaultChecked;
    }
  }
}

function postMountWrapper(element, props) {
  var node = element;

  // Detach value from defaultValue. We won't do anything if we're working on
  // submit or reset inputs as those values & defaultValues are linked. They
  // are not resetable nodes so this operation doesn't matter and actually
  // removes browser-default values (eg "Submit Query") when no value is
  // provided.

  switch (props.type) {
    case 'submit':
    case 'reset':
      break;
    case 'color':
    case 'date':
    case 'datetime':
    case 'datetime-local':
    case 'month':
    case 'time':
    case 'week':
      // This fixes the no-show issue on iOS Safari and Android Chrome:
      // https://github.com/facebook/react/issues/7233
      node.value = '';
      node.value = node.defaultValue;
      break;
    default:
      node.value = node.value;
      break;
  }

  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
  // this is needed to work around a chrome bug where setting defaultChecked
  // will sometimes influence the value of checked (even after detachment).
  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
  // We need to temporarily unset name to avoid disrupting radio button groups.
  var name = node.name;
  if (name !== '') {
    node.name = '';
  }
  node.defaultChecked = !node.defaultChecked;
  node.defaultChecked = !node.defaultChecked;
  if (name !== '') {
    node.name = name;
  }
}

function restoreControlledState$1(element, props) {
  var node = element;
  updateWrapper(node, props);
  updateNamedCousins(node, props);
}

function updateNamedCousins(rootNode, props) {
  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form. It might not even be in the
    // document. Let's just use the local `querySelectorAll` to ensure we don't
    // miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);
      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;

      // We need update the tracked value on the named cousin since the value
      // was changed but the input saw no event or value set
      updateValueIfChanged(otherNode);

      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      updateWrapper(otherNode, otherProps);
    }
  }
}

function flattenChildren(children) {
  var content = '';

  // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.
  // We can silently skip them because invalid DOM nesting warning
  // catches these cases in Fiber.
  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    if (typeof child === 'string' || typeof child === 'number') {
      content += child;
    }
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */

function validateProps(element, props) {
  // TODO (yungsters): Remove support for `selected` in <option>.
  {
    warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');
  }
}

function postMountWrapper$1(element, props) {
  // value="" should make a value attribute (#6219)
  if (props.value != null) {
    element.setAttribute('value', props.value);
  }
}

function getHostProps$1(element, props) {
  var hostProps = _assign({ children: undefined }, props);
  var content = flattenChildren(props.children);

  if (content) {
    hostProps.children = content;
  }

  return hostProps;
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$4 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;


{
  var didWarnValueDefaultValue$1 = false;
}

function getDeclarationErrorAddendum() {
  var ownerName = getCurrentFiberOwnerName$3();
  if (ownerName) {
    return '\n\nCheck the render method of `' + ownerName + '`.';
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 */
function checkSelectPropTypes(props) {
  ReactControlledValuePropTypes.checkPropTypes('select', props, getCurrentFiberStackAddendum$4);

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
    } else if (!props.multiple && isArray) {
      warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
    }
  }
}

function updateOptions(node, multiple, propValue, setDefaultSelected) {
  var options = node.options;

  if (multiple) {
    var selectedValues = propValue;
    var selectedValue = {};
    for (var i = 0; i < selectedValues.length; i++) {
      // Prefix to avoid chaos with special keys.
      selectedValue['$' + selectedValues[i]] = true;
    }
    for (var _i = 0; _i < options.length; _i++) {
      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);
      if (options[_i].selected !== selected) {
        options[_i].selected = selected;
      }
      if (selected && setDefaultSelected) {
        options[_i].defaultSelected = true;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    var _selectedValue = '' + propValue;
    var defaultSelected = null;
    for (var _i2 = 0; _i2 < options.length; _i2++) {
      if (options[_i2].value === _selectedValue) {
        options[_i2].selected = true;
        if (setDefaultSelected) {
          options[_i2].defaultSelected = true;
        }
        return;
      }
      if (defaultSelected === null && !options[_i2].disabled) {
        defaultSelected = options[_i2];
      }
    }
    if (defaultSelected !== null) {
      defaultSelected.selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */

function getHostProps$2(element, props) {
  return _assign({}, props, {
    value: undefined
  });
}

function initWrapperState$1(element, props) {
  var node = element;
  {
    checkSelectPropTypes(props);
  }

  var value = props.value;
  node._wrapperState = {
    initialValue: value != null ? value : props.defaultValue,
    wasMultiple: !!props.multiple
  };

  {
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
      warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValueDefaultValue$1 = true;
    }
  }
}

function postMountWrapper$2(element, props) {
  var node = element;
  node.multiple = !!props.multiple;
  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (props.defaultValue != null) {
    updateOptions(node, !!props.multiple, props.defaultValue, true);
  }
}

function postUpdateWrapper(element, props) {
  var node = element;
  // After the initial mount, we control selected-ness manually so don't pass
  // this value down
  node._wrapperState.initialValue = undefined;

  var wasMultiple = node._wrapperState.wasMultiple;
  node._wrapperState.wasMultiple = !!props.multiple;

  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (wasMultiple !== !!props.multiple) {
    // For simplicity, reapply `defaultValue` if `multiple` is toggled.
    if (props.defaultValue != null) {
      updateOptions(node, !!props.multiple, props.defaultValue, true);
    } else {
      // Revert the select back to its default unselected state.
      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
    }
  }
}

function restoreControlledState$2(element, props) {
  var node = element;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  }
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$5 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnValDefaultVal = false;

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */

function getHostProps$3(element, props) {
  var node = element;
  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;

  // Always set children to the same thing. In IE9, the selection range will
  // get reset if `textContent` is mutated.  We could add a check in setTextContent
  // to only set the value if/when the value differs from the node value (which would
  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
  // solution. The value can be a boolean or object so that's why it's forced
  // to be a string.
  var hostProps = _assign({}, props, {
    value: undefined,
    defaultValue: undefined,
    children: '' + node._wrapperState.initialValue
  });

  return hostProps;
}

function initWrapperState$2(element, props) {
  var node = element;
  {
    ReactControlledValuePropTypes.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$5);
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
      warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValDefaultVal = true;
    }
  }

  var initialValue = props.value;

  // Only bother fetching default value if we're going to use it
  if (initialValue == null) {
    var defaultValue = props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = props.children;
    if (children != null) {
      {
        warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
      }
      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;
      if (Array.isArray(children)) {
        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    initialValue = defaultValue;
  }

  node._wrapperState = {
    initialValue: '' + initialValue
  };
}

function updateWrapper$1(element, props) {
  var node = element;
  var value = props.value;
  if (value != null) {
    // Cast `value` to a string to ensure the value is set correctly. While
    // browsers typically do this as necessary, jsdom doesn't.
    var newValue = '' + value;

    // To avoid side effects (such as losing text selection), only set value if changed
    if (newValue !== node.value) {
      node.value = newValue;
    }
    if (props.defaultValue == null) {
      node.defaultValue = newValue;
    }
  }
  if (props.defaultValue != null) {
    node.defaultValue = props.defaultValue;
  }
}

function postMountWrapper$3(element, props) {
  var node = element;
  // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.
  var textContent = node.textContent;

  // Only set node.value if textContent is equal to the expected
  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
  // will populate textContent as well.
  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
  if (textContent === node._wrapperState.initialValue) {
    node.value = textContent;
  }
}

function restoreControlledState$3(element, props) {
  // DOM component is still mounted; update
  updateWrapper$1(element, props);
}

var HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';
var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

var Namespaces = {
  html: HTML_NAMESPACE$1,
  mathml: MATH_NAMESPACE,
  svg: SVG_NAMESPACE
};

// Assumes there is no parent namespace.
function getIntrinsicNamespace(type) {
  switch (type) {
    case 'svg':
      return SVG_NAMESPACE;
    case 'math':
      return MATH_NAMESPACE;
    default:
      return HTML_NAMESPACE$1;
  }
}

function getChildNamespace(parentNamespace, type) {
  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {
    // No (or default) parent namespace: potential entry point.
    return getIntrinsicNamespace(type);
  }
  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
    // We're leaving SVG.
    return HTML_NAMESPACE$1;
  }
  // By default, pass namespace below.
  return parentNamespace;
}

/* globals MSApp */

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */
var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer = void 0;

/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node

  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
}

var warnValidStyle = emptyFunction;

{
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;
  var warnedForInfinityValue = false;

  var warnHyphenatedStyleName = function (name, getStack) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), getStack());
  };

  var warnBadVendoredStyleName = function (name, getStack) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), getStack());
  };

  var warnStyleValueWithSemicolon = function (name, value, getStack) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    warning(false, "Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.%s', name, value.replace(badStyleValueWithSemicolonPattern, ''), getStack());
  };

  var warnStyleValueIsNaN = function (name, value, getStack) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, getStack());
  };

  var warnStyleValueIsInfinity = function (name, value, getStack) {
    if (warnedForInfinityValue) {
      return;
    }

    warnedForInfinityValue = true;
    warning(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, getStack());
  };

  warnValidStyle = function (name, value, getStack) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name, getStack);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name, getStack);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value, getStack);
    }

    if (typeof value === 'number') {
      if (isNaN(value)) {
        warnStyleValueIsNaN(name, value, getStack);
      } else if (!isFinite(value)) {
        warnStyleValueIsInfinity(name, value, getStack);
      }
    }
  };
}

var warnValidStyle$1 = warnValidStyle;

/**
 * Operations for dealing with CSS properties.
 */

/**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */
function createDangerousStringForStyles(styles) {
  {
    var serialized = '';
    var delimiter = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (styleValue != null) {
        var isCustomProperty = styleName.indexOf('--') === 0;
        serialized += delimiter + hyphenateStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);

        delimiter = ';';
      }
    }
    return serialized || null;
  }
}

/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */
function setValueForStyles(node, styles, getStack) {
  var style = node.style;
  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }
    var isCustomProperty = styleName.indexOf('--') === 0;
    {
      if (!isCustomProperty) {
        warnValidStyle$1(styleName, styles[styleName], getStack);
      }
    }
    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
    if (styleName === 'float') {
      styleName = 'cssFloat';
    }
    if (isCustomProperty) {
      style.setProperty(styleName, styleValue);
    } else {
      style[styleName] = styleValue;
    }
  }
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

var HTML$1 = '__html';

function assertValidProps(tag, props, getStack) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getStack()) : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;
  }
  {
    warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.%s', getStack());
  }
  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getStack()) : void 0;
}

function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return typeof props.is === 'string';
  }
  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this whitelist too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;
    default:
      return true;
  }
}

var ariaProperties = {
  'aria-current': 0, // state
  'aria-details': 0,
  'aria-disabled': 0, // state
  'aria-hidden': 0, // state
  'aria-invalid': 0, // state
  'aria-keyshortcuts': 0,
  'aria-label': 0,
  'aria-roledescription': 0,
  // Widget Attributes
  'aria-autocomplete': 0,
  'aria-checked': 0,
  'aria-expanded': 0,
  'aria-haspopup': 0,
  'aria-level': 0,
  'aria-modal': 0,
  'aria-multiline': 0,
  'aria-multiselectable': 0,
  'aria-orientation': 0,
  'aria-placeholder': 0,
  'aria-pressed': 0,
  'aria-readonly': 0,
  'aria-required': 0,
  'aria-selected': 0,
  'aria-sort': 0,
  'aria-valuemax': 0,
  'aria-valuemin': 0,
  'aria-valuenow': 0,
  'aria-valuetext': 0,
  // Live Region Attributes
  'aria-atomic': 0,
  'aria-busy': 0,
  'aria-live': 0,
  'aria-relevant': 0,
  // Drag-and-Drop Attributes
  'aria-dropeffect': 0,
  'aria-grabbed': 0,
  // Relationship Attributes
  'aria-activedescendant': 0,
  'aria-colcount': 0,
  'aria-colindex': 0,
  'aria-colspan': 0,
  'aria-controls': 0,
  'aria-describedby': 0,
  'aria-errormessage': 0,
  'aria-flowto': 0,
  'aria-labelledby': 0,
  'aria-owns': 0,
  'aria-posinset': 0,
  'aria-rowcount': 0,
  'aria-rowindex': 0,
  'aria-rowspan': 0,
  'aria-setsize': 0
};

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

var hasOwnProperty = Object.prototype.hasOwnProperty;

function getStackAddendum() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

function validateProperty(tagName, name) {
  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
    return true;
  }

  if (rARIACamel.test(name)) {
    var ariaName = 'aria-' + name.slice(4).toLowerCase();
    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (correctName == null) {
      warning(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== correctName) {
      warning(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      warning(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(type, props) {
  var invalidProps = [];

  for (var key in props) {
    var isValid = validateProperty(type, key);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());
  } else if (invalidProps.length > 1) {
    warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());
  }
}

function validateProperties(type, props) {
  if (isCustomComponent(type, props)) {
    return;
  }
  warnInvalidARIAProps(type, props);
}

var didWarnValueNull = false;

function getStackAddendum$1() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

function validateProperties$1(type, props) {
  if (type !== 'input' && type !== 'textarea' && type !== 'select') {
    return;
  }

  if (props != null && props.value === null && !didWarnValueNull) {
    didWarnValueNull = true;
    if (type === 'select' && props.multiple) {
      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.%s', type, getStackAddendum$1());
    } else {
      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1());
    }
  }
}

// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames = {
  // HTML
  accept: 'accept',
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  action: 'action',
  allowfullscreen: 'allowFullScreen',
  alt: 'alt',
  as: 'as',
  async: 'async',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  capture: 'capture',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  challenge: 'challenge',
  charset: 'charSet',
  checked: 'checked',
  children: 'children',
  cite: 'cite',
  'class': 'className',
  classid: 'classID',
  classname: 'className',
  cols: 'cols',
  colspan: 'colSpan',
  content: 'content',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controls: 'controls',
  controlslist: 'controlsList',
  coords: 'coords',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  data: 'data',
  datetime: 'dateTime',
  'default': 'default',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  defer: 'defer',
  dir: 'dir',
  disabled: 'disabled',
  download: 'download',
  draggable: 'draggable',
  enctype: 'encType',
  'for': 'htmlFor',
  form: 'form',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  headers: 'headers',
  height: 'height',
  hidden: 'hidden',
  high: 'high',
  href: 'href',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  icon: 'icon',
  id: 'id',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  integrity: 'integrity',
  is: 'is',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  kind: 'kind',
  label: 'label',
  lang: 'lang',
  list: 'list',
  loop: 'loop',
  low: 'low',
  manifest: 'manifest',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  max: 'max',
  maxlength: 'maxLength',
  media: 'media',
  mediagroup: 'mediaGroup',
  method: 'method',
  min: 'min',
  minlength: 'minLength',
  multiple: 'multiple',
  muted: 'muted',
  name: 'name',
  nonce: 'nonce',
  novalidate: 'noValidate',
  open: 'open',
  optimum: 'optimum',
  pattern: 'pattern',
  placeholder: 'placeholder',
  playsinline: 'playsInline',
  poster: 'poster',
  preload: 'preload',
  profile: 'profile',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rel: 'rel',
  required: 'required',
  reversed: 'reversed',
  role: 'role',
  rows: 'rows',
  rowspan: 'rowSpan',
  sandbox: 'sandbox',
  scope: 'scope',
  scoped: 'scoped',
  scrolling: 'scrolling',
  seamless: 'seamless',
  selected: 'selected',
  shape: 'shape',
  size: 'size',
  sizes: 'sizes',
  span: 'span',
  spellcheck: 'spellCheck',
  src: 'src',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  start: 'start',
  step: 'step',
  style: 'style',
  summary: 'summary',
  tabindex: 'tabIndex',
  target: 'target',
  title: 'title',
  type: 'type',
  usemap: 'useMap',
  value: 'value',
  width: 'width',
  wmode: 'wmode',
  wrap: 'wrap',

  // SVG
  about: 'about',
  accentheight: 'accentHeight',
  'accent-height': 'accentHeight',
  accumulate: 'accumulate',
  additive: 'additive',
  alignmentbaseline: 'alignmentBaseline',
  'alignment-baseline': 'alignmentBaseline',
  allowreorder: 'allowReorder',
  alphabetic: 'alphabetic',
  amplitude: 'amplitude',
  arabicform: 'arabicForm',
  'arabic-form': 'arabicForm',
  ascent: 'ascent',
  attributename: 'attributeName',
  attributetype: 'attributeType',
  autoreverse: 'autoReverse',
  azimuth: 'azimuth',
  basefrequency: 'baseFrequency',
  baselineshift: 'baselineShift',
  'baseline-shift': 'baselineShift',
  baseprofile: 'baseProfile',
  bbox: 'bbox',
  begin: 'begin',
  bias: 'bias',
  by: 'by',
  calcmode: 'calcMode',
  capheight: 'capHeight',
  'cap-height': 'capHeight',
  clip: 'clip',
  clippath: 'clipPath',
  'clip-path': 'clipPath',
  clippathunits: 'clipPathUnits',
  cliprule: 'clipRule',
  'clip-rule': 'clipRule',
  color: 'color',
  colorinterpolation: 'colorInterpolation',
  'color-interpolation': 'colorInterpolation',
  colorinterpolationfilters: 'colorInterpolationFilters',
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorprofile: 'colorProfile',
  'color-profile': 'colorProfile',
  colorrendering: 'colorRendering',
  'color-rendering': 'colorRendering',
  contentscripttype: 'contentScriptType',
  contentstyletype: 'contentStyleType',
  cursor: 'cursor',
  cx: 'cx',
  cy: 'cy',
  d: 'd',
  datatype: 'datatype',
  decelerate: 'decelerate',
  descent: 'descent',
  diffuseconstant: 'diffuseConstant',
  direction: 'direction',
  display: 'display',
  divisor: 'divisor',
  dominantbaseline: 'dominantBaseline',
  'dominant-baseline': 'dominantBaseline',
  dur: 'dur',
  dx: 'dx',
  dy: 'dy',
  edgemode: 'edgeMode',
  elevation: 'elevation',
  enablebackground: 'enableBackground',
  'enable-background': 'enableBackground',
  end: 'end',
  exponent: 'exponent',
  externalresourcesrequired: 'externalResourcesRequired',
  fill: 'fill',
  fillopacity: 'fillOpacity',
  'fill-opacity': 'fillOpacity',
  fillrule: 'fillRule',
  'fill-rule': 'fillRule',
  filter: 'filter',
  filterres: 'filterRes',
  filterunits: 'filterUnits',
  floodopacity: 'floodOpacity',
  'flood-opacity': 'floodOpacity',
  floodcolor: 'floodColor',
  'flood-color': 'floodColor',
  focusable: 'focusable',
  fontfamily: 'fontFamily',
  'font-family': 'fontFamily',
  fontsize: 'fontSize',
  'font-size': 'fontSize',
  fontsizeadjust: 'fontSizeAdjust',
  'font-size-adjust': 'fontSizeAdjust',
  fontstretch: 'fontStretch',
  'font-stretch': 'fontStretch',
  fontstyle: 'fontStyle',
  'font-style': 'fontStyle',
  fontvariant: 'fontVariant',
  'font-variant': 'fontVariant',
  fontweight: 'fontWeight',
  'font-weight': 'fontWeight',
  format: 'format',
  from: 'from',
  fx: 'fx',
  fy: 'fy',
  g1: 'g1',
  g2: 'g2',
  glyphname: 'glyphName',
  'glyph-name': 'glyphName',
  glyphorientationhorizontal: 'glyphOrientationHorizontal',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphorientationvertical: 'glyphOrientationVertical',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  hanging: 'hanging',
  horizadvx: 'horizAdvX',
  'horiz-adv-x': 'horizAdvX',
  horizoriginx: 'horizOriginX',
  'horiz-origin-x': 'horizOriginX',
  ideographic: 'ideographic',
  imagerendering: 'imageRendering',
  'image-rendering': 'imageRendering',
  in2: 'in2',
  'in': 'in',
  inlist: 'inlist',
  intercept: 'intercept',
  k1: 'k1',
  k2: 'k2',
  k3: 'k3',
  k4: 'k4',
  k: 'k',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  kerning: 'kerning',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  letterspacing: 'letterSpacing',
  'letter-spacing': 'letterSpacing',
  lightingcolor: 'lightingColor',
  'lighting-color': 'lightingColor',
  limitingconeangle: 'limitingConeAngle',
  local: 'local',
  markerend: 'markerEnd',
  'marker-end': 'markerEnd',
  markerheight: 'markerHeight',
  markermid: 'markerMid',
  'marker-mid': 'markerMid',
  markerstart: 'markerStart',
  'marker-start': 'markerStart',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  mask: 'mask',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  mathematical: 'mathematical',
  mode: 'mode',
  numoctaves: 'numOctaves',
  offset: 'offset',
  opacity: 'opacity',
  operator: 'operator',
  order: 'order',
  orient: 'orient',
  orientation: 'orientation',
  origin: 'origin',
  overflow: 'overflow',
  overlineposition: 'overlinePosition',
  'overline-position': 'overlinePosition',
  overlinethickness: 'overlineThickness',
  'overline-thickness': 'overlineThickness',
  paintorder: 'paintOrder',
  'paint-order': 'paintOrder',
  panose1: 'panose1',
  'panose-1': 'panose1',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointerevents: 'pointerEvents',
  'pointer-events': 'pointerEvents',
  points: 'points',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  prefix: 'prefix',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  property: 'property',
  r: 'r',
  radius: 'radius',
  refx: 'refX',
  refy: 'refY',
  renderingintent: 'renderingIntent',
  'rendering-intent': 'renderingIntent',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  resource: 'resource',
  restart: 'restart',
  result: 'result',
  results: 'results',
  rotate: 'rotate',
  rx: 'rx',
  ry: 'ry',
  scale: 'scale',
  security: 'security',
  seed: 'seed',
  shaperendering: 'shapeRendering',
  'shape-rendering': 'shapeRendering',
  slope: 'slope',
  spacing: 'spacing',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  speed: 'speed',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stemh: 'stemh',
  stemv: 'stemv',
  stitchtiles: 'stitchTiles',
  stopcolor: 'stopColor',
  'stop-color': 'stopColor',
  stopopacity: 'stopOpacity',
  'stop-opacity': 'stopOpacity',
  strikethroughposition: 'strikethroughPosition',
  'strikethrough-position': 'strikethroughPosition',
  strikethroughthickness: 'strikethroughThickness',
  'strikethrough-thickness': 'strikethroughThickness',
  string: 'string',
  stroke: 'stroke',
  strokedasharray: 'strokeDasharray',
  'stroke-dasharray': 'strokeDasharray',
  strokedashoffset: 'strokeDashoffset',
  'stroke-dashoffset': 'strokeDashoffset',
  strokelinecap: 'strokeLinecap',
  'stroke-linecap': 'strokeLinecap',
  strokelinejoin: 'strokeLinejoin',
  'stroke-linejoin': 'strokeLinejoin',
  strokemiterlimit: 'strokeMiterlimit',
  'stroke-miterlimit': 'strokeMiterlimit',
  strokewidth: 'strokeWidth',
  'stroke-width': 'strokeWidth',
  strokeopacity: 'strokeOpacity',
  'stroke-opacity': 'strokeOpacity',
  suppresscontenteditablewarning: 'suppressContentEditableWarning',
  suppresshydrationwarning: 'suppressHydrationWarning',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textanchor: 'textAnchor',
  'text-anchor': 'textAnchor',
  textdecoration: 'textDecoration',
  'text-decoration': 'textDecoration',
  textlength: 'textLength',
  textrendering: 'textRendering',
  'text-rendering': 'textRendering',
  to: 'to',
  transform: 'transform',
  'typeof': 'typeof',
  u1: 'u1',
  u2: 'u2',
  underlineposition: 'underlinePosition',
  'underline-position': 'underlinePosition',
  underlinethickness: 'underlineThickness',
  'underline-thickness': 'underlineThickness',
  unicode: 'unicode',
  unicodebidi: 'unicodeBidi',
  'unicode-bidi': 'unicodeBidi',
  unicoderange: 'unicodeRange',
  'unicode-range': 'unicodeRange',
  unitsperem: 'unitsPerEm',
  'units-per-em': 'unitsPerEm',
  unselectable: 'unselectable',
  valphabetic: 'vAlphabetic',
  'v-alphabetic': 'vAlphabetic',
  values: 'values',
  vectoreffect: 'vectorEffect',
  'vector-effect': 'vectorEffect',
  version: 'version',
  vertadvy: 'vertAdvY',
  'vert-adv-y': 'vertAdvY',
  vertoriginx: 'vertOriginX',
  'vert-origin-x': 'vertOriginX',
  vertoriginy: 'vertOriginY',
  'vert-origin-y': 'vertOriginY',
  vhanging: 'vHanging',
  'v-hanging': 'vHanging',
  videographic: 'vIdeographic',
  'v-ideographic': 'vIdeographic',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  visibility: 'visibility',
  vmathematical: 'vMathematical',
  'v-mathematical': 'vMathematical',
  vocab: 'vocab',
  widths: 'widths',
  wordspacing: 'wordSpacing',
  'word-spacing': 'wordSpacing',
  writingmode: 'writingMode',
  'writing-mode': 'writingMode',
  x1: 'x1',
  x2: 'x2',
  x: 'x',
  xchannelselector: 'xChannelSelector',
  xheight: 'xHeight',
  'x-height': 'xHeight',
  xlinkactuate: 'xlinkActuate',
  'xlink:actuate': 'xlinkActuate',
  xlinkarcrole: 'xlinkArcrole',
  'xlink:arcrole': 'xlinkArcrole',
  xlinkhref: 'xlinkHref',
  'xlink:href': 'xlinkHref',
  xlinkrole: 'xlinkRole',
  'xlink:role': 'xlinkRole',
  xlinkshow: 'xlinkShow',
  'xlink:show': 'xlinkShow',
  xlinktitle: 'xlinkTitle',
  'xlink:title': 'xlinkTitle',
  xlinktype: 'xlinkType',
  'xlink:type': 'xlinkType',
  xmlbase: 'xmlBase',
  'xml:base': 'xmlBase',
  xmllang: 'xmlLang',
  'xml:lang': 'xmlLang',
  xmlns: 'xmlns',
  'xml:space': 'xmlSpace',
  xmlnsxlink: 'xmlnsXlink',
  'xmlns:xlink': 'xmlnsXlink',
  xmlspace: 'xmlSpace',
  y1: 'y1',
  y2: 'y2',
  y: 'y',
  ychannelselector: 'yChannelSelector',
  z: 'z',
  zoomandpan: 'zoomAndPan'
};

function getStackAddendum$2() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

{
  var warnedProperties$1 = {};
  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var EVENT_NAME_REGEX = /^on./;
  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

  var validateProperty$1 = function (tagName, name, value, canUseEventSystem) {
    if (hasOwnProperty$1.call(warnedProperties$1, name) && warnedProperties$1[name]) {
      return true;
    }

    var lowerCasedName = name.toLowerCase();
    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
      warning(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
      warnedProperties$1[name] = true;
      return true;
    }

    // We can't rely on the event system being injected on the server.
    if (canUseEventSystem) {
      if (registrationNameModules.hasOwnProperty(name)) {
        return true;
      }
      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
      if (registrationName != null) {
        warning(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
      if (EVENT_NAME_REGEX.test(name)) {
        warning(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (EVENT_NAME_REGEX.test(name)) {
      // If no event plugins have been injected, we are in a server environment.
      // So we can't tell if the event name is correct for sure, but we can filter
      // out known bad ones like `onclick`. We can't suggest a specific replacement though.
      if (INVALID_EVENT_NAME_REGEX.test(name)) {
        warning(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.%s', name, getStackAddendum$2());
      }
      warnedProperties$1[name] = true;
      return true;
    }

    // Let the ARIA attribute hook validate ARIA attributes
    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
      return true;
    }

    if (lowerCasedName === 'innerhtml') {
      warning(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'aria') {
      warning(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
      warning(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'number' && isNaN(value)) {
      warning(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    var isReserved = isReservedProp(name);

    // Known attributes should match the casing specified in the property config.
    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      var standardName = possibleStandardNames[lowerCasedName];
      if (standardName !== name) {
        warning(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (!isReserved && name !== lowerCasedName) {
      // Unknown attributes should have lowercase casing since that's how they
      // will be cased anyway with server rendering.
      warning(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'boolean' && !shouldAttributeAcceptBooleanValue(name)) {
      if (value) {
        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.%s', value, name, name, value, name, getStackAddendum$2());
      } else {
        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', value, name, name, value, name, name, name, getStackAddendum$2());
      }
      warnedProperties$1[name] = true;
      return true;
    }

    // Now that we've validated casing, do not validate
    // data types for reserved props
    if (isReserved) {
      return true;
    }

    // Warn when a known attribute is a bad type
    if (!shouldSetAttribute(name, value)) {
      warnedProperties$1[name] = true;
      return false;
    }

    return true;
  };
}

var warnUnknownProperties = function (type, props, canUseEventSystem) {
  var unknownProps = [];
  for (var key in props) {
    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');
  if (unknownProps.length === 1) {
    warning(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());
  } else if (unknownProps.length > 1) {
    warning(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());
  }
};

function validateProperties$2(type, props, canUseEventSystem) {
  if (isCustomComponent(type, props)) {
    return;
  }
  warnUnknownProperties(type, props, canUseEventSystem);
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$1 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$2 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnInvalidHydration = false;
var didWarnShadyDOM = false;

var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
var SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
var AUTOFOCUS = 'autoFocus';
var CHILDREN = 'children';
var STYLE = 'style';
var HTML = '__html';

var HTML_NAMESPACE = Namespaces.html;


var getStack = emptyFunction.thatReturns('');

{
  getStack = getCurrentFiberStackAddendum$2;

  var warnedUnknownTags = {
    // Chrome is the only major browser not shipping <time>. But as of July
    // 2017 it intends to ship it due to widespread usage. We intentionally
    // *don't* warn for <time> even if it's unrecognized by Chrome because
    // it soon will be, and many apps have been using it anyway.
    time: true,
    // There are working polyfills for <dialog>. Let people use it.
    dialog: true
  };

  var validatePropertiesInDevelopment = function (type, props) {
    validateProperties(type, props);
    validateProperties$1(type, props);
    validateProperties$2(type, props, /* canUseEventSystem */true);
  };

  // HTML parsing normalizes CR and CRLF to LF.
  // It also can turn \u0000 into \uFFFD inside attributes.
  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
  // If we have a mismatch, it might be caused by that.
  // We will still patch up in this case but not fire the warning.
  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;

  var normalizeMarkupForTextOrAttribute = function (markup) {
    var markupString = typeof markup === 'string' ? markup : '' + markup;
    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
  };

  var warnForTextDifference = function (serverText, clientText) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
    if (normalizedServerText === normalizedClientText) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
  };

  var warnForPropDifference = function (propName, serverValue, clientValue) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
    if (normalizedServerValue === normalizedClientValue) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
  };

  var warnForExtraAttributes = function (attributeNames) {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    var names = [];
    attributeNames.forEach(function (name) {
      names.push(name);
    });
    warning(false, 'Extra attributes from the server: %s', names);
  };

  var warnForInvalidEventListener = function (registrationName, listener) {
    if (listener === false) {
      warning(false, 'Expected `%s` listener to be a function, instead got `false`.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', registrationName, registrationName, registrationName, getCurrentFiberStackAddendum$2());
    } else {
      warning(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum$2());
    }
  };

  // Parse the HTML and read it back to normalize the HTML string so that it
  // can be used for comparison.
  var normalizeHTML = function (parent, html) {
    // We could have created a separate document here to avoid
    // re-initializing custom elements if they exist. But this breaks
    // how <noscript> is being handled. So we use the same document.
    // See the discussion in https://github.com/facebook/react/pull/11157.
    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
    testElement.innerHTML = html;
    return testElement.innerHTML;
  };
}

function ensureListeningTo(rootContainerElement, registrationName) {
  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;
  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;
  listenTo(registrationName, doc);
}

function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapClickOnNonInteractiveElement(node) {
  // Mobile Safari does not fire properly bubble click events on
  // non-interactive elements, which means delegated click listeners do not
  // fire. The workaround for this bug involves attaching an empty click
  // listener on the target node.
  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
  // Just set it using the onclick property so that we don't have to manage any
  // bookkeeping for it. Not sure if we need to clear it when the listener is
  // removed.
  // TODO: Only do this for the relevant Safaris maybe?
  node.onclick = emptyFunction;
}

function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
  for (var propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = nextProps[propKey];
    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      // Relies on `updateStylesByID` not mutating `styleUpdates`.
      setValueForStyles(domElement, nextProp, getStack);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      if (nextHtml != null) {
        setInnerHTML(domElement, nextHtml);
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string') {
        // Avoid setting initial textContent when the text is empty. In IE11 setting
        // textContent on a <textarea> will cause the placeholder to not
        // show within the <textarea> until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        var canSetTextContent = tag !== 'textarea' || nextProp !== '';
        if (canSetTextContent) {
          setTextContent(domElement, nextProp);
        }
      } else if (typeof nextProp === 'number') {
        setTextContent(domElement, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // We polyfill it separately on the client during commit.
      // We blacklist it here rather than in the property list because we emit it in SSR.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else if (isCustomComponentTag) {
      setValueForAttribute(domElement, propKey, nextProp);
    } else if (nextProp != null) {
      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertently setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      setValueForProperty(domElement, propKey, nextProp);
    }
  }
}

function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
  // TODO: Handle wasCustomComponentTag
  for (var i = 0; i < updatePayload.length; i += 2) {
    var propKey = updatePayload[i];
    var propValue = updatePayload[i + 1];
    if (propKey === STYLE) {
      setValueForStyles(domElement, propValue, getStack);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      setInnerHTML(domElement, propValue);
    } else if (propKey === CHILDREN) {
      setTextContent(domElement, propValue);
    } else if (isCustomComponentTag) {
      if (propValue != null) {
        setValueForAttribute(domElement, propKey, propValue);
      } else {
        deleteValueForAttribute(domElement, propKey);
      }
    } else if (propValue != null) {
      setValueForProperty(domElement, propKey, propValue);
    } else {
      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertently setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      deleteValueForProperty(domElement, propKey);
    }
  }
}

function createElement$1(type, props, rootContainerElement, parentNamespace) {
  // We create tags in the namespace of their parent container, except HTML
  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
  var domElement;
  var namespaceURI = parentNamespace;
  if (namespaceURI === HTML_NAMESPACE) {
    namespaceURI = getIntrinsicNamespace(type);
  }
  if (namespaceURI === HTML_NAMESPACE) {
    {
      var isCustomComponentTag = isCustomComponent(type, props);
      // Should this check be gated by parent namespace? Not sure we want to
      // allow <SVG> or <mATH>.
      warning(isCustomComponentTag || type === type.toLowerCase(), '<%s /> is using uppercase HTML. Always use lowercase HTML tags ' + 'in React.', type);
    }

    if (type === 'script') {
      // Create the script via .innerHTML so its "parser-inserted" flag is
      // set to true and it does not execute
      var div = ownerDocument.createElement('div');
      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line
      // This is guaranteed to yield a script element.
      var firstChild = div.firstChild;
      domElement = div.removeChild(firstChild);
    } else if (typeof props.is === 'string') {
      // $FlowIssue `createElement` should be updated for Web Components
      domElement = ownerDocument.createElement(type, { is: props.is });
    } else {
      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
      // See discussion in https://github.com/facebook/react/pull/6896
      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
      domElement = ownerDocument.createElement(type);
    }
  } else {
    domElement = ownerDocument.createElementNS(namespaceURI, type);
  }

  {
    if (namespaceURI === HTML_NAMESPACE) {
      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
        warnedUnknownTags[type] = true;
        warning(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);
      }
    }
  }

  return domElement;
}

function createTextNode$1(text, rootContainerElement) {
  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
}

function setInitialProperties$1(domElement, tag, rawProps, rootContainerElement) {
  var isCustomComponentTag = isCustomComponent(tag, rawProps);
  {
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  var props;
  switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent('topLoad', 'load', domElement);
      props = rawProps;
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          trapBubbledEvent(event, mediaEvents[event], domElement);
        }
      }
      props = rawProps;
      break;
    case 'source':
      trapBubbledEvent('topError', 'error', domElement);
      props = rawProps;
      break;
    case 'img':
    case 'image':
      trapBubbledEvent('topError', 'error', domElement);
      trapBubbledEvent('topLoad', 'load', domElement);
      props = rawProps;
      break;
    case 'form':
      trapBubbledEvent('topReset', 'reset', domElement);
      trapBubbledEvent('topSubmit', 'submit', domElement);
      props = rawProps;
      break;
    case 'details':
      trapBubbledEvent('topToggle', 'toggle', domElement);
      props = rawProps;
      break;
    case 'input':
      initWrapperState(domElement, rawProps);
      props = getHostProps(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      validateProps(domElement, rawProps);
      props = getHostProps$1(domElement, rawProps);
      break;
    case 'select':
      initWrapperState$1(domElement, rawProps);
      props = getHostProps$2(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      props = getHostProps$3(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    default:
      props = rawProps;
  }

  assertValidProps(tag, props, getStack);

  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement, rawProps);
      break;
    case 'option':
      postMountWrapper$1(domElement, rawProps);
      break;
    case 'select':
      postMountWrapper$2(domElement, rawProps);
      break;
    default:
      if (typeof props.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }
}

// Calculate the diff between the two objects.
function diffProperties$1(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
  {
    validatePropertiesInDevelopment(tag, nextRawProps);
  }

  var updatePayload = null;

  var lastProps;
  var nextProps;
  switch (tag) {
    case 'input':
      lastProps = getHostProps(domElement, lastRawProps);
      nextProps = getHostProps(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'option':
      lastProps = getHostProps$1(domElement, lastRawProps);
      nextProps = getHostProps$1(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'select':
      lastProps = getHostProps$2(domElement, lastRawProps);
      nextProps = getHostProps$2(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'textarea':
      lastProps = getHostProps$3(domElement, lastRawProps);
      nextProps = getHostProps$3(domElement, nextRawProps);
      updatePayload = [];
      break;
    default:
      lastProps = lastRawProps;
      nextProps = nextRawProps;
      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  assertValidProps(tag, nextProps, getStack);

  var propKey;
  var styleName;
  var styleUpdates = null;
  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }
    if (propKey === STYLE) {
      var lastStyle = lastProps[propKey];
      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          if (!styleUpdates) {
            styleUpdates = {};
          }
          styleUpdates[styleName] = '';
        }
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {
      // Noop. This is handled by the clear text mechanism.
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // Noop. It doesn't work on updates anyway.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      // This is a special case. If any listener updates we need to ensure
      // that the "current" fiber pointer gets updated so we need a commit
      // to update this element.
      if (!updatePayload) {
        updatePayload = [];
      }
    } else {
      // For all other deleted properties we add it to the queue. We use
      // the whitelist in the commit phase instead.
      (updatePayload = updatePayload || []).push(propKey, null);
    }
  }
  for (propKey in nextProps) {
    var nextProp = nextProps[propKey];
    var lastProp = lastProps != null ? lastProps[propKey] : undefined;
    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
      continue;
    }
    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      if (lastProp) {
        // Unset styles on `lastProp` but not on `nextProp`.
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = '';
          }
        }
        // Update styles that changed since `lastProp`.
        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        if (!styleUpdates) {
          if (!updatePayload) {
            updatePayload = [];
          }
          updatePayload.push(propKey, styleUpdates);
        }
        styleUpdates = nextProp;
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      var lastHtml = lastProp ? lastProp[HTML] : undefined;
      if (nextHtml != null) {
        if (lastHtml !== nextHtml) {
          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);
        }
      } else {
        // TODO: It might be too late to clear this if we have children
        // inserted already.
      }
    } else if (propKey === CHILDREN) {
      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {
        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        // We eagerly listen to this even though we haven't committed yet.
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
      if (!updatePayload && lastProp !== nextProp) {
        // This is a special case. If any listener updates we need to ensure
        // that the "current" props pointer gets updated so we need a commit
        // to update this element.
        updatePayload = [];
      }
    } else {
      // For any other property we always add it to the queue and then we
      // filter it out using the whitelist during the commit.
      (updatePayload = updatePayload || []).push(propKey, nextProp);
    }
  }
  if (styleUpdates) {
    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
  }
  return updatePayload;
}

// Apply the diff.
function updateProperties$1(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
  // Update checked *before* name.
  // In the middle of an update, it is possible to have multiple checked.
  // When a checked radio tries to change name, browser makes another radio's checked false.
  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {
    updateChecked(domElement, nextRawProps);
  }

  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
  // Apply the diff.
  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);

  // TODO: Ensure that an update gets scheduled if any of the special props
  // changed.
  switch (tag) {
    case 'input':
      // Update the wrapper around inputs *after* updating props. This has to
      // happen after `updateDOMProperties`. Otherwise HTML5 input validations
      // raise warnings and prevent the new value from being assigned.
      updateWrapper(domElement, nextRawProps);
      break;
    case 'textarea':
      updateWrapper$1(domElement, nextRawProps);
      break;
    case 'select':
      // <select> value update needs to occur after <option> children
      // reconciliation
      postUpdateWrapper(domElement, nextRawProps);
      break;
  }
}

function diffHydratedProperties$1(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
  {
    var suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;
    var isCustomComponentTag = isCustomComponent(tag, rawProps);
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent('topLoad', 'load', domElement);
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          trapBubbledEvent(event, mediaEvents[event], domElement);
        }
      }
      break;
    case 'source':
      trapBubbledEvent('topError', 'error', domElement);
      break;
    case 'img':
    case 'image':
      trapBubbledEvent('topError', 'error', domElement);
      trapBubbledEvent('topLoad', 'load', domElement);
      break;
    case 'form':
      trapBubbledEvent('topReset', 'reset', domElement);
      trapBubbledEvent('topSubmit', 'submit', domElement);
      break;
    case 'details':
      trapBubbledEvent('topToggle', 'toggle', domElement);
      break;
    case 'input':
      initWrapperState(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      validateProps(domElement, rawProps);
      break;
    case 'select':
      initWrapperState$1(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
  }

  assertValidProps(tag, rawProps, getStack);

  {
    var extraAttributeNames = new Set();
    var attributes = domElement.attributes;
    for (var i = 0; i < attributes.length; i++) {
      var name = attributes[i].name.toLowerCase();
      switch (name) {
        // Built-in SSR attribute is whitelisted
        case 'data-reactroot':
          break;
        // Controlled attributes are not validated
        // TODO: Only ignore them on controlled tags.
        case 'value':
          break;
        case 'checked':
          break;
        case 'selected':
          break;
        default:
          // Intentionally use the original name.
          // See discussion in https://github.com/facebook/react/pull/10676.
          extraAttributeNames.add(attributes[i].name);
      }
    }
  }

  var updatePayload = null;
  for (var propKey in rawProps) {
    if (!rawProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = rawProps[propKey];
    if (propKey === CHILDREN) {
      // For text content children we compare against textContent. This
      // might match additional HTML that is hidden when we read it using
      // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
      // satisfies our requirement. Our requirement is not to produce perfect
      // HTML and attributes. Ideally we should preserve structure but it's
      // ok not to if the visible content is still enough to indicate what
      // even listeners these nodes might be wired up to.
      // TODO: Warn if there is more than a single textNode as a child.
      // TODO: Should we use domElement.firstChild.nodeValue to compare?
      if (typeof nextProp === 'string') {
        if (domElement.textContent !== nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, nextProp];
        }
      } else if (typeof nextProp === 'number') {
        if (domElement.textContent !== '' + nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, '' + nextProp];
        }
      }
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else {
      // Validate that the properties correspond to their expected values.
      var serverValue;
      var propertyInfo;
      if (suppressHydrationWarning) {
        // Don't bother comparing. We're ignoring all these warnings.
      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||
      // Controlled attributes are not validated
      // TODO: Only ignore them on controlled tags.
      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {
        // Noop
      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
        var rawHtml = nextProp ? nextProp[HTML] || '' : '';
        var serverHTML = domElement.innerHTML;
        var expectedHTML = normalizeHTML(domElement, rawHtml);
        if (expectedHTML !== serverHTML) {
          warnForPropDifference(propKey, serverHTML, expectedHTML);
        }
      } else if (propKey === STYLE) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames['delete'](propKey);
        var expectedStyle = createDangerousStringForStyles(nextProp);
        serverValue = domElement.getAttribute('style');
        if (expectedStyle !== serverValue) {
          warnForPropDifference(propKey, serverValue, expectedStyle);
        }
      } else if (isCustomComponentTag) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames['delete'](propKey.toLowerCase());
        serverValue = getValueForAttribute(domElement, propKey, nextProp);

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      } else if (shouldSetAttribute(propKey, nextProp)) {
        if (propertyInfo = getPropertyInfo(propKey)) {
          // $FlowFixMe - Should be inferred as not undefined.
          extraAttributeNames['delete'](propertyInfo.attributeName);
          serverValue = getValueForProperty(domElement, propKey, nextProp);
        } else {
          var ownNamespace = parentNamespace;
          if (ownNamespace === HTML_NAMESPACE) {
            ownNamespace = getIntrinsicNamespace(tag);
          }
          if (ownNamespace === HTML_NAMESPACE) {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames['delete'](propKey.toLowerCase());
          } else {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames['delete'](propKey);
          }
          serverValue = getValueForAttribute(domElement, propKey, nextProp);
        }

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      }
    }
  }

  {
    // $FlowFixMe - Should be inferred as not undefined.
    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
      // $FlowFixMe - Should be inferred as not undefined.
      warnForExtraAttributes(extraAttributeNames);
    }
  }

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement, rawProps);
      break;
    case 'select':
    case 'option':
      // For input and textarea we current always set the value property at
      // post mount to force it to diverge from attributes. However, for
      // option and select we don't quite do the same thing and select
      // is not resilient to the DOM state changing so we don't do that here.
      // TODO: Consider not doing this for input and textarea.
      break;
    default:
      if (typeof rawProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  return updatePayload;
}

function diffHydratedText$1(textNode, text) {
  var isDifferent = textNode.nodeValue !== text;
  return isDifferent;
}

function warnForUnmatchedText$1(textNode, text) {
  {
    warnForTextDifference(textNode.nodeValue, text);
  }
}

function warnForDeletedHydratableElement$1(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
  }
}

function warnForDeletedHydratableText$1(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedElement$1(parentNode, tag, props) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedText$1(parentNode, text) {
  {
    if (text === '') {
      // We expect to insert empty text nodes since they're not represented in
      // the HTML.
      // TODO: Remove this special case if we can just avoid inserting empty
      // text nodes.
      return;
    }
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
  }
}

function restoreControlledState(domElement, tag, props) {
  switch (tag) {
    case 'input':
      restoreControlledState$1(domElement, props);
      return;
    case 'textarea':
      restoreControlledState$3(domElement, props);
      return;
    case 'select':
      restoreControlledState$2(domElement, props);
      return;
  }
}

var ReactDOMFiberComponent = Object.freeze({
	createElement: createElement$1,
	createTextNode: createTextNode$1,
	setInitialProperties: setInitialProperties$1,
	diffProperties: diffProperties$1,
	updateProperties: updateProperties$1,
	diffHydratedProperties: diffHydratedProperties$1,
	diffHydratedText: diffHydratedText$1,
	warnForUnmatchedText: warnForUnmatchedText$1,
	warnForDeletedHydratableElement: warnForDeletedHydratableElement$1,
	warnForDeletedHydratableText: warnForDeletedHydratableText$1,
	warnForInsertedHydratedElement: warnForInsertedHydratedElement$1,
	warnForInsertedHydratedText: warnForInsertedHydratedText$1,
	restoreControlledState: restoreControlledState
});

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$6 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var validateDOMNesting = emptyFunction;

{
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo$1 = function (oldInfo, tag, instance) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childText, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null');
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var invalidParentOrAncestor = invalidParent || invalidAncestor;
    if (!invalidParentOrAncestor) {
      return;
    }

    var ancestorTag = invalidParentOrAncestor.tag;
    var addendum = getCurrentFiberStackAddendum$6();

    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;
    if (didWarn[warnKey]) {
      return;
    }
    didWarn[warnKey] = true;

    var tagDisplayName = childTag;
    var whitespaceInfo = '';
    if (childTag === '#text') {
      if (/\S/.test(childText)) {
        tagDisplayName = 'Text nodes';
      } else {
        tagDisplayName = 'Whitespace text nodes';
        whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
      }
    } else {
      tagDisplayName = '<' + childTag + '>';
    }

    if (invalidParent) {
      var info = '';
      if (ancestorTag === 'table' && childTag === 'tr') {
        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
      }
      warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);
    } else {
      warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);
    }
  };

  // TODO: turn this into a named export
  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

var validateDOMNesting$1 = validateDOMNesting;

// TODO: direct imports like some-package/src/* are bad. Fix me.
var createElement = createElement$1;
var createTextNode = createTextNode$1;
var setInitialProperties = setInitialProperties$1;
var diffProperties = diffProperties$1;
var updateProperties = updateProperties$1;
var diffHydratedProperties = diffHydratedProperties$1;
var diffHydratedText = diffHydratedText$1;
var warnForUnmatchedText = warnForUnmatchedText$1;
var warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;
var warnForDeletedHydratableText = warnForDeletedHydratableText$1;
var warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;
var warnForInsertedHydratedText = warnForInsertedHydratedText$1;
var updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;
var precacheFiberNode = precacheFiberNode$1;
var updateFiberProps = updateFiberProps$1;


{
  var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
  if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {
    warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');
  }
}

injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);

var eventsEnabled = null;
var selectionInformation = null;

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
}

function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOCUMENT_NODE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function shouldHydrateDueToLegacyHeuristic(container) {
  var rootElement = getReactRootElementInContainer(container);
  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
}

function shouldAutoFocusHostComponent(type, props) {
  switch (type) {
    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      return !!props.autoFocus;
  }
  return false;
}

var DOMRenderer = reactReconciler({
  getRootHostContext: function (rootContainerInstance) {
    var type = void 0;
    var namespace = void 0;
    var nodeType = rootContainerInstance.nodeType;
    switch (nodeType) {
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        {
          type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
          var root = rootContainerInstance.documentElement;
          namespace = root ? root.namespaceURI : getChildNamespace(null, '');
          break;
        }
      default:
        {
          var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
          var ownNamespace = container.namespaceURI || null;
          type = container.tagName;
          namespace = getChildNamespace(ownNamespace, type);
          break;
        }
    }
    {
      var validatedTag = type.toLowerCase();
      var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);
      return { namespace: namespace, ancestorInfo: _ancestorInfo };
    }
    return namespace;
  },
  getChildHostContext: function (parentHostContext, type) {
    {
      var parentHostContextDev = parentHostContext;
      var _namespace = getChildNamespace(parentHostContextDev.namespace, type);
      var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);
      return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };
    }
    var parentNamespace = parentHostContext;
    return getChildNamespace(parentNamespace, type);
  },
  getPublicInstance: function (instance) {
    return instance;
  },
  prepareForCommit: function () {
    eventsEnabled = isEnabled();
    selectionInformation = getSelectionInformation();
    setEnabled(false);
  },
  resetAfterCommit: function () {
    restoreSelection(selectionInformation);
    selectionInformation = null;
    setEnabled(eventsEnabled);
    eventsEnabled = null;
  },
  createInstance: function (type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
    var parentNamespace = void 0;
    {
      // TODO: take namespace into account when validating.
      var hostContextDev = hostContext;
      validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);
      if (typeof props.children === 'string' || typeof props.children === 'number') {
        var string = '' + props.children;
        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
        validateDOMNesting$1(null, string, ownAncestorInfo);
      }
      parentNamespace = hostContextDev.namespace;
    }
    var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
    precacheFiberNode(internalInstanceHandle, domElement);
    updateFiberProps(domElement, props);
    return domElement;
  },
  appendInitialChild: function (parentInstance, child) {
    parentInstance.appendChild(child);
  },
  finalizeInitialChildren: function (domElement, type, props, rootContainerInstance) {
    setInitialProperties(domElement, type, props, rootContainerInstance);
    return shouldAutoFocusHostComponent(type, props);
  },
  prepareUpdate: function (domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
    {
      var hostContextDev = hostContext;
      if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
        var string = '' + newProps.children;
        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
        validateDOMNesting$1(null, string, ownAncestorInfo);
      }
    }
    return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);
  },
  shouldSetTextContent: function (type, props) {
    return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';
  },
  shouldDeprioritizeSubtree: function (type, props) {
    return !!props.hidden;
  },
  createTextInstance: function (text, rootContainerInstance, hostContext, internalInstanceHandle) {
    {
      var hostContextDev = hostContext;
      validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);
    }
    var textNode = createTextNode(text, rootContainerInstance);
    precacheFiberNode(internalInstanceHandle, textNode);
    return textNode;
  },


  now: now,

  mutation: {
    commitMount: function (domElement, type, newProps, internalInstanceHandle) {
      domElement.focus();
    },
    commitUpdate: function (domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
      // Update the props handle so that we know which props are the ones with
      // with current event handlers.
      updateFiberProps(domElement, newProps);
      // Apply the diff to the DOM node.
      updateProperties(domElement, updatePayload, type, oldProps, newProps);
    },
    resetTextContent: function (domElement) {
      domElement.textContent = '';
    },
    commitTextUpdate: function (textInstance, oldText, newText) {
      textInstance.nodeValue = newText;
    },
    appendChild: function (parentInstance, child) {
      parentInstance.appendChild(child);
    },
    appendChildToContainer: function (container, child) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.insertBefore(child, container);
      } else {
        container.appendChild(child);
      }
    },
    insertBefore: function (parentInstance, child, beforeChild) {
      parentInstance.insertBefore(child, beforeChild);
    },
    insertInContainerBefore: function (container, child, beforeChild) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.insertBefore(child, beforeChild);
      } else {
        container.insertBefore(child, beforeChild);
      }
    },
    removeChild: function (parentInstance, child) {
      parentInstance.removeChild(child);
    },
    removeChildFromContainer: function (container, child) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.removeChild(child);
      } else {
        container.removeChild(child);
      }
    }
  },

  hydration: {
    canHydrateInstance: function (instance, type, props) {
      if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
        return null;
      }
      // This has now been refined to an element node.
      return instance;
    },
    canHydrateTextInstance: function (instance, text) {
      if (text === '' || instance.nodeType !== TEXT_NODE) {
        // Empty strings are not parsed by HTML so there won't be a correct match here.
        return null;
      }
      // This has now been refined to a text node.
      return instance;
    },
    getNextHydratableSibling: function (instance) {
      var node = instance.nextSibling;
      // Skip non-hydratable nodes.
      while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {
        node = node.nextSibling;
      }
      return node;
    },
    getFirstHydratableChild: function (parentInstance) {
      var next = parentInstance.firstChild;
      // Skip non-hydratable nodes.
      while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {
        next = next.nextSibling;
      }
      return next;
    },
    hydrateInstance: function (instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
      precacheFiberNode(internalInstanceHandle, instance);
      // TODO: Possibly defer this until the commit phase where all the events
      // get attached.
      updateFiberProps(instance, props);
      var parentNamespace = void 0;
      {
        var hostContextDev = hostContext;
        parentNamespace = hostContextDev.namespace;
      }
      return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);
    },
    hydrateTextInstance: function (textInstance, text, internalInstanceHandle) {
      precacheFiberNode(internalInstanceHandle, textInstance);
      return diffHydratedText(textInstance, text);
    },
    didNotMatchHydratedContainerTextInstance: function (parentContainer, textInstance, text) {
      {
        warnForUnmatchedText(textInstance, text);
      }
    },
    didNotMatchHydratedTextInstance: function (parentType, parentProps, parentInstance, textInstance, text) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForUnmatchedText(textInstance, text);
      }
    },
    didNotHydrateContainerInstance: function (parentContainer, instance) {
      {
        if (instance.nodeType === 1) {
          warnForDeletedHydratableElement(parentContainer, instance);
        } else {
          warnForDeletedHydratableText(parentContainer, instance);
        }
      }
    },
    didNotHydrateInstance: function (parentType, parentProps, parentInstance, instance) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        if (instance.nodeType === 1) {
          warnForDeletedHydratableElement(parentInstance, instance);
        } else {
          warnForDeletedHydratableText(parentInstance, instance);
        }
      }
    },
    didNotFindHydratableContainerInstance: function (parentContainer, type, props) {
      {
        warnForInsertedHydratedElement(parentContainer, type, props);
      }
    },
    didNotFindHydratableContainerTextInstance: function (parentContainer, text) {
      {
        warnForInsertedHydratedText(parentContainer, text);
      }
    },
    didNotFindHydratableInstance: function (parentType, parentProps, parentInstance, type, props) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForInsertedHydratedElement(parentInstance, type, props);
      }
    },
    didNotFindHydratableTextInstance: function (parentType, parentProps, parentInstance, text) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForInsertedHydratedText(parentInstance, text);
      }
    }
  },

  scheduleDeferredCallback: rIC,
  cancelDeferredCallback: cIC,

  useSyncScheduling: !enableAsyncSchedulingByDefaultInReactDOM
});

injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);

var warnedAboutHydrateAPI = false;

function renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;

  {
    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
      var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);
      if (hostInstance) {
        warning(hostInstance.parentNode === container, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');
      }
    }

    var isRootRenderedBySomeReact = !!container._reactRootContainer;
    var rootEl = getReactRootElementInContainer(container);
    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));

    warning(!hasNonRootReactChild || isRootRenderedBySomeReact, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');

    warning(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');
  }

  var root = container._reactRootContainer;
  if (!root) {
    var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
    // First clear any existing content.
    if (!shouldHydrate) {
      var warned = false;
      var rootSibling = void 0;
      while (rootSibling = container.lastChild) {
        {
          if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
            warned = true;
            warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');
          }
        }
        container.removeChild(rootSibling);
      }
    }
    {
      if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
        warnedAboutHydrateAPI = true;
        lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');
      }
    }
    var newRoot = DOMRenderer.createContainer(container, shouldHydrate);
    root = container._reactRootContainer = newRoot;
    // Initial mount should not be batched.
    DOMRenderer.unbatchedUpdates(function () {
      DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);
    });
  } else {
    DOMRenderer.updateContainer(children, root, parentComponent, callback);
  }
  return DOMRenderer.getPublicRootInstance(root);
}

function createPortal(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;
  // TODO: pass ReactDOM portal implementation as third argument
  return createPortal$1(children, container, null, key);
}

function ReactRoot(container, hydrate) {
  var root = DOMRenderer.createContainer(container, hydrate);
  this._reactRootContainer = root;
}
ReactRoot.prototype.render = function (children, callback) {
  var root = this._reactRootContainer;
  DOMRenderer.updateContainer(children, root, null, callback);
};
ReactRoot.prototype.unmount = function (callback) {
  var root = this._reactRootContainer;
  DOMRenderer.updateContainer(null, root, null, callback);
};

var ReactDOM = {
  createPortal: createPortal,

  findDOMNode: function (componentOrElement) {
    {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
        warning(warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner) || 'A component');
        owner.stateNode._warnedAboutRefsInRender = true;
      }
    }
    if (componentOrElement == null) {
      return null;
    }
    if (componentOrElement.nodeType === ELEMENT_NODE) {
      return componentOrElement;
    }

    var inst = get(componentOrElement);
    if (inst) {
      return DOMRenderer.findHostInstance(inst);
    }

    if (typeof componentOrElement.render === 'function') {
      invariant(false, 'Unable to find node on an unmounted component.');
    } else {
      invariant(false, 'Element appears to be neither ReactComponent nor DOMNode. Keys: %s', Object.keys(componentOrElement));
    }
  },
  hydrate: function (element, container, callback) {
    // TODO: throw or warn if we couldn't hydrate?
    return renderSubtreeIntoContainer(null, element, container, true, callback);
  },
  render: function (element, container, callback) {
    return renderSubtreeIntoContainer(null, element, container, false, callback);
  },
  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {
    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;
    return renderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
  },
  unmountComponentAtNode: function (container) {
    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;

    if (container._reactRootContainer) {
      {
        var rootEl = getReactRootElementInContainer(container);
        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);
        warning(!renderedByDifferentReact, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.');
      }

      // Unmount should not be batched.
      DOMRenderer.unbatchedUpdates(function () {
        renderSubtreeIntoContainer(null, null, container, false, function () {
          container._reactRootContainer = null;
        });
      });
      // If you call unmountComponentAtNode twice in quick succession, you'll
      // get `true` twice. That's probably fine?
      return true;
    } else {
      {
        var _rootEl = getReactRootElementInContainer(container);
        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));

        // Check if the container itself is a React root node.
        var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;

        warning(!hasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');
      }

      return false;
    }
  },


  // Temporary alias since we already shipped React 16 RC with it.
  // TODO: remove in React 17.
  unstable_createPortal: createPortal,

  unstable_batchedUpdates: batchedUpdates,

  unstable_deferredUpdates: DOMRenderer.deferredUpdates,

  flushSync: DOMRenderer.flushSync,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    // For TapEventPlugin which is popular in open source
    EventPluginHub: EventPluginHub,
    // Used by test-utils
    EventPluginRegistry: EventPluginRegistry,
    EventPropagators: EventPropagators,
    ReactControlledComponent: ReactControlledComponent,
    ReactDOMComponentTree: ReactDOMComponentTree,
    ReactDOMEventListener: ReactDOMEventListener
  }
};

if (enableCreateRoot) {
  ReactDOM.createRoot = function createRoot(container, options) {
    var hydrate = options != null && options.hydrate === true;
    return new ReactRoot(container, hydrate);
  };
}

var foundDevTools = DOMRenderer.injectIntoDevTools({
  findFiberByHostInstance: getClosestInstanceFromNode,
  bundleType: 1,
  version: ReactVersion,
  rendererPackageName: 'react-dom'
});

{
  if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {
    // If we're in Chrome or Firefox, provide a download link if not installed.
    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
      var protocol = window.location.protocol;
      // Don't warn in exotic cases like chrome-extension://.
      if (/^(https?|file):$/.test(protocol)) {
        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');
      }
    }
  }
}



var ReactDOM$2 = Object.freeze({
	default: ReactDOM
});

var ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom = ReactDOM$3['default'] ? ReactDOM$3['default'] : ReactDOM$3;

module.exports = reactDom;
  })();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(145);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var camelize = __webpack_require__(147);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgM2I0ODdlZGZmMzM1OTMzZjg2NzgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3BlcmZvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZm9jdXNOb2RlLmpzIiwid2VicGFjazovLy8uL3NyYy9tYWluLmpzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1wcm90by5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL3NyYy9jcmVhdGVDYW52YXMuanN4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1pbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ludm9rZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVydGV4U2hhZGVyLmdsc2wiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYWdtZW50U2hhZGVyLmdsc2wiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RleHR1cmUuanBnIiwid2VicGFjazovLy8uL3NyYy9zdHlsZS5zY3NzPzNlYzEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzIl0sIm5hbWVzIjpbIkdsaXRjaCIsInByb3BzIiwic3RhdGUiLCJ3aWR0aCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJoZWlnaHQiLCJpbm5lckhlaWdodCIsImRvY3VtZW50IiwiYm9keSIsInN0eWxlIiwib3ZlcmZsb3ciLCJ0ZW1wSGFuZGxlUmVzaXplIiwiaGFuZGxlUmVzaXplIiwiYmluZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZSIsInRhcmdldCIsInJlZnMiLCJjcmVhdGVDYW52YXMiLCJzZXRTdGF0ZSIsInBvc2l0aW9uIiwiYm90dG9tIiwibGVmdCIsImZvbnRTaXplIiwibWFyZ2luIiwibG9jYXRpb24iLCJoYXNoIiwic3BsaXQiLCJDb21wb25lbnQiLCJyZW5kZXIiLCJnZXRFbGVtZW50QnlJZCIsIndlYkdMU3RhcnQiLCJjYW52YXMiLCJnbCIsInZzIiwiZnMiLCJjcmVhdGVfcHJvZ3JhbSIsInByb2dyYW0iLCJjcmVhdGVQcm9ncmFtIiwiYXR0YWNoU2hhZGVyIiwibGlua1Byb2dyYW0iLCJnZXRQcm9ncmFtUGFyYW1ldGVyIiwiTElOS19TVEFUVVMiLCJ1c2VQcm9ncmFtIiwiY3JlYXRlX3NoYWRlciIsInRleHQiLCJ0eXBlIiwic2hhZGVyIiwiY3JlYXRlU2hhZGVyIiwic2hhZGVyU291cmNlIiwiY29tcGlsZVNoYWRlciIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwiYWxlcnQiLCJnZXRTaGFkZXJJbmZvTG9nIiwiY29uc29sZSIsImxvZyIsImNyZWF0ZV92Ym8iLCJ2Ym8iLCJjcmVhdGVCdWZmZXIiLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwiYnVmZmVyRGF0YSIsIkZsb2F0MzJBcnJheSIsImRhdGEiLCJEWU5BTUlDX0NPUFkiLCJjcmVhdGVfaWJvIiwiaWJvIiwiRUxFTUVOVF9BUlJBWV9CVUZGRVIiLCJJbnQxNkFycmF5IiwiU1RBVElDX0RSQVciLCJzZXRfYXR0cmlidXRlIiwiYXR0TCIsImF0dFMiLCJmb3JFYWNoIiwiaSIsImEiLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsInZlcnRleEF0dHJpYlBvaW50ZXIiLCJGTE9BVCIsInRleHR1cmUiLCJjcmVhdGVfdGV4dHVyZSIsImltZyIsIkltYWdlIiwic3JjIiwib25sb2FkIiwidGV4IiwiY3JlYXRlVGV4dHVyZSIsImJpbmRUZXh0dXJlIiwiVEVYVFVSRV8yRCIsInRleEltYWdlMkQiLCJSR0JBIiwiVU5TSUdORURfQllURSIsImdlbmVyYXRlTWlwbWFwIiwicHJnIiwiVkVSVEVYX1NIQURFUiIsIkZSQUdNRU5UX1NIQURFUiIsInVuaUxvY2F0aW9uIiwiZ2V0VW5pZm9ybUxvY2F0aW9uIiwidlBvc2l0aW9uIiwiYXR0TG9jYXRpb24iLCJBcnJheSIsImdldEF0dHJpYkxvY2F0aW9uIiwiYXR0U3RyaWRlIiwiaW5kZXgiLCJ2SW5kZXgiLCJhY3RpdmVUZXh0dXJlIiwiVEVYVFVSRTAiLCJjbGVhckNvbG9yIiwic3RhcnRUaW1lIiwiRGF0ZSIsImdldFRpbWUiLCJjbGVhciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJ1bmlmb3JtMWYiLCJ1bmlmb3JtMmZ2IiwidW5pZm9ybTFpIiwiZHJhd0VsZW1lbnRzIiwiVFJJQU5HTEVTIiwibGVuZ3RoIiwiVU5TSUdORURfU0hPUlQiLCJmbHVzaCIsIkNyZWF0ZUNhbnZhcyIsInJlcXVlc3RJZCIsInVwZGF0ZUNhbnZhcyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZ2V0Q29udGV4dCIsImxvb3AiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3IiwiaCIsInZpZXdwb3J0Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7Ozs7OztBQ0x6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1ZBLDZCQUE2QjtBQUM3Qix1Q0FBdUM7Ozs7Ozs7QUNEdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLGNBQWM7QUFDekIsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYjtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QXNDO0FBQ3pELENBQUMscUNBQXFDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7Ozs7O0FDakNEOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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Q0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Qjs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsRUFBRTtBQUNmLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsRUFBRTtBQUNmLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZ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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsc0JBQXNCOztBQUV0QjtBQUNBLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2YsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYixjQUFjOztBQUVkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxpQkFBaUIsa0NBQWtDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpQkFBaUIsRUFBRTtBQUNyQyx5QkFBeUIsd0JBQXdCLEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7O0FBRWY7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrS0FBa0sseUNBQXlDO0FBQzNNO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrREFBa0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AseUNBQXlDO0FBQ3pDLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhNQUE4TTtBQUM5TTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RCxtQkFBbUI7QUFDaEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNGQUFzRixhQUFhO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixlQUFlO0FBQzNHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhLQUE4SyxZQUFZO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUxBQXVMLCtCQUErQjtBQUN0Tjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtKQUErSixpQkFBaUI7QUFDaEwsT0FBTztBQUNQLCtKQUErSixpQkFBaUIsd0RBQXdELG1CQUFtQixnQkFBZ0IsOEJBQThCO0FBQ3pTO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMElBQTBJLG1CQUFtQixnQkFBZ0IsOEJBQThCO0FBQzNNLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzREFBc0QsZUFBZTtBQUNyRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQyxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7QUNqaWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DOzs7Ozs7O0FDbkNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQjs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DOzs7Ozs7O0FDcENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSwwQiIsImZpbGUiOiJtYWluLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDcxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAzYjQ4N2VkZmYzMzU5MzNmODY3OCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjMnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIElTX1dSQVAgPSB0eXBlICYgJGV4cG9ydC5XO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV07XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIga2V5LCBvd24sIG91dDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAob3duICYmIGtleSBpbiBleHBvcnRzKSBjb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uIChDKSB7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQykge1xuICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEMoKTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYgKElTX1BST1RPKSB7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYgKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0pIGhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAoKHR5cGVvZiBjYWxsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShjYWxsKSkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2l0ZXJhdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yXCIpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2xcIik7XG5cbnZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAoIUJVR0dZICYmICRuYXRpdmUpIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBET01JdGVyYWJsZXMgPSAoJ0NTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsJyArXG4gICdET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LCcgK1xuICAnTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCwnICtcbiAgJ1NWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LCcgK1xuICAnVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QnKS5zcGxpdCgnLCcpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IERPTUl0ZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IERPTUl0ZXJhYmxlc1tpXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wZC5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKTtcblxudmFyIF9zZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY3JlYXRlID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoc3VwZXJDbGFzcykpKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0ID8gKDAsIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuICB2YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpbnZhcmlhbnQodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ3RoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAlc2AuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0pO1xuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgRCkge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjZWwgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHNldFRhc2sgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyVGFzayA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spIHtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGU6IGZhbHNlLCB2OiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IGU6IHRydWUsIHY6IGUgfTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wZXJmb3JtLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb21pc2UtcmVzb2x2ZS5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOiBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFVwc3RyZWFtIHZlcnNpb24gb2YgZXZlbnQgbGlzdGVuZXIuIERvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHNwZWNpZmljXG4gKiBuYXR1cmUgb2YgcGxhdGZvcm0uXG4gKi9cbnZhciBFdmVudExpc3RlbmVyID0ge1xuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBidWJibGUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGNhcHR1cmU6IGZ1bmN0aW9uIGNhcHR1cmUodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICsgJ2Jyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjYXB0dXJlIHBoYXNlLiBZb3VyIGFwcGxpY2F0aW9uICcgKyAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZW1wdHlGdW5jdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWZhdWx0OiBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHQoKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gez9ET01Eb2N1bWVudH0gZG9jIERlZmF1bHRzIHRvIGN1cnJlbnQgZG9jdW1lbnQuXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIC8qP0RPTUVsZW1lbnQqL3tcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuICBpZiAodHlwZW9mIGRvYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2MuYWN0aXZlRWxlbWVudCB8fCBkb2MuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2MuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICogXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgaWYgKHggPT09IHkpIHtcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIC8vIEFkZGVkIHRoZSBub256ZXJvIHkgY2hlY2sgdG8gbWFrZSBGbG93IGhhcHB5LCBidXQgaXQgaXMgcmVkdW5kYW50XG4gICAgcmV0dXJuIHggIT09IDAgfHwgeSAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RXF1YWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NvbnRhaW5zTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBpbnB1dC90ZXh0YXJlYSB0byBmb2N1c1xuICovXG5cbmZ1bmN0aW9uIGZvY3VzTm9kZShub2RlKSB7XG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxuICAvLyBub3QgZW5hYmxlZCwgb3Igb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWNjZXB0IHRoZSBmb2N1cy5cIiBmb3IgYWxsIGtpbmRzIG9mXG4gIC8vIHJlYXNvbnMgdGhhdCBhcmUgdG9vIGV4cGVuc2l2ZSBhbmQgZnJhZ2lsZSB0byB0ZXN0LlxuICB0cnkge1xuICAgIG5vZGUuZm9jdXMoKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c05vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZm9jdXNOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgQ3JlYXRlQ2FudmFzIGZyb20gXCIuL2NyZWF0ZUNhbnZhcy5qc3hcIjtcbmltcG9ydCBcIi4vc3R5bGUuc2Nzc1wiO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcblxuY2xhc3MgR2xpdGNoIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgfTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICB0aGlzLnRlbXBIYW5kbGVSZXNpemUgPSB0aGlzLmhhbmRsZVJlc2l6ZS5iaW5kKHRoaXMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMudGVtcEhhbmRsZVJlc2l6ZSk7XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy50ZW1wSGFuZGxlUmVzaXplKTtcbiAgfVxuICBoYW5kbGVSZXNpemUoZSkge1xuICAgIGNvbnN0IHdpZHRoID0gZS50YXJnZXQuaW5uZXJXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBlLnRhcmdldC5pbm5lckhlaWdodDtcbiAgICB0aGlzLnJlZnMuY3JlYXRlQ2FudmFzLmhhbmRsZVJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8UmVhY3QuRnJhZ21lbnQ+XG4gICAgICAgIDxDcmVhdGVDYW52YXNcbiAgICAgICAgICByZWY9XCJjcmVhdGVDYW52YXNcIlxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5zdGF0ZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5zdGF0ZS5oZWlnaHRcbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgICA8cFxuICAgICAgICAgIGlkPVwidGl0bGVcIlxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgYm90dG9tOiBcIjIwcHhcIixcbiAgICAgICAgICAgIGxlZnQ6IFwiMjBweFwiLFxuICAgICAgICAgICAgZm9udFNpemU6IFwiMTAwcHhcIixcbiAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICAgIH19XG4gICAgICAgID5cbiAgICAgICAgICB7bG9jYXRpb24uaGFzaC5zcGxpdChcIi9cIilbMV19XG4gICAgICAgIDwvcD5cbiAgICAgIDwvUmVhY3QuRnJhZ21lbnQ+XG4gICAgKTtcbiAgfVxufVxuXG5SZWFjdERPTS5yZW5kZXIoPEdsaXRjaCAvPiwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyb290XCIpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYWluLmpzeCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYykge1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZiB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fd2tzLWV4dCcpLmYoJ2l0ZXJhdG9yJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBkZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgTUVUQSA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVk7XG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIHdrc0RlZmluZSA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QRCA9ICRHT1BELmY7XG52YXIgZFAgPSAkRFAuZjtcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyICRKU09OID0gZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKSB7XG4gIHJldHVybiAkT2JqZWN0LmNyZWF0ZShQLCBEKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4yLjBcbiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO3ZhciBtPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLG49cmVxdWlyZShcImZianMvbGliL2VtcHR5T2JqZWN0XCIpLHA9cmVxdWlyZShcImZianMvbGliL2VtcHR5RnVuY3Rpb25cIikscT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2xbXCJmb3JcIl0scj1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmVsZW1lbnRcIik6NjAxMDMsdD1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmNhbGxcIik6NjAxMDQsdT1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LnJldHVyblwiKTo2MDEwNSx2PXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucG9ydGFsXCIpOjYwMTA2LHc9cT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5mcmFnbWVudFwiKTo2MDEwNyx4PVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcjtcbmZ1bmN0aW9uIHkoYSl7Zm9yKHZhciBiPWFyZ3VtZW50cy5sZW5ndGgtMSxlPVwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50XFx4M2RcIithLGM9MDtjPGI7YysrKWUrPVwiXFx4MjZhcmdzW11cXHgzZFwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbYysxXSk7Yj1FcnJvcihlK1wiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy5cIik7Yi5uYW1lPVwiSW52YXJpYW50IFZpb2xhdGlvblwiO2IuZnJhbWVzVG9Qb3A9MTt0aHJvdyBiO31cbnZhciB6PXtpc01vdW50ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oKXt9fTtmdW5jdGlvbiBBKGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPW47dGhpcy51cGRhdGVyPWV8fHp9QS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD17fTtBLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihhLGIpe1wib2JqZWN0XCIhPT10eXBlb2YgYSYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGEmJm51bGwhPWE/eShcIjg1XCIpOnZvaWQgMDt0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsYSxiLFwic2V0U3RhdGVcIil9O0EucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKGEpe3RoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyxhLFwiZm9yY2VVcGRhdGVcIil9O1xuZnVuY3Rpb24gQihhLGIsZSl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1uO3RoaXMudXBkYXRlcj1lfHx6fWZ1bmN0aW9uIEMoKXt9Qy5wcm90b3R5cGU9QS5wcm90b3R5cGU7dmFyIEQ9Qi5wcm90b3R5cGU9bmV3IEM7RC5jb25zdHJ1Y3Rvcj1CO20oRCxBLnByb3RvdHlwZSk7RC5pc1B1cmVSZWFjdENvbXBvbmVudD0hMDtmdW5jdGlvbiBFKGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPW47dGhpcy51cGRhdGVyPWV8fHp9dmFyIEY9RS5wcm90b3R5cGU9bmV3IEM7Ri5jb25zdHJ1Y3Rvcj1FO20oRixBLnByb3RvdHlwZSk7Ri51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQ9ITA7Ri5yZW5kZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbn07dmFyIEc9e2N1cnJlbnQ6bnVsbH0sSD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LEk9e2tleTohMCxyZWY6ITAsX19zZWxmOiEwLF9fc291cmNlOiEwfTtcbmZ1bmN0aW9uIEooYSxiLGUpe3ZhciBjLGQ9e30sZz1udWxsLGs9bnVsbDtpZihudWxsIT1iKWZvcihjIGluIHZvaWQgMCE9PWIucmVmJiYoaz1iLnJlZiksdm9pZCAwIT09Yi5rZXkmJihnPVwiXCIrYi5rZXkpLGIpSC5jYWxsKGIsYykmJiFJLmhhc093blByb3BlcnR5KGMpJiYoZFtjXT1iW2NdKTt2YXIgZj1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWYpZC5jaGlsZHJlbj1lO2Vsc2UgaWYoMTxmKXtmb3IodmFyIGg9QXJyYXkoZiksbD0wO2w8ZjtsKyspaFtsXT1hcmd1bWVudHNbbCsyXTtkLmNoaWxkcmVuPWh9aWYoYSYmYS5kZWZhdWx0UHJvcHMpZm9yKGMgaW4gZj1hLmRlZmF1bHRQcm9wcyxmKXZvaWQgMD09PWRbY10mJihkW2NdPWZbY10pO3JldHVybnskJHR5cGVvZjpyLHR5cGU6YSxrZXk6ZyxyZWY6ayxwcm9wczpkLF9vd25lcjpHLmN1cnJlbnR9fWZ1bmN0aW9uIEsoYSl7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmYS4kJHR5cGVvZj09PXJ9XG5mdW5jdGlvbiBlc2NhcGUoYSl7dmFyIGI9e1wiXFx4M2RcIjpcIlxceDNkMFwiLFwiOlwiOlwiXFx4M2QyXCJ9O3JldHVyblwiJFwiKyhcIlwiK2EpLnJlcGxhY2UoL1s9Ol0vZyxmdW5jdGlvbihhKXtyZXR1cm4gYlthXX0pfXZhciBMPS9cXC8rL2csTT1bXTtmdW5jdGlvbiBOKGEsYixlLGMpe2lmKE0ubGVuZ3RoKXt2YXIgZD1NLnBvcCgpO2QucmVzdWx0PWE7ZC5rZXlQcmVmaXg9YjtkLmZ1bmM9ZTtkLmNvbnRleHQ9YztkLmNvdW50PTA7cmV0dXJuIGR9cmV0dXJue3Jlc3VsdDphLGtleVByZWZpeDpiLGZ1bmM6ZSxjb250ZXh0OmMsY291bnQ6MH19ZnVuY3Rpb24gTyhhKXthLnJlc3VsdD1udWxsO2Eua2V5UHJlZml4PW51bGw7YS5mdW5jPW51bGw7YS5jb250ZXh0PW51bGw7YS5jb3VudD0wOzEwPk0ubGVuZ3RoJiZNLnB1c2goYSl9XG5mdW5jdGlvbiBQKGEsYixlLGMpe3ZhciBkPXR5cGVvZiBhO2lmKFwidW5kZWZpbmVkXCI9PT1kfHxcImJvb2xlYW5cIj09PWQpYT1udWxsO3ZhciBnPSExO2lmKG51bGw9PT1hKWc9ITA7ZWxzZSBzd2l0Y2goZCl7Y2FzZSBcInN0cmluZ1wiOmNhc2UgXCJudW1iZXJcIjpnPSEwO2JyZWFrO2Nhc2UgXCJvYmplY3RcIjpzd2l0Y2goYS4kJHR5cGVvZil7Y2FzZSByOmNhc2UgdDpjYXNlIHU6Y2FzZSB2Omc9ITB9fWlmKGcpcmV0dXJuIGUoYyxhLFwiXCI9PT1iP1wiLlwiK1EoYSwwKTpiKSwxO2c9MDtiPVwiXCI9PT1iP1wiLlwiOmIrXCI6XCI7aWYoQXJyYXkuaXNBcnJheShhKSlmb3IodmFyIGs9MDtrPGEubGVuZ3RoO2srKyl7ZD1hW2tdO3ZhciBmPWIrUShkLGspO2crPVAoZCxmLGUsYyl9ZWxzZSBpZihudWxsPT09YXx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhP2Y9bnVsbDooZj14JiZhW3hdfHxhW1wiQEBpdGVyYXRvclwiXSxmPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBmP2Y6bnVsbCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGYpZm9yKGE9XG5mLmNhbGwoYSksaz0wOyEoZD1hLm5leHQoKSkuZG9uZTspZD1kLnZhbHVlLGY9YitRKGQsaysrKSxnKz1QKGQsZixlLGMpO2Vsc2VcIm9iamVjdFwiPT09ZCYmKGU9XCJcIithLHkoXCIzMVwiLFwiW29iamVjdCBPYmplY3RdXCI9PT1lP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYSkuam9pbihcIiwgXCIpK1wifVwiOmUsXCJcIikpO3JldHVybiBnfWZ1bmN0aW9uIFEoYSxiKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZudWxsIT1hLmtleT9lc2NhcGUoYS5rZXkpOmIudG9TdHJpbmcoMzYpfWZ1bmN0aW9uIFIoYSxiKXthLmZ1bmMuY2FsbChhLmNvbnRleHQsYixhLmNvdW50KyspfVxuZnVuY3Rpb24gUyhhLGIsZSl7dmFyIGM9YS5yZXN1bHQsZD1hLmtleVByZWZpeDthPWEuZnVuYy5jYWxsKGEuY29udGV4dCxiLGEuY291bnQrKyk7QXJyYXkuaXNBcnJheShhKT9UKGEsYyxlLHAudGhhdFJldHVybnNBcmd1bWVudCk6bnVsbCE9YSYmKEsoYSkmJihiPWQrKCFhLmtleXx8YiYmYi5rZXk9PT1hLmtleT9cIlwiOihcIlwiK2Eua2V5KS5yZXBsYWNlKEwsXCIkXFx4MjYvXCIpK1wiL1wiKStlLGE9eyQkdHlwZW9mOnIsdHlwZTphLnR5cGUsa2V5OmIscmVmOmEucmVmLHByb3BzOmEucHJvcHMsX293bmVyOmEuX293bmVyfSksYy5wdXNoKGEpKX1mdW5jdGlvbiBUKGEsYixlLGMsZCl7dmFyIGc9XCJcIjtudWxsIT1lJiYoZz0oXCJcIitlKS5yZXBsYWNlKEwsXCIkXFx4MjYvXCIpK1wiL1wiKTtiPU4oYixnLGMsZCk7bnVsbD09YXx8UChhLFwiXCIsUyxiKTtPKGIpfVxudmFyIFU9e0NoaWxkcmVuOnttYXA6ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGw9PWEpcmV0dXJuIGE7dmFyIGM9W107VChhLGMsbnVsbCxiLGUpO3JldHVybiBjfSxmb3JFYWNoOmZ1bmN0aW9uKGEsYixlKXtpZihudWxsPT1hKXJldHVybiBhO2I9TihudWxsLG51bGwsYixlKTtudWxsPT1hfHxQKGEsXCJcIixSLGIpO08oYil9LGNvdW50OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hPzA6UChhLFwiXCIscC50aGF0UmV0dXJuc051bGwsbnVsbCl9LHRvQXJyYXk6ZnVuY3Rpb24oYSl7dmFyIGI9W107VChhLGIsbnVsbCxwLnRoYXRSZXR1cm5zQXJndW1lbnQpO3JldHVybiBifSxvbmx5OmZ1bmN0aW9uKGEpe0soYSk/dm9pZCAwOnkoXCIxNDNcIik7cmV0dXJuIGF9fSxDb21wb25lbnQ6QSxQdXJlQ29tcG9uZW50OkIsdW5zdGFibGVfQXN5bmNDb21wb25lbnQ6RSxGcmFnbWVudDp3LGNyZWF0ZUVsZW1lbnQ6SixjbG9uZUVsZW1lbnQ6ZnVuY3Rpb24oYSxiLGUpe3ZhciBjPW0oe30sYS5wcm9wcyksXG5kPWEua2V5LGc9YS5yZWYsaz1hLl9vd25lcjtpZihudWxsIT1iKXt2b2lkIDAhPT1iLnJlZiYmKGc9Yi5yZWYsaz1HLmN1cnJlbnQpO3ZvaWQgMCE9PWIua2V5JiYoZD1cIlwiK2Iua2V5KTtpZihhLnR5cGUmJmEudHlwZS5kZWZhdWx0UHJvcHMpdmFyIGY9YS50eXBlLmRlZmF1bHRQcm9wcztmb3IoaCBpbiBiKUguY2FsbChiLGgpJiYhSS5oYXNPd25Qcm9wZXJ0eShoKSYmKGNbaF09dm9pZCAwPT09YltoXSYmdm9pZCAwIT09Zj9mW2hdOmJbaF0pfXZhciBoPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09aCljLmNoaWxkcmVuPWU7ZWxzZSBpZigxPGgpe2Y9QXJyYXkoaCk7Zm9yKHZhciBsPTA7bDxoO2wrKylmW2xdPWFyZ3VtZW50c1tsKzJdO2MuY2hpbGRyZW49Zn1yZXR1cm57JCR0eXBlb2Y6cix0eXBlOmEudHlwZSxrZXk6ZCxyZWY6Zyxwcm9wczpjLF9vd25lcjprfX0sY3JlYXRlRmFjdG9yeTpmdW5jdGlvbihhKXt2YXIgYj1KLmJpbmQobnVsbCxhKTtiLnR5cGU9YTtyZXR1cm4gYn0sXG5pc1ZhbGlkRWxlbWVudDpLLHZlcnNpb246XCIxNi4yLjBcIixfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDp7UmVhY3RDdXJyZW50T3duZXI6Ryxhc3NpZ246bX19LFY9T2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDpVfSksVz1WJiZVfHxWO21vZHVsZS5leHBvcnRzPVdbXCJkZWZhdWx0XCJdP1dbXCJkZWZhdWx0XCJdOlc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMi4wJztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ107XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfQ0FMTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuY2FsbCcpIDogMHhlYWM4O1xudmFyIFJFQUNUX1JFVFVSTl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucmV0dXJuJykgOiAweGVhYzk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyAnLicgKyBjYWxsZXJOYW1lO1xuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgLy8gRHVwbGljYXRlZCBmcm9tIENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG5mdW5jdGlvbiBBc3luY0NvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gQ29tcG9uZW50LlxuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIGFzeW5jQ29tcG9uZW50UHJvdG90eXBlID0gQXN5bmNDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzeW5jQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKGFzeW5jQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9IHRydWU7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcblxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcblxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pO1xuICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTtcbiAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIHByb3BzID0ge307XG5cbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBSZWFjdEVsZW1lbnRzIG9mIGEgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZmFjdG9yeVxuICovXG5cblxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmO1xuICAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIGNvbXBvbmVudC5cbiAqIEBmaW5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcblxue1xuICAvLyBDb21wb25lbnQgdGhhdCBpcyBiZWluZyB3b3JrZWQgb25cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuICAgIGlmIChpbXBsKSB7XG4gICAgICByZXR1cm4gaW1wbCgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxudmFyIFBPT0xfU0laRSA9IDEwO1xudmFyIHRyYXZlcnNlQ29udGV4dFBvb2wgPSBbXTtcbmZ1bmN0aW9uIGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IHRyYXZlcnNlQ29udGV4dFBvb2wucG9wKCk7XG4gICAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbWFwRnVuY3Rpb247XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gICAgcmV0dXJuIHRyYXZlcnNlQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBtYXBSZXN1bHQsXG4gICAgICBrZXlQcmVmaXg6IGtleVByZWZpeCxcbiAgICAgIGZ1bmM6IG1hcEZ1bmN0aW9uLFxuICAgICAgY29udGV4dDogbWFwQ29udGV4dCxcbiAgICAgIGNvdW50OiAwXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCkge1xuICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGggPCBQT09MX1NJWkUpIHtcbiAgICB0cmF2ZXJzZUNvbnRleHRQb29sLnB1c2godHJhdmVyc2VDb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50ICE9PSBudWxsICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG57XG4gIHZhciBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5cbiAgdmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG5cbiAgdmFyIGdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyNlbXB0eSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJyN0ZXh0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICByZXR1cm4gJ1JlYWN0LkZyYWdtZW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnO1xuICAgIGlmIChjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXREaXNwbGF5TmFtZShjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCk7XG4gICAgICB2YXIgb3duZXIgPSBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fb3duZXI7XG4gICAgICBzdGFjayArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIGdldENvbXBvbmVudE5hbWUob3duZXIpKTtcbiAgICB9XG4gICAgc3RhY2sgKz0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBWQUxJRF9GUkFHTUVOVF9QUk9QUyA9IG5ldyBNYXAoW1snY2hpbGRyZW4nLCB0cnVlXSwgWydrZXknLCB0cnVlXV0pO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudFByb3BzLl9fc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudFByb3BzLl9fc291cmNlO1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSAnXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lcikgKyAnLic7XG4gIH1cblxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4lcycsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIHZhciBwcm9wVHlwZXMgPSBjb21wb25lbnRDbGFzcy5wcm9wVHlwZXM7XG4gIGlmIChwcm9wVHlwZXMpIHtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0pO1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbiAgfSBlbHNlIGlmIChjb21wb25lbnRDbGFzcy5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIG5hbWUgfHwgJ1Vua25vd24nKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZnJhZ21lbnQ7XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoIVZBTElEX0ZSQUdNRU5UX1BST1BTLmhhcyhrZXkpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJXMnLCBrZXksIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yWydyZXR1cm4nXSkge1xuICAgICAgICBfaXRlcmF0b3JbJ3JldHVybiddKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJXMnLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnIHx8IHR5cGVvZiB0eXBlID09PSAnbnVtYmVyJztcbiAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0ocHJvcHMpO1xuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgaW5mbyArPSBnZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG5cbiAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3ltYm9sJyAmJiB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG52YXIgUmVhY3QgPSB7XG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gICAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUHVyZUNvbXBvbmVudCxcbiAgdW5zdGFibGVfQXN5bmNDb21wb25lbnQ6IEFzeW5jQ29tcG9uZW50LFxuXG4gIEZyYWdtZW50OiBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uLFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gICAgYXNzaWduOiBfYXNzaWduXG4gIH1cbn07XG5cbntcbiAgX2Fzc2lnbihSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCwge1xuICAgIC8vIFRoZXNlIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gcHJvZHVjdGlvbi5cbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lOiBSZWFjdERlYnVnQ3VycmVudEZyYW1lLFxuICAgIC8vIFNoaW0gZm9yIFJlYWN0IERPTSAxNi4wLjAgd2hpY2ggc3RpbGwgZGVzdHJ1Y3R1cmVkIChidXQgbm90IHVzZWQpIHRoaXMuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LjAuXG4gICAgUmVhY3RDb21wb25lbnRUcmVlSG9vazoge31cbiAgfSk7XG59XG5cblxuXG52YXIgUmVhY3QkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdFxufSk7XG5cbnZhciBSZWFjdCQzID0gKCBSZWFjdCQyICYmIFJlYWN0ICkgfHwgUmVhY3QkMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3QgPSBSZWFjdCQzWydkZWZhdWx0J10gPyBSZWFjdCQzWydkZWZhdWx0J10gOiBSZWFjdCQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0O1xuICB9KSgpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB2ZXJ0IGZyb20gXCIuL3ZlcnRleFNoYWRlci5nbHNsXCI7XG5pbXBvcnQgZnJhZyBmcm9tIFwiLi9mcmFnbWVudFNoYWRlci5nbHNsXCI7XG5pbXBvcnQgbG9hZFRleCBmcm9tIFwiLi90ZXh0dXJlLmpwZ1wiO1xuY29uc3Qgd2ViR0xTdGFydCA9IChjYW52YXMsIGdsLCB2cywgZnMpID0+IHtcbiAgY29uc3QgY3JlYXRlX3Byb2dyYW0gPSAodnMsIGZzKSA9PiB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdnMpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcyk7XG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgaWYgKGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY3JlYXRlX3NoYWRlciA9ICh0ZXh0LCB0eXBlKSA9PiB7XG4gICAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHRleHQpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICBpZiAoZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICByZXR1cm4gc2hhZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbGVydChnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgY29uc29sZS5sb2coZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNyZWF0ZV92Ym8gPSBkYXRhID0+IHtcbiAgICBjb25zdCB2Ym8gPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdmJvKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShkYXRhKSwgZ2wuRFlOQU1JQ19DT1BZKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgcmV0dXJuIHZibztcbiAgfTtcbiAgY29uc3QgY3JlYXRlX2libyA9IGRhdGEgPT4ge1xuICAgIGNvbnN0IGlibyA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGlibyk7XG4gICAgZ2wuYnVmZmVyRGF0YShcbiAgICAgIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLFxuICAgICAgbmV3IEludDE2QXJyYXkoZGF0YSksXG4gICAgICBnbC5TVEFUSUNfRFJBV1xuICAgICk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgcmV0dXJuIGlibztcbiAgfTtcbiAgY29uc3Qgc2V0X2F0dHJpYnV0ZSA9ICh2Ym8sIGF0dEwsIGF0dFMpID0+IHtcbiAgICB2Ym8uZm9yRWFjaCgoZSwgaSwgYSkgPT4ge1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGUpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0TFtpXSk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dExbaV0sIGF0dFNbaV0sIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgfSk7XG4gIH07XG4gIGxldCB0ZXh0dXJlO1xuICBjb25zdCBjcmVhdGVfdGV4dHVyZSA9ICgpID0+IHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTsgICAgXG4gICAgaW1nLnNyYyA9IGxvYWRUZXg7XG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHRleCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleCk7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGltZyk7XG4gICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgICAgdGV4dHVyZSA9IHRleDtcbiAgICB9O1xuICB9O1xuICBjb25zdCBwcmcgPSBjcmVhdGVfcHJvZ3JhbShcbiAgICBjcmVhdGVfc2hhZGVyKHZzLCBnbC5WRVJURVhfU0hBREVSKSxcbiAgICBjcmVhdGVfc2hhZGVyKGZzLCBnbC5GUkFHTUVOVF9TSEFERVIpXG4gICk7XG4gIGNvbnN0IHVuaUxvY2F0aW9uID0gW107XG4gIHVuaUxvY2F0aW9uWzBdID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByZywgXCJ0aW1lXCIpO1xuICB1bmlMb2NhdGlvblsxXSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcmcsIFwicmVzb2x1dGlvblwiKTtcbiAgdW5pTG9jYXRpb25bMl0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJnLCBcInRleFwiKTtcblxuICBjb25zdCBwb3NpdGlvbiA9IFtcbiAgICAtMS4wLFxuICAgIDEuMCxcbiAgICAwLjAsXG4gICAgMS4wLFxuICAgIDEuMCxcbiAgICAwLjAsXG4gICAgLTEuMCxcbiAgICAtMS4wLFxuICAgIDAuMCxcbiAgICAxLjAsXG4gICAgLTEuMCxcbiAgICAwLjBcbiAgXTtcblxuICBjb25zdCB2UG9zaXRpb24gPSBjcmVhdGVfdmJvKHBvc2l0aW9uLCBnbCk7XG4gIGNvbnN0IGF0dExvY2F0aW9uID0gbmV3IEFycmF5KCk7XG4gIGF0dExvY2F0aW9uWzBdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJnLCBcInBvc2l0aW9uXCIpO1xuICBjb25zdCBhdHRTdHJpZGUgPSBuZXcgQXJyYXkoKTtcbiAgYXR0U3RyaWRlWzBdID0gMztcbiAgc2V0X2F0dHJpYnV0ZShbdlBvc2l0aW9uXSwgYXR0TG9jYXRpb24sIGF0dFN0cmlkZSwgZ2wpO1xuICBjb25zdCBpbmRleCA9IFswLCAyLCAxLCAxLCAyLCAzXTtcbiAgY29uc3QgdkluZGV4ID0gY3JlYXRlX2libyhpbmRleCk7XG4gIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHZJbmRleCk7XG4gIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICBjcmVhdGVfdGV4dHVyZSgpO1xuICBnbC5jbGVhckNvbG9yKDAuMCwgMC4wLCAwLjAsIDEuMCk7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBjb25zdCByZW5kZXIgPSAoKSA9PiB7XG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgZ2wudW5pZm9ybTFmKHVuaUxvY2F0aW9uWzBdLCAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWUpICogMC4wMDEpO1xuICAgIGdsLnVuaWZvcm0yZnYodW5pTG9jYXRpb25bMV0sIFtjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHRdKTtcbiAgICBnbC51bmlmb3JtMWkodW5pTG9jYXRpb25bMl0sIDApO1xuICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGluZGV4Lmxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgIGdsLmZsdXNoKCk7XG4gIH07XG4gIHJldHVybiByZW5kZXI7XG59O1xuXG5jbGFzcyBDcmVhdGVDYW52YXMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IDA7XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51cGRhdGVDYW52YXMoKTtcbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlcXVlc3RJZCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlQ2FudmFzKCkge1xuICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5wcm9wcy5zdHlsZS53aWR0aDtcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLnByb3BzLnN0eWxlLmhlaWdodDtcbiAgICB0aGlzLmdsID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiKTtcbiAgICBjb25zdCByZW5kZXIgPSB3ZWJHTFN0YXJ0KHRoaXMuY2FudmFzLCB0aGlzLmdsLCB2ZXJ0KCksIGZyYWcoKSk7XG4gICAgY29uc3QgbG9vcCA9ICgpID0+IHtcbiAgICAgIHJlbmRlcigpO1xuICAgICAgdGhpcy5yZXF1ZXN0SWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgfTtcbiAgICBsb29wKCk7XG4gIH1cbiAgaGFuZGxlUmVzaXplKHcsIGgpIHtcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHc7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaDtcbiAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHcsIGgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGNhbnZhc1xuICAgICAgICB7Li4udGhpcy5wcm9wc31cbiAgICAgICAgcmVmPXtlID0+IHtcbiAgICAgICAgICB0aGlzLmNhbnZhcyA9IGU7XG4gICAgICAgIH19XG4gICAgICAvPlxuICAgICk7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IENyZWF0ZUNhbnZhcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jcmVhdGVDYW52YXMuanN4IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiKTtcblxudmFyIF9hc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzaWduKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX2Fzc2lnbjIuZGVmYXVsdCB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKClcbik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9wcm9taXNlID0gcmVxdWlyZShcIi4uL2NvcmUtanMvcHJvbWlzZVwiKTtcblxudmFyIF9wcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb21pc2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gbmV3IF9wcm9taXNlMi5kZWZhdWx0KGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gX3Byb21pc2UyLmRlZmF1bHQucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBzdGVwKFwidGhyb3dcIiwgZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RlcChcIm5leHRcIik7XG4gICAgfSk7XG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2VcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5wcm9taXNlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnByb21pc2UudHJ5Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5Qcm9taXNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciB0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyICRQcm9taXNlID0gZ2xvYmFsW1BST01JU0VdO1xudmFyIGlzTm9kZSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xudmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIEludGVybmFsLCBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIE93blByb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcblxudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSA9ICRQcm9taXNlLnJlc29sdmUoMSk7XG4gICAgdmFyIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbiAoZXhlYykge1xuICAgICAgZXhlYyhlbXB0eSwgZW1wdHkpO1xuICAgIH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHByb21pc2UsIGlzUmVqZWN0KSB7XG4gIGlmIChwcm9taXNlLl9uKSByZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIG9rID0gcHJvbWlzZS5fcyA9PSAxO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHJlYWN0aW9uKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faCA9PSAyKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSBydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpIG9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgdW5oYW5kbGVkID0gaXNVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgdmFyIHJlc3VsdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZiAodW5oYW5kbGVkKSB7XG4gICAgICByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pIHtcbiAgICAgICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZSB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmICh1bmhhbmRsZWQgJiYgcmVzdWx0LmUpIHRocm93IHJlc3VsdC52O1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICByZXR1cm4gcHJvbWlzZS5faCAhPT0gMSAmJiAocHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jKS5sZW5ndGggPT09IDA7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpIHtcbiAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3YgfSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICBwcm9taXNlLl9zID0gMjtcbiAgaWYgKCFwcm9taXNlLl9hKSBwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgdmFyIHRoZW47XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmICh0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgJHJlamVjdC5jYWxsKHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9LCBlKTsgLy8gd3JhcFxuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJFByb21pc2UsIFBST01JU0UsICdfaCcpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoY3R4KCRyZXNvbHZlLCB0aGlzLCAxKSwgY3R4KCRyZWplY3QsIHRoaXMsIDEpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9hKSB0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX3MpIG5vdGlmeSh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gJFByb21pc2UgfHwgQyA9PT0gV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFByb21pc2U6ICRQcm9taXNlIH0pO1xucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKTtcbiAgICB2YXIgJCRyZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoTElCUkFSWSAmJiB0aGlzID09PSBXcmFwcGVyID8gJFByb21pc2UgOiB0aGlzLCB4KTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyICRpbmRleCA9IGluZGV4Kys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1skaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCkge1xuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIEJSRUFLID0ge307XG52YXIgUkVUVVJOID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1IpIHtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpO1xuICB2YXIgZiA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZiAoaXNBcnJheUl0ZXIoaXRlckZuKSkgZm9yIChsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTspIHtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBPYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYgKGlzTm9kZSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyBTYWZhcmkgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIH0gZWxzZSBpZiAoT2JzZXJ2ZXIgJiYgIShnbG9iYWwubmF2aWdhdG9yICYmIGdsb2JhbC5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkpIHtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmIChQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSkge1xuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZiAoIWhlYWQpIHtcbiAgICAgIGhlYWQgPSB0YXNrO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfSBsYXN0ID0gdGFzaztcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWljcm90YXNrLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgc2FmZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgaWYgKHNhZmUgJiYgdGFyZ2V0W2tleV0pIHRhcmdldFtrZXldID0gc3JjW2tleV07XG4gICAgZWxzZSBoaWRlKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH0gcmV0dXJuIHRhcmdldDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgQyA9IHR5cGVvZiBjb3JlW0tFWV0gPT0gJ2Z1bmN0aW9uJyA/IGNvcmVbS0VZXSA6IGdsb2JhbFtLRVldO1xuICBpZiAoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkgZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS1maW5hbGx5XG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnUHJvbWlzZScsIHsgJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSk7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHg7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHksXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyBlOyB9KTtcbiAgICB9IDogb25GaW5hbGx5XG4gICk7XG59IH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseS5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtdHJ5XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUHJvbWlzZScsIHsgJ3RyeSc6IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYodGhpcyk7XG4gIHZhciByZXN1bHQgPSBwZXJmb3JtKGNhbGxiYWNrZm4pO1xuICAocmVzdWx0LmUgPyBwcm9taXNlQ2FwYWJpbGl0eS5yZWplY3QgOiBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlKShyZXN1bHQudik7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeS5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtyZXR1cm4oWycjdmVyc2lvbiAzMDAgZXMnLCdpbiB2ZWMzIHBvc2l0aW9uOycsJ3ZvaWQgbWFpbih2b2lkKXsnLCcgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAxLjApOycsJ30nXS5qb2luKCdcXG4nKSl9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVydGV4U2hhZGVyLmdsc2xcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7cmV0dXJuKFsnI3ZlcnNpb24gMzAwIGVzJywncHJlY2lzaW9uIGhpZ2hwIGZsb2F0OycsJ3VuaWZvcm0gZmxvYXQgdGltZTsnLCd1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjsnLCd1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7Jywnb3V0IHZlYzQgb3V0Q29sb3I7JywnI2RlZmluZSBQSSAzLjE0MTU5MicsJ2Zsb2F0IHJhbmRvbSh2ZWMyIHApeycsJyAgICBmbG9hdCBxID0gZG90KHAsdmVjMigxMjcuMSwzMTEuNykpOycsJyAgICByZXR1cm4gZnJhY3Qoc2luKHEpKjQzNy41Myk7JywnfScsJ3ZlYzQgZ2xpdGNoKHZlYzIgcCl7JywnICAgIGZsb2F0IGI9MC41OycsJyAgICB2ZWM0IGM9dGV4dHVyZSh0ZXgscCk7JywnICAgZmxvYXQgdD10aW1lLW1vZCh0aW1lLDAuMyk7JywnICAgIHZlYzIgcT1wLW1vZChwLGIpOycsJyAgICBmb3IoZmxvYXQgaT0wLjA7aTwxNS4wO2krKyl7JywnICAgICAgIGlmKHJhbmRvbShxKT4wLjMpeycsJyAgICAgICAgICAgcT1wLW1vZChwLGIpOycsJyAgICAgICB9ZWxzZXsnLCcgICAgICAgICAgIGJyZWFrOycsJyAgICAgICB9JywnICAgICAgICBiKj1yYW5kb20odmVjMihtb2QodGltZSwxLjUpKSk8MC4zPzEuMDpjbGFtcChzaW4odC8xMC4wLTUuNSksMC42NS1yYW5kb20odmVjMih0LzEwLjAtNS41KSksMC42NStyYW5kb20odmVjMih0LzEwLjAtNS41KSkpOycsJyAgICAgIC8vIGIqPTAuNjU7JywnICAgIH0nLCcgICAgYy5hLT1yYW5kb20odmVjMihtb2QodGltZSwxLjUpKSk8MC4zPzAuMDowLjMqcmFuZG9tKHEpOycsJyAgICBjLnJnYis9cmFuZG9tKHZlYzIobW9kKHRpbWUsMS41KSkpPDAuMz92ZWMzKDAuMCk6dmVjMyhyYW5kb20ocSkscmFuZG9tKHZlYzIocS55LDAuMCkpLHJhbmRvbSh2ZWMyKDAuMCxxLngpKSk7JywnICAgIGMucmdiLT1yYW5kb20odmVjMihtb2QodGltZSwxLjUpKSk8MC4zICYmIHJhbmRvbShxKTwwLjAxID8gdmVjMygwLjApOnRleHR1cmUodGV4LHArdmVjMihyYW5kb20ocSksMC4wKSkucmdiOycsJyAgICBjLnh5ei09cmFuZG9tKHZlYzIobW9kKHRpbWUsMS41KSkpPDAuMz92ZWMzKDAuMCk6dmVjMygwLjMqcmFuZG9tKHZlYzIoMC4wLHAueSt0aW1lLzEwLjApKSk7JywnICAgIGMueHl6LT1yYW5kb20odmVjMigwLjAscC55LXRpbWUvNS4wLW1vZChwLnktdGltZS81LjAsMC4wMikpKT4wLjk/dGV4dHVyZSh0ZXgscCt2ZWMyKDAuMCxyYW5kb20ocSkpKS5yZ2I6dmVjMygwLjApOycsJyAgICByZXR1cm4gYzsnLCd9Jywndm9pZCBtYWluKHZvaWQpeycsJyAgICB2ZWMyIHA9dmVjMihnbF9GcmFnQ29vcmQueC9yZXNvbHV0aW9uLngsLWdsX0ZyYWdDb29yZC55L3Jlc29sdXRpb24ueSk7JywnICAgIHZlYzQgY29sb3I9Z2xpdGNoKHApOycsJyAgICBvdXRDb2xvciA9IGNvbG9yOycsJ30nXS5qb2luKCdcXG4nKSl9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZnJhZ21lbnRTaGFkZXIuZ2xzbFxuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBZ0FBWkFCa0FBRC83QUFSUkhWamEza0FBUUFFQUFBQVJnQUEvKzRBRGtGa2IySmxBR1RBQUFBQUFmL2JBSVFBQkFNREF3TURCQU1EQkFZRUF3UUdCd1VFQkFVSENBWUdCd1lHQ0FvSUNRa0pDUWdLQ2d3TURBd01DZ3dNRFEwTURCRVJFUkVSRkJRVUZCUVVGQlFVRkFFRUJRVUlCd2dQQ2dvUEZBNE9EaFFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVS84QUFFUWdDcUFRQUF3RVJBQUlSQVFNUkFmL0VBTUlBQUFJQ0F3RUJBUUFBQUFBQUFBQUFBQVVHQkFjQ0F3Z0JBQWtCQUFFRkFRRUFBQUFBQUFBQUFBQUFBQVFBQVFJREJRWUhFQUFDQVFNREF3SUVCQVFEQmdRREFSRUJBZ01SQkFVQUlSSXhFd1pCSWxGaEZBZHhnVElqa2FGQ0ZiRlNDTUZpY2pNa0Z0SGhna1B3OFpLaUpWTTBGN0pqUk1Kemc5S2pOU1pVZEJnUkFBSUNBUU1DQkFRRUJRUUNBZ0VCQ1FBQkVRSURJUklFTVVGUllTSUZjWUdSRS9DaHNUTEIwZUZDRlBGU0l3Wmljak1Wa29LeUpEU2lROExTVXlYLzJnQU1Bd0VBQWhFREVRQS9BRUM5c09YNlBRNzZ4anAyZ0JlaDRYb0tqME9wSkZiY0dDU1NEanlQS28yMDhEU1NVTWhOV0czb05SSkptN2c1M3BUVFFUTmJvU2FuVGlQR1FGS2JiYVF4Q2tGSDl1cElpekpLTnQ2NllTSnFSa0tPWFU2WWtpWWtaa1ZRT3Z4MUVrRXJPQW8xRHFMSklKYzZBbnBwaVRNN1NZQmlvNm5TYUlKam5ocEdFYWtVcnBpeEZqWTVKVmhqbFBROUI4Tk1PV05nYmgyaUhxdEs2blZ3WnVlcWtZbzVhZmg2YXZUQTJpUXJqODlUVEdQR2NEU2JFYUdrclVBYWkyS0NOUE1Ja0xIb05RYkxLMWxnS2E3WjNvcDJKMUFNclhRWXJWeUlVcU9vR3JFOUFLeTFaS1IrVzJyRXlCdEJGQ05XU01ZTVFCdHRxRGNpSVYweDdVaFBSUVRxcTNRblhxVTU1WmsyU1oxVWtWSnIvczBPYlZkRUlHUnl3NG5rZWc2RFR3S1JlZkx0M1BhZGlkTkF0dzZlUDVTS1ZVV1FlNm14MVRaRjFXRk1xdTZVNkhVRVRabytuNVd6U1NEVWt5TFF1WkdPT0xreC9TZjhkV0prR2haZklLa3BVYkxValVpdVNUQVJjU0JnMzRhUTZKRTBNaW5rT2dIcHBJVFBVdXBFQTUvcDZVMDRwQ3RrL3VWMTZmRFVXU0d1QzZhUzJDVm9RTnE2ckxFQzdvaCtYSnFrYWRETmczaTQ5dy9UcHlLWjZpY3lOdjRhZUNSOWRXS1R3dEc2NzAwa3hOQ05rL0gxcXdSZWxmbnExTW9kUlR1TUllNGFDbjVhczNGYnFSWk1TVUZRQlg4TlBKSGFhVXN5dGFyditHbmthRGRIYVNkQWgwekhnbVFZeG1IdUh1T295U2dsSmg5dDlOSThHdDhaeHJRYVVpZzFtdzRqY0hTa1VFZG9TRzJCMDhpTWt0cEhOQU5OdUhKY1dOYzlkTTJJbGl5MkNIVVpIZytPSU1qK3lsZEtSUWIvQU8xQ01CVzYrdWxKTGFTSXJZSXAwdzVtbzRtbE45SWM4bFVWNWtVOUthUWpWeVU3YVEwbnFnVjIwaEdUUnFScENreCtuQkJKMGh0RFgyZ0RwRHdaMVlDZzZhUWpVODVqNi93MGhwSXpYRzUwaG16WkJlbU5xZzAwOEMzQnEyeVhJQStwOU5OQktRcXQ2clI3K25wcG9KU0ZzY2VhVjY4dW1tWkpNT1FRaEY1RUVFalVDWXU1YXNTU0g0bm9OU1JDd24zaUZoU2xLYjAxTXJZS25qSTM5T21uSU0wMElHK25HUGVCcHBEbWNjZGV1bUhNWkk0eDAwNHhGWTc2ZERHdG1vTnZYVGlOQlNvcnB4bWFtajlScVJFOFdQMTB3aVRIRVRYVFNTUkxoZzNBSHg5ZE5JNFVnZzkyOU5SSFJLN1pwL3MwaHlIY0FpdnhwcEVRWE1TcDM5TlNRaUFkeWZqcVJBeENiMDlkSVlsUW8xYUhTSkJHS0ptNkRVV1RDRU1OQjAxQ1J5YXNGRjVlcDB3OEd4WWhXcDMwaEVxS0lzMzh0SWNJUVFBTlhTSEp0eGRXV0x0R3ZiNXhGQ05nVDFMQVZvQjZuUW1iSy8yMTYvb0ZZY08vVjlEbjM3ai9BSFd1OG5LMXBpcnB2b1VmdHNLa2NsNkZmalErdngrUTFkeGVGL2RmcXlybSs0VnhyYmpZbC9ieThpeS9sMDl6azVvemtwS05hU1QyNjNDSzlSWGlwWlZWZ285bnRJOUtEcm9qbjEyWUlxdE84T1B4NWczcytSNXVYTm42bjBiVS93Q25rWFNQK2t5MTgyUWFKN0JUU3lpSko0ZTBFZ3I2L05qWGZYSVd0dW9vNjl6MC9GeHJiMjdCQ0tSR01kd3NVYzhZL1Fxa3R3VnZXbS93NjZIYWZRMDRUN2dIeVZvQlpyY1drcGp2UzMvUzJqUjlHNWU1K29JSkg4TkY4ZGF3K2dQblZ0dW5Yc0VmR2NwOWY0L2s4WGUzOFVCdFVlUldZRlFFYU04dHpXdEdwUTZyejR0dDAwdXBTck9aZlh5Rlc0em1Jc280VGRRdGN6U3J4TVNGWWxyVDJuci9BRkVqYjEwYlhCZXpjT0I4L0xwalNuV1JmeWVhdTRyWm9mZGo1V2paRDJTcUZvNjdCcEFBZDY5T3ZUcm8zSGlUdFA3dng0R055T1RaVWFmbzBmNGIvZ2hIbmtpU05EYnhNQ0pHRXM5ZVNOUTFQS1NsU0I2NjE2cHZxemxyMnJWZWxkOVgyODV0MWFJaTVESlJPM0Q5SFNSWTZxaFVHcEpyL1VRZFdQSFJnMWVUbXE5T25sNGQvbVNVL2ZZWFZwSmJtZVp5MXpGL2w1SFlOc0FENm1tdzFCNmFXbnlDS2VyMVVkWmI5Uy9uK3JDMXA0eGYzaU5mU3pXOXBqZ0dZWFY0d2lpQ3hpcjhhN3ZRZFFtaHJjbXFlMUp0K1g0MEQvOEFEczA4bDNXdGZGK1dyangrUk9oazhQZ3g0L3ROZ2M3ZEpJanRQbGVWdFpFQTBDUnhSdXNqVlk5WkNvK1IxVzFtM2V0N2YvWFYvUHQ5QnEzdzN4LzhWTnlucmZvL2d2RDRqRmYrVWVVdmlNYkxEZVJZZ0x5anRiVEVmOU1zYm9CU1I2YmNhKzNpMndIV3JiNkNyZ3c3N0tOM2k3YW1sZXVaNFZObFhzbFhTUFAvQUYwK1lwWkx5eVhNM3l6U2lWYjJkR2x2Wk9jZkNVMFNKV2o0S3JjVzQ4aXAzRlRUV2hUaUxIV0YwWFR5N21kVDNDMTc3WEtsUzlWcXRGcEd1djFBaGpqV2RITTM3ZkpoeVpnaG9tNjFORFNueCtPaVUzSFFDdFNxdEx0cHIrWFNmNWt6QnBrcmE1aHlXSmdrVytzWFdaU2hVOGxVKzBLam1yYkdoSFdtcTh6cFpPdDNvOUMvaVlzaWF2anE5MWRmaXZnOVgrcGFFUGtrZWV2NE0xYjVZSmZsVERjNDBnMnlxL0E5QTVxcWduZHQyT3NDM0grMVYwZGRQSHFkYmg1TmNzV3JmWHZWNmEvUHAvRVEvS2JsTHlXN0N5U3ZmU2hlTGtzeUwyOWl5aHlTRjl2eFB4MXJjV3UxTHBCem51VmxaMlNiM1A2YWQvaC9xYmJXSEdYSXRZYmhVVHRLUk96OG1JSkh2UUU3MEo2Vkg1NmphMTZ5MTM2RDQ4V0s2cktVcGEvMCtZOWVQZWRMZ3c2enRLbHdKcXVKNGdrZHpiTUFBMFlVaFZsUUJkdjYvVFdWbjRUeU9WNGRuMGZuNVA4QUkyTVhOcXZSZlR6YWlWNWVhOFBvV0pKZlFaZXdnemRqQ2J2Z0dtZ3FwalFnTHUzRnFFL0FkQnJHVlhXMjIyak5mSFpOU25vQTQ3akkrUjM5d0pwSHNiSzFVeVJuMklydE1CVW1ReGo4T3Y1NkwyMXhWWGVmeDBrb2EzV2pwQXZabkMzSXduMEsyMzl1dGh6bGE1bXV3WVpPVlNWV1ZpS3NTUFVmOE9qOE9aTzh6TCtHdjBNdmtZcktteExhdmpwOVNYSDVaYmY5azJQbXR4Qk0yUHU1UlpPMXZHMG9GOXhMR0lIb0RRY2hVOU5keDdsdy93REd6N0s2MXN0MUcrOUgzK1hSK2FQTmNYS1ZxS3o2L3dBUlpQM0d3MlVab3JXd3VaajBMTHhEQS9nZHY1NnpuVzFWTGdtczZ1NHFtd2xoc3poSkpHanVaemJTOUZGd3BSYWY4UXFvL002anVrc1RqcU5TWThQeGRhTkd3REt5bXFrSGNFRWJIU0xlcE5URmhsMkh5MHhJMFhHTzRVQVhmVFNLQVRjVzVpWTdVcnFRekJzOGRHQU9uUkZtVWRCNmFUSFJKWi9hQ09tbUhDbU1KWmhVYmJhaXlTR0dHMlZpQ0JUMTFXV294dTRpbFFDYWFTWW1Sb0VJa1ZnS2l2VFVpb2RjRklvNFJ5R20reDFFc1JhbG93ZXlRTHZRVjFBbU5XRHZqSEVpdituK2VweUI1cVNNc04yckdnSTFKV0FYVW1wS0svUFZxc1FhUG1rQTNPazdDU05SblhjVjFHU1VBZkozSVB0VTlldW9OaEdPcEVqaUo0blRKbGpZZGpsYnNvQjFBcHA5d0krcEppbFBRbmZWaXNRYUpJbDJwNjZza2hCZ3oxR21iSE5VckFvVlA5UUlPb05rMFVyOXdjYTBFMXhORFVnTnNCNlYxVWpWcHJWTXA3S3lUVWRqV2dHcENZcnJmSG1hbm9kS0NNamhncjl3b2RXM29LYXFhTDZzZG9Nbzh3aURDb0FwVTZyZ3NrbFh1UTdVTlNSd0k2YVpJZHNRY3pubFZYUk55ZmpxMVZLbllUcEw3bElXSjNKcnF5Q3ZjVDdISW1NamxXbnhHbWFIM0RMWlptM0xCWmFsT2gxRm9tbWc0YlN6dW94TGJrc0Q2SFRFb2szMjFoSXNpOGh4WDAwbUtBaGNudFJoVkozMk5OUkV5Q0xjY1RJR0pZZGRJUnJGWDJKb0IxMDR4c1dlMWlGQVNXR2tTa1NQSWZ2UDRwNDlmVFl5ZFpMaTVoQlhsR1VXTXlnME1ZTG4wOVRTbGR0TlZPM1JGZVRMV25VWnNkZDQzeVhHdzVmRnlyTlozU2NrWVVxcC9xUmg2TXAySTFOcUhBMUxxNmxFT2JDcXNoNUlLSGZjVVA4QVBVcEpRUjdueDZDV0xtRm9lbTJsSTIwQ1M0UUszQUwrQjFPU0VHeUx4MG5kbXA4dXVta2ZhVFlzRVZPMjQxRnNmYWJ6aWVQNmdOTkpLQ0pOandDU1FOdEtTTFJFZTJVQTdEYlRrU0ZKQ2dPNmpTa1JwcDhGMDRqZER5NWU1YUgwMHpFaWFrSVpocGlZU2h0MFQzazdEcnBoekIwUnBBVi9UcENQcmxMZFY5aDMwaEVMdEg5Vk52anB4bVl1QVI3cVUwaEVLYWRFMjA4RFNhbGxKWVU2YVVDa2tDUUhZNllVbnBtRmVJMGhTWU9TZWcwaFNSWm5rVGJvTlNTSXlRSlpaS2FlQmlPOGpOMU9uRWVDVmwzR2xCRnNtMmw2UTRxZHZocU1EcGpMWlRDWlNwOUJzUnFKWW1OK0dTdmJIb0tiNmpZc3FNRnl5QmVJcVBucUVGZ3U1V1B1Q25wcWFLMkxGMWJrTVNmNDZrUUJjOEk0TnR1ZElaa0Y0U0JwNUltQ3J0cHhHUUlVYjZZYzBQME5OT1JJekFrMXB2MDA0alF5dC84QUxVaGpZc1pwdjAwaHpGby9qcERIc2NKcVA5dWtLQ1NzWjJycGh5VERHQXdQd09ta1FTZ0ZEWFVSemFXTmFEcHB4eU5jS0dQS20rbEl6QXR3cExHcDIxTkVXUWlwclQrZW5HTjZRazlPdWtQQVV0TEYzb1NQeDFHUjBndEhZY042ZGRRYkpKRXhJRlZlbSttSlFhcEdLN0RTRVlMSWZYU0lreUNiZ2E5U2R0SWxNRWk3eXVQdzF1MTVsYm1LMmpVY2dKWENHbngzL2xvZTFyVzlOUHIrTzViVjFXdG5vVVQ5eWZ1RGUrUTNjbHJaeU5GWUlQMnVKb3hqSHdvZmF0ZW5xZXAwZHh1S3FLV0E4em50cmJUUkZUWkM1aUFoalZxdkNHa2xwL25ib1B5MW8xcjFNS3pSbDR0UExEZHRORXdXN1E4MHI2SDAwMlpKcUgwSlliT3RwWFZGMFl5OVh5ekZSM2swWWp2TGVsck5NQ0ZySU4xb055YWdmRFhIWjhUNCtTRjBaN0o3WnphYzdBclcvZFhSakJiMytZeDJKSnNGUm1pajdVa29pSE1CRFFjZzM5UTM2N2FDZGEydHFhOXE3YWFhK1lvbSt1N3g1WWJpNGU4YVVrc3hOWFZHTmVJSkZOcStoMzBkc1ZkVW9BVmtibXM3cElscGRNelNXc1RTUnJPQ2JydWU1dUNHaEJXb0hTZy8rRHEyMWU3Qk1kMDNDL01FWktVeEhrakxjUSsxbGFYZmlTUnNhK2hOZlRST05ibDRNRDVGOXIvM0x6N0FNbTR6RWtndVdZSnlLeGNSVlVWaHNRb0Fyc050R2FZMW9ZcjNjbHZlMzEwanQ4Z1lZTHhZbnRrN2hWRFE3a0JRekhxRFRadU5kRXExVzVNdlprVmRxblQ4djlRbmFZSmpFdDlrcjlMWEhrbUl5eXN0R1VEbFQwcnNhN0VuNWFIdG4xMjFyTEQ2Y09Gdnk1Rld2VFdOVitQaWV0ZWVMWXJtbUdqdU05a25VRHVTSjlOWWdyV2pjRFY1YUU3QmdvL0hVdG1hL3dDOXFpK3Ivb0R2a2NmRTJzRlhscy9GUlg0eDFmNUUrMml5dWFodTd2UFNDNXZ1MmlXNWNrUlc0TEQ5dEVYMm9DVkMwVmFlbXFMV3BqYVdQUmQvTTBzSEh5NXEydm45ViszaFh5WFpmUTI0aUJZNTBEQ0dTVUZ6R1hxWXlZenVvQUJxZmtEL0FDMVhsczJ1OGZtR2NTaXJaZEcveTBDR1F1YlczdG10bG1lVElxRmd0NVBhSWlHNU13Q0d0UVRWU2ErdXFNZExOekdnYm55VnJWMW4xZEY0ZlQ5UlR1MWdScHB4V0s3bEJhU1kxQ293b1NObEN0V213WFdsUnR3dXh6bWJiVnUzN2JQcS9EdjRRK25SR2NTZlhyYjhnaW1aVlYya1JRRmlQdS9SVWZqdWRSYjJUNUZ0YS9mVlpqMVIxWGI0ZjFCbDFrTGkwdUk3bXluV1FJU0k1RlVvYXEyMUFlbjVIUk5NU3RXTEtETHo4dStPNnRqc3JmTCtEL2daTm43aHo5U0t5NUtTaXMwbjZsSVBVQVVCMjZhUzQ2NmRLanYzTzc5Zlc3MDEvSDBHN0RaOWNxNXNaWUYvdjdMSXJYWnBDSGpJQU1ZUUFLU3dGQlNsTlptYkI5dGJrL1I0ZFRlNG5OV2Q3TEwvQUpJZXZUVHcrWUh1Mmt4c2sxMGxzNG5DbU5Wa1J4WGxzcFlVNmdHZ1ByNjZKb2xrU3Ezb1orV2NEZDFWejAxVDErUDh4c0Z0L3dCdzJvdlU1L1hZOVk1ck5ZbklidndBRTBGYWJub2V0ZmxyT1YvdFcyOXJkZmd6WXlZdjhtcXQvZFRWYTkwT1hpdWNMV3JUVzJUaHNzM2pvV252TWZPcmkxdmJZKzh6aGhTTkp4V2pLcTFQclN1MmJ5c0VQV3J0V3owYTYxZmg0N1Fyajh1WHRjVFZhK0RYai83ZUpydk0vaDgvZFdWeFl6M0JzWVgrb3ZPUWxlTkJ5NUdTcm50Z0Q5SmFRMEhUOFh4NE1tTk5OTGQyNmY2L1FMeWNyRmVIdTlLK1AraFg5NzVmNEZaMzEvZlhOamVacStFbi93QnoxTngvMDhRRmR1ODNMYjVScFQ0SFczajRmSXRXdFpWVjMwMStuOHprT1I3bnc4ZDdXVlhrdE9qblQ1UCtRcmVQK2MrU1kveHZLZUdXZDNDbmoyWmFLNHVySzVqNXhyYzI3Qm81b2VwamxGS2NsNmpZNjNzOVB1YmR6czFUb3A4ZjRIRTRyUFZLRko5aXZJWmNVNzl0WTdwbTJsbFZTalZKcjY5UitXaDh1RDdpOEEvamN4NExkRllNeWVVSmtaRlhnSVJ4Sk5hQTFIdy84SzZGcnhuWFdaTlYrNDB5eFhiQXgrTS9jS3c4VE1XTmRwY25qWm95VWdQN1QyOXdEV2ltVGJnd3J0L0RSRVd2VnlvYTcrUm5XdlRFMXRlNVA5UjB4WDNkc0picFlwc1VWUW45QXVGTWxQd1pBdjhBOXJWRmswWFV5MnMwby9Nc2JIWHZqdmxHT2JJNGE5alpFWXBQQkl5eHp4U0Rxc2lNYWcveVBvZFJpT3BjckpncklZWGtPYWtNcDZNTndmd0kxSk1hQmV1c2JJakUwcitHcEVXUW10WDlScER5ZUNDUUNsZHRNSUs0NlZZcUNuNGFnMFdKaCszdW01S3ROUWFKcGhPZUVNdklqcU45UkpzaVEyakpWaVArSFRrWURtUGdkZ3JuWXJwaEpENTQvbGpBQmJ6ZTVXNkg0YWFDUTg0NW8zb1FmYjEwaW00Yml1RmpjSGtOOU9ET3NvSWpJUXhMeVpoVFVwS2RqWkhmTDJ4SjR1Q2ZocHBKckN5Rzk4V0pZbW53K0dta3RXTTFMY3h5TU80dzBwSDJ0QktNZ1U0L3AwaWhrMUdVclQwMDVVejBYVU1iOEEzdStIcnAweGJXemExMmlyczRVbjRuVXBHVldiSTVDVkJMQi9tTk9tTTBmTXhZVTB6RUtYa09LUzdXWXNLaDZrNnJZZGh2MktVOHd3QzI4TXdqRlhvYWZucDB3bG9xZTh4N1JjMzZFSGNhc2txZ200eTlhM1VBa2dDbW90RWt4d3h1UTVoZmY2ZE5WdEZxWjluOHF5d0tGWWcwUFRTU0ZabFo1VEpTTklWNWF2cWloc2hSM1JxQ1RweU1reUMrcXdvZHZucG9Ia04ydHlLQmh1ZFJnbU1HSDhnRVRpS1RZZkU2aTZrMVlib00vYXNWQmJsOHdScUVGbTRuUzNFRTZCbFA0NmpBcE1PU0xidnZRK21uRXdiRXpxazh6dC9TUUJweU1nT1M3TERnS2hxNmxCRTVOOCtsVzc4M3pranNXS1hjeWhXUG9qSGIrV3RManFNYWp1WVhMYzVYNUU3eGI3c1ovd0FPeHVSeFdPSU50a0VvanNXRDI4dkhqM0lpT2pVMjMrV2xrNCsvdkFzWEtlUG9nMTl2dnV2NUxaWjYzZ3VyaVM5eHQxS3FUMmt6dEpVU01GcWpPVFJoV29QOGRQOEE0dFhDV2c5T1ZkV2s2cHkrVzhlOGRoaGl6dVJnc0huSkVLM0Q4Uy9IclFiN0N1NTZheXplYlM2bW1TSzJ1ZTFjMnpwTmJUS0hpbGpZT2pLZWhWbHFDTk9OTWttSzBWcUFnVjB4SWxwWktxOHFiK3VrUEJIbHR3dFNSVUhTR0IwMXVwSkZOT01DcnV6VmFtbWxJd0htaUoyR25Rekl2YVpEdWV1bkdOc1pCYmlldW1HQ2RwQ0NkeFUrbW1Kb21TRGdoQjJycGh5Szg2eExVcnZweG1DWnI4czUyMjlOUEJGc3dONkNLQS9rTlBBMGtPNXlRUUZhYjZmYU0yREd2SGNralUxVWpKNWIzc25kb3hxTktCcEpKdmlyYmpUUVB1TjF2Y0NWd2E5ZlRUUVNrT0lpdkdDQlhVR1NOTnhhZ0RjYjZRZ2U5b1hhZ0ZBUFhUeVJQSk1PenFTQ0JwYmg0STdZc3hmcUpPbjNFV2oyR3gvY0JWS1U2NlVqUU1XT3RqR29QcVR0cUxMVU8yTVFvc2JVMkhxZFFaTkUrNG5YYlluL0FHYWFDVFlQbkJscjhUOGRPTUI3MjNGS2tiblVpSUhudHExSzlkUEJFSHlXN0NvcDAwd3hEbGhvZWxOT016UXlrVkduR05YRWs5TlBBajR3MUhUZlRpUGxoUHcwaEh4aGIwR2tJeE1KSm9SMDBoR3dSZ2JEU0VaaEN4MjY2VEViZXk0SElkUFVldW9EbTZKMkZCcENKS3NPdnBwMHhHcVRjLzQ2UWdWZHhDdklldXBJaXpURGI5dy9MVHNZS1cxbnlvdE5NVEdLeXg0V01IanY4ZFFaTklrZG1tNTM5QnBoRWR5dlJhMEdrS1FmTzIrMm5SRmtkcTlkT1JOOTFrSU1IZ0xueUNhUkMwTWdoN1Ric09RNUFxTjZscVUrV3BQQTdwUHNPN3FsZHpPZS9LZkw4cDVaazQ0NzBrUkNRR0syVGNiR3BxVDFQcHJReDRhMFJoWnVSYks5ZWd1WnU3N2Q3Y1J4amxNL3NDTHVhanJxeXEwS2JQVUMzTmtiRzNhNHZBRnU3a25oQy82MVU3MUkvcEg4OU9yUzRRblRhcGZVMmVMUkxMa1R6UHNZQmVTOVJVOVIrR281dEtqNGxMT21NTDROSGJ3U3d3c2pTWE1UWDF2ZEVsUWs4Y2dFUVlWcUNRN0thVUI0NjVibXR1dS9zdjA3bmIreThpdU82by83dnlBZC9sYnF5ZHhOYjl4NVl6SGNXOXp2SFRZTlFWOTNXbFRyTngwVDZQcDRIb2ViTEMxWFVVQTk3WmwxdFptNFNCZ3F5RDJKRWRsNEZxc0tlaDFwZW0zVkdNbGVtbFc0L2g1ZDBScW9aZjNyaDFCS2t5cWVkT3ZPakRpTnExL1BVMU1hSXBiMTFmei9BSytRVHZjUkRNcVM0eEd1SUlCenUza2pQY3Eyd1o2N0VVMnI2YXFwbGEwdG9XNWVPbkRyckhYVFVYOGZiMzBaaXVGc0cvdGtOeVV1YmhsSmpjYiswRmFWUC9DZEdaTFZlaytxTkRJd1Z5VmFhcjZWYjFQK1hqL0FKNUN3bnZqSmVZdTBXd2R3c0VjbHorM0M3RWdWWUJ1SzFyNjEyMVRpdXErbXozTHlDK1RodmRiOGRkbHVtdlIvbi9NZmJydzNBWlh4WTQyM3RWa3pGQTBGL1BHWlR5TkFYRmZhcW4wNDlCVFdWWG1aS1pkemNWOEVhbVQyekhreGJXazNHamFuWHlGbk1lRFhtSXc2L1hXOXhkVDI0cC8waXg4ZVBHb1lnS1R4RmFiZGRHNCtXcjVOR2tuNHlCNWVCdHc5N092KzJQNUN2WVMzMW04RWswY3pXMTZoWlliaW5iWlM1SEp3Q3AvVjdnUFVqUjJTdGJTbEVyd016RG12U0c5MFc3UHA4V2JMaTZFY3lPc3R2TkJDYXJieGhaR1ppU2FVL1FnTmVyOWZVYWpYSHByTXY4Zk11eWNpTGFRMHV5MStYZ3ZtZlpXZTMrcWlodVllNWJUdjlXaFpqeEhOUitwcWU3ajYwQUErR2xpcTRsUFZhRTg5NjdrcnFVM3U4djZ4OUNGUGFRelR4UEhKVjBmamR2VXNrU0FVVjFwOGoxMVpXN1NmNWVaUmx3cTFrMCsrdmt1elFQa3M4ZkJjYzdNelNoQXc0cFh1dHlHd1ZSVUFHdjhBVWRYcTkyb2NBTnVQaHJhY2N1UERyNVF2NWttL3d5UndpRmlzanJFamNvQUtxRzI0azcwNm45UHJxdW1lWEtDTS9CcXFiWERoTHA0ZUgrbmNYcHJjVlU5c3dzS3JJckRjN2UzYmFncDYwMGZXM3pPZHk0a28wanRxVGJHTVdidzVsclo1SjRDV1I1VUxLN3JzcHBzRkErRytxY2ozSjBuUmhtR2lvMW1kVzdMeFhYdytBK1JwTmwrVnhrb3VUU1FxQmRTT1lyVWRDckYrSVZXUDZPSUc1cDY2eDI5bWxYMGZUdWRSUDNOYnJxbHJQcC9vQmNaTGZZV1c5d3FwSkRheVNnMmNxOGlHMy9XckVqOUlxVFhSV1ZWeUpYNnVOVE00MXI0SGZERHJXZlQrUElQZlRYTU56SGU0b010WFdWQnpWQkhlTFI0NVkrVlJScVZJWHFldTJoZDZhaTM0WGRCdDhEM2JxTFIvL3RlSytJc2VYNVBMK1R3WkV4V0Q0aXlzSm9UbWNmQVVpdFJjU2V3VHRFRkR0M0hxVkc2cDZkZGFYRXgwd09zMjNPeTlMN3g0VDAwT2E1OXI4bFdpcm9xUDFWN1Mvd0M2SWx5SnY5b0VTVTdna2xWcUNFSGszR25JTjhodjhOYVAzcGZUUXlsd3RxNnkvRHk4ZklFQ04wbzBiVkEzR2pUQk41dWorb3J4ZitxZzY2aHRKdTBteUM5akVvWnlRMWExTzQyK1IwblhRZXRvY2hXNmx0NnhXeEpGdXhFOWhQMWVGanUwZTU5eTE5TlUxVDY5KzRSa3N1M1R0NUVnWHNKdUFwbkxKeUZZbERsaUs3cnhBcnYvQUxwMUhaNUV2dTZ3Mk1GN2xsV1RzWTVGZ2hDKzFFaTdkS2oxTGprQ1Bub1ZZbjF0cWFGdVJqYTIxUVg4U3kvbHVPTTJTc1orTWNkR05wS1MxdGNqMVZrSFEvQmwzR3BYZEs2RWNkTDIxWFg5UndiN3dZcTRxallob0pGSldTQnJnYzFZZGFWUUEvS3ROUTJ1ZklkWlpUOFYyR1hGWkxGZVEyWnU4WTVjSlFUUXVPTTBUSGNCMTNwWDBJMlBvZE82d1dWc3JHRnhia05SQnRwaHpLMFJnNEJIVFRNa21NRmpFeEtzZC84QXcxV3kxRFZGWjl5SUhxQU5WbHA0TFFsU1R2eDBoRXExN2JIaWRqNkRTR0dPMHRFNGhpYUgwSTFHU1VCK3l1MnRSdTFWK05kSVlubk1MSWxWWWh4OGR0T05DTVpzMnJSVlpxRWV1a05DUUNmeVRqUDdTU1BucDRIa1AydWNodWtGR3ExS0VhUTBJa2ZYUThRRzlwQjlkTUtBdmFabUlweDVhYVNpMktUVGt2SzRiR0J5amdFRHFkOU9Nc1BkbGZYZjNEa2htTHd5MWV1OWVsZFRTTFcxMElNdjNHdWJvZ21TaDlkNkRVdG95YTdERmcvdUhORTZLU1dVL3FCNmFpME5hdGJkU3hjZjVIYlpPT3NiVWFsU05Sa0Z0aGcyWEYxQ1kyRWhvQ2FhWVZhdWRDdnZLck9LZVgyZTVIQjBnNnN0RlcrUWVOc3F5U0l0Vk81UHcxSk1aMUU2VzErbkhFaWg5ZFNJRTNGWEJWd25yMDB6SnBrWHlLL1pITWRmY3RSUWFlcUdzeEl1T2NyMStKMWFVbWFRbWdCL2pwaHpla2ZFZ2RkU1F3UmdQQUFWcHBtaVNKcXVWTlFldW9qaysybmNGYU5xTUVoZ3NzckluRU9UK09tZ2ttRklzZ2JnY2FtbnoxRW5KbTViYzE5cDIwaENkNXBkM0ZqNDdsN3l5OXR6QmJPMFREYWpiRHIrZW5TblFydmJhcDhEa2wxbHVYeUYvY3NROFNzN3NTU3pTeUdnQkovSFcwa2tvT1pibHlDazVCYXFPYWpjZzlOdFRJRXFDOWpqWVN3RXhTRDBQU28rQkdtYWtrbkFkelhtbmsza1AwcHpsOU5ldGF4ZGkya21ibXl4VjVjUTNVN24xMVRYQlNybEl0dG12WmFzdTM3RCtZMmRwWlpUSGVRWmVLM3NZWVZ1N1MzbllLNWtYbVplMXlvTjFBcXRhazBwNjZGNUZhVnIzbWZsSDh6UzRtVHMzb1BIaW4zejhQejJiVEMzRnZOaVduY1IybDFjdWp4c3o3S0pPUDhBeXlmekh4T2huaHVsSVZYbDQzYUM0amJoRHhPNUhYOGRVaHNrS1lHTW1vNjZjaXdaUEdCTDAyT2tNUmJpMVZ3YWowMDRnRGNXaDRrMEcya1JZR2xBb1dKMUlnYUZORzVyL1BUaUdERXVzakpYOU9vTkZpWVV1WVJJVHhHMm1IWUl5ZG9VaEwxM3B0VDEwNklXRXU3bWtpbktlbnJxMUlyWmdMcVFMUkZxVDY2ZUJwSTVqZVQzUDEwNHhGa2NwVmFkTk9NeVA5UXFOV3AvRFRrWlBYdXk0QnBzTktCNUpkblBTaEowekhUR1d5dnlwRzN0cDY2cmFMVXdyY1RCZ2xQNnVtb0VwTWxoVTA1ZFBYVENOamR0UnhxS2FROGtOMEJhblhUa1dTSW9hRHBzZE1NR0xPenFGWlI3ZjhOSXNRdzJnNHB4SFFhaVNSOCs1MGhHVWNZTzNYU0hSSHVyVldVaW1uR1lHa3RnaFBvVDhkU0dCMDBCQkowaUxJTTF2elBUU0dOQnNUMTQvbnB4b05FbG9WSjIwaGpWMkRXbE91bmtSdUZ2UWFhUkhwaFVEYlNrUmlZRU81RytsSWlNeURueFhUeUlrUlE3MXB0cUk2TjVVMHBwaHlLYXFkL1RVaGphQ1RwUUl4ZXAyMHdpTEpFRy93QUJxWXhsYXhEbHhQVDAwaGtIckdDaEJJL0RVV1RTRDhmRllhblk2Z1dFV1JlUXBXbGRPTVFwbytOUnBFV1FKWXp1ZFBKRWh5TVNlRkRxU0dBZm5TencrSHl6bE9kdk5PSW1BOUdVVkJQOGRYWXR5YThIL0FINVgveGZIK0JRY0VhM1djaTdibU9HMzVUbDI2bFlSeTQ3ZkhwclFiaXVwaDFVc2xaSzh0OFBieVhWcEdIdTdnMW11NUtHWHVQdlFBSDJnZkQwMVVxNzNENkYyN1lwWFVSTHk1bXZIYVNWK2N6ZnFZOUFQZ05FcEpkQWQyYmVvMWZiaUNPYk9Xa0xLSEpualVxZWhxdzBMeXYyaEhIV3AyaDR0YnBPR3QvcEJJajJ6Q2FWaFgzUnlBcEgvd0RsRTZ4M1dhTlFhVlhGMURnclQ3bVltS3hNTjJ0VmxXVHR6UmtnS3J1ZVFxMUNSdDAxenZGYldTMUdlb1lzeXk4ZXRuMksvdUkxeWlUU0JXQkFvOGtoMk1pcU9SWmdhc3hvZmxyU3I2SUkydDkxUFFoZjJHYzJNM2J2RkVnRkk0cEFZVkpweTRnazdrVS9wcnEzN3kzYXJRR3R4N0tqU3RyNGRBbGJtOGdoaGh3YUNhUjQrNUxkU1JsYmNJQjdsUlNhU3VLZ043ZnhHcXJLcmJkL3AzL29YcDVFbFhHdk52dDhGNHNoU1hpcERLdDVMUE5jRGxNOE1ybGxlVmVJQldHTGdGcCtRL0hVMVdYb2tsK083S0haVlQzTnUzbStyLzhBVlIrUEUzNG1helROWStYTE5IRWtmQW16ZEM1TVkveTdjVFNvNWZQVWNpdHNlMzZrOFZxL2NydmhQd2EvVCtJK1NlWDQxN2t4UlhVWWcvZFdPVGhWRWtqUHNGQWY2cUVheXY4QUZ0R3FOdDhxbWtNMVQvY08xdXNCZFR3bzF0UEZGSnhtbWpxcXNnMzRrOVdwMHBYOGRUcndiTElrOVVDdm0wZExYVXFFL3dBdjFLa3grRG44Z2lteWVSaG1tZnRneEJpcm1PT1Z0dmN4OTBoQkg0VjlOZEJrenJDMVNyWDQvZ2NwZzRiNWFlWEttOU5QSlA4QVYvb1E3N0ZYVmxjeXdXeVBlM01JNG1ONHk4VENRVVUxVUFVcjByOE5XNDhxc3B0NlVVNXVQYkhkcWszYTdOYWE5T2hMeW1NditkbFl5enhQUEcxVGJRQ2lxVzJBWG1kL2R0c045VTQ4dE5iSmFCbWZqNVhzbzJwVC9hdjYrWTFZbjdhWmlVbHNyY1EyMXUzRldTVGtlTGRRQVBhSy9ob0RMN2hSZnRUYk5YRDdWay92YTE3ZmpSZklFNWUxc3NEa3hqcmE3TU50R0JCTzh5OEN6SzFTUGFBYWtEODlYNG5iTFhjMUw2bEhJKzN4N0t0YlJYbzU3LzYvbVJaTGJHWFR3clp5ZlFYazlWWHVGNTBMZzdORUZITUFEclVmOElPK3JFN1ZXdnFTK1gxQjM5dXpTcDZiUHAxZjA3L1g1SWszSDIyOG1sdEJtTE9WTWhIS0YrbmFmbEJNVkJDbjJ5aGFFR3V4MzY2WmU0WWs5alczNGYwSzcrMDVyZXV0bGR2cHUwZjU5QXhnZkIwaGRqTGRSWFZ6eVUzTnZBMzdTTWxYQWR6dlVINEFWQVBYUWVmbXpvazB1MzlEWDRudGFyTHMwN2QwdjRzWU1ybmNkWTJZRXZhdnJoRUt4RXFpd1F5MFA3aVJ1R3J4NkxYWWI5ZHRCNHNOclcwMC9VUDVPUlZTM05hZnFKcHhXUThwdDU1c0VzTHlXSzkyWkpKVlg5cENHSlhZVUJQOHE3NjFGbHJoYVY1MS9VNS9QZ3R5S3ppYWI4MytJa2oyVjFKam5UdlVUZ3I5eUZDc2taNXQvU2R4dDFCTzQ5UURxVjZLL1FweFpIamV1alhicWhFenVZdVJtYjdKV044MTdhWEZiV1pwYWt2Q05nckFra3FLZTA5ZGdkYldEQ3Z0cXRsRFd2ek9SNW5LdlhOZkpTMjZ0dlM1OFBQeThHWTI3STlzbDd3ZFlLOW52clZvd3hGVEd4Sm9HcDArT2xaTlBiK1BpVzRyMWRWZlZkcDdmQVZGWWpvYWZoclNPV05vbGIrb0J2NWFRallHaGY4QVdLSDAvd0RtTkljMmtTbTNFWWJuR2g1SU9wVW5yUTZidVByQnNrdkdKaWxRUEZjeHJ4WjFQVWphb0k5YWFaVkUzSnErcGxhcE1qT3pkU3pFbitaMDhJYVF6Z3ZJcjNFelZoZjlwaHhlTTFJb2ZVQ3ZwcXJKaVYwRVljOXNibEUrQzhpdnNsTmN5VG9iaVhhNWpsRlZjRDlNa1pOUFRZanIrT3FiVmRhd1hZOHM1Tno3aDdIWi9QZUtaYUc2eE1DaTVpNUk1Y2w3V1dGeFV4eW1ncU9qTFJ2dzFWUkpwNjZGMmJLOXloUTBOSis1dmxOdmMvOEFYNHV3dTRDZmVJZTdBVnIvQUx4WndQekdwS2xXdXBGNThpZXFRdzQvN2wrTzNOMGtWNWEzT09MQUVzNFNWQUQ2Z3hra3I4MUdxM1JvdnB5RTNFRnM0NjBndUxTRzd0cFVtdHBWRWtVMFpESTZuMUJHcUduSWRWcHFVSGJZUm9GUEliam9kVnRFMVkzUEFuSGx5NjdqVEVnUGM5Mk9UMmlncjExSklhVGNtWnViWlJHU1dIb2ROdEZKcWZQM29ia0pQYjZEU2dqdVpMdDg5Y3VRUzM4ZDlLQlNaeVplZWNIa2VueXBwQ2tqZlZrT0NUU3VrTUViYktOQTZzdWtPbUdUbTBrSUxQOEFpTlJKcGtlNzhoV0FIdHk3bm9GMDhDbEN4bDgzTk5FM042RHFkU1NLMnhIdXNoSVhJQm9TZlhWeUtXenkxdkg1Ky9ZZkg1NlFreG54bDh6RFpxVTlkUlpORHBoY2xleE1qd1NubDZnYXJaWWg0dDgyMDF1dmRISi9YOGRRZ2xBSnlsN2MzRTZDSkNBZGhwRG5seGpaVGFCN2xObkh1SFhURGxhZVI0K09DWmxWYUN0UnFhSU5DNGlkcVhrTjZha3lBUDhBSUlETXNWd25XcFZoK08rbnFOWURHMjRxQ1JxWkF3azJBUG9OUEEwbVVQdlBYOHRPSU0yeUlGSEpLL1BVR1RST1MyREx5QzdIVEVqRHRtSTFvYVYwaEVxS2RUMTZqL0hVWUVFYks3QWNWMjM2NmFCMHdxOXpWS0xwaVVsZi9kTHlVZU9lUFBidEVza21Yam50Z1pLZ0t2Q2hJcDYrN1Z1S3J0WUQ1V1RiV1BFNWF1bm4rbGNmL284cnF0UjBMTHYvQUMxc0pHRTJGUEdMM0QyZHRjbkpXL2Z1QXdNTmVuQmhROWZucXU2cytoWmpkVjFGdWVNSkszSDlCTlYvQTlOV2xUTnR2ZFN3VkNFRkQxVmhVSCtPa01ia3VBM3REZG9rK3Y2ZEtCNUpFTWoyTXdsbFBKU0txd05RZndJMGs0WTh3ZEErVC82b3IrYUhISjRoWnJqaEZDZ3Z4ZHF0MDd6S0tFSXhOT0ZCMUk1RTZ6bHhXN04yTlI4NzByYWkxdnR4OXg0UHVGZ0piNjVpVzB5bVBLTGtWSHRoS3lLV1dSQ3gyQm9hcVQ3U1BocW5MZ3RSVDJlbnpET1B5UHVMWHFocFNTM3VnczF2S2s4WFFTUk1ycVNQU3FralZFUUZKcDlEVmNNU0RRZEJUU0hJYlFMMkdKL1Z2UWFRaFZsZ1hrVFRiNGFrbVZFTlIzWnVDaWcwNGd6am8rd2pEVVdTUXdXWURRbmtEejFFbVFMNUM3Y0QwK0duR1lyNVRERXQzQUsxOUJxeE1xc2lKYTRKNVdxemNSMXBwMnhraVhjNEF2R3hpZWpLTnZucGt4MmhTdXJXV05pSFhjZW1yRVZ2UWd0Q0trMDMxSWhKNFVQb05NTFEzMjRvMjQwaDB3MWFPVlRwVWV1b05GaUdHMVVUUks3R2dVYWcwVFI3YzNKVWNWL0xUUVBJTWVlVG1LTVRwNEdrbjJqOXhsTDdEVVlHR0dLMm95K3FucHBEalhqY2RITGFxcGFqMTZhZ3k1RTg0M3RLYTdmanBwSlFENTBWVzI2anJweUpnbFB6MDRqY1ZSZ2Q5TUloeTJheVZQeTIwNHdNbHhzcGFsS0RUalFlcmlRdTU2MTBteFFaUGpZd3ZGVi9QU0hnZ1RZdFRXdnRIeDBwR2dIejJLeDdMVGYxMDVDQ0M4WkIwNGlJOGhERWRLYVJFMEdaOTZldTFUcDRFZXhSeU8zVFNISllnYjBOTlJITm9oK0pycGh6VE5DU2RocVNZeHI0RlQwMDR4Z1J2L0k2WkRIaFZLYWtPZXhBQjZqcHBDRHVQbExVQUhUcU5SYUpKaEV2UWRkUkpNalRUYm1ta05KQmVSMlkxNmFjaVlseHk2N2V1bkdJN2RzdDdlcDMwNGhNKzQyUXRWd3NWbjlRRE9KKzUyUWFxRkNrTVQ2ZkRST0hMS2RJbGRaOEgvVUY1RnE3SW5Vb2E0dTYzeHVZaFJMUldsTERZYmJEK1pHajB0REViSTA5bmYzZHRXNFQ2T3g1Q1dHTmgrOUthVXJ4NmdIclU2anVTY0xxVDJOcVhvaGZ1MEtHZ1F4UmRGNWRUVFZpS21obiszOHNkajVQajQ1bW9aWll5cFBxVllHbjhORDhoVFJsdUZ4WTd0OERsaW11bzRpb0tYY1JtVUVrQi9jNGVuNERqMDFrcDZmRTBJMVpzKzRmaU5wZldOeE5QSHhQRmxtVlJWaXE3OHE3Q3FrQ21zZm5ZWVgzSzlhblVlemMxMXVzVC9iWTU5ekY1RmhPT1B4MEtmV1NSS0xxU1JHRmVvVmd4UDZxL3dDVmRDNFp5ZXF6ME84ek5ZMXRxbElvSk5GZzZ4enVMeTVtVW8xdlVPNHFkd09wNm5jKzBhMHRyeWRGQ1JsZmNyeDlHOTFuMjZ2OGZRTlFaWm9NSEdKWTQzVXU5cjJDR2VmaEpWbGpRZ0JWM1B3ME84YzMwK0lWOTkxd3k0OEk3Njl2SVJoOWJqWlRkY08vYlNVbGlscnlkeTNKUlJtcWFvU1IrT3RXSzNVZEgrUDFPWlR5WWJidjNWZlR6K2ZrYk1oTmYvWFd6M05rRGNrTUkya2xMcTVwVStuUWoxclhUVXJYYTRlbndKWjhtVDdsZDFOZTB1Wi9IeGtIM2d1Y2RPWm1uU1NNMG5BUUVSa051eWdDcE5EOE50WFVpNmlQSUN5MnZodExjcjkza1lYZVF1YjJWYnJJdTBscktTa3hEQXRWVkZRd1ViRGthOGE3NmxUR3FxSzlTR1hrMnlPYjYxYjE4ZW5lT253R3BMKzl2ZkdPemFsYmZzU01IbmFpSDJwUXFCN2FrOGV0RHZ0ck8yVnJsMTFONm1hMStONmRHbjErSFlnNWZ5dnkyL3hFTms5K2JmQ1RsSVpydDQxaDV5d3FBWTFlZ0lSU090QUNhN25WK0xpNGFXYjJ6YnFsOGU1bmNubmNqTFJKWDIwNzJpTmZDZkR6Z0gyWGxjVnBrYmE0UzIrdnVJVzVvc1hMdGR5blVrbXBOZmNYcjh0V1g0anRWcHZhdngrSUd4KzYxcGVzVjN0ZUhTZnhyUHlOOG5sL2tsMWVtVzV2WkRjMURXS290ZXhRMTdhb3ZRdDBxS241Nmd1SmlWZEZwMzgvTXRYdU9kM2U2MnI2YWRQS1BNMnorTVhLV3d5K2F1NXA4ak01bGtzSkpGK29DR2pjaVhxU1JYM2UzVExrcWRsRWtsMzdDLzhBcnJ4OXpMWnR2WGJPb3dZd1pTQ0picUcranhoaFZUYTQ2S3BQZUlabzE1U0ZuSStKSkFyWHJUUWVYWTlJZHZGLzZHbnhxNUZYOXlwSFN2bjI2Ni9vSGNObThwNUVndjhBSXlwZDVKSlY1MjhqT3NFUmozSlNGVkFEbWxDZHdQeE9ncytLbUwwMTBYajMrcHBjRzk4dFpzMXU3clhTQm52cExEeDZGczlKRXF4WGpLVWlqb29NemUwaFZPNXBUcjE2NkFwVzJWN0YyTk85cVlrMi9IOWVoVi9uZWZGMWNpR3dzRzdhQWlWKzJVNFJ0dUtEYm1kNjlBZm5yZjRYSGhUYTM0L2djdDd2ejlkdU9yZis1K0g4L3dBYWc2YVM1eHVNbWhpaVpzY0tjcG9pVm5ra05LcEoyMUFQSC9LNTIwUWtyMzFldjVmSXo3MnRqbzRVMThWMWZrNDhQQjlCZnRMbHJ1d3ZuVXJiOThtTHVTZTBLWlZOU3E3OWZVaitPaTcxMjNxbnFadUsvd0IzRmRyMDd0SmZtdXk4KzRuUXQyNWVNbENwOXJnMUlJcjFPdFd5bGFIS1k3YmJRK2hJanVSamJrSVMwMk5rWkpKSUI3VmZqMElCMnFONmFnNjc2K0ZpK3VSWUx4KzZqaHRmandJUDBwYmRLTVBrYTZJa3k0TURDNittbkdNYUg4TklSOHBJTlZORDh0SVJtSlhHeEFiOGRJUmxWSE5hVS9IU0VlZHMvcVFuYlNFWkY1S3F4M0tpbGZscENDdGxmMnNCNXlRSmRBZ2NZcGk1VkNQVUtyQUg4OVUzbzMwY0YrTzZxNWFuNGtoczVrMG01cTZHTTBDcUkwQzhSMEd3ci9QVExIV0IvdTJtU2ZkWGw3ZVdrZVR0bERSMnpFelc0NnhFamVoOVVhbXFsV3FjUHVYMmJhMzE3ZmwvcVhIL0FLZi9BQzI1azhvUGlrMGpUWWJLMjBsMWJSbmJzWFVLYzJDZWxHVWU2bnk5ZEVyaXErREpaNld4dy9pbTQvS1pMY0daL2NqdFlmdk92dVY0NzRkbTN3cjJsM2ZYMFNMSk9JQXFSeDl3Y2xVczVGU1J2c05abGFTZ3krYmE0U2s5OForN3ZpV2JtZTF1SlpNVktxODBOL3dTTndvcXdEcXhGUjhEU3ZwcUx4c2RaMTMwSGU0NFhFRVYxYnlMTGJ6S0pJWlVQSkhSaFVNQ05pRHFFUUVicEJjOFQ5SlB5MDRwQjA0WDlJNjZRcE50bEtRQ3JkUFE2aXgwVDA0bjFOZjVhaVBFbnpnRVUwaG1aQkNOMkpxT21rT29ORXN4cnN4cnB5SnBrNXZRcWQ5SVlGM25kZGp6T3kvdzA2R2FGKys1TzZoUitaMVlpRE1Wam1VQXFRZmpweG9ZVXgwenBNb0kyT3hwcUxKSWVzTkxMREloK0pvQlgwMVd5eEQxYmR3am54RytvRXdoQThmZVR1ZEFlZzBoeWRrYnlJV1VxK2dVMHBxSWxVcWp5UWk0WlN2UWsxMVlpTEU2VXRGS3lNS2o0RFUwaUJGbktUUjhLZnBPbkdaRm1nUm9XVlI3dE9obUJwVktxVUkvUFZoVVpXdEZjS1J2OGRNT2c5YlJsaWc5Q2Q5UVpZaGp0Yk5TT0h3SFhVQ1JwdXNlNnI3aDdUNmpUeUlnRzNXTGRhN2FReG1ocXdwcFFPRTdhVWtvaCtQOHRSSFRLNS8xQUxqSk1WallQcVYvdU1FaGY2U2hMR0tWZjExcFFVSzlQbnEvalAxZ2ZNcW5UVTUyeVJBdExLM1Erd0k4dFBYazdVMy9BUHAxcUl4YkFzZXcxUDUvaHFSQTN5eFJ5Umd4c1dJNkUvRDhOTklpR0VwcHhIdjRmbHBDSk0wTTFxbkdRVXB2K1owd2o1SmJaMVVTS1VrSFYxM1UvaVBUVGpodkgrWFovRjRqSWVQMk55MzlueVpqYTl0d0FWa01ScWxUMUZQa2QvWFZWc2FzMDMyTHFaWFZOTHVQSDJUOHl1c041WEJaM1Y5SGJZdStidFhjYzdDT0NoVmlyZkFNR29GUDVhamxwVjFjL2hsbkh5T3QxNEY4M2YzYzhIczgyMkN1YngwbldRd3ZkaU90cUhHeC9jQjNBUFZnS2F6MWlzMUtOWjhxaWNEZk00cDdTR0RDcXNwcUNDTmlEODlVQlNjZ1M1dC9jUVFRZFNJQStPRjRycGRxcnA1R0MwQ3F2dVBRblVTU1lUU1NpVUhXdjh0TVNUUGJ1MWNsR0d6RVYwaE1qTkFHOWt3b2ZscVJFeFRGdTUvYTJycFNPU3Y3TmNxdTRCcnBwRkF1WnJCRVB6RWZVYm41NnNUSU9vbFhWaVk1R1VqK0dyRXlsb2lmVHNkbDBob05pVzdBalNKQk96VXE2cXcyK2Vvc2tnM2FzRURJZWgxRW1hTHB3NW9PbW1JdGtKMkNFVjBvSWtxRzlpUUFFN2pTZ2VSbngrUVI0NHdUMCtPb3RGaVk1WTZWQ3F0V3ZUVUdpeE1QeXp4enhLbzZnYm5VWUp5TGw2NFdWZ0JYNEhVaUpDN2pBMXJweHBOeVNxd0ZhNllrU1F4QzFYZlRDUGg3dXVrTVppTXQrZW5ITmJ4MDlOOUlSRXVJcXFUMDA0d0N1SWpVbmIveTBoZ2RQR0Y5Mm5Jc0N5cjcyMjlkU0lHY0Z1SDNwcFNPVDQ0Z2k4UU5SSE55UU1SVWo4dE1JOU1ZRzFOeHBEbW9wVWdEcjY2UXpNbnRrSzE5ZFNHQnN5QkcyMUpERVJwbFU2ZUJwTmtVNlZHKy93QU5LQnBDZHBlSkdBSzc5ZDlOQThrMzYxV0h1TzN4MDBFcE5Va3NmVlRYVFFJanRLS2JkZFBBalE1WURycElZOGppZHR4K3JUc1JSWG5Gd3MrWnZna2p2eG1rQURHcWdMc0F2eUZOYVdPbTFhbUZtYzJZallhYTN0OGswMSt4NEQzTDdlWUxydXRWOVFLVjFiZFN0Q3FqU2VvVWJLUzNrMG1RU0JqWlI4bmFaNkZtSUlCSXJzTkRiVlZRRTczWnpHZ3QrU3JXN1J3ZjJOejEzNUhjalYrUG9ENVhMQkhldVRLdDVHVEdZaURHNDJveTdpbnoxYVVuZFgyTjh6dFBNY2Znc2xHUUw2eExXMlF0eFFOSE82Z0Uvd0RDOU9TNnhjOU50b05IRGVWSmV2a2xoM3JDWFl1WFE4NlVBS2ozRWo1VUdoOCtPYXg0aG1HKzJ5YTdITW5uM2lDM0Ywc3JRc3MxcVJHcXhrZ1BIS0dibTVxT1JVa2JhNXJGa2VCdXI3bnBQRXV1WFdyYjZhUkpWRStJZ3g4N3Jib1VaQWVZWVZZSDlSL1RXaDMyMXJWeXU2MUh0eHE0cmVsUkJJeGwwalNpT1psbnhyVk0waG9aRWFtMjdENTEyNjZhOVlVOUdLbVNYdGV0ZTc4Q0ZuOFhaWW02dHJKN3hoTkN5aEhlTmxTWDNsbG9DUFN0RDZWMWRoeVd1bTB2NkFQS3hVeE90WGJWUDY2NkczSHhZUDZyKzMzOFZVbjdnWjVhampLcDVBb1J1Vkk5bEc2SDhkUnZhOGJsMi9HcFBGWEM3YkxMclBYeDhqWDVMZ2xzN2VWY2ZET0k3SXNyeVNJeFh0U056cUN4QjQwTkc0N2FseDh6ZHZVMXFVYzdpcXVQMEorbng4LzRDWjNyT3psa085eEJkSGxKRkVPRHhzUndOU2FnRStnNVZwOERyVTIyc3ZCbzU2dVRIaWJuMUszWmR1Myttb2ZremR4bjVMZkg0N0dKaDdCZUt3T3BBWklwR0ZaT05DWElwMVk3VjBGOW11TDFXdHZmOFRUcnlyOGlLWTZmYnA0ejI4WURWNTQvYTVLY1lYRnJLYkc0QzI4MTAxYmk0V1dGNjhpckhjVVdvSHdKME5Ya1dvdDl1cTdkalR5Y0ttUmZhcEtxOUcrcmxQcTVKZHZoTFBIV1dTdVpidXpmSVdkeUdnOWhtaVpBRkI3aXhnRG1UdUZKTzN3R3FyWm5kMVNUaHI4ZklJeDhhdU5YYzFiVDY5dTNWZVBrVDdLM3d0cGZmM2lSQ0xQSXhHVzhmcElXTGtOUUtwTWRTS2dWSDQ2cHZiSmF1enZYcCtPNFpqeFlhVys0djdscitPd0J1TWVMSEx5WkhHQVJZbmt5Y2JsdVRtSnFVcnZ5QlBvV085ZHRGckp2cHR0Kzd5QUxZWGp5YjZhVTgvRDhlSUthUzV0Ny93Q29najdkdmRjN2lNSVFZK0pKRVpWbkJLcnQ4YWpWMEsxWWZiVCtmekJtN1V5YnFxRmJYK1dyV2lNNThwY2lTZTRzYmhwWTUxQm1aUlNvQjZCbktrNzdqaWQ5TXNTNldVRHZrdE4ybzVsYXg1ZWY4dW9Rc2ZMNU1mYXBiWGtzMHNnUGJTSm1KalV5Q3JsaWYxVkc5QlFmTWpiVlYrSXJPYXdFWS9jdHRVcnpQNDZ2ditubWFMV1dmSzVEdHhYbHhQTXY3VVNHc3ptQWdodXBQRlY1ZGE3ZE5TdWxTc3RMOUNqRy91NUlyWitYZlR2OGwrWFFJLzJLNFdPN3RyS1pudDhleVQzdk9rZHB5VXFBVkpBclVGcThpSzZvKytwVGE2Nkx4Qy84WnBOVmY3WEw4UGtKbC9rTVZiWnFhRzZLVFc3eTF1TDJOdVNpVWoyamdOMlFFKzZuNWExYVlyMnhwcnJIUTV6TnlzT1BPMWFIVnZXM24yMDdwQWpQNGdwTDliQndLdWVTaUZXV0l4MHFHVU52b25qNXA5TE16M0RoYS9jckd2aDBqeEZvZ3VwakpxYTFBcjByclE2YW5PeEtnMEpJdnJVVTlScTBGSlVkeXhIRU1IVWRBd3FkUjJqcG0zOXA2VlRnYWRSdVA0SFRDTUd0ZzM2Q0Q4QjBPcE5pZ2pORTZtaDZqcU5PUkQvaFVNVnhuWTdhWlF5eXh5TFJoVVZDMTZmbHFGM0ZaSlY2ajdZZUhZL0o5OHBERkZORTNFb1dFVWxENmppUlVhSCs0NDZsbTFDZDVsNHluamN5UnhWcVNRNk1lWEVnS1J2OHdkVzQ4anQxSVdVQ256UTlSeFA4dFhFRGNtKy9Ma1BoWFNFVDhWbHJyRlRQSkFhbzQ0eVJ2dWpLZGlHSHFEMDFWa3hxNmhsdE1qcDBDZUc4a3Y4QXhySVdtWXdOMDlua2JPUXZic3RHNEExNGtWQkIyUEJnZXVuaVZEN2pLenE5QWg1Tjl3TTM1WmVObGNvNkhMeXFxWE53aUpFanJFT0tleEFGNVU2bjExVlhBa3kxNTdSMTFJV1B5alRsbzdzcTVBNUJnS0VxQlUwOUtqclQxMDFzU25RdHB5SEVQVTZiL3dCTmw1bGZJc1ZuUEg1MTdscmlaTGU1eCsvYzRRM2ZJT3FrZjBobHI4aVRxWEp3MFdDbVJQMWJyVmE4a2swL3phK1FYeE1qczdWN2RnTm52dlBra3k5OWpMWHh0SWY3ZlBOYXVidVp4S1dnY29TVlZRQldueE9nbmpyVkp0azhlVytTelZVdm1idkhQdWRpOHBjeDJlWXRoamIyWnVDUzgrNWFzeE5BcFlnTWhQVDNDbnowMnlmMmxuM0hWeGRRUHFXeE1yRUtSOFFkVU5oS0NNY0s4ZHFiZjQ2WWtqNElydFNudUdrTzJaeXdFeG40NlJFR0VxakVNTk9OSmk4Z3BXZ0NqNGFVQ05YYldkQ3gwaGhXeXBWSkNvV2xEMTFaVWd3ZXNqRTFCcCtHcFFSSnRyY0ZIWGVwMG1oMHl3c0pkSXl4dElQMDZwYUxFTjhPV1NnVVVDZ2JhaVdTYjRMNVdsREZxQWFZVW1XUnlRRnBQdURVRUQ4ZEtCNUViSXVYaUJPeDlOV0lyWXNTb1dacWJuVWlETlVkdnlOQ0tINGFRakdXQWZwcFE2UWdCZUlFa2RLZnA2YXNLMzFJOXNTWkZxTnE2UWt4eHNZQkpDSEg2Z0tqVmJMVUU3V1R0c09YcjEwekhrTVJyRE1GM0ZENkhVV1NRUHlPTzRBdkh1aC9QU1F6UUZhUGlmZ1JxWkVsUk9hRDRqMTB3aWtQdlpiWGc4Z2psbGNyRGNXMExRQ3RRVldzWnA4TndkRWNScWJMdklCemxaN1gyS216Qmgrc2RJQlNHTUxHb3Ava1VBbitOZGFTTWhndGdDYVYyMDR4bEU5R0tIOUpPM3kwaEd1ZEFyVkhUU0hNN2Eza2xuV09LTnBKQ0toRUZXTk4rZzBoamJmM3ZmaUVSV2podmNQWGJUSWNncWV0ZE9NYllaNUlXRHhOUnZYMUIrUkIwaHlRQzl5VElxY0crS2REOGR0SWMzcEhQQkpGZFNmdXhnZ2dqZFRUMDAwRGx4SDc1VFkveERDNGpCcTBPVXNZaERlM0Z3aVRoMWpGRUVkVHNENjhodFNtaGNtSGZkMmFoQjFlVHRva3VxTEkrM1hucitjWTZSYjZKWTh2YWhXbE1Zb2tzVGtnT0J2UTFGR0ZkVTVlTzYxM3I5c3g4R0Y4Zk83NlBxT1l0K1I1Y2FIMEowR0dHM3RtTUFIcFhycENKbG5DenpLQnVOSWRCZTZXa2dBNlUweUpOZzZTT3I4anUycEVXRXJPTUlOeFg1NllkQit3dFVua1ZEMElyVFVTYU1jdmhJakVmYUNwRmE2U1ltaW9QSU1XWUo1R0FvSzdhdlRCN0lYaEdpdFVqZlVpQmlKaHlweC9EU0ZKbjlTaTBQR3AwMER5VEk3Z01LOVB4MDBDazJEWUYyT2tJRjNqRjI2MHA2RFRvYVNLc3BHM3FOT1JURDJMeUlqb3JIZXUxZFJhSnBqNWdzbkhKR0ZydldncHFwb3RUR2RaMkVKcjZqYlVTMUFxN3VFVDNNT21wUU0yQ1o4bkNyVStPbWdiY2o2TEl4ZmlEOGRLQlNUb2I1RzZOU3VtSFRKUW5xdFFkSWN3K3NNWFUxUG9CcENrMUcrTHQxb2ZocERTZVBNR1gzTVBucHhBdTZjSUNGNmZIU0lzRDNVb0s4U1JUVG9pd2E1QlB3SjZhbU1USUFzY1k1VXI2Nmd4emZISkdTTjk5TVBKS1NSUnVkOU9JeWNvMjlBTk1JaVNOR2hKclUrbXBwREVXVzQ5cEFOQU5PTklNbm1VQTc3K3AwNlF6WU9hWGNrblVvSVNhUk9GUHRQNDZlQ01rcGJ1b29ldW1nZVNUYjNYSitKTmE2WWVTYnpJRysya1NrK2E0UWRkTkFwTlp1Rlk3ZXZ4MG9GSmxkWE56WjR1K3lkc0ZhYXhoTXlySUNVSkc0clFqNGFuWEc3RUwzMm81MDhseWQvRkpjdEpHSUpwM2FTUjZBU25udlFEK2tiNjBhcWVya3hMM2JiOHhWc3p4V2E1ZXE4RklRZGQzRk9wK1oxWXlwR1ZyZlpDNnQ0TWRHbkt6dFdNa3ROZ1J5NSs0L0RiVmJvcG51V0s3aUNjUEg1N3hUbWMwNGhzeXpTTUdQRUJEdjdSOFRxUDNFdEYxTFB0TnJjOUVBNysraHZwNDdXeGlFVm5IN1Yyb1Q4VCtlckVvMVpRMm4wTEwrei9BSkpONFA1SmFYN082WW1kbHQ4cVBUZ3pWam1wOFl6ditGUm9UT3QyZ1ZqbzBqOUdab212OFpidEU0S3RHckNRYnFhanJ0MUJCcm9ISnFnckZDS296dUdqdmZxRlFCN2t1NmhhMVVNQnpmOEFnQ3V1ZTVHRlhtT3AwWEQ1VnNGbFpGSFpEQ0phNXE2eGwxZVBhbWRqY01GSVh2QUVBbWo4dWxhY2Z3T3FzZVQwYUtZME83eHV1U0dyYmQydjhBWDVGNDBrTnFML0FCTnUxeEl6MWxqbTl4WWlwNUtGb3hZOWZocS9EbWx4WWp5dVB0ck5WTDgveDFCOTdGaXN4YVNXNm42cklnMFZtQkJMQWU4SWoxb0RUbFFmbHF5anZSejBSUmxXUE5WMS9kYnovT0pFdTV4WSt0WEYyclN6NU1IL0FLeG1hc01LN0N1eEZXcWRhZGNucDNPRXUzaXpuTFlaeUxIV2JXNytGZjZtdnlPUEpYRjVCYlpqSUc0dExhS1BsRkZTZ1ViVUpCK0pPMWRTNDdxcXQwckRaVnpzZDNrVmNsNXJXTkVSclJzUXR4REhKYXhKYWgrUDFGeVdqaExuMmhnQlhsV2hQdEIzK2VyTExKRGg2K0JUUytCV1hwVzFkM0tYeThma1pQbGJXeXRtdExHUVNYdjdrWEo0VEJHWTNKWWdNMVQ2bFFQYlNtbSt5N09iZFBqSkpjeXVPdXluWFhxbzArUHo2YVJBMFl2N2xSNER4dGJER1d5RzZrQjczZlJtTGsxUmlYZGlDcFhiMmpiUU9UZ1BKa2x2VHlOWEY3clRIaGhLWDUvejdoVFBZcXl5T01zL0lsdkpiWEJ6QlpKN1o0TzA3M0RjUWV5dkZRVlp0d1FUdHZvZkZrdFM3eHhOdkdlM21IWnFWeTRsa2R0dE82anEvTDRpMlkydDFpbWh2QXNjS3EwM04vOEFtRmpYdGtDcXR4TG1uRUU2TDB0S2dHYzBpeXZvdXM5L0x3Y1QyMUNPU3ZiYTd0N2RKMGtTTlFJbW11QjJLblkwSUFMdUI4UkhXbTFkVTQ2T3JjZmxyL1JmVUl6WnEzaFEvaTlQNnY2Zk1CNS9PU1pDU0dCT3pMUGJEdFFjMVdPQ0ZRS2t4dzFJSkZlUUxGanY2YUx3WXRxblZKL1YvRi95TXpsNTNrYVVwMlhqQ3JYNFY4ZmpQeU04QkhqemROY3BMTGYzYlNCQmRTVUlXUUZmY0sxTzN4cHRxR2QyaUd0cThDL2dVeEt6ZFc3dWV2bVJzcUxrU08xK3l6WEFsZjZHV05xeU1YWXIvd0FzVTJCL3ExUEZIOXZUdi9xVjhyZExkOVdtOXJYWDZmeE4rQ212OE5hWE45R3dzWEVpUnl6Zm9JanFDNnB5REhjMDNwcU9ldGNsbFhyb1Q0anZoeFd2K3pYNGZRSmVhZVEzRjNiZlE0ZTVseUZoY3FUUEdGUGJOZU8zTmd1MUI3cUNsZlU2cDRlQlZjM1cxb3M5ejVkclVqRk4xYnIvQUsrSHdFR3l4Q05KSWN0T2JOWEZWU0ZTeGNxUU9QTG9EdjZIV3hmTjAyTGNjcGc0ZXIrODlpZmgray95SnpaQ1cxc0lNTmJtWXdJMGpSVEZpd0NrMUh0TzIveDIxVDl0V3M3dUEvNzd4WWxock1hdyt1bndGTzZnRnZNd1phY3Zjb0IyL3dEbDhOYWRMU2psYzFObG5vRGpESXU0RlI4dEVHYWF5Q05JUm1rMGk5R1A1NzZRaVFsMmErNVJVZEthUTRkczd1eXZTa1Y2bkdkL2JITWc0cWE3QU1QVFZicSt6THEycTlHU213dVN4ZHlMdXdaNExpSW5nNi9xRlJUL0FBMjFIZW5vOVIzaWE2R3lEelhOMlRuNnFHM3VpcG93a2o0UHQ4U2hYVFBEVmxXNW8xZVNlVlIrUldVUy9SL1RUUWtsM0VoZFR5V2dHNEJIVDQ2ZW1QYStvcldrVTZFaWxOOVhFRDBDbnhCK2VrSTNSU2haRk1nNXhnamt2eFgxMzBoQmlHMWt2N1pMZTBGWjFsYUtCQVIzR1NZRmxETDY3cC9QVmJjUFVzNjFBeGRnZUVpa01wSUlwUWc5Q0NOV0Zabkc1VnRtL0p0cTZRZzNnL0lzMWdUSkppc2pjWStWbE1abHRwWklTeUhmaVdqWVZIeU9vV29uMUpLelJwdjgza0w2ZjZoMzdiRThpVkpMc1R1V1oySlppZm1kSlVTSk83N0J2SDVwSnJZZld1Z2FuYUxNRHYzQlFFMEhTdXpmeDFSYkhyb0ZWNURqVTZoKzNsemZYWGd1SXlPUW5XYWFPQmt1WitRWUJZR1pmYzFUdUZVVk9vODZtTlpZeDZwcXYxalg4elE0MTM5cE45Z2RsZnV2NHBhcld3bGt5TWxQYjJGNFJIOFhlbitHZy90UHVUV2RXL2JxUVBIdnZCWTN1WlcxeTFrY2JZVGxZN2U4YVRtcVNIYWsyd0FCUFJodDhkUyswbjBlbzMzYlYxdW9YajRGdHpSa0FVSUlJci84SFZFQlVnTEpJdkZtVTBwcDRJaS85VTYxRE43ZmhxVUVaTjBWNFFDRlBYcFgwMG1oNUEyUms3aFpXQXI4ZFNSQnNHS3BHNDZqVXlKdnRsWjU0MUhVa1Ywd2l4N1NGWVlZL2p4R3FTNG5wSU9GUGg2YVFpWkRNcXB6TzRwdU5SZ1VtcTd1R2RDaS9wT25TSGtDWG5OZ0YvcEhYVWlJTVczWm5JVCtlbkdKY05rRnE3cjdqMEdtSEJkOHZCMlk5UFRVa013RGZJanR5OVNOU2dneUhIRHhrRzN0K09wRVlHbkR6SXJLai9vSW9kVnRGcVlkRnVnM0c5ZFJKSHZGMEd4MjBtSTJ4M0t1bmFrM0k2YWlLU0pkV1NzZVNqcjZmUFRvWWhDSmtlbFB5MUlZNTE4NGViSitYM1VWMTdZKy9KM0hGUVZTSW40L0lhSzRsVXNjbVp6N041STdKSXJhOE1qU0ZpaEFja2cvR3UrdEF6V1JUWDEwaGpFbXBHMmtJM1JSdGN1a0tqY24zVTNvQjFPa09NdUh4bVB1cGJqdVhxMnZGUkZCSWVTZ1M5U0svSURxTlFzNExhVlRCL2s5amtMSzVpdDc1MG5jSjNFdUY0c1dSalFWY2JucDY2VmJKclFqZWpxNFlCNEg0VjFNck1hR3ZUVGlETnZZOHJFU00xT1BKL2dRTlJra0NsbmVyT0hQdU5UdjExSVltMjh0a3lsYmpsRklmL2VUM0wrYS93RGhxTEhEbUQ4cXozakF1bzhMZU1sdmVSbUNkby82b3o2VjZxZm1LSFVMMVZsRDZFNlhkWEtIejdSZWZYOWo1RkZZWk85QXhONjRpblNkeUlrNUE4WkFXUHRJTk4vWDExRzJLanEwL0J4OHUzejZGK0hNNjNrdVcrKzUvaVZ2bkRnWkxoeEtqaU5yc0tyV3dmOEE0ZzFTQWRpd1dtcyt1S3pVbWsrVFJPQ3diSk9KRGdnZ2dFTU53UWVoQkdxbWdwZUpNa1h1QU42NmlPYTF0aXpiaWxOT0luMmtKWUJmWDRhWWREWmg3SUpJc3A2QWY0NmlTWk55TVNORVJUWSttbUhSVWZsdHVwY29nNmY0blZ0U3F4WGQxRVk1RFhiNWF0S1dEWksxTzUwNHpNSy9NNlJHVGR6SUFJSkpHa1BKNHQzSXdwWGJTRkpya2w1RS9FYVEwbW1WbTQ5eGZ6MDhDazJRM0MrdlhVWUhUR2Z4Mi9hS1pRemJjaHFOa1RUTERTK0VzUFdnR3FvTHBCT1F1cXJwNEdGeTZ1QVhOVFVEVHBFV3pUSGVrR244TlBBcENWcmVFMHFmejFGb2RNTUpkbmgxMzFHQ2NtTFhRb1RYOHRLQnBOSDFrUllrOWZYVHdLVFJOa1l4UUExMG9HYkkwMTZ6ajI5TlBBMGtPWmxJcWRTZ1VrRnBlVFZIUWROUEEwbWJUdHQ4QjEwb0ZKNnR5RjMzcnBRS1RjdDdUcnBvRkpqTGV0VGM3VTZhZElVa1NTOWV2dDNQejA4RFNhRFBJdzM2NmVCcElrOGpGK09uSWtWenhVMU9wRVd5TjNSNmFSRXlFcDJwMTBoNUNObWZmeVkxQUdtWTZKalhDZ1ZCMjAwRHlZQzRWdXRhNlVDa3lWdWhyNjZVQ2tnK1UzQVhBWEtwY2RtWitQYlVHak95bXBVYi9EUkhHdFdyYXNtMDE5SDJaUnlINmVwUm1YZ2ptaGtrSWFhUUN2Y0pJUWN0enpZK3Y4OUdJeUdSYkhDaS9qaXRyVGllRWF5M2tzamlPTU9hbml6TjhCVHBxTnI3ZXBaVEc3dlFMZjJyQ0xDZitxbCtqdHp5bE1NWlNONXZVQjI0bGdPZ0owSzczbm9IVnhZMHRXOUJKOG84aGx5czR0SXF4NDYxOWtNUTllTzFTZlU2SXgwMnJ6QTgyWGU0WFJFTEEyeTNWK2tUR2dKcFgxL0xWbG5DS2FLV1doaThkSEV6cE1vYTNFVGlUa0tEZ1ZJQko5S0U2eDczYjZHNVdxVUorQjJYOWpmS0w2NzhVaDhLdjVSL2Y4VmJxTFRmbHlnQTRoU2ZVSVNQZC9scHFsMmtyMjdYUFlQWDJQTnBkM2QwWjB0YmR6SXM1a05LQ2k4MlVkZHlPdnkwRGJIdGJmUU4zdXlSUzMzRXdTWFNDNHRIY2lFODRaQlZYN3FLZUxHaHFWWUhXVEt4M2xkSDFPdzlyemZjeC9idTRhMXI4Uk94bVF6MXhoZnFMdVNHMmtOcTFYVU16Y0ZCSEorT3ltdGFLZDl0V1hwUlhoUzlUZXc1Y3RzVzYwTFFxdWZLMmNaNU5lbUIwWWlGWWtvN0Zlak82aytsYVVOZGJkY1Z2Q1RrNzh2SDFkdHZ5Ni9GbzNYV1Z0T0xpS2F6dG9uVkhXSmpKTzdTY2dlNHhWVzl4cFUvSFRWeFdubzM5Q1dUa1U2SjFTY2VMK2VoaG1NMUYvYjRJTHVPMWpteHpyOU96eE1ieGtjaDFVcjdVSS9xNWVtcFlzRDNPSmkzWFhRcTVmTVZhTGR0bXZUVDFmeStZbzNWL05rYm1hOHVvZ2JxUWtKSWFzZ2o0amlxOHEwUHoxcFZvcVZTVDBPZHZtdGx1NzJXdjVSNEcyTzNzM1VQY1B3alVncVRXaFlIOU94cHRTbGRWdTFsMENjZVBHMU5uQ0dXem1rdHUzQmFXclNROGd5ek1Ga2lZSlExQWFvWmo2VjIrV2dyS1piWnVWdXF4V3FjZVBacitmaDI4aTBybXpUTTRtL255MTRMNlhnQkhIKzBzRnZWYUJReWhTU3RLc3k4VnIwMnByRDNiTHJhby9pZExXankwdDl4eXZsb3Z4My9BSUZabGJ1Vkk4ZFp4cENRck5IY2NWV1VzeEFvWkdISTEzQTMxc1N2M04vTCtoZzJyYU5sVWw1OS9xUmN2WWZReVJ6VzdxODBYSXRNaDdoWUVVSWNWTktlbXA0NzdrMCtoVnlNUDIyclZlcTdyWDZnZVB4NWJvdlBLekwzUUdWNmdndFRma1IwRmQ5dlRSTnVSdDBSbjE5dFdSdXpuWDhhK1h3R0hBWThnTGprbVV5aGF5Y21XbmJJTFVBUFVrYjBiUU9mSi9kQnQ4SEJDKzJuMFhsMC9IaUZiakxZYng1MWdXTTN1WG5sVWk5SXIzRVVFRUJpV1plSkE2VTFSWEZrektlbFYyQ2NuSnc4V3lxL1ZlejYvd0JlMEFyTDNWcmZQYXVxbU9LZFNKWWszVGtoMjVnajVWSXJTZzFmaW82ejVGSEx6VXliWC91NnJ0ODVDL2pXR3M3bUtHU2FjTXduWjFndDFYdHV3QnBISHhlcTBKOXJOMStHcU9SbGFiaGR1LzZqOExqMXZSYm4zYmhkUGd2NXNqK1dZcDQ3bTN1RlMzVkpWN3hrTXRXaUJKSC9BQzFxQXE4YWUwYm1tK3A4WExLYTEvSG1MbllJc25DK2I2Zkx3WDZ3SldSdVJjQjVUeWx1V1VMSXJwUkVyVUVWSklCNmJiYTFNZGR1blJITzhuTHZUdDF0SGRhTDhhZUFJTVVGemp3MGx3RGN4OGlJWDJxcGFsQVJzQm9xWFcvVFF5WFN1VERMdDZsT2orUDZBOVl4WDRnYmFOa3dWVWlYTWJkd2tEMjAvUFRweVJhZ2lrVVArelRrVExpd0ZhYmFRalpGTXlFZW8rQjB6VWpwd00rSjhrbGdaaGZsN3ExY2JNV0xTUmtDZ0FxYUVhcmRQQXZybGh5eWJmdzQrL2xOMWFYQmo1SW9VWEVYRG1EK08xUHdiVVUzWHNKMVZ0Vm9EVDQxbEZRcUVVeFNFQWxEVUU5UnZ2cVgzYWtmczM4RDJUQ1c4VnNaM25qTHhpczBjYks3Z2RLMEIwbGtseEEzMjJRbUdQU1ZZNHc3cXkxNUVEcitIdzFZaXZRSldlTHNydTJ1cmhRT0Z2R1czMjk5TnVvMUcxb0pLc2cyeGtGc1BxRWQ0NzJFaDdaNHpSZ3czQi9JaW40YWV5bFFSVENQa2R2YTNTWS95TzNZaGNrelI1Rkc2UlhrWkJZMS93QXJxd2NmbnFGTkpyNEZ0NGNOZHdFNktDM0JxclhhbTRPclNrd1dvRkJVZjRhUWowOG1PLzhBSFNFU2JKeUpHZ2RoMjVsS2U0OFFDUnNhbmJZNlpra0ZyVHlESjR4QUxhOG50MWIyM01NRXp4Q1FVcFE4VFExR291cVlwSUZ6bGJxNGZuSklWSDlLcDdWQTlCdDEvUFRxcVF0ekRXS3pyeXd2WVhYRjFrVWhITkFPblE2cHRpVzZVR1U1TnRqbzlVZFgvYlRJNUs2KzNXRitzUGZtV09TSloyM1l4Unl1a1lKOWFLQU5QN25ncmp6S085S1dmeHRWTmh2RXMzaVUrZjZtV1VNMjZsaUZIcDhkWnlDUUZJZDZhY2FUYkhJd0ZCdWZUU0hOTDI3VHRWZ1ZPa05COGNkd29RQ1RweFFUYkRIc0hFaEhUcHFMSFNIcXlxOXF2SmZkUURmNWFySm4zWlBQYy93MDhEbTBSY2ZXdW1HUEdSZ1BscDBJZ3oycGxlb05COE5PSWwyT0prbGNLcTExRmlTREUrSlcyaFBOQ0hBcnZwaVRVQ0RtbEFtZU1mbHF5cFd4Y2xpYmtlUTIxTWdZaEJYYnFkSVFSdFIyZ0dQeDB4SkJhM3lJRGNUMDFHQ1VrdnZpUWUxdnhHbUhrMXR5clZmejAwREVxT1dwQ2svbnBvSFBicUpvYlc1dXd2UHRSUEtCOFNpbHY5bW8yczBteXpIVGRaTHhaeXJucnk1em1TdjhsTTNDV2pTenNCeEJhVWhBb0EvSFdwZ3g3S3BHSHlzMzNMdDlDQjQxSGlidTV1N0hMKzFKWVcrbkpvS09vMkFKNkg0ZkhWMTIwdEFiR2szREZtK3QwanVHampvUVNlTk50aC9ocWE2RmRsRElMUmdkQlhUa1JoOFNMeFhQSzJSWkx1NGtTM0N1dkpSRWFzKy9wWFlmaHFOdWhaUnd3L21QSExYSndOZFlxYUpFaVl0SkdwOXZOZ090TjFOQjY2cnJhT3BmZkducWhZdk1MbUxmOSthTjVrUUJBNmt0UlI2VkdyVTBVT3JSQUVjRTIzNlgrQjlwcjh2US93QXRPUk1JOGZKTmNKYnhMemtkbFVLQjd2Y2ZocERFM0oyZjBkck5KYlhEQWJKSkJOK28xTktvdzJQNGJIVERpOHRWcnB4akxtUjZiLzRhY2NMWWxaVjUzSVFsS2NQYWVKL0VmK2Vvc1I1SmRDV2RtQjROV25KUUIvRURTZ1JMZ2RyVzZpdUhZU0twREJnUXdvUHcxRWt1cGNNbjMzdmNmNC9oc1Y0NGh0cHJHQklMdVdkVXVXbGROaHhMZnBXbnBTdXFjdVA3bVIyYVNURGFjbmJWTHdMMCszdm1pZVgrTWYzaTZqUzB1clZqRmtOK01BWUtINXFXT3dLbXBGZGpvVFBnZU9IMnQwK1dnZmd6YjZ1ZXd5V2w3YlgwYTNOcFBIY1d6MUN6UU9zaUduWGRTUnRvZUdpOU5Qb0ZZSkZTaHFLYVljTVdPV1BJSUtjZlU2WW5KTnZya0dQa1NOTkE0azVTS0c0SlBVazExTkZiSzZ6OXFuZmZ0cjdSdCtlclVWMkZ0b3RTS2pVVjQxMjBoanh4UWZqcHhFZWpLZHRJUjVUZXA2NlFqeGdXV2c2YVF4cEd4b0RweEJmR1NsQ1BtZFJhSnBqMWpyaFhnQjUrNGJIVlRMRXpUZXliR2hyOEJwRHlBSnBQY2FtcE9wREdLN211bkVTVUlGQ1RRNmkwT2dqQzU0OGkybUhOYzF5Vkh6MG9GSkNlNGZxRHFVRFNSNUxuazRVNlVEU2V0T3dHeDZkTktCNU5EVHl5c0ZIVFRrWkpTd09zZklqVERrYVV5YjdiYWNhU0t4a1g4UGhwREdVYlNPYUVuVGlOM2FZYm5mU0hOWkZEWFNHUENSV25wcENJYzM2MkkrT25JczBzdFFTZE9SSXpLZW8waGpPTVYwaHlUR3hqMkhycGhIanlub0R2cHhTZUNVOUMya0kyaTRSZWhxZElVa0h5U1NHK3drU2RpdHhESTROd3RPU3h2UThkeFdwSTYvQWFQd1VUeHR5dEgwNzY5d1RrZEpncVRPNCtlU0pTaU5GYXhocEFqR2luaUtraXZVblZpWm50Qm5ENGl4eldIaG51YmRvYk1PZzR4dXdhVGgxNVVvT0pKMkg4OUNaYnVyTkREaldTdXEwQnVjaHNyTzJsQ2tSSkl4QVJUN1VST29BL0xVS051d3MxVldwVmt3RE96SVBhVFVmaDg5SG1ZSGZGYk16WGdjQ29XaHI2QTZyeU9FWFlsTmpvdnduQzJ0L1pSM0VpcTU1dmJYQ09vY05ISXZFMUIrRmVXc2FJdEpxdTAxZ3N2eDIydk1EZDJHYXRHYnY0NGwyZGR3YmNIZ1E5QnVvSjRFZjVTTkxKVkxWRUtYYjBaYlBsT1FONWhXek5sR1BwcnVHTkY1MFlrelNVcHhwVUd1M3oxbjV0MXF5Zy9BMG1BTXZqYmUydHhqcGNlMXpMY0JiTk9KVkQzQ3BkbklxQXZFbllmQWpVYlkwcXcxMUhya2F2dVRPYmZOOEJkcmRTUkYyV3k3clIzRm81ZGJkSlVGZWNpclFOeVUwYnB1UFhWT0c2eHVPL2ozK0IyVlo1T0pXYjBhNmR2aS9HU3VwUEdNaFBESVlJSlpFZml5ek1yUndxcEhRS1FDVFE5YUFVK090TmNpdFdwWm0zNEZyVmUxTnozNkw2ZjZmTUEzMkx1N05sckoyMlJUUmE4ZjRmaUR0dm92SGxyWXg4L0d2amVqaVB4L29DcE1lT0NYQ1NGM3FVYzduY0NvNkRZRVZwb2xaT3htMjQvU3ljdjhmUU1ZMkdHL2crbHQ1WXVjUkhKWnZZN3FmZzVyVUtlbE9uejBOa2JxNWFOUGkwcmtydHExcDQ2VDgvMEM5cGo4Y1lIdXJzUlhDMnIrMEpzSkZja0FBZ2lwcjZmTFF0c2w1aFNwTlBIaHc3WnZGdHIrdjQvcU5IaVRPMXRMYVR4TkRZVEt4dHIzbjlPQkxHU2UzelpXS1VydXEvcVd2NUE4cnJLMWZkZmpxYWZBYmEydFF1ejZmTHlKVnRrcmFDeFFUWlI1clZKWmtXMldOMVNVc1NXWXN2NmlQaXg2ZW1xN1kyN2FWMURNV1d0YXk3eXBhN2lka283VVhSdWJJeVhjVTRQZWlZbmtINWRXWGNDdGRxNjBNYmNROUlNVE9xcTI2azJWdXZ4K0g4eUhIOU1MbDVwTGNyeWFxd05UanMxUjhpS2RScXkweDFLcUt1NlhYcjIvSFVrbThaY2UwYk9xeXZNclVVcnlxdTNRQUdtLzhBNDZyMmVyNUJUenhqYWIxYkNjbVVOMUFGWlBxR0FYdXcyOUl3NWpBclRnQldnYi96MVI5dmEvRDRodjhBa2I2OU56N3BkNCtCR3RjS00vTTB1THNwSlZzMEltdUtsSVlFanFTV21rQ3FPSXJYM2I2dGVWNDE2bjEvSFFEKzFpeldtdGYyL2w4L0lCU1QzQWVPYkpYUmxSRlpvZ1IrMHFzMUR4TzVacUwxcG9wSlJGRi9NelhlMDdzdDVTNmVDL20vMEhURlcyU3dMNC9KV2NnbnhkNjZHMW1oSlNQWlhGSm1MVkJCNlZXcDZiYXk4dHE1SnEvM1Y2LzBPaTQxYllYVzFkYVc2ZlQrNS8wMVBjeGpMYUhIY29JWkxpNkVuYlY0NU4zNWNpdENTR0oyNkJhVnBUVFlzamR0WENKOG5EV3VPVW5aL3FKS1lTK2E0YUs4dDVJWlFyU1BRaHk2cUtua0tnVkpHMVR2clZlYXNTbkp6SzRlUjJpOVduMStQOFA1ZzY4dEpyQ1l1bHVGU2RSS29sTFNGVkJJSkxLQUJXbnoxZlM2dXRYME03UGh0aHRLV2x0ZFpjZk5BcEpDbENWSUc5ZldtalRuajEzdDVlb1BjUFNncHBLVUp3K3BwTmt6amtRT09wYmlPeVQxc2V5a2dFZm5xU3VpRHBCOGJPTUNqaXArSTA2c21NNngxSm1BeE5sZTV5eHRicVdSTEtXUUNjUlJ0TTVVYmtLcUFrMTZmTFR5SlZMMi9zSGplV21qdGJPOWdRSUFxV2puc1RiYkFkdVFLMzh0RDJhUVpWNmFsYi9jQzB2ZkdNdmJYT0prYUMzaXBHUkY3VVoxM3F3NkhsOHhxT0pxMHBsT1MxazArZ3I1T2V6dHMxZHl4VUZ0ZHAzQkd2dTRyY0lINC9rVHErdlFoWnhaZ2g1Q3lveUFBclhmcnNkV0ZSa21RbldCN1lOeGpsSUwwL3E0OUFkSVVteTNsQ09yOFEzRWcwUHJUU0dRd3h3MjJRczhsWlcwSnBPZ3VMTmZoTkVPWUFwdFduSkIrT3FXNGh0bHlXNU9CVmpvUUQrR3Jpa3o0amtRS2RkSVJsd0drSXhLZzZRajZKbWphb05DT2hIejBoR2ZjcS92UU1ENkQyMS9ocENKMFZ2Yk1FbXRuS0V2eGVKeDAycnRwRW9PMXZ0SGIvM1A3YldFa0NjWk1hWkxTNXB1R2NIdWxoK0lrR3EvYzNhMTYzdC9mUlI4SytqL0FQdE5qaHRmYmp3Wkl5T01rblptNDlOWlNZVUw5eFlkdW9ZYmpUaUIvRmtlbnA2YWNZSTJjUWxiM2ROTU9pZkxiSzNRQ21tSkVtMGc0RmFEVENHQzJqNUlGb1FEcG1PUzRMTlYzTyttSFBKN2ZpeWxlaDlQWFNHUGpiU01LQ200MGtJMzJlSGFTUVYzT2t4RHBnY1BGQy9KeHlJL3gxRWs5RURmTFNzWWxhbEFCUmFmanBJZHNwek1zd3ZpMVBiUWF1UlN5TDlPSjFMRG9kUE1DSWx4YVBDYWpjYWVTTE0wbFVxQWVvMGh6MnZ2cXVrS1RkSEs2bmJUUUlscE94b2E5ZXVtSGtsUnZVZzZVRG4za3VjaXdmaTk3ZlRKM1ZaREFxVm9DMHdLaXAzMVRlcytsZDlDMmx0czIvMjZuTE41VjdhYTRCSDA4a2dTdlFrb0tuK0ZSclpxbzBPZHlOTnRvWEp1SEZwQWFzU0tmaDhkV0ZKQmU0bFFsZzI3THdKWWN0ajE2NmNpUlhkK1hHZ0xkTklReFlpQ1cydXJkVmJ0TmJxMXhPUjFLbGFsU2ZtQ0YvUFRQb1dWV3BZdUd1TVZFMk54OW5BYmxyMkFOTmNScU80MTFScFpTL1QycVNWK1FHcTR0WnVPd1JWcWkrSVRteGNmSmhSN2VVVjVKeEpyL3NQeXFOSW0yTE9ad09EbStwYkl1TFNlRkZra2RlS3Z3ZXZGaXRmZDArR21sMUlXclY5ZEJZVEZYMkNjWm5HM0VkL2F3KzYzbWlxL0J5UlFzdlZkdFMzSjZGV3gxOVMxTmZrWGtkdjVEQmF4WE5uSGIzNnNYdUxoRHhXUVVvdGZTdGV0ZE5XcnIzMEZmSXJMcHFBSmNWTEczRUQzZnFDK3BCOVJUcVBtTld5VkVKN1dSVzRrR3BOTklRd1IzaVlxeWUwdUlXUnduS0puWGlXTERZaXRLalREekFzcXpMVWc3bjExSmtEZWs1VGNOUSt2dzBvWTRZc1dodXJkbVdHazhaQU1pc09MMXJ0eFByK0dvTWtnM1llVWVRMnVOdWNMYlhicGlybGxOemJnbnNzNlU0bDErSXBxRnFKazFkeEJZWDJlOHhqOGV5ZHd1VnlBdHJDYUtWcmxIcVVlV01BeDhRQnMvVUErdGFhamtwVjQzUFhTUDQva0VZTWpyWlB0M0xSOGIrN2VMOGx5NzRkb1dzcmhtNDJyR1FTSklUdUZKQUFWajZEY1Yycm9KNEhFaDllU200WmFGamNOQXF1MWFWNjZHQzBHTHE2RThTc242UnBpVGNpL2VQUXM2bnBxd2dLR1E0c3NsUlZqWFUwVnNWNWtLdFFkRHFSV2FUSFhycHhqeG9nRDhkSVJqMkJXdnBwQ05Fc2FnN2RScERHSVd1a0kwdkFEOGovTFRpSkZvR2lOUDRIVERvTzJGNDBSclhZOVJxTFJOTWwzVjRIR3dvYWFhQjJ3UExJUzVJNi9IU2daTWsyZjd2dHJ2NmFSS1NRd2FNOERUYlREbTVaSDRBS2RLQjVOVXJCZXZVNlF4QmU0M3BUcjY2UTBta2d0OHlmWFRqRzBJN3FCNi9IVGlDTmhqbS9XNDIrR21ra2tFSGhIR2c5TlJISVR3L0xyNmFjWWlYTnY2RWI2a016Q0dKUWFuU0dKYlFnaWcweEloeVd6RGZycEVTSzZOWGZxUFRVaGpWMk9aMzA0eGliUW5iVERRWXRac0Iwb1BqcENneCtpY0d2cCtHbkdneGtoWURZYVNFUnpHUUJYcnB4akJ0T016V3lrVUk2alNHa21acUkybUF4OXhDeTl1OEVobERBT1duUitOQVBUZ3BCcWZqcSttTFZOZy9JdnRTUlVubFVrNGtsUERqRTBmQnBXUE55Q1FhVk93QnArbFFOR0tzR2UzSVZTK2h3bmlHSkRPRmVSUkpKdlN2S3JBZkgxMEhlbTZ6RDYzMllrTHR6aExuUHZOZVRCN1B4eUFNMGJzRlNSMUc1WTFvS3NkTzdxbW5jcldPMlJ0OWhIdWt0akk2MmlsYlluaW5MYzAvSDFKMFNwN2dkb25RZGZDc2V5eXZEeG81NHVLK29JMjBIeWJhQm5HcTVPaC9Ec1pQWUpFS0JIbEMvZ3NpN2wyL0ttM3kxbXB5RjIwTEt0N1dTMGt1cGJkUUxESkdFd2tqOUxTbFRjUWxTZHkzNnhxekxyVWhSeFlaWWx0Y09xNHU0am12TFJ5SkladDVBc2p5Y1lxSnRRS1NhcjZOb09JNjZoYThqTFBYbVV1UEliS3lTS09HMWxsTjFDOXg3cmd4TEh4ZVNPTWVncC9VZW5wdHFpemRyQk5hVldPZTVXSG5tQVRJTmx1MGp3WGtnazUrd0tER0ZBWGtwcUtnN2c5VDY2RnlYaTZsZEdkQjdjMnFPUDdrVWRlK1ROQVlyR2ZIckJsT1BidnBLR0syRGNmYTRMTXhweDZIYXVpbHhwbHpwMjhRK3Z1RUpWZGZWMGI2VitQOGhZeXMwdDRqZDkzbFJhdUgyNWplaFBJMUpKTzIraThTVlRPNUxkMXJxdngzSWtGeGJ4U1MvM1N2OEFiWjFqczdtcHEwYktwNFNxU051MmFmbHRxMkcxNmVxMVg4dm1DN3ExZi9KK3h4VitXblg1TVdyakltenZKbWk0UkxFYVJkcGlRekFVREsyOWFqZlI5Y2U2cWt3Y25KKzNrY1FvNlIrcURQaVJ5Ri9PYm1hYmtGWXRGSHdCTE1DQ1FCVDE5TkNjcFZxb1NOWDJsNWN0dDlyZkRRc1B5REIyVTF2SERXZUlGUzhscWpBVHBOUU1ycVdOR0ZXUCtHc2pEbXNuT2gxWEw0MWIxalZkL01Hd3hKZWVPTGcya1dPK3NKdWNqU01VaWRKbTRLcTEzQ2tqOVFwUTlkdDlYTjdjbS90WUZyWGZoKzFLM1Y2K2FCRVdQeU9LbHVyU1dFUVhIRU1GM2FRS1NQd3AxR3JuZXQwbXRRWEhpeVltNnRKTWpQaWI1cEVsRkZsSUpMT1hXTHU4aTFGSk5LN2JEcHFheTFpQ3Q4YkpNOS9uRW0yVEVTY1VlV1lRbVpSS2FmcVk3bW54RzQxQlpWT2lrdmVCeExjTjYvUC9BRk5VZHJmMmVSdDVZM2krckJFNjIzYTc2c3dGUUhEQTh3MVAwZ1UzMVBmVzFXdXhTOE9SWFRUaHZXRXAvd0JSdHpQa0htWGxrVWdtdUlzZmhZbDdLV01jMFZuWUlqS1ZkR1FjYWxoMTVWUHdwMDBEang0c1VkYlc4WWJzR1dwbHRQOEFiWHczUlh6VUErNzhmeHNVQ05hM3lYMXpOUnBGTURSd2dOdVdqbGNLQ0FBUldoSHJxVk05bTlWQytQOEFBdHZ4OGNTbkxmbEMrUnV3T1JmRTQ2NHdXUnM1MnhtUldNMmJ1LzYrUnIrMTdsRy9Ma0c5cC93MDJiSHZzc2xXcFg0MS9rUzR1Ulk2dkZlcjJ2cEwvVFZmWFFKV21PdzF2Y3c1VHV2ZmlacExZOTkrMjhNaW5rUWZqeHB0OGZVNkh2ZTlrNi90Ny9FTXBURld5dk82Wld2WW5YdURlNHRyM0l1eVIzTjErOUhjQWNiUkNFQ2NBNVB1TEtLMUk2blZkTXlUVmV5MGp1VHo4ZU4xcFUyMW5zUjhEZ0xnUnJaWGRyTmQyRnduMUJ1Q0k0b0NRVHhYbjd5RDhsRzlldndzejVxcjFKdzFwNWczRjQrU3oyV1RhYW50QlRaczJCb2hCMjM1ZlBYVXJJZVlQRjRHRHdDTGlDQlEwM3BXaEhYVmlja0xWZzk3YmdHUmtZSnlvSG9lRmZnRDBycDRJR0RIY0t3UHdvZXROS0JtdkUxdXRUVVZyODlPaUxVbDEvYkh4UzB3ZHNtYXlDbythdWwvNmVKOWhGRXdxUHpJL1ZxYjhCNjFVVDNHL3dBditndS9HcDRjbkNrbHhrVkVWaTdxQzhaVDNOT3BwVlNEVGpvVzl0cjBMMVhkMUtOOHg4c0dkeHRqWXg4V2Nva3VTZWgzbmpIYjQxUG9LY3Z6MFJXdnFrR3U1UWtOWnFSeUJLTWV1OVJxNlFlRFQycElTUWFNdnhIcHB4R2lRQlNDTndlbWtJelI2L2pwQ0RHSXlyMlZ6RzdWYU5HREVBME5QV2gxQzlOeFpTKzFnNlpERlBJcE5hc1NwK0lKcURxWkI5VERsN2pwREdZWTAwaEhoWW5xZElSNVhjNlFpUmJKQzlCS1NCdFErbnowaHdsUGF0WnhxeU1IdFdjTXAvcURFZFB3MHc4UWRxLzZhTWhZM0hnbVp4NlB5dXJhL0RTUm5xcVhGdkdVTy94NEhVZmNkeng0cmRvdFg1cTB2LzhBYVJxOEZxTEx6SGJLUXhyRTFRQTFkdFl5TkJpZGUycXR6ZGhTbStwSVppMUpFUktXQTJycVJFMzJyOXNrZEs2UWdoR1NmblhTRUZiSUJlSjJycG1TR1MzRVJVRmlBTlJaSW1kbGUwZTJhN2JmanBoRVFvV0k1ZW1sQXhLaGo2bjE5TklZTDQ5U0tTRVVwNjZRNHoyVkdVdFNncHFJN0ZMeXRSY084VmYrRWFkRHNyYkw0eDFKYVJmd09yRXl0Z0JBOXE1US9vSjFJaWV5T3JDckg4dElUQnNxRG55WFlqVGtUSVNNdEJwNEhOeXNUdjZqVENKY2Y5SjB3aWFpUHlxQnRwaVFEKzV1UnNyTHhUKzIzZ0l1cjhoN2NWQUM5bGhVdFgwb1NOdFV1WGtxbDhTMktySFoyZWowT2FjeEpkRzJqdDRvenhYazZuNGlSdGl2eHFCcmJxam1yTVdYZDZsWkFRdzJJTlJ1TlRLelhJM1ZtMkE5TklSc3gwSzNGMGdjZnRwVm1IKzZvcWY0MDBoSVpiY3ZGWXl6T0tQZlNVcVR2Mm9qVW44Q3hwK1dvUHFYMEQzZ0hrQzRYeVlSdmFMZUM5dDU3QmVSNG1GN3BDbmNIV3RCVUVmQW5WdGJOSnBkeXRwTm9iL3VQbWNwNHpaNHZIMk13WTNOdnphZVJBMHlFYlZWejAyME92VTRMck9GSlVHVnlkM2tuV2EvbWt1YmxBVUR5TnlIRW1vQUhRVU9yRlZMb1UyczMxTlZ2ZTNOakozYmFSNFpQNnVIUTA5Q09oL1BUdFNNbTBGSTh0aDhpb2h6dVBYbjBGOVpxSTVCOHlvMk9vdzEwTEZhcldxTnIrTFRTUkc1OGJ2WThwWnFLbTNKNHpJUG1ocC9LbW8vY1hSNkR2RSt0ZFNGam9ZN3pLSlpaVU5hcEhWN3Z1cWFySEh1ZHpRaXZUZlU3T0VWcGF3d3Y1WGo1N1hFVmd1SXIzSFhUZ1cxQ0hLZjFld051aG9QVFVLM2x4M0xjbVBhcDdDRVlYRFVaU0NPb3B2cTZTaURXVklQR2grR2tPTk1OamIydUtNcnNESWltUmhYb2ZRYWhNandBYmZJWEVUczhjakkwbXowT3hyNkVldXBRaUpPaHZGWS92TVVyL1d2KzBhYUI1RGVBenN1QnlVR1RnalM0N01xU3FoQlpDMFRjaHlGUnR0cFZzNjlIRGhyNjZFNnVCM3duM1I4bWs4cE9VVzVrVWt0TGNReXU3Uk9wTmVIQWtLRnA3UlFiYUZlS3FxR1V5M3ZiUTZFdVB1ZjRyWlFZOTU4Z29USnhMTkVzWU12YlZ0djNPTmVORFViNzdkTkNmYWN3ZzVjaXNJSVhXUkVxTExHNnZESW9hT1JEVldWaFVGU09vSTFHSUxkMDlCZm5jeXlVMDhFV0NiaUVoOXh0OGRTSUVkMFFldWtNUm1lbGFuYlVrTWVsMUkrZW1FYUhBT25FWUt2V21uSE13bnVGZlU2WVkzOXJqSlFmcFBycGh5VEF2RjlNSTNPcWtFMTZhUklIVE95TlFEZlNJbSswZDFkWHBUZlNKSmhDNGN1NHA2amZVUjVNb2lRTjlJZVRDNE5TUGxweFNRV2k1dFFhVUNDRUZwc0RUcnBEb21RV2dWcWtmUFRTSUp4cUZGQU5SWk0yQzM3aU1kSVJGZTIyTk91bkdnaVBBMUQ3YW5UakVmdEVON2xwcEVUY3FsaDAyMGlSOHNKWTlOdElSaExqQy92QTMwcEdnMUxZRlQwcWZYVHlLQ1JGWVNNYUNPdncwaFFUZjdPSkZyS0tmTFRTS0RTMlBqVDJxS2pwcFNSYUlrdUxSdmxwNUdnZ3o0alliME9ua2FBVTJQS2s3azBPMU5Ta2pCclcxWm1DcU9wQXIrSnBwMXFJOThydDVjZmJ4WXgxTExiU1NtSnlLVkxFQnRxN0E4ZHRHWXQzUnN6dVJhWEhnVlJrc2RmK1EzeHhsbTNjbDVjMzVVamhpakEzWXNmeC84QURSTm1rZ1ZKdlEzWDF4NGw0K3NhWHJ0NURuWVVWRlJUMjdTSGdLQlFUNmZIcVQ4dEJ0WHQwMFFUTks5ZFdKWGtQbHVXOGhrN2R4SWtka3BySGEyNDRRQ2cyLzRxYW5URld2VHFReVo3WFVkZ0NpR1NaRlA5Wm92ejFjRGxxK0t4b3VVaVJ6UVNnSXJmT09nMW5aMU5UU3d1R2RMNFczaFd6bEVrVWtuY1dLSWlJY2l2TWs4aUtqWVUzT2hzYVVNdHZhV1dOallTdDAxdkd2Y2xoTUlqdGFyR0pKSW91VEJhaHFIM011dzlmNFdiWlpDZERETlpqRzJVVnplMzdkcTNoaGxGbE1Lbm1sQUpJaVJVQ1JhaWk5ZHFpdGRENUtRMnkramJVQzlpZkpDYlRHNXUybmt1NHd4RnlWVldLcmJnUkhsekRBTVZrcWFkYTE2NnlaZGJObzJyYlhqU3NDelBObFlJc3RlU0NXVy9lU1VBSGtwajVjQUtrRG9BTlVaSEZ2TTB1SHBqMDZGTC9jakFXbC9rSlpZWGJuYmtmVlJncnhlZzVJWDJvT3ZMNUE2SnhaSGpmVFJsdVBEOTJyVm4rMzgvaVY3TE5hUmNEUEdzYkJURXNNWmFRUEpXaEpicVJRN2dkT21qSWI2RW5hbGYzZGVrZGZ6RkRNMjk4M0dGdUJpL1U2UmtVUWduclNvNmZ3MXBZYlY2bk44ekhsZWppUElFUld6M2tzVnJLekR0KzIzWWlvRzllTlBnVG9sMjJxVVpkY2J5TlZmYnAvTDVsZ0dHN3hWdmJkdUNlS1dPT0tSV1JVUUs4aHFGSUpKSWIvS09uWFdOTmJ0eTBkbDY4TmFwSnBwTHcrbjlBMWNYZVltUVQ1Ti9xSjNqU0JWa1ZJVVFvYXFSV29JRktWK2VobFdpY1YwUm83OHJVMjlUNmVFZUJBdUZ5Rm5jaDVCMkxtYXNFOHR5cEk0a1VaVzZqZ2VWUVQrT3JFNnRlWFhRb3NyMXRQUnZSdC9wOEJqeUhqbVR0cldQSVFTMjMxU3dxbHpDWDd6T0dBUmlqRUJTMUtVL1A0VjBKWExWdUhNVG9INU1HU3FWcXhNYTkveDVDcmQzY0VVN3RjUUcxQyt4Ynk2THlwVTAzTzVBWTAycjg5R1VvMnRIUGtqT3lacTF0Nmx0L3dESzB2OEFIa1k1UEx4eXl0RGg0dUVTMEV0MUt6RXl0eUhSaWFBYlVYVDQ4VUwxL1FiTm5WclJqWHhiN2tPNWh6bjFDeS9Vc0VpS3hQS1J3VXh5R2xGV29aalE5RjFPcnh4MEs3MDVDc3JidW5YNFA5ZmtHZkdQRTRMTzZ1cjV6SGtyb2p0TGJja2VidlNrRU1rWkpKQUZRUXdyNjZHNVBLZHFxdjdWNDlvODJIOEQyNm1LOXNqZTkrSFhyNEwrWVl5ODU4ZjRaaTF4c2MwaU15cGNYYk1SYnRKN1dWb3BCd2JxZUxBQ2gyK2VoOEVaUFE3Zkpkd3ptMXRpWDNLMTBudStubHJvREpNaFA1TGhiK1RQenh6Uld5SkZCRlp3ckhjdWVmTVNDY0JWUUIyOTFGSExwdm9wSllzaVZPL2owK2hqNU4zSXcyZVJyVHB0L2QvK1hiNUkzZmJmSFc5NWZmVmVVeUM1aVl4eDlnMEhjNTBCN3JzdzRrY1Q3aDg5VjgrN1NqRW8vSFl2OXV4V2RYZk01MC9FK1phSGw5LzlzNUx1MndFRWozbHpCY0xHTEtKbVcyalpBWFZpeWozZE92STExa1k2WnExZDY2YWRUVlY2WHNzV1NQSmEvS2V4R2k4aVZYbHVKTFdidEpHdmNpTEs4WlVHaU5HV0sxMkJyeEczcnF0NHBVU2FVeDIvSGtjL2ZUeUlybVFiRDlKYmM3L0RYYUt5ZlE4bWVHeW1UZmpqYUxQMmJ1QVhBbkJpaldqRXE3YkRkS01Qd0FPbXVyTmVrQTVGR2xLSGJHelp6eGp4eklZYTVqeU9OOFh6S2xqRmVXY29TV1I0d2hIT1ZSSDZCMFlBSDRuYW1xTWxyMmFsUzAvSCtBSlhKZEpLQ3NMaTBTUGRTWEZTRUxkZVBwWDUwMW8xdlBVSXRqaFQzQy9pV0dqeWVTUnJ5b3NiYWp6ZW9MZjBvYWZFNnVycnFVdFIxTDN3dVBhWHRyelZsbHEwc3BKVVF3S0t1MjlLYmRkS3poU1NWZXhYWG4za3J6SmR2R3pKRHZhWXVOaUJTSTlXcFFiMDNQNGpRMWF5eXl6aXBWUWpKSEdsRC9zL0xSUU5CNzJqdFQwMGhORWVhMlltcUNvSjNJMVBjVjdTSzlsTC9UdVA4cDJPcEpvaTZzK1d5cXREN1grUnIvSFNsRFF6NWJXNkh1QzFGZHR4WGI1YWNZTHdZdGNrcXZJV2htVlFPbFFRT20ycW5hQzVVa2tSWUpvb3pISWl5Yi9yOVNQdzB2dUlYMm1hNU1IRVRSQzBaK1c0L2dkUzNvWjBJRnhoN3VBa3F2ZFQvTXZYK0IwNnNtUWRXaUJ4WU1WWVVQd1BYVWlKa3Nra1RLNmtlMDFvZHgrWTBoRE5KbGJMSTRRUWhlemRRU0k3MjQzVmdhZ3NsZjVqVVkxTEcwMGRLLzZic2tZYlBOUnFnQ1hNVnJKekIzTFcvT0toSDRPTkxsWDNjYXRXL3dCbDNwLzdKVC8reWpSNGpodnpMZHZienVkZHhySGcwQmZ2WktxZm4xMGtPeGRtSHZQdzFJZ1lLRHk2YmFRaWRFZHFEcnBEaFMwY0dsZEljT1c4NkdnUDVhaU9tRklwVlZlSVBYVE1rWnN2S2hIOHRNTUdMQ0NHVkYyb2RNSUppMGFNQXFBVTlhYVFpYkRjcEhIMmdoNlVycGh4ZnpGdVpiaFpPbTFLNmREQ3A1TGJ1c0NsdDZucjhxYW1obUltUlVoYS9BNm1RWU9ZdDBwdnB5SnFJMzM2NmNVbXdRMTNwMTBoamZEYk83QWVtbUpCcTB4clNNdnRxQnBwSGdtUzI0aVpVQTNPMU5JY3EzNytUMkxKaTdTS1VQZlc4Y2kzRU5EN0ZmaXk3L1BmVGNkemxjZUJWemF4aFU5M3A4SUtWeTkyMGx3c3FwKzJuRHR4bm9GUVVBL2xyV3IwMU1SbnZsRXVJeTg2NUN6VVFPTGRUT09oTWlyUTFIcWErdW9VVFhVbGZhNGdVcm0wNElHYllzS2xmaHEwcU50Z2grbGZ0cFdlNmxGdkI4YWdnbW41a0RTR1FZeU1vamN4STRhM3RJeEFtLzhBOTcvVWZ6YXAxR3ZpWFcwMENIMjB0MnlIbWxtcml2QVN6a0gwNG9RUDhkVzE2bGFlbzZmZnB1MW04WEF0QjI3WTEzM05EVFZGZjNNdHlQUkZRVlozQUZhaWpmdzFZVUdpN2ZpQ3E3TTN0QS94MGhHbEMwZXlHb0EzcHBDSlZ0ZnlXMHF6UnUwTXluMnlSa3FSL0RUTlNPbTEwR2RQSjViNjFlMXpFUXVra1VJTHVNQkxnSld2V2xHRlIwT3F2dHc5Qzc3a3FMZlh1YTE4Ymt5VVlPRnY0cmpnYWl5ay9iZmYxNE5VRS9ocVcrT292dHorMXlETG0zdWJKbXRyKzFhRXIwRGdsZnlQVWZrU05UV3ZRcWE4VFJhNDBYbDVERGFBbVdXUUtxZFJ1ZlFqU2tTMUozazFqRmo0SkU0VFd0eHpWSGlZbG9wS2RTUTN1VTdWOVJwSjl4N0tOQlNJTmZRMDA1RXpScEN3Q0RreDlOUElocnQ0Wk1OYXJkU1J4eTgxNU9qclVHdlQ4S1YxRjZrdWhEZ3lhTy9LVW1Kei93QzVGNkEvTDRhVUNWZ2tKM1daYm52TFBDcERBSzIrM3krT21IVExBaSs3TjNiZU9XT0h4WWFPNXQyZnVYRFVma2pNV1ZRR0I0Z1ZQeHJxaStQZGFRdFo0ckNMR3dQbGRyZVlOY3hsSkk3ZDQyN001WGRXZWdJS3FLbmNIY2VtK2g4dEZWcU80WGl5N2xyMUQ2eTIxNWJwY3dPczF2S09VY2lHb0kvOHRRaUN4TlBvQzdncUdvQlFEU0VSU0N6VXBzZFNJbnBqNERTSE1TdGR2anBoSGdqQ21vL2hweEcrS0xrMVQwR21FYldROHR0TU9iVWpZVU9rT2JDZ0NrblRDQmx3cERFblRqRXV3VVBCVS9xR21IUnVCcEpVK21tSE53ZGEvRFNnVW1xUmk1cVB5MDRqMklEa0tqU0hKOXMzdkNIVVdTVEM0V09SUlEwWWFZY3lBVUQzSFRDTmtVaTdxRHB4R01pNzEvdzBoU1ljVXBYMTBoR2lTM1J6WDEwcEVaUjI5TmxHa0lsUldSWTBJcFhTa2NLMitHTWlBZ2FhUlFiL0FPeEFibFJ2cGg0TS9vNDRoVGpTbncwaEE2OUtyVUwxMDR6QWtqdHkzT3BFV2ZCd1Y5MitsQkJzanpNQ0NLYWNSRk1hMG9WRk5TR05VbHJFQVNvNG5UREFuekdHVU5iOTZCemV6S1pKZ3ZOK2FsVjdaNDdnZTBkZjQ2MHZ2YjFxb2ZqNGdHZkdrNTh5bi9JRzRXQ1hOaTNHNHZibVMwZU5XM0tJRk5EeE8rNStPcFQyWUpHa29ySzVabVo2NzBOTk9Wa3FMSHl5eHdsRklqSW9YOUFTU2FiNlVqazdENCsxWE1Xa04vTDJ1YmpnNmptVlBVRmg4SzZoZHVIQlBHbHVValA1TmZQaS9IN1dlMVVSM0tYYUczdUZGQ1RHeGNrL0d0TkQ0MU50UWpJNHJvZFYvYXZOMlhsM2l0cG5yWXFzcktxM01aTzZYRWRPYXRUMEZQNGFDdmoyMmFMNlczS1M0Y1pibis3MmEwU1M1TGZWenltaXVHWkN0QnRXaWdxdXB5U2pRRjVqeHhNbGZlVUxmUW1Pb2phMGhNWWtpRHFxdVpnUnNHNjFCMVZtcm81THNWbktLQ3QydWZIYzViV0YxY3lyaWJtVWQyM0RGRWJtcFdwQ21teGJmNWF5cVdUWFRVMU10ZE5CdHhPWFMya3VZYnBBdUp0aXNkdHhUbFhsRXBjVUJyUWxsWWZqUWFwKzA3ZXJ1WFlPVXFWMk1TOG1MY3RCZTNjNnIzTHFhQ1pIVThZNHBRZVJrV214VS9wLytLa1h4Nkt2Y2JEeTNYSTdkbVZSNVQ0MUJoTG00eDRYdWN5eHM3a0VxQ3FuZVNyK25wdDErT3I2WkxObWcxanZUVHEveS9INFlnUzQ2V0tXYXFnOW1UdFBKR1NZMTNwK3VwRyt0TlpFMGpDdmdhcy9KeHAwWHpDOWhpTFc2dUJSWlVoYjNSQ0VoaUN2R3ZNdDBxVHY4TkRYeXRJME1YRnBhM2VPMGZ4OEpHeDc1STdxemFSa2pkWkZvQUJJb1JYNThoeUJxV0JGSzlOWjZyb3plZVJLeVQvSGNuWm00ZTdsdUZ0dUszRXJxMElISUpTaEJZaDlsM3JVVjY2cXhxSW5vRVpiTzA3ZXI2ZUJxc0lMNlhJMnR0bHNZdWFab0drYTF0bkRFTjJ6Mm5rS21nSHgrSUdwV2RWVnVyMmthN25aVnZWWDA3ZmtFZklqTGlZcmVLNjRRNUNKQjNyZUxoektJcENoSVVxSTEyUCs5cWpFbGQrWDQ2dnVYNXJxbFY0cnc3L0JkaEhlRzlsaGVhNkNMajJwejdqcVNJM2JqN2kzK1ZhK2xhYTBxdXFhanFZdHEzZFc3UnRmaS94MFJKd2QwTEs0dDdJV1RYRENWdU13WHFTU0Y3WVlGVFhiY2FyelYzSnVZQ3VGYlp0cHRkdFhySDZmekpGeEdicThuYzJ2Q2FhUlJERmNNQk9YcFQyMHFmdzFXdlRWS2ZwMERMcFh2WnV1cmVrOWY5QTVpUEJjOUhsYkxLbEtYVHlxNndtcU4yZ0dQQmlDcEhLblg1NkV5ODNHNnVuWUx4Y0M5YnJNM0RuOHZENWovZTRiTDNVVXNXVHhzZHhOZHIzSnJaZURSZ2Nxb0NTckUwNGhqVnRaQ3kxcS9TNGcyR3EzckY0YThEekxmYkM4OGt0b2Y3NWtwQmJSdWtyMk1QR08yUkIxaTVxRnJUNGo4dFc0dWQ5bCtpcW1Pci9VeStUeDhmSTlOMjFXZWkvUStoczdUeGE3NDRlM2VHMHQ0MXR1UUg2Mi93QW9QdUo2L3FQcnFxMTdaVjZuTDZtbml4VXBXRldFdndoUTg1enh3ZjArY3Q3ZnV6R1RpalYvYmZqVWNYMjVWQkpQcFhXandzQ3l0MGIwQVBkZVQvalkxbFMxVCtwVnVYODh6Mllrai9hdDdlM3Rua2VKMlFjVmxjVUpGYWdINGVsZDlkSGc5dng0MXJMazg5NW52dWZPL1FsVkw5UmdmSEwrbWFCNC93Q21oMllVQXFUNmZ6MEpiZlRxYWVLK0hOKzJQNGhEd0RGMzF6NVhKZTR5ZVcxZkVNeDc5dEVYa2pSMEFES3dTVGk3VlBFMDIxTE55YTRzYWQrbHZPQmNQZ3JQeUxlcFYrMi9MK0pac1AzQXpHTGtkMHlzMTNER3hTWlo1REtqcWRpc3NjbEVZRWRRMGJhenEycmEwMW1yT3M1UHQwNG5hOWFaSytVVmZ5YUYzenpHZmJuTjR0ODVZdmFlT2VTTUM3WTJJOW15dkNCeUtwQ1NmcDVpS2xlUDdUOVBZMUs2ZU8rWGNxeFBtamdPWHg4V0xXdHRQOXR0TEw1RVB3YnhUdDJjTVV5VmVUL3Fic1YzRVRlakQ0LzA2M0hvam5lcjFDM2tua2xyaUdHQXR6Mjc2NlAvQUZSNURpbHVxMVJDVHVPWHI4dngwUHViMUpWWlRtZW1ueWw4WnllVUNWV092cUs3c2ZteC9scU5iSXV0allMVzJZTUtiTjBQeCtHcDdpcmFaTGJrbjNVb0IrV25samJYSjZMU3BGUHgwOGpiU1F0clg5YWdqNCt1bmtiYkpxT0tqWmdhRUQxVWFXNGp0TnFZeFFRUXZUNC8rZW0zRWxqYkNOcll2SHlLZzFiYzFQcjh0UWQwWDB4c21DSWlsQWE5U2RSM0YyMkRKb1ZiK25pZmpUYlVkN0hXTk1qeTJ0UWFvRFg0YWRaQ3UyQUJaZkdUWEVRTnVnTEtlbEtIOHRFVXVnVEppZllYbXRwVVBiblJveVdINmdSL0RWNllJMUJPZkZkbUJyai9BQ2lxblNIZ3UvN1I1YUsxeTJCVXp0RFBmUEpiZlRwK21VaTNWSDViL3BES3JENTZqV3U3N2lhL3NuNkIySnBiTmU1MEJkQnlsUU5aUnFBaTc1VTY2UWdlMFJwV21rTVpKQTNxUHcwaEc5SUhCb0JwRGtwQVkrZzM5ZEtCRWxMbGxJK1hUU2dST2h2T2hMYjZpSUoyMTZSUUhkZlhURWt3N1lYTVpJQ25ydlRUTkNHRzNrRGJFbWgwdzVKaENLOVNLajQ2WWN3djRJNWdLcjE2RWFjWVRmSmJjVWppWGM5ZnkxT3BGaUprN0JnZU5OanVOVElzQ1BiU0tlbTJwRUlQdnBQY3BJM1BUU0VTNGJQMFBValRTT2duWTJQTjZVMzB6SkliYmF4aXRiZnVPS01ScUpNQ3l3dmNYcWxSN1F3L2hweUp6MTkzWnNmSjV0TmQyczhkMUF6UXlGb3p5WGtFQUtuNWdqVnZFYTlVZUlIejZ3Nno0ZENwNys2TFN1em5kM0pQNTduV2tqSmJBOTNjQnVuL0FJNmNpQ1pwQ3psUXg5QlN1Mm5naVdUZWVKcjRyaDhIbjU1cTNGeFppNWp0U1AwelRvR2lOZmtIRGZsb0RIeWxseTJ4cGZ0TmpQN2ZiRHg4ZVp2L0FPVHNKZDdKUDlQU09ObUZSellBbWdIeHBvNUdTMlB2Mk9VVGVVM0Z5eThtZ3R1S2dmNTVaVVVmNEhWbFJJSS9mcTdEK1pKQUNEMkxkVlllbFRvZWkxWmRsZlFyQ0VFUnRLZGkzUS9MOE5XRkpBa0prbExramJZVjlSOGRJUjZ2RW5yVFNFWklwbGRVNmNqdlgwR2tJbHlPQXZKZmFkZ3E5S2ZBYVFqZGEzUEZxc2FNRHM0MklPa09odXN2SUxwNFBwOGpISGtyVWJCSngrNEI4VmVsZHZucWw0MTIwTDFsZlI2bUQ0ckd2TzkvNDVNMEdRNGhVc1ptQ3NySHFVWTdNZmhwS3pXbGhLcWV0UVhuNzN5UElXOXRiNXFCblMzTFVlUkFKRFVBVVk5VFQwMzFLdGFyb1J2YXo2aTYxaEcvdVQyRWZBMVgrUFVmbU5Ua3FNc2JqcEh2VWpOQVczREdwV2c2bXFnN0RTWWlmNUJjNUdHM2h0THBWN2J0eldXTWhvNUFuU2hIdzlRZDlTcDFIWUFTVXFBUFd0UjA5ZFNTMUdaTXRXbW1tU09IYVJqUlNLNlRxb0dURHR5OXBiVzBKTE9MMnBFbXdvUjhSVHIrR3FvTEpKVU04aHRTWXIzbEdSeEtEMmtWSFFqNGFab2ZjeDI4Wis0S1lUQVhHTUVSYTdMaG9IUHVTUGFqZTM0blZXU202QWpIbDJ6STZlTGVSUDVIWXZMY0lJN3FBY3BXWFpHai93QTUvd0F0S2I2cXZqMnFld1JqeTd0R0hvaWtpaDBZUEcyNnVwQkIvQWpWUmVla0JqU3ZUU0VlR0wvTHZwQ05xMjdjYXNLNlljMkl2RmhwaEcvdGcwUHJwRG03dEtCdi9IU0VhNVFGU29PbUhCdHlBemJkTlNReG5idDJ4eFhUTVJ0V1FGcU5waEcxaXFLRC9QU0hOZmNWaWFkTklZMkNoOWRJY2xRbmkxRlB2MHhKRWxKM0pveG9mbHBFcE4zTUQxclhUUUtUNUpncDlwMG9FYnhjeTdnZE5OQTU4c3JrNyt1a3hHOUY1RDg5TUlJMnNBSXFkenBNUVd0clFNd0IyMHc2RGFLa051QUJ2OGRJa1IzdVY0bGZXbTUwaFNEYnU1U2hOZWc2NmVCaGN2TG9PMUJ1UFhUa0d3VThsQ2VPNU9uSXRtSEtTdS9yMTA1RXlHL1hUaUk4Z2txZjVhUXpOWEZ2NmpweEN4NTNmNUNkaGF5M0Foc29vRWlDcVNvSkFxUS9xVFU2MDJxUlZ3NWpYK255Z3pNdHJPelhZckZvb0xWTGVlNElOdGF4M01xTTRJL2VjSGlRR29mVDRhaTNKVWxvS0dBOFB6R1g0M0J0WkVzVjl6U2xTT1FHOUZyNm5UWHVxb1dQRzd2UWw1dUdXM3UxdExZckhERW9KWUVNcUgxSkkvcS9BYWhqdE9vK1dtMXdiZkI3Q0xKNXllM1ZHbGtXM2w0eTFITG1WSURiOUJVNldhMFZrZkFwc1QvdWRBMk9zTVRpbWtWMkRQTFJHTERpQUZYcUJ2OEFscUdCeTJ5emtMYWtoby8wL3dEbWsvalhsRDRTN2ZoaHN1a2NTaHlRaVhWZlkveURmb2I4dFJ6MDNWbGRTR08rMW5lV0Noam16MHR4YlRPemtXNXVQV01KeExweCtITG8zNERRU2ZxaEJ6L2JKamw3cU5aY3hWdmJjWHBnZGw1YzFrRm12Q2dOQnNBVzlhL2pwdVJmUms4TmRUbm43bFdFTStEZ3pjVURMUEV2NzBKRlRFMU4xWWZnYU44TlpGSEZqWldwRzhkdTQ0RnVvTHZoL2RwMVdXNmRsTEZlNWFvc0V5KzRHcXFBci9ocSt1WDZBbWZqT3ZxOFFuNUVsdmNRUlhIQlJrRmV0N0pHVVlKZDBIY0FaQ1FTdEVBSXA2N2F2YlFBcEVQemZ4N0Y1cnhsRnMwQXlObEJieVF5eEFzRUs4MWxxcE5TZVcxS2luNWpUcTBPVUY0TWt2YTMxL0psSDN0ckNjZWs5M2N5UnVaTzA4QmpSUVF1MVZWRzNwOGRYMHQ2b1NORE5SUEVyWHMxckVRdnlnbStPVE1lZHJheXRFeUVsRkpYOXo0bW0xTnRWY2hScTFJVndMVE5LdHIrSTNXVm90Mk8xRE5HcFZ3T1JZS3o3MTlwSFFnYlYvRFdmYTBhczNzZFUxQ1pzeU5wQ08vUjNralZ5MzAwa2dES0dOQ0dja21oK1BUVFZzeWRxSnArWFlFZjl2M1YzZEdkUy9JOFNVaGRqYmNRZitXV0JQdE5LRDQ2di95RlZSL3FDZjRXKzA5L0JQVDRHN0crTDV6RXJkeTNTMjlxQUpFczBtZm5OSXJ0MGdRbjRFMGJwOC9YVFpNOUx4RXY4ZHlQSDRtWEZ1bEpkWThma2lmYStJWDBsckh3dEN0bmU4bnVIdVhCbGtqUFJGalN2QnZtV3BvZTNKUzc2cnBBZmg0RjdMOXVsdXM5ZjZFUys4YjhudThnYmE0a2xXenRDNklaWnUwQ2lVb3FjU3JWS2pZMDFaWGtZcTFuU1g1RmQrSHlNbDlzdmF2T1AwSFB4ckZXdGlyc01XMW5rVWtSWm5tSDFVYmNGRkpZZWJGcWl0UDFmUFdUeWN6dEhxbGVXbjFON2k4YWxFL1J0Zm5yUHdia2JNM2tjaU1jYmJEUXRGbExpa1NYVHNPNng5ZVBIOUlOTndCclB4S3U2YmRBbjdiY3VlbjArWjdoclc2OGRzMVFYYlNUWGpCN3FLWmpjVE81NnNHYmRTQnNCK25UWnNuM0gwMFhUc1ZMRFR0UHhCdm0vd0IxOGI0OUVNRGdiVnNqbjBSV3VmcVc0eDI1Y1YvZlpOK1JIUkVwODZhMHVEN1c4L3J2NmE5dkYvQTVqbis1L3dDUGQwcEY3L2xYNC95S2xsKzVYM0N1cE9adkxTR0VobUZzdG9uWkkzSEU4K1RFZW03YTZKZTA4V3ZaL1U1eGUrYzUybFdYL3dDS0UvS2VZWDAwZC9aMzZLK1J1VlJZWlloUlJ6TlhJUWsrNGoyZyttak1YQnBWcTFlaUJPVjczbnlVdGp5SlMrNkZTNGtsUWZUUjFEVUFsUFdoSDlJK0ZOYUtTZXB6bHJOTGFodWw4cXpIak42K0p1NzN2OXVuTlcvNnlMZjBKYnR5citITTZiYXJDVjNWaDNHZmNyS1JXNHRjTmxMakVBdjNRdUttQWphVHBWNEg3YnQrVEU2ek9UN1h4ODF0MlNpcy9NMXVON3Zud0tLTlI1MVZ2MVVqYlpmY0NUeXFCOE45d3JPSHlDSWdKSGYyckN6elVWZjZrYWJnNUkveXlkeEQwcDY2eEwreVd3VzM4VzJ4L3dDMTYwZngvcEQ4emV4ZStVeTBkTXRkazk2ZEg4YU42Zkd2MEZpMjhVeDExNUxkMjJXdTVjaFpXVEl1SHY1bE5xSklsUEpZNUZKTkpQUXBXbXg0a2pYVDhUZDl0TzFkbG4xVXpyOGZBNW5tNVhreWVxMitPajhoL3dBM2tHd0dJdWJXK3V4Ylg4MEROYk5FQUpoSCtsT1hXbnVPMnJiNmc5V1ZoWTIyVXl6eVpUSXp2UFBKc1o1U1dra2FnQUZUOEFLYUI1R2RVOUtOZmc4RzJWYjMwWDVraHNhM3U3bzRuMGJmWnRDck40R2hiaVBXVFY5QkcyeFVrK3BwdCtXclZrWVBiRFZkVVluRTBvNkQ5dnJUMXA4dFdyTURQaktaWFF4Rms0UHNvZmp1TlRWL0VIdGhjNkdTUU1DYTFWdW5UZjhBOE5TZHlQMnlSSGJNYVZXZ1BxUi9WODlSZHlTeGt5REhtWndVSUZOaldsSy9ucXQzU0xxNDUxQ1VXSGRUN2dTYTBIRWJWUHoxUThvWFhqTWxIQ1NBaCtKS3QwUFExL3cxRDdwWi9qdVRJNGR3ZUJUZjBCSDhkOUpaSkhlR05EYVBIbVpTUkd5MTNYMUh6MUI1ZFlMUDhkdFNpRy9qc2lQeWRTc1hxMU9wcDBvZFQrK1Evd0FieEZUN2lXY1dQeCtQZ1lnM2NybTRkVjZwQVJ4akIvM21JWnZ3cHJRNGpiYlppZTRKS0VnTDR0YjIyWXpGaGlyMTVmcGJ1UVJ1SWYxY1Q2Q29KQjBkZHdtek1wV1drTUtURHczenpCWExPWjdQSFNReVF1S0V0R0pDSEpwNjlmNGFseGN1cWZqcDlTekpYWlk3RVFwZVdrTjNDRDJMaU5KbzY5ZUVpaGhXbnJRNnk4Mko0c2xxUHJWdGZRMjA1U2ZpRExxeUxialZhSElxWTl5ZncwNGlRTEkrblVhUWphdHY3YUFiL0hTRVlQQlFiNlFqV3NJSjZhY1J2UzI1Q28vanBoR0JNMFRmcU5OS0JCR3p5QmlZYjlOTUlackRNOGhTdGFhakE4aDIxdjQ1UUFUdWRNS1FnNE1xQXFmMGpiU0hGN0tXYnlTaHlDUUJUVHBqYWdLOHhUVEE4VU5RTlRHQUZ4aFoxWWxrSUErV25UR0loeHJpUVZIcnRwNUdKTDJuYmFsS2FZVWs3Q3dWdjBWaDdldE5NeHhoeWtaN0t4cjhkL3cxRkNCYmlDMmdsbXVKVmdnUlNaSm5JQ290S0ZpZmdOS3pVT1NkSmRsSFU0eXo0UzF5ZDhvbFdjeGlSSUdVOGtZOCtJWUgxQkhUUm5FLytOYUdaenF4bXRxSTEvQmVnOTk0NndjaWdrWGRPVkswci80Nk9NMWdxWXlBRUFlNzUrbXBJaWU0aXhteW1XdExDSUY1YnFhT0dNQ3A5MGpCQi9NNmFZSHFwYVhpZG5lWCtHNEc4eU4vaUw2MFc0dHJKb3JSQWVpQzNnU0dxa2REN05lZXJtWktaTFdxNDFaN1B4L2E4T2ZqVXJsVXJiOVBnVmZrZnRWYlk0eVBocEdlRWtzRWM4bUFwMHI2Z2Exc2Z2RHRwZGFtTG4vNm1xcHZGYWZKa2o3YzRmOEF0T2Nsa2VCSVpybVdHSXNCeExDUG01NmRkZEp4Y3l5VmJUT0c1dkV0eDc3YktDdlB2SmEzZDE1aGYzeWUrMFZrZ0xWTlFWQTY2bGlzdWdGbHErdllScnVaWWJiMm5jVVJRT3RkV2c1RWhtUm93UDFINEhycFFJMnlCUlVxM0lqWWYvRzJuZ1I3YmJxem1oTGJBVTlCMXBwaHp5Um1aZ0NkaHZwQ0pNRkdJR3hOS2tBZitPa0k5dXA1bEtRUU0zTnp0VFlnZmxwRGg5b3phV2tUVHVXa0ZBOWFWcU4rdW9qaGZGWjlpeVc5NC8xTnAwa2psRmFEcHNhRTZyZEV0VjFDYVpaMHQwSmw5NHJpc2lvdWNaSXNZay9SSWg1eEZ2WDNMNlY2YWZjMTJFOFNmUmdpeEUzaHQxUEptYkZMdnZIdFJxaDl2YTZsZ1JRVk9uc3A2T0N1ajJPV3BBZms4Mk15dVJXYkV4eVc5bXNTQVJTVVloMnFYMDlaUzFJWGFuVG9BSjdONGw1OVVQcU9nMVltUURYajBFa0phOUZ1OHNjSXEvQlN3VGxYZHZscU5uSTZJMll5TWQvZnZMQ0tSSUJHb0g4eVB6MVpqUkd6STBjaFZxcVNEL01hYTBNVlFyWjNzOHhVU0FIZ0tCK2gvQTZySnBoVEg1WElXcVRKWjNCaWhrSENhTldwVmExb1I2aW8xRjFUNms2MmE2RDE0SjViWVkyM3U3ZkozRDBaZTZpL3FCa0I5SzlLalVNbFUxMDFMc1Y0ZXJHL3hueWkyOGlrbWdXRXhUS3g3UlVsbGRWOU9sYTAzMVRiRzBwQ3E1bFpqUEdvSUpCRFVQRTBJTkNQUTA5ZFZGMG13eWNSVCtPbWdjMHN3SjI2NllSSVZpUXROdElSSmpQSmFldW1ITlVzVE1DTklSQ2UyYzEyclRUaU5MUnZGVFNHUEtuOHZqcERuc2hkbENyL0FCMGhqMUl6R056WFNITmtaSmF1NUhwcGhFeU1NckJ2WFNIUnZMRW40dHBFamVrYnR1T21tRWJWQ3FOeHZwRG01T0xiYVlja3BFbzMwaHpZQ29PMmtJbldzZ0JIdzB3Z3JEZExHOVR1S2FhQkVsc2lqRGMvbDZhVUNrSFhOMmdCSWJwNmFRMGdPNnZhZzBOU2RTR2tFeVRGcS80YWRJaVIrUkJyMDA0eHVWeWV1a0tUWnlYalFDdGRJWWl0TXBjcjAwNGpFdUZaUjFOUlhUclI2ak1yWHpHOG5peVYvd0RSRms3VHVzZHhLUTBnTzQ1QW1vV3ZvZXRQWFd0bHBXdDJrNVhrWkZyTjlBWkRhNHpFd1dkMW01cmE0bnRJbGZzM1VsUVRLdklIaHZ5YXA2bXY0YUZmcWxJdFhwaWRSZDh0ODNteWNVdjl0a2FLMFVvQW9OT2ZOcWI5Q0J0MEFINTZldU5KRFpNN3N4THVybG5tY2s4Z2xCVG9LcW9CL25xYVNSUlp5TlgyNWx1N001QzZnaUhla1RzSXgzYXI3bWcrTkJxbk9rMHBDT08zVnRyd0kzM0V1M3lYa2xsYXYrcUNDSkdYWWU1ankwc0tpckd6dWJKR3FKSTNnK3N0S2lYSHVVa3AxWkExS2o4RHA1aGlpVnAyTzdmOVBubHNYa2ZpTjFrcEpCL2NNYmJtM3Z2NnBKWlQ3NHBpSzcxVVUvSFFWcUtsbXdpbDNaUUZmRy9JN2ZLL1hYMmFvYm1PWm5VUjFxSkNpeG1RclhmZ3ZLbE50QldzbW5JYWswNFFEOGxpeDl6ajRvSFFKSGRkMUdpaklZenNHNGdNQldnSUpKK05OWmRzMVkwNm16aHcyZDE0RlJaV3d5ZGxmWXpLVzBLcEpkRmdzTEVGekJDZ1JVZmI5UlZDMVBRNnJ4MzFhZlkxZVJncmVtblVQV3hiS1FRVFdVeTBsU1NXMm1MSjJuY1ZKVnFBcnlwN2ZjZHpyU3E5eWc1SEpYWllYc3IzY1lzcFJXdDRxLzhBVUFMd2FRSnN3Tk53U2FodE5id0pWS1U4KzhmZkdaRk16YXVKTVBmUHlFYWNXRU1qa3R4TkRVZzcwOVY2YTBjTG1zZHhsazlYWFFnWXlPV3dlWElSU0k4WUZJd1dXWGtEc0c0aW85dGFHdXFNclZvcWIvSHE4YzNUMCtNL09QSVpNSmVuNnNSU2NKTGVBcVpaQURSbUpxdTZuWU5XbFNmOGRCNWFhU2FlREs5MGRsM0hTZkN4K1JLMTVrclEyK05RcVl1NmFNL2JKUElxYWRTZW5TbWdWa2VQUlBVMExZMW4vY3RDSE5mM1NKR0xHRzNzcktNY0JrWm1qbG1ORFVjVVVCUUdwMUh4NjZkVlhlVy9BdDNQc2xXdmoxL0lpeHg0Ryt2WG5NMDAxODdWK3BuZDVWNUdnUEdvQTZuOHRLenlKUjJIcFhDN1RMbng2ajFiZlR4SVJkMmlWNDA3MGtoSklJMzRwdlE5ZWdHczIwbTFXcjZHTTZ5WGNqWEZpN1YyNjBLbWhvVFg5V3cyMzJwcXA2ZFFtbWpJUGtma21Pd0RSMnp4dGY1Vm9ST2JLMy9aV05OcU5MSTRQYlVuOUk0TXpkYUFiNkk0dkN0bG16ZTJ2Ni9Bd2VaN3Q5cS8yc2RkOS95WHhFNlQ3aFpYSTNrY1F6ZHRoclJsazRLdHAzd1NvREtHZVdVRThqVksxWHAwb2RibFBhK09xNjFiZnhPVXllNzh0My9mU3Y4QStuVDgyWjIvM1hoeE9Ebi9BTHlzVS9ranpTUjJRaGplR0NSQW9FY3psdVFJNUUxVkJ2U25yWFFsL1p0MlpiSiszM25yOEFwZjlpdlRBL3VOUExNVmhOTDQvd0NoUytReW1RSmtEeU0xM003VFhrN0U5MldhUTFacE45dHpzdnozMTFsS1YwanAyT0R2bnlhcHZWdVg0Z1pudm5jZTV5UjBGVHE3MGcwM2ZpRUxmSDVuTExIRHhMUnhNV1JRb0RBa2Jtb0ZkVTJ5VXBxRlU0K2JMQ2dlc2I5c25zN1JNbjVOZVFZZXplaGpOMHdXUndkL1loSUoyMzFtNU9jN2FVVHMvSTMrTjdPa3QyV3lvdk1zN3dYN1JRV2RoY3plWVdzT1V6dVNmbmVQS2duaVJBVHdXTXNLVlA2bUkvRDAxejN1SHZEdFpmWmJWVitaMFh0WHNlTEZqZjhBa1ZyZTl2bWt2NXNyRE9QNG5oNXN0YnRodm80RnVKbGdzcDR5eUdTRmluRkpDWE85Sy9xL0RYWTRMWHRpcTI1YlhVODg1bGFWelgycmFrM0NJVmg5dC9OaGk4Wm1icDRvOEpmc3JHMWxjTzhVVDFZSHRTQWdjbEZSeE5hRWFiSHk4VjhyeHJyVXR5KzNaOFdDdWF5aXQrbXV2MExZdzYyeVpLMnh5b0d0ckVHV1ptLzVSbUk0UngxWWJrQTE2MTBUYm9CSVJQUDg1RjVGNVpiMnR0YWlab25TMzdZV3J5T1R4Q1ZVOUsvRFZNd3BaWldydFpKTFZsZzQ3eFM4d21LdFlaQ0xsclpWTjNhcVAzRllWNUdGdHkxQi93QzJldjhBU1IwMXgrVGxVeTVIMjhIL0FEL245VDFMajhITnhzRmY3bzYxL3dEOFgvRDZIMTdnN1NWSTdxM0hkdDNVTkhLcHFycXc1S1FBTjlSV1YxZTE5UXA0YTVGdXJyWHN3SGVZZDBUOXB6RnYvd0F4QUswVGVoQkJHLzRhS3g1cDh6THo4VFRyQkFseDBrOHhoNHF0dndxc2ltckJ3UnRUYW0zclhSTmNxU251WnVUanQzanRCcGJHR0xZcnVUVXMxS21uclVhdFdVRHRoalNEMyszczlPS0x4VVZQK2FvK2ZycExJa1FlSFV4YTFLTVZsVmdUK0c5ZWxScXhYbm9SZU9OR1NyS3lrYUtSM2RRdFZWWXorczE5UUNPbTIrK212Y2hYRTVnWmNkWlN5a0t4N2EwQlphbWhKK0h3MEhiSWpXcGplaUdhTEZXOUFKVVpWTEttMWFWSTI2OU5DTzc3Qm4yMTBaSW13cGpsNXM2eDJjZkpuVHRsbklBSHVCLzJhVmN5Z3J0Z3RPZ1dzc0pEZFk1YmhReVhNMjhWcjI2VEZTdk03YmNhQWl0ZncwbmxTWW54clZGUHlhMWdzcmQ0NWJnRzNIRnBybEtNcUtSVnFVRzdLdGR0WFlyVFpGV1NzWTJ5b1BKck81OHB5Q1pISVJ0YTJ0eE10dkRHaXR4alNGRlNPTUg1S0ZVZlBYUVlickhLWHhPUjVHTzJScHZvMkk2enorSitScElqTVd4ODU0QnR6VkNRZEhxTDErSm1XbkhlUEFPWmk2anY4SDQva2R1L0MxeGEzSi8zaS9kVS9ueVA4TlJvdHRtaVYzdVNaMjc0RVV6WGdQajJRZ2RaQkxZd0xJVXBRUEd2Qmh0MG9WNmFINXpUejJzdWxuUDFOakE1eHI0QkNYSE5VMUcrZ2k2Q00xZ3kxSUdrTWEzczNVVkExSkNQa3RXNkVhUWpiL2JsbDlwTks2UWpXK0RjZnBKT2tJK1RIVFJpaTc2UWp3MkxNcmNodlRiVENBMHdNVW5FQ2hHbElqZmIzVWtacTNUNWFjWVliRElrME5meTAwQ0dld3lRY2hHK1dvd1NRZmp0RXVZK1MwSlBwcERtRFlnTEdTRkhMVGpTQ01qanFweFphTU9oR2tNeGF1TFJRM3ZYcHRYVWlKQW10bExrMDZiNlFqT3lVUlRDVDEwaEUrN25EZzFPa2tQSW5lWlNXeitKNXFPZTRXMjUyc2l4eXMzQ3JnY2xVSDRraWcwUG50RmZtWFlKM3lqais4bUFTZFJScEhrWDNOdVFxam9QNDYzS3JRNXk4eTVacXRjN0RhWXkvd0FWUEFKRnVhTkZJUUR3WlQ2MTZqVHVzdE1WYnBKcG9BWGo0bHJpWXJJcXdLcWhFTlF4WWpjaW82VjFZcGpVcmNTUFArblh4OGVSL2R6Q0lJK2RuajNiSXo3RWlsdUtwWDhYSzZBOXh6TEZ4N1B5Z045dHhmYzVGVjRhL1E2anZaSXJxOHZwaXZOcHJtNGR5ZHVzcmIxMTUzVndqMnZBbldsZmdnUTBLc3A0R3ByK09ubVE5VzExQk0wRUZsbThkZFBHNGpqN3NzN1JJMGdISUNOQ1FvUHovd0REWFkreVQ5cTArSjVsL3dCdHNubm9sL3RFek9lR3crUzJGOWRTT3dpdmJtYVZKNFR2eFdWZ2xBUjAyOWRWWitYYkRuZmtXOEQyaW5LNE10dzMzK0JXMG4yMmV3V1dPL1VYY0xOVkpBQ2pnVTI2Vm9manJRcjdoVy9UUm1IbDloellXNVVyeEYzSitCM1VDdEppcGU2RnFUYlNVRGo4RzZIUm1QazFmVXlNM0N2UVY3aUc1Z2xGdFBDOE0zUmxjRVYrZStpOUdBTk5PR1NHOWdQdHBRQUExMkE2ZE5SR1BCUXIwMnJ0VDU2ZUJ6YUdSUXhydW0vdzZEMCtPbUhKT0xnZDUzdkpoUUNuYkI2Vi9MU0VUYnk3NzBwVSs2TktpbzlEcGtTYjdHdUVwRzN0cndZMGVuWGlUUTZjUmEvZzk4dVhrVENXbHVyeVJyV3dJWUlHVWY4QXMraExkU1BYcU5VS2U0Vlc2aUVnNzVCaG9VdGJtNXZiVXgvVEt6M0VNM0VNT081SEZ1TmErblRVbTRIbFB0b1YvYzJ2aW1UbGRBalcxUU8zY3FuRkhOT3RPcS9ucDVaQnJHL0lCNWJ4SEoyTUJ2ckpmN2hhZGU1QjdtQVB4QXFmOGRPbW1WT2pXdllKNE5mSDRySDZLNXZHeDJXakxUQ2Mvb1p1TzRKRkNPbE50UnMybjBsRXFLclVQUmxmM052TGN5eVhBOThrakdSeUJUZGpVbWc2YXVUZ3Bha2lySElaS0xYNE5YWS96MDBpaUJvdFo4YmE0aVpIb2J3Vk5hR3ZKaFFhaVNBOGJFR3ZxUFVIZlR3UWttUVhpUmlrc2ZjQi9Td1BGaC80Nlpva21NR0d6T1Z4YnZlNGt0RUNqVkFiM2hISEZpQWVvcHFMVTZGaXRBeWVFK1ZwanIrVjhqY2xJSmd4bFVDcWtBRXFBdFFCN3FiNmphcWFMYVpHbVAyRjhzc2MvTlBEQXBqa2lQN2JjdWFTRDFBTkJ1TlVXeHRJS3BsVFliVitSMy9EOENOVkY4azJLcktGcHYwcnBoeWZCYnZzV0cyb2prZzI3TWVsTklSOTlMc1JTdWtPYUpzYUpGcW9vdzY2UWlBK05tQjJRa2FjWStGbE9ncVYyR21FWS9URjlpS2FjUk50Y1U3dDdBU3VtRVRteHpSbXJpZ0dta2taUTJhaGl3SDRhUkkzZGtqVE1SSGtqWlQwMGtJemlqcWFuU2tSdkxDbkgxK0drT2FlOXVWUHAwMGhqZGJYTEtOL3lPa09URXVXSkZUVFNFWnZNaWdzV3FkTU13UGRYZFhORCtlcEpFUWU4OVRXdW5JeWFXdVdVbW5RYmFRcE5abjVibjAwNGpkRE1LMFk2UWpkSktDbzQ2UWlFMjdGanNkSVk5U1ZVWnBIcHhSSFk4OWwyVTByK2VpZVBSMnVrbEpWZHdpb1BNSnplT3kyYlNTMjNWVEl2RmFuMDRna21ucHlPaUs2R2JiVVN2S2I4WGQ5WFlkcU5JYWoxQ0tGMDlWQkd6bGk2V2VXTXhSYm9IREVub09JUC9qcVJBamwrMlNTMVJ2VmpzdjQ2WmpGcS9icUJJOFNML3N0S2t0eHhWVS9VeENFS055T3A2YXplUmtpMFB3TkxqNFc4ZTVMU1JXOGtzNzZMeTY3dWJ5UHR1VHpqaE5DZVBIMjlEVDAwVGl2VjBVRkdUSGF0L1VNSGkrRm11TURKY0lsYitEbk0wZlh1SXg5NlUrTk9uejFLN1doSEcybnFNLzJzKzRTZmJmN2c0bm5jZ2VQWDhYMCtSU1FudDhMbHkwUk5QVkR4Yi9oNUQxMVZhcnZWK0pkYUtXUjJObUxHd3RMRzc4aHhsbkc2WHJReDIzVGdzOHFOek93b2VKMkFYNWZBNnljdjdXelN3dVdxc0ZwYUc5dmZGWUpCRmIzRjBzOGx5V1FvUDN5WktnZEI3WDJCOU5aVjY2cFBRMnVQZmFyUHFhdnVMaGNXMThXeGtxUlNXeVNYcVNpTnBwRWk0aVA5dEZaQVExWEs3MEJCK0kxTjRrMjQ2RC9BT1hiSFZTdFNxTE80L3RHUVpyYXhTUEFSbU41cmN5SklzaUNXcnVvV29FZTZrTCtvZnkwUmg5TFV2VXorWEdUV3FHZUcxOGJ5K1p6OC9raU5KaXByNlVwa21MUXN2ZFJwSUptcUtDTjVGNEdpMW8ydEJLcnRMTXB6RUZaZVNZN0hYOEdTeG9SN2pBOFZHTWxaRVJmcTdkRjdqKzJsU0dGU3ROeFRUMnZ0ZWcrTk9TbXNaOUJIY0pCZHA5SmFrQ0dhT1dzcWQwR3A1U0JSd1ZxampRZE5ReXEwU3RYK094MEhFdmplbHZUWHBIWDZ2c3ZBWnhuN0hBQnJYQTJjZDNORzNHTm9GQlFFNyt3L3dCVkQ4cTZCV0syVFc3ajRtdzg5TVMyNDY3bzhEM0UzTS9sRjR6NWVTVkxkWkNSYk04a2JzekNxcVFDQVZIV3UybGtxc1NpdXJKWUcrUkx0b2wyMVgxOGcwdGhicktjY2JSdTB0WkRLaVZNc1hROFdlbzJvUFhRanMzckpyVXhyOXNmMUEyUnVjTGdzcDNieTB1STA0c3R0YUJWamFSaHZ5NHBROGQvaG9uSGl5WmF3bXZpWi9JNVdEaTNteWZsVmQvb0RML3pHOXVZQk9MT1I3UkhCN1BkQ0VCVHVBaURwUTA2OU5FMDRDVC9BSEtmZ0FYOTl5dFNzYjJyejFEczNuQWw4UWZPNHVPWkpVcmJoT0ovZWtYZFZVQWx1STlYSG9LYUZyN2ZHYlpiNGgyYi9zTmJjUjVNYWF0MFNLM3lPWHYxeDVrbWxlUy91SExYckUrNlc3a0ZUellia0lDS3I2R2crT3QrdUdzd3VpNkhBMjVtUlU2K3B2MVB1Mks0eE4vZGt5dnlra2FwcjEwVzcxcVo2eFh1L0ZoaXh4SGtySXRyR1pWVGtDbTVici9scjBQNGFHdG54TFhRUHg4SGt2U0dQbUIrejk5Y3hSWDJabmh4ZGpJQzdYTjQ0aVFJdlZ0L1FuYjU2eThudVV2YlJTZEJ4L1l0dGQrUnBmRTE1eWI3WitPeVMyMWpmREx5eERqM0lsS1Jsd2ZSdlVmTUE2V1BIeWN1clVJdXk4bmc4ZFJWN21KTjE5d3J1M2VtQ2hqc0ZBWlE4YWd5Y1dQUXU0Sk8zeUd0S3ZCci9kcWMvbTk0dS8ySlZGWElaYkpaV1kzR1J1cGJxYzBIY21kcEdvT2dxeFBUUjFLVnBvbEJqNWMxOGptN2JPNi91Zms0UEJmRkpydTN2WXJmTlRndzRxT1ZlNTNaQVFHY0lLRWhWSk5hMDZhOHc5dDRyNUdaSnIwclczd1BUL2NQYy9zNHJOTkt6NmZFb2o3U2ZidTUrNG1SdXN4NVhadmNlUDJnYUt5WTg0N2U4dkM5R1BMa0dZUmlwTk51UjMrR3V6OTA1djhBalk0by9XL3lSeVhzL0JyeWNqdm1VMHIrYkRQbG5rV1F6T2J1WThHSTJ4dUxQMCtON2xCSGN6cWFPeWROdHVLMDlCcXoydml2RGlWci92dHF5SHZQUFhKemJhL3Nwb2dQZCtWWE9MOGFtZ25zWmJPL21ZaCs4UjdybVE4eTQ2R3RQeXBUV25mVXdsMDFLcXRjNVBpOHZaWGtEMHZiYVpKMmtiK2xnNEttdjQ5ZmxwN1VWcXRQbzBQVEs4ZDFaZFV6cmZINXV4ekdLdHN4QlpYWGF1MDdpaU9IdWU0Yk1xdXJjZGlDUGN3MTUvbjRyeFpIVGRYNm5yL0Y5eVdiR3JxdG44Z1paNDJhT3pqU1lkbVF5elNKQXJFckVzMHJTTEhWZGp4REFHbTN3MjFYbXlwM21yblJMNCtZWnc4RHBpaTJqbHVQQ1hNRWU3eDg1aS9jUkpDTmw3WU5hbjQvUFQweXFkTkNXWEhaMGNwTUd5WTVCSHljTkVmMGc4YUg4T21pRmwxaEFOOEUxbTAxTkl4dmNqS3NHVnFnSGtCdU9wUEk2dSs1cUJMakpxRjFOTDRhMmpVU1FFa1ZKQWJZaWhvZHRYVnpObEdUaUt2UXlYSE5PcVNySHlwczFWK2ZyOE5UV1dHRHZCdVVoWEYrUFJYRW5hb0Zad3ZHcG9LdnN0UUtrNmpiTTRKTGpxcjZEUXZobHhheE9iVXM4Uy9yWUFtaC93QW9CMzY2Q3R5RXd6SGhyWFFuVGQ0MjF1TElSRzg1bFpvNTBQRHRnVmI1VjBNc3FuVU92aGJqYWtOdmpOeFp4TkNicTJwYkZTWm91b1hqMTRnL2dTTi93MFBiUHFWWnNWbFgwdlVOK1MybUhpOTluQUp1NnBTbkl5Tjc2RVZRYmpvRDFIejBxM2x5Z1hCdXVtcm5OLzNUek1MTE5qTWU2d3VWUVhBUi93RDIzYjNVUWlncnNOZEZ3S04rcG1aN2xrVzNZbjBCT0Nza2V5bm55UWEydlZrUitNcThSRW9BV2lxdzlwZHR5QitPaXM5M3Vpb0h4Y1NlTnUybXYwS1M4eXVJN3ZNWkMraDNodUoza0JHMzZtSnFQbHJvTUNhb2t6anVTMDd0cnBJVnhrVFgzMi92WlhJNVdOMUc0RktuOXdiR282ZnBPcE4rc2dsNkRyVC9BRXVYcGI3YnlSVE5WWXNqTXNJTzlJekhFYUQ4NjZzOXlyNk1MNzdYK1ZtYUhCL1kvaVhrYkdDN1RrbjZqNmF4RFFCMHVLWUVnMUZQOE5TR1pHT09JTktFajBPbmtZazIrRlZuRE9hRDRhVWlKd3hWc051Ty93QWRSa2M5R05qUTlOajY2Y1JDdk1lRkplSUVqMXBwQ2dpTGJocUtWQlB3T25HSWQ5aGJlNUhOUUZsSHFOTVBBQXVjWElqR05mY1I4TklpYUxlT2EzY0JnUjZiNmtNSDdTWndWYjE5ZElkRFhqTW9ZdUlMZmlEcU1EaDZPNzd3clhiNGFRajJhTlp3QVJ2OGRJWUI1SERibmp1UGpwMElXN3V6TVRzcDZkTk9NUURFMFRiZXVrSWkzazNBRmVyYVFpci9BTHYzMEE4VWtnYWNSenRMRzhVWUpET0ZKREFVK0FQcnF1VThsVjVrMUt4M2ZSUkJ6SmxMMk1XMXZHZ0FZQXM1UDZtWXQxUDhOYlNPZGJGNlM2cXBKK2V5K3Y0YW1WeUNwNU9SSlBValRpT3R2OUdYakp0N2Z5VHpXNEE3Y1VJdElXUG9FQm1rL3dBRjF6WHZ0L1FxZk02VDJiSCs2M2R3bC9FZThZclNRQ1pYcVpGNU1HRk4yM05OY2RKNjViU0Y0R21Tc1k5NmJyVDNEWWxUOHRLWUxVMFJNakhETFVTcUhWb2FvRC9TS2NxL2pYZlhlKzAwMjhkZUxQSlAreDVYZm1XWCsxSkVISCtZK09yTlBpc2czMFV0dEkwVDNqY1h0QzVQSTl4NDY5cGlUdUpBTjlBYy9nWHZkM3JyNUd4N043NWl3NHE0Y2kyeDM3R0dhVHhpZStPSW12YmVPK2xpUzVnNU54aWxTU29CU1Q5Sk8zeDFsVnhacUxkdFoxZHVkeGM3MmJrNUZuSytHWGxueWxTTXZDUlVPbTYvQ3Y4QURST1BrOW1BWnZiVTFOZWdnZVVlSVpQSTJNU1kyQlpyN216bFdQRnVDS1NRcElwWFd0eHVaU3I5VDBPVTUzcytTMUpvcHRJak40Wmw1b2ozZ2JXNlN2N0Vxa1ZQcHVOYS93Qituakp5MytKa1VwcUdnRmZZM0tZd2hycUNTUGYyU1U1UjArVENvMWFySjlHRDJvNjlVUmd6M01vakMvcklxUjZEVGtBemNUclkyeXdyUUdnVWJldld1bzdaNmtwSTBjcW1wQjMrUHgwNHhoY1hQWlRraHJ5MnAwMzBoeDQrMDMxWXk5c2pzZURTQ1ZBUDFLd0lGYTlSWFVMSlBVdnhPSlFlKzkxOWtKUFBzbGlyeTZrbnRiSXhpM2lsSktMRzBhdUFCK0owMVV1bzFtK2dpaTllMWhNamY4dW50TmFpdjRlZ09wd1FUZ24rUCtSM1VrakcwN2tEb09URUhsRzIrMVFmOXVvdXNrNlhzdWdia3RzRmxIZTR5VnY5UGNPS1NTMi9Ray8xRlBqcU1OTFRVczlOdFhveURkK0V6Q0g2bkVTQzdqU3BVS2FzSy9MWWl2eTBsa1V3UnRoYVVyVkFUQzR1Tzd6RFFaUWRpMHM2UzM4ekRpeXFwL1RXZ05XTzFPdXAyZWhYVlNGUFBNY0xLTzFNTThHUXQ3d3M5bmNKVHVKR2xDVkZLRURlbkUxSHcxR2xreVY2YlJLUldHNTZpdFFldjhkV0ZMUVJ4Tmt0M1BHMHpoTFpkMkxmNERTWTllaHV6THJiWEl0SVpPVWEwZGlwOVQwL2xxSTdJMEY0VjlzaTg2ZERYY0g1ZGRQQThoN0M1Njl4ek5jWTF4RkltL3dZRTdiZkhVTFZWbERKVnRIUWMvRFBMa3M3dTRYTlhKRU10V2JhbzVkVktqMHI4ZFYzcjZkRnFYNDhqVDFMSThQOG54L2s5ekxhd1JsSm9pVEh2eVdSVjYwTzI0MVJiRzBwQzhlVldjRDdhd3hUb3IyN0pJbFNDNk1IRlIxRlZydU5VU0VKeUZJN0ZLYnJVL0hTSE42WWdNT1ZOdFJITmo0WlVISWZ3MGhRUXBiRlJzVjNyMTA4alFRM3hqTTN0citHbmtSS3R2SG5sb1RUK0dsSWhpeDNqeXhSMVlBL0lhaTJPa0VKZkhyZWFPZ1NqVS9ucFNTRjY3d0UwTE1GaU5Qa05JY0d0am5qYjNxUVBnZElSb2tqVkR1bGRPSWpTS1AxQVUrV21HSVpZcVMxTnRQQkVqeVREOVFXaDA0cE5sdHlZMXJ0NmFRaVU4aVJpaFlWK0drSnNpWE40QUNxNzZjaklLbW1iMU5QanBER2hYNWFjWXpIU21rT1lNeXJYNDZjWStXUURmOEFscERTYkRMeUh0MkdrT2ZVMnFUWFRqR3FWZ2x2UEx4V1R0eGxoRy82V05RS0g1YjZLNDFXN3luRHFwbGVSVmxmcEtYOG92YmdUUzdsSWpJVDJZeUZHeHJVbmZZZkRSVjhqeVdkcmRXWmpVYUNuUDQza2pFdDVkSXhhVUdRd3IvUWhQV1J1aTErR29TTGF3SmMzRUVLc2xTUlNwU09nRlI4VHB5QUVtZVc0RE9SU0pQeUFyMC9FNlF4MGQ5c2JTTzg4ZHNMSVFoWTFYbTB0ZmQzbGFxbjViSFdGekYveVNkSHdyeGgyd1N2dWY0bzArTU9TdDR4L2NiTDlTalppZzNJL25VYXI0bG5qdnRmUmsrVFZacVRWYW9UUEFzKzhkK3NEN1IzQjZmQ1FkVi9QcU5hMWxCaVAxS1VLWGtiMldSeithaFNFRHVYTFE0MllWV09PUzE5b1g0RG5YVmkwU0kzMXN6ckgvVGg5eTM4bThMWHhqUGg1OGo0OU9XYUkvdWNtaVFyQ1dxZmFwcHhadmlvOVcxbWN2SHRma3cvaTVKMDdsd1QyOTNuTDFzaGZXOGR2TGFSTktZbFlHRlQyMVNuRTBJb1R1UFRsdnJGdlYyYnMvQTNzRjFXRW4xTkhsbDI4MTlZWDFqQjM3VzNzZzk2MENxb1MzbU51aWtjZjFBU0VtbndEYXRiZGxwNEViVjlNUHFWYmZXbHBnc2hOY3d4cEpiejF1SlF5Z29RQTZkdWcvU0c1MW9QV21vM21FVVlIVnpJRzhuanVyT3h0c1RQQTlsWnlRdElFbForVEtHSlVia1VkUVY1TFN2NGFLcmVVQTVNY1dGMW9JWXJSbzFsTWxsTkdaR2hEVmtlUlFWNXJRVTJyNjZaMmNDUzFLenp0bC8xdDA0WUF6b1lPRkFvS0llYlZBQkxjU2VYSWpvS2F2cmJSZVdvZGpiMTgxSHlCK0IrcnhtWGtqdW93MDlxVklSU3BqWU1SNzE5Q0N0YWZqcU9lSFJSM05MaHF5eU90dTM0a1BlUjVtMm15Rm5jSkExdWlzRGNvR0xCdUxWcWVPMUF1dzBMaXBOV2FXZkx0dFVacnpPWWExd2MrYm5maWdnNFJCSE5Xa0o5cXJTdnVJRzFkQ1V3MnRrVkVhT2ZsNDhXRjVHOUkwS2I4bjhodkd1NWIrUkJGbGI2aDdRQUloaEFvcUErdEJ0OHpVblhVNGNOVlhhdWkvVTg0NVhLdTdmY3QrKzM1SVdyYktaYUtYbWt6dUNmZXBKSVA1YUt0U3I3R2JUUGxUbE5oV2ZNM2w3R2tWbTB0dXloa2tFYnZ3S3NRYUtsUGFOdC9kUTZvV05WY3ZVSmVXK1RTcWFmbC9JTCtPZUwzZDRxSmN1VXRZS3VIazJWZVI1SHI4ZERadVNsKzAxdUY3VGE3LzVORjExSE9TOThROFhpWmJ5NjcxMnExVllZdzU1ZjVTWDRnZmp2ck4rMW16UFRSSFF2azhEaDFodmRieUZYSi9kNjRSa1hDMmNVRFJDa2R6SUJKSVBTbzJDajVlMG41Nk14ZTExV3RtMlpISy83UGx0cGlxcUw4eE16L21ma2Zrc2dreTkvSk9GRkVRbWlBRDRENC9FOWRhbUxqNDhmN1Vjem41dWJOKyt6WUFMRTZ2QXp6U0VaQkhib3AwaEYxL2VIelM3KzVYbjZ3WWVOMGdNcVl2QmlIdUR1UmQwcWtwalplWDdoYmxzUGdQVFdMN1h3bHhzTVBxL1ZiNC8wTmZuY2w4bktvNkxSRisrYTI4djJXKzNPQyszV1B1WWJueUM4dHBMVDZ0QVJKVnBHZTVuVVYyVmpJVVEvcTF6bkdyLzloenJaWE95a2FlTWREYXlaMXhlSXNhZnFmNGJLZXdOdFpjRGtaWlZLV3FtTzFnREJlVkNGYVVCanNUK2tWMTIxckhMMVJXWGxPWVc5eVU1RHRMYlc1S1FDdFF6MXBYWWtiMDlOS3FHdFlYTHUyTm5aeXgza2ZIS3ZjaFpZMi9XaUJLMC9QbHExZGZJcWZRNkUvd0JPWGxiNUcydlBETHFiL3FyY05lWTRQdlVMVHVwVDFxS1ArVGE1UDMvaXZhczFlM1g0SGEvOWM1MFRodDhpOUd3TWx3aGQ0cUduSVE4YU5RRGVpbWxUcmpOL2lkMHVRcXMxdzRDR1JRNnZKSFRjSyt6ZytvSUlycXpkQTc1RFJybjhmbHR1QmNDWlFUN2lncWFkUVQwSFRWaXlKRWZ2Yis0TXVyYUNGakU2ZnZzcE1hVUZXSTZkZlhWdU50OXkyem5vQjVjVUpwR00wRWtEMFZ2Y280Y1dOT0tuNDdhS1dWVlJUYW4zRy9FeWd3akozRVlreHR1dEJSZGpXcEZQVFQvZlJVK1BEYWtJd1lPN3RKVnlWc213NWNvbkpQejlvcDExVGJOS2duOXFpZWhMc3MvYzJGeXN0NWJ6bXlNY2taZUxhUm5haFhpZWdwOEdGTlFXMXJSa2I0TE5RZ3cxNVpaekZxTGZnTG1JMDJRdzNEcVR2eUNrb1NQai9EUTE5T29xcTFMYXpEK2dYc0xIUHBZaTZ1TERsRXZRVzU1U3lSS0R3Ymh0VmpYalVIVlY2ZUJSZkxqM1JPcGhtczlqTERCWE9VczVXaXlNTUxReVdrd2VOeFg5SU5SVGw4RDY2THhVbXlxVXV0cXR1eW1xN25MdHg5ZGtzbmNaTzdnaWhzc25CTGJZcklQL0FOVEdXdHJtRXl1b1dwaWNBdFJpUjFwME8vWjQ2cW1PRTlWcTBjZG51OG1hWHBQUm1GM21uaThma25kbWFTK1p4ZEdjbHBEMjQxVmVCOUM2TDE2Qmh0cDFUZGtVZGtUdGtkTURudTlTcmZKdTVlL3Z5Z1JTVjRHRlFCd1ZObEJwOHRiV0xRNWpPMjNJVSsyL0hJMjJlOFljaEZ2clV6eFN0U2l5V2xaT3A2VlV0cDhyaUg0RmVMV1VkQS82WDh5RDRwazhZSlNaTGE4RXJSbjBFeUFBajhlR3A4eXJlS2x2QnRmeERPRytxT2pjZmtTQ0JYY2F5WU5GTVpvWkV1SSs0UDFlbytlb2t6UVZCa0t1S1UwNHpNNWUwRm9temVsTk1NYVlnR2ZmZXVuSEpjZ2lSTjl5ZE1PYVJKR3FrTUJUNTZjWnNGekczRXJNbTFkT01RSjV1Mi9OZDE2RWFVRHlhVEVrakJsUDZ0OU1STmM5a0dXbFA0YWNRTyttdVlXcEczdHIwT25FZ2hhczVJREhjZFJwQ1l5NDVwT1BYYlREREpaVzZ6VTUxNDZRbTRKY3VMRGc4RFVINDZSRGY0aWZtY1c4Rnk2T05qdURwMFRUa0F5MlpJTmZ5MGhwRm5Jd1NLN0VDb3JwREhQL0FOOEo3ZDd5enRnN0M0aGlZeUFHaWdTRUZmWHJwY2R6bGNkbEJMa1VTd0tYRXVVVTdjeDJXVHZFczJQYmhNcXhpY2dBaEFvUWIvSWl1dGZVNTl3Qk12NC9jWXE3bnRIOTVnYi9BSmkvcEtub2ZsVWFlbHBVa2JWZFhBRm10WlFheXFRMVBXZzFaMUl5ZC9mWjdDZjltLzZlZy9IamU1TzJhNGtIL3dDZHYvYW9INEl5NjRMM2pOdnl0ZGs0L21kNzdOeDJsanIvQUx2VWJoanZvN2FFY1JSRVZXUG9hQUFhNTUzMU83V1hjelRKQlpvazExZTFqeHRyRTg5N0tkbVNDQlM4aC84QXBVMDFaaXE4bDFWYXRrTXZJV0hHN045TlJOdk1qTmNScGtMcUxzWEZ6YkpPOXNkaEgzcU1FcC91cVF1dlZjV0w3ZFZYd1BGczJWNU1scnZ1NUVIekg3SytSUjVtNzhrOFF5NUdRdXo5VlBhVEUyenEwbzVsVWxYMnNvcitsNmF3YWU4NGxrZU82YWh4UFU2Sy93RDF6TmJGWExpc3JTcGpwOUJUeldldlBETCtEQjUyQVhkcGNXc0Y0Wlk0a1ZTWjFxZVVCL1pZajFhTHR0L3ZhMjlxdHFjMXZ0amVvMWVMZVlRbUlqQTVNcEVEWCszc0h1N2Mvd0NZTkE5WjRxRHFZKzZ2ejFtOGpnVXZyR3B2OEgzdkxnMG1VTnNlWHhkM0FKc2piaXdETVN0OWJOOVZZRmlLRUIwTll5ZlZXMzFpNWVEa3g5TlVkcHhmZWNHWmV2MHY4anhmRDRycUthNHNybU80Z2NWamFKdTRDZlhjZFB6cHFyNzlxNk12ZkJ4NUczVjZNVDhuNDlkMmJ0YXlRYnJ1MVI3U1BqdnRyU3g4aFBVNXpsKzJXbzRncm56angyNnhXVEZ6YVk5MXQzalYzbmhUMjhtSk8vSHB0NjAxcWNYT3NsWWJPWDl3NE44TnAydmExMUZpL3dBSm1pMzFLeGQxQUtoRU5YWGF2NlQvQUxOSDc2clF5M2pzMTBCSm1hTWxXNUk0MlpLRUhmOEFIVWlzOXRZMnVaeHkyalUxSXBTdW1nZElzejdZeUsvbWxuYktOd2hhbndvUlRURnRPb1ovMUR3bUQ3bzVGbG9ETmEya3UyMVEwUTMvQUphaFY5UjhuVXFLNG5tbmNXcVZPNFdueE9wbFEzV3NjT0V4YXIxbWJkeWZWeU9uNERURnRZUnF0NzJTT2toWXR5M05maU45OVBCQ1NTZkpvclM2UlNYaWwvOEF2c0I2VitJMjIxRjFra3J0UFRRTjNXUWh6RnFiYktvWkk1UXJpN2cvYm1OQjdlWXBScWZBNmh0am9XNzVVUDZndVR3NUx5SlA3VGZKZFRSZy9zU3QyNUtkUlJXMi9ocDFaOTlDTHg2U25JdDNVYytObE5ya3Jaa2tVMEt5Z3FkajFWaHYvanFaVTlCenh2aVJPRCt2K25qdVVjR1dhSGxTYUtFTFZXVUExK0pMYXIzcVlMbGlzNnlpdTVucExJKzZvN0VxWDNOSzdWSTY3ZkxWaFEwYWhLSkhDcU4rbjUxMDdHZ1AzbHN1T3hjVW9scTl3UXJ4ZzEzNm4rR29rbm9RSU1pMFMwa1ZaVkFwU1N0UjY3YWswS1E5aGZJYjNIczdZdTcrbWxkV1ZvenNTR0ZHVUhvUVJ0VFZkcXF5aGtsYUN3UHR0OXlZL0ZMaklqUEdWamN4bDFpcisyMDlRVVkwL1NLVnJ4R3E4bEpyRlZxWFk4cnE1TGsrMm4zRlR6ZTJ2RXVJVmd1Yk9zcGxTcXhOQldsVHlKNDArWjBQa3d1aWtOeFoxYlJsZ1l2SVdWL0VMaXh1STdtM0pLOXlKZzY4aDFHM3JvY0pWaytnVWFPcTdEU0prZHJYbFdpMWJTR01WczZibGZkcERCQ3p0bU1nUlJ0cEVvQ3Zha2hHL3dDV21FVDdWRUlCcFUrdW1IQ0tJdkQzSUQrV21IU0IyUnNMUzRqUGRpVU1laEFGYTZkTVFsNVhDcEdHSVhiclVha01LVjNFSWl3OUIwMDVGZzJReU1DRjZhY1loeVJONi9ucHhvTnlMSUUvYjJvTklSRWxxQ1N4MzBobVJaR0ovTFNHSVVqMU8ycERHeUNJc2RNSW5tMklRSDEwOGlJTTBaM29OdElZMDc3YWNSbURRNzZRaktwUFRwcElVa2JJSXpZeTZWQVdlUUxFa1lKQmN5TUY0amp2MHFhYU80ZVI0N095U2FpSEtucm9ENWxOWUtaOHB2TGEybWV5Z2lQY1dxR1J4VnZiMUlVVjQ5UHgxUHJxQXRwTVVjcG1yKytVUVhOekkwRVNLcVJBOFUvTURyK2VraURzMkxiQnBta2pqQkxPQUZYODlPUU00WVlVUDBrNE16czFVZ1E4UnpwU3BiU0hSMUI5cXJjUTR1MGphUGk0QURvUGo4ZDlZUElsNVRvT1A2Y0U5QzRzdjR5OS9odnJaSWxkNTFLU2lnMmpOUkh0OHYwL25xT1hHM1hkM0lZTXFWb09TODNnSi9GUE5GZ08xaFBKMzRaRi9wV09ybmY1VUlPajhPWDdtT2U0UGt4L2J5K1RGVmtMeFIydC9jS3VQekZicTNuVmdEQmVFc1J5K0hLcTh2bFE2S2Y1b0MrUFJqTDRENW5MOXZQTk1ONUxLc2kyNWtTeThnZ1RabmpxRmtOQ0tjcUFNdjhBdkFhYTlGZXJxTld6cTVPOWNmY3ozV1ZmUFlPeWJKNE9hM2toTWx1d1l2RmR4eHl4ZHNOdFg5RFNBbXZKdmlOYzFhbGxaK1owdU5xMVZxUTdueVQ2akgzbU94V0hZWGtkdU1ia1drQ2kxdG8wbTdpZ01oSVlqaXlpbGVsVDg1S1ZXUEV0YjlVaUprcnE1dHNMZDNmQ00zdDNQSFlXQmxUbEVxd3g4cG5aU1FSeEZhdFhxUlRWZCtrZUJSZzF0SUJ5VmdsdzF2Z3ZxcGJ1eHlFa2wxNDFjY0M3Sk5GSHZiU2UwdXhaVktJVDd2UWpiVUtXZGRmci9NSXo0bFpTbnAyRXFjbTZobmlRQzN1TFVCSTBVY1FPMjNGbGRSUWc3ZE5GeEJtU0x1YThkTnpqekpjOGw3alBHRUFhT1NNbFFBNFlqY0RrSy9qcXl0dHJGTXFKSzJ2SkwvRkNIRnl4c012WjFEeXhQeVV3RUFBRGFwQTRobHAwMzBWdHJkdDltRllzdHFwVlU3bDM4aVpodkdjNWxuRHM1aGhrUDdzMG51SEYraEM5U2RVNU0xSzZHdHh1RG55ZXB1RSs3OERSY3EwbVVreHR2TTAyTXhqa0thRlJKS2kxZHgxNkgyalJPS3FyWGMxcll4ZWJrZVROOXVqbXRQell1MnVIeWVSdVh1cmlCbXArb25aUXRhZGZ6MFZmSldxaE1BdzhiSmx2TmtOVnZnN0NDMU56Y0JWaWpvSGZrcXhnbmJxVHYvNmE2ejNiSmQ2SFNKY0xCWDE2dnlCVjE1UDQ3akF3c29UYzNJTkFxRWRvVTlTNUZUWDRBZm5vaXZGdmI5ek0zTDd6U2svWm9rQ3NqNXJsTCsxN1lsRnRFUlQ2ZUFVQnAwcWVwK1pPaThmR3BUb2pGejgvTm0vZFlVN2lhNHVKbmxuTE5LZHlXSlkvejBTdEFBMThHOWR0SVJta0R2OEFwVXRwQ0pNV09tY21vNC9qdHBDSmFXRU1TMWxLMS84QWoxMHc1NUpOYlJWNExYNEgwMDRqcWovUzk0SkJjelpINzQrVE10cGg4TUpvZkhubUo3YU5FaEYxYzBCb1JHcE1hZzlXSi95NjVIL3NITnRpeHJCai93RGt5L3AvVTNQYmNDYis1Ym9oVzh6OHd1L3VINWplK1J4U0F5VFFUSlkyby9WQmFRcHhpUWorbG1MY3owOXgxcSsyOFJjVEFzZmZ2NXNGNVdYN3QyMTA3ZkFXdkpQSUxqRjRZV3NWc2x1dDFFc05selVMY1JvZ0NzeG9hMDJxSzZQMGJCK3hYM2pmaitVOHJ5eTQvRVBDdHhCU1JUY3lMRkVXRGRXZHRsQUc1SjFPOTFqcTdNcnJWM3RDSXJXNnhYaHoxMWNDNnRUZU9pTlFoNWVGVDNBRFgyMXAxMU9kSVhXQ0VRNWZRMmVLK1NaWHhYeVhIK1hXWU1NME4wWlVJQUNzdkwzcnZ0U2pjVCtPb1pjVmNsSFI5MFhjZk04V1JYWFpuNkxlUDVQRDVuSFdtUnhwZTlodmJlSzRqdU5pV0V5QWdNeE96TDBJSHJyeXJOaWVQSmFsbDBaNlNzanlVVjFvbnFSNy93QVpXVjJtTTVTZGw0MUJvckJmVWl2eDY2cGJETWZLalNOQVRkNFB5UzBIN2QwZ3QwcHlaeFZXVVYycVR0K2VrdE92VUpybnhXN2FnZWZEWDM3RTE0b2p1RElGRDIxR0RGbEpCOTM2ZGg4ZFhWdjJRUXN0T3hQT0k1bFVNamhGM1lzdklBZXU0K1lHcDdsMUsvdkcwVzZJaDVDTjQ2ZTJnbzFRUVNTS1Y2YmFxZHh0emtDNUdGSTM1QnVBTzNLTTFKQTJJWUgxMUZXWVJTMGhqQXpMV1FzbFlQMEY1cWV1d3FDQi9FYVVnMmRUMEg3Q3RpcnFQNldUSEtJNWxaR25pQ3R4QkZLRWpwV214WFVMV1U2bUxuVjZ1VmJwMkplV3Y4TmE0Nk94aXVaRWc0aUtLVkRzQnVTRzVkS2l2dTFZclZlaFZoeDVMWDNOZVp6TjkzODI4bHhOak1YTUx0cFFvQmlVaDI3VlhLanFBNFVPYS9McnJvL2I4S2IzUHNYZTQ4aDQ4U3FscXhOaHZiS3c4Snh6TkhGMmNmay9vN1dWWkhhWjQ3cTFtWW1TSWtCUXNteHB1emZFRGZZeTBkcnZ4YS9Sbk44YTFjZDAzMGtYOGhjejVQSFRXMW5GSEhlR1ZMdTFSdUpaN1J5eVNrbjhTcHA4TlN4VlZMUy9oL0lMNUx0bG82cUZySzgxM05ubkdKeGMzaDJQdUlZWXA4emRPa3pYS1JsSlJickc1WUdoSTRucVMyNHBxN2k1YmZkYTdHZnorUFZZVSs3S244THZqaWZMTFFQVDZlV1kyMHlNYUF4elZqWUVqNGc2MThxM1VaenVKeGRGM2ZZYkpIQ2ViZVNlT3JCeHQ1aTdvV1B1akZ0STNFVTlRUStuZFhrd056KzJMUitRUmdlekkwZFNZbTdSNUZiWS9MV1dhaVkzUVhBVktnVUZQVFVDUkdueU5IclVBblRpUERlTXc1VnJYNDZjUnZpa0IvYzVVcHBDTTVKek1CeGJZZkRUQ0lOM0hJd29HSUhXdGRPTUI1U1ZrSzl4aVI4OU9NU29vbmxqRzFWK09tSEpjZGtRb29wTGZEU0VTSHRYS2U1Q3Z3cnBoRUY3UWttcHBwME1ZeDIvYjMwNGc5YWxFampCTkswcnBERExqNW8xUWU0R3VrTTBGa2xvdFY5dzBpcDFCMmZnUzRpamxVZS9jRWFjbFFVSkxVamxYb05NVEFsOVlCaVNGNjZtaGprRDd0M3RuZjhBbmwxOURDV2UzWllwMVlnZ3ZiS1ZjN2RCdDBPcDhPV3JXN1NWZTRKVjIxN3BmMUtudUpoM0pHZGdDYTdING40YTBqR1pBdU1uZENOdVVuTXV5a2g2TVc3ZlFHdnBwUWhtenpCMmQzNVY1RmpzS2xHZklYTU5zdkVVL3dDYzZwL0t1bnRkVlRiNkpEMXB1c2w0bjZSZVIyU1dmaUdJOGV0UUZoZDR5VkFxUkRDM3RvUCtGQnJ5emtaWFpwK082MzFQVStGVlZ5dC83RWwrUXV4NUt5YUhqemQwWnlCSkpHZTJlQm9mMDhtQkJIUTZDU1pyN0xUSlhmMzB5elduaTlwZzhUSExKZWVTU3h4M2pXL3VhTEZ3enAzbnFPZ2VSa1FINU1OZFI3Qnh2dVpuZHJTdjZuS2Uvd0RNZE1QMnU5djBOV2ZoYis1ejJ3QllpUzNnakxic1RSQnVmVTdhN3QyaHM0Tkl0VE80OVk3VzdaQUFZMGRTNE95aFVJOU45cWI2OG10ZWMwLytYOFQxM0RlTWFxK20zK0J5RjVia2NOYStSWEhqMlVmbjlMRmJJRXVoeWpCbGdTVXFyRXRRY25QcnIwaTFiZGFubWxMMDFyWWs1VHg3R1QrQTJOaGlCOU5mTmZHNnQ3NEVHUDJxeXZGeVZpNElKVWh0VHRsMncyVmY0NnUycWtmeFQvdnlDVEpQY01zNjQyeGx1NUozZGxubGhnQlpsRThlNUhFZnBtVngvdTZtclVzdENsMHk0M3FFc0I5dzhCZHVzMFV6WXUvWWlyUnNsbElUODZmOU5KMS8vTTZHemNXdDFxZzdpKzZaTUwwWSsyL2tMWFUwVWVTdFljcVhBNFN4MXRiNWxIcjJYOXNvK2NSWWZQV1JtOXRkZGFNN0RpZjlncGRwWkZKTVdQRDVTN2xpZTdDSTBhcDJaeUlwa2w1R2k4VytSK09zeDF2ajFhT25ybHdaMUVxQUhuUEViZU82WjRBdkU4bVliSzJ4cHEvSHpYME0vbGV5VWpkVkNYbFBFOGRlbzBNMXVzcnFEN3FBY2ZoUmhRNjFzWE1hVXljaHlmYWRZU0ttanhzOEY5SllpRjFtNXNBSkFWUEZmWGYrblc2cnBxVGtMVWF0dGdidnRMYjM5aDl3YlEzc2JJWFYvZjFVbmFsQ05QSXFxSHFNditwNSt4OXhvNUUyTStMczJCK1hGaC9zMUNpMWZ4SHlGVTRXM1ZDYnVVZTRiSUcvbWRTWldrU3JxNk56SUhKSVVVVmVYUUFhUk4yazllNytuajVzZHdOcWJnbnBwRFNiTUZZRyt1VGVYUUJqQnF4YjFQVlYvd0RIVENReDNkNlpaVEhBcThFTk9RUDlWT240YVlsSkJ1TWtJSFBJVkk2TldqQWdlbWtoU2JyUHl1NHZZMHRzaEJGbExQa0ZXRzZVOXdiOVZmcUthZzZlR2hOWkc5SHFoaHZQRUwrLzVaWHhyS01CZW9SSmIzQjRPdFJ4TWRSN1NLQ2dwcUt1dWxsMExuaWZXckVTL3dBZGU0MlZyYksydmI0a3FKUjc0elEraEdycEJtb2NNMytOK1B5Wm0rWVd5cThhQm1La24zRUNvQUlJNit1bWRvSHJWMmVoQjhrczNzTDc2VGhKR1l4NzRwRHk0czNvcDJKMnAxR25SRnFIcUJWYVRueEIzM29XcWV2eDFLZENFYWpOajhVeTJFMlNaZ0RDT2ZFNzlPdXgxQW5CRlRMVEl6OTJLT2VDVDNHTnhYai9BTUpHNDA0cENlSHpFMW5IT2Nma0RaVFNEaEpibGlvZEQxbzNROVAwblVMVlZ1cUpKd1dCOXZQdWxMNFRCa281VWE2bHVWckZWcW9zd05RNVgrclkrbE5WWmFPeVNSZml5N0pMcyszUDNYUGtPQXZiN3lTU0cxZkh1dk83MlJHamxyd0JVZjErM29vMzBQbHhxaVRucUc0Yys2WkxEeHVYdE1uQkZkMlU2VDIwd0R4VElhcXkvTFZEMENrMCtnWVJ3ZWkxMHBIR0REMlhjQWtLK20yb3RqaFNUSGR3OU50Tkk1bXVPN1M4dVZhYjAwaGpWSmRxb0tVQXA2NmNVZytSM21ZMTZlZzBoRVc5Z0RJRllWVTZTRUplVHhCRXJoUlZUcVF6RitXd01STlIwMDR4Q2x0bURiTFVIVGpIblpvdldsUFRTUWlOTkFHL0hUa1FYY1c1WC9EVGpFWDZmZWczT2xJZ2xaMmhxTnRNSW5YTUZJd28zMDRnZkphTTNvVFg0YVF4b05pdzZnMTA4ak0xbTFZQ3BYZjVhUWpFUWtkUnRweEFiekNOb01Fc3hCN2JTQThrcVpBeW1tdzlldnB2K0d0SEFyMHh1eWVsNXExOElmOEFVRnp1ZENsUElKN2Z2T2hnRUxxdk5FTlRON21BRE1Cc3Y0ZGRLQUZnWTRDWXppYkxFMkZsSjdsTGo5MTBHdzRwdWQvdzAwNmFDVmRkVEhMSkRpN1ZEYlJMYldjNFBGcFdWcnBoWGNtUHF1dzB5VTlSN2FkRUxXUFAxT1RoNEtSRUhBTlRVbXA5Zm5xVDZGYU9zUEJhUXBhR01VamtLaGgxb0FLSCtZMWhST1JtN2ZURW1qcFRBMnNWMVpoSkU3c0RSbUtSRjNvR05DS2ZNSGJSbFlhQXVqT2F2dlY0eERpNHJxMW01Ry90K2IyODdKUm10NTBJb0FQWGYrWkdoY2FlUExDNk0wTDMzNHBmVTUzdjdXeW1paG1zb3ltUHVYVzJ1dzVxMXZmSU9ISUE3Z01GQkcydFZOeTArcGsycXRxYTZkL2lTWjEvdXR6YUIxQk42RnNMMUZJcjlUc3NVaSt2dU5LNmRJcnNmbzk5dWNLZkZNREQ0UGFOMllyUzJ0NTdRdFUrK0lLbDBsV1ByS3ZkL3dEM211ZHkzKzVadm9kSGp4ckdrbjRCankySkxiQTVCYmEzVm5XRU5LbnRSbUR5Sno1ZWxSUURyWGZTczRVRTZhdlVvN3l1T2F6ZngzR3RDSXBsTHlYVjlPUjJvWmJ1aUUwb0RRcVdIcjhOVlc2RmRBVlBOWXk1aVpaZWJZYkx6T1k1bmJoOU5jUkU4WjRtakZWWWtLYTBvRFEvR283bHFWMVFmaHVwMjI2TVUvTElybUxPVFcxNEhtbklDMzl5aWRxTzRKSkVjeEsrMFBJQlNUYWdZVjI1YUx4V1RxQThuQzZXOGpibGx0cmkzeGtZa2FYc1EwWm5rUnYzSnBHWlJ2c2VLZW5vZFBNTUVTa1I4cmlZTC9QWThSTWtYMUVpMjF1VVVzeGFVVUQ4d0txTjYwL0tsZFBWK2xvMCtOazIzcS94OVNGbDhuZlIzVVhqbU9qVzJ5bHFra1YrN2tnV3M2THdFYUFiY3grc1UyNmFmRmlTVysvVHNiM081ank3Y09IVFQxUHcvd0RINGlXTTFqc0d5UXZFZUUzYWlraFg5VlVIYmthcDNDNzhxZjFOK0d0TlV0ZEhJNWNtTERkYWFyUi94RitXNnp0eThzbHVlTnZibG5qWSt5SWhEWFlkRzJIcm9tdU9xNjlRREx5TWwyMG5vSzk3ZTMxL00wOTVNODhyZFN4Mi9BQWJhS1ZWVmFHYmE5ck9XeUUxU2FIK0duR0pQTkk0MURMVjZkZElSbEJGTGRPS0E3N1VBcWRJUVh0Y0dkbW5LeEQvQUh6N3R1dTNYVFNQQnV1WkxMR29EeE1yc0QycTlDVitQeS9QU0VCNXNuSTlhRUtEdWVJL2xVNmNZaE5PNUpJSnI4U2FuU0VheXhiY211a0k3bys4MlpzdkN2RnNWOWxQRjJpZ3M0YmVCczdDRlcxQ1FMUmxCSy8xM0VnTXNuNWZIWERlMFV2eStSYmw1VTRtS3I4ZUIwdk12WEhqV0toejNhWWk0dWpQbkZWa29ucklWU1NPTU0zNmdRUVFhZjQ2N04yU01OVmJFcnlEUFhlWXVCYzNMRjVWVVFXeTlmYU5xNytwNm5UVnFSdGJRMTI2Mm1Qc0pvYi9BQnpDL3V3MXRiMy9BSG1qaWpQTmU2MGtRQjVNZ1BFYmdiMU5kVGFsNlBRaW1rdW1yR2pQK09lSVl2RWVQWTIzeU10NW1jbDNNcmV1YXhSMmVOS2xZSVVCMmVTYWhsTGVnNGo0Nkh4NWIydlp4RlZvdk4veVJkbHgxcldxVDFldnlFcTVpdXJ0VnRVSUZ0ajRuWXNDS01DYTFKRzFTS2FKMFd2aVVhdlR3T24vQVBUbjkyR3QvQzd2eEthRXpabkZ5TlBZU2JFZlRTQ3BGQ1IraDl4OG4xeHZ2dkRlK3VXdmZSbmFld1crL1Y0Mi93QnVzZUpjL2huM0ZsOGdtTnA1Wmk1TVZkWExySGo3MWdxeFN6T29JakxHbENhSGo2TnNPdXNQTng5aTlMVnZoMU51K0sxVk5VNnBkbU5tUy92RU15dGJTUngyNFl4eXd1Z0lQTnYxY2lSVHJRZzZCWFNaSlkxUjlaa2hwQ0piV1JzMVl5aTVpbzBVa1NjR2FNYktDMzZTdy9xM0cyK291dW5nV2JvY1Vzb0kwTUVUdjIzaWUzbWFNdXNpeW5pdzllSXBRMEZCdnF0MUxYWnBUTXI0R0xZYUZiMFNSODBuWlAxTXhQdVViTndCQzdVcUdPbldpZ2RabnRJOTNnSTJSbFJWRHJXUVVPeFkrNzQ3R3A5ZFJkdkJrNlovb1JseFdUalJYdkxhUnJRaEkrZGFoZTRLQ3Z4SUpIWFMydGtubW8zQ2VvNFkrMGZHVzdSZDVJN1VrVjdpRjE5dXdGVStCL2pxRGw2R2Jrc3NqbU5SUjhudUxDR081dVd1TzRZSWdaWVI3QUVwdTlOaWxLZncvUFJXSk51RFI0OHgwaGVKUWZrMXhnTU9iVzR2THl2bEZ6QlBjd1lLN2hrU0lRM2g3U09rc2JWTEdPcWNDQVFRUjg5ZGx4YTMyd2xvdTV5Zk96MXk1dXZ3SzhtdEpMMjNKdDQrTnQvZGViRTE0Z1NFQlFCMUJGS0hZR3Z6MGNydzlldTBqYkR2cEtXbThtNEtVaHNlbDNiODF0cDJzZSs3Y1dTT1poUXB5b0NBV29UNmFyeXFaaDlWSlBDMm9sZnRjVDRFaklaUElYTm5aMkhkRXNrd2F4NTdtR1NKSVZsTXU0V2pGWkZYcCtIemxqeHFqYjdkZjZBK2ZLOHRVbDVyNmR5a2J4MXRjcDNZd1FJcFE0K1B0SWJXL1hXcHlkOUxGbytKNTgySDNhc2I5d1dqeUxRd01UVDNkOUZoNURiNDc2dTRXTjJUeEwrOU5meC9nVzN2R1RjZGhZdEhpbENucURUV0dhNDJmVXRIRXRmaHZwb0p5UWJtWkdCa1UxY2FVQ2tGeTVLV0g5WjI2alNnYVRLM3o1cU9UYmZEVHdLUXhEbVk2Y2xOUGlEdHBvSFBac3lyZ2ltdytHbEF3QmUrL2ZjcWExUHI4Tk9Sa1pNVmMxaEJQNmRNeVF3V2pLWFFnYVljTFhGdWs3Z0FWRk5JUkZsd2hmZFJwQ0lVdUlkQ1ZLN0RUakFtL2VXMWJoV2hIVFRqTm1XTXpaNWNIM1BRNmxBMGxoNGpuZVdvbFRldW1ncnRaSXl1TEs2a0xBcjdSMEEwOENWa0I1Y2F6bGxLa0g0VTA1TUJaMjFreFdLdnNrVTdrZG5ielhCVHJYdElYcC9MVmVTenJWdEZtT3U2eVhpejgrL0o4dE5uTTdsYzNieHBFOXk4a2pSaW9WZSsxYUx5Sk5QejBieHNicGpTdDFNM21aYTVNcmRmaDlDdnNoYjNxRlo1NHlJcGE4SlJ1aDM5UHcwWWpPWUt1TzVUY0FDdjh0VElsd2Y2WFBHbnovM1VzYm1SZWNHS2lsdm5xS2dNZzRSLy9iY1UxbCs1NWRuSHQ1NmZVMVBiS2J1UXYvSFU3YjhtbjRadXp0NDZsSVlwVlVEMDdVSkczNXZyenUvNzM1S0QwWGkxbkczNHNRTFBMWFhDSEhoM1pWVkZTUmdQMXVLSGtldGZ6MVRhcmVwdmZhcis2Q3FCUGt2THZ1Yk5QYjJ6UGhyaGJISDRDUVArMUpaMjk2ZTZ4QzFBTXNxTTY4NmV2dzE2WDdYeDNnd0pkM3F6eVgzZmsvZjVObjJXZyt5MmIzbms5c3BWdUZ4azA3bGZRUlNVRlA0Nkx2a1ZhTjlvWm40NnQ1S3J6Ull2bUNPM2ptWFpUUi9wYmxrS2tLUGNoSDZpUU42K3V2TWVMNnVSU2Y4QWNla1pyTllyUjRIQ1gzUGVMUGVhNVhKUndpTWt4UXlJckNva2dpV0o2RmRtSEpldXZVTWZUVTh4eU5iaHJ6K095dmozMmo4TnVjYk5TN043Y0dkWHB1dHpFSm8wSU94b3ZwcUdSVnM0ZmdYWXJXcXBxWitBZVRYbDVpL0tMbTdaN05zVGovcXBYZ3F2TUVtTXF5a0dvSWJkZWg2Nm8renRxNDFDSG5kckpXN0htRXh2aDJheXVQdnJhS041VW1Sbml0d09VaEc0Vm9qVUVzZHVtcXNXVEpXMjFoT2JGZ3ZUZFhyK094QzhneG5rV096V1h2UEVwUko0L1BkU3pRNGlWVklqUXNUeGUzbXF2SmVsVjMyMWV1UlJ1TGFNRXR3c3UzZlJTZ2pmK1gzV0Jtc01iNWJBa24xVnBGZVFPb2U1alNPVWtBQlpYV2VPaFUvOHVhbis3cWRzTmJFTWZLeVluMUgzRmVaZUtaMjJpaWhQYU1FS3hmdE0xNUY3QUJWZ0ZTZEs5VHlpSUgrYlhQNS9hcnB1MUdlZ2UzZjlyeGJGanoxMFhkQjFNUFkzRnRKa0xJd3oyOURXYUIxbWpMMDlTcFBFajRIV1Rrcmx4YVhUT3N3WnVKeUh1eFdxeFltOFppYTM3cXdBTkl4Wnk1QkpKOVZyMHJUUmRPWFphTm1UelBhY1ZtMnFxVzlmNkFYRVluKzJlUjJGd0VVTDlTc1pwMEJiNDYzZUptV1N5UndmdUhBZUNycy9Fdy8xTzRtS2J5TEc1WGc3T3VQdFluWlFXSEU4eU9RL0xyclFyYUx1cHoxNk4xM0xzVW5MYVpTU3hXZTJ0WGV6SjkwaWU0OFJ0MEc5UG5xMXRKd1U3WEU5Z1g5UzZVSWNNZjZnUVF3UHdJT3B3UVBVZVcvblNNRUFkS2YwZ2VwMHc4alFMNUxLMFcxdDE5eEZPNEJ1SzlTZm1kTVRlaG9NcXR1S2JBVWRkdjRqMTB3d091cm1XOG1XMlQzeHFhYmV1a05KS2tBeG9UaWVNa2Y2UCtJYVE1WVAyOXplTzVmUjNyRjJ5ektKcGxGV2luVTBVRUhvbTlOdW5YVlZwbWV3Vmpza3ZNZk03NDlhMnRwY3lYZHM0aXQwTDNrTXdBNG9PcEFhaEkvTFQ5QzNjbXRVVlRML0FHdWVVeGVOWG45dVdLWXVna3FpUzAyRHEvcDhnMnBLWTFCbkUra2laZkU1NDNFMTlsVStyK29ibEpjcUF3TkFCVUFmS25RNlNoZENGays0SHRjV21Rdkk0TENQOTh0eGtCTkFLbW13NmpycHlKTXo5cEppNC9wRzc4RTViaEpieWoyc3EvMUE3VTlOdDlPaDJoZEpJSklyOHE3NmswVjZoUEdZNzZnVFRzd1JZMTVMeXB2OGRSa2trUlZ5RS9BeHEzN0JOVlFpdE4vVDRhVUR5RXJiSXVJaEhiWEVrUWNVa2pKb0R0NkVkUitPbWRSOXhaL2l2M1V5L2pXSHRzUGpZT0x4VG1ablplZmNWdUk0SGxzbzIvcEcrbS94clpycFZVK1NXcGRUUHNSMVpqY3BMZVdOcGZQQ2JkN2lHT1o0RzNLTklvWXIrVmRadVNteXpyNEd2UzI2cVk2NFBMb1VFTDdIMCtlcW1XU05DeXB3Ry9YVVlFYXA1bDRrRGY0NlVDUUZ1VVN0YTZjUm9CQkZCMUduRWFKN2pZZzdrYkRUaUJOekdYWHVVOTNycHhBNlRHZDZwSUZDZElZRzNHSGRTZUFxTklZRjNHTmtqUFRyMTA2RURwYmNLcE5LTnFSRUd6eGR3N0QxMjA0ek1JYkZpYWtiZkhUREJHR0FJS0RTRWVTRDBKMGhHU1JNMndGQnBEa3RiRG1QOGRJUjgySEIycCtHa05CRXVjWXNRM0JCK09rSVJ2UFhodHJXMWd1bWxoZ1o2aTRCL2I0dnN5MFdyRmp4OU5iR0YycHgybWs2M2VuaW11dnlmUUJ6Tk8wRkc1VElSUVpDYThzb2lvaUhGV2tQdTl4cFUwNmRLNnJjOXdUUVRiekpYa3RaSG5jdWVqRmlXcDhpZE9WeVFVdEo3MUl5bktTU1V0emRxbWxEVGNuU0YxQ2VCeDRnenRuQXY3MDZ5QXlLTjFDamNqYjExR3owWktxOVNSMVQ0cGFyS0xHRWRQaFRjOGp0K0ZOWWlUYmJObkk0aEhRZmkwVWxzK090MmxidVRIbGR5SnlvdmJITWIrdFFSb2hKcElIbVNOOTFmRUxTL3dBWW5sbG5WY2xqSk81UEdWVXEwRXJDc1pEN1VVMGVoOUMybzNySzA2bGxMUjFPTFB1SDRyYmVOK1RyY01wVHhyeUZTMjMvQUxFM3FwUG8wYm4rR3I4V1IzcFBkRk9TaXJmeVpuOWhmRmo1Rjkzc0JqWlFKN0o3OVo4cENSc3FZOEc2RC84QUN4akEzK09yOHVTS1NVNHFUZUQ5QkwxRWt2SXJpMlZ4ZUpMenQ1NDZrR1I2Tkp5R3c0TW9vdzlmVGVtdVhkNGNuVVJLRWo3WC9jWENmY3k1ODI4VnZaUCt2eFYvUGFBUlZBbnh4ckRGTXU5ZG5WbFlucDdmam9wNDl0VTMvY0NmY2JzMHUzNkM3a1VrbXVieXh1WVh2ciswaE1XTXZXb1drbWhZb3JiaituZnAvVU5COXk2NjI2QWp5cjdmM015UVF5QnA4WEZGQkpiM3NEZnR5d1hjMURIR3hJSVpTKy9Qb2VvMWE2ZmJmakpYVzZzdk1xanliSjNHTjhoK2d6OXl0M2pMWWYyMHp4clNRdVNESTBpYk8zSGpWZmdPUHgxUEhUU1YxTE1tVjIwdDBJeFc0N2JTU3NyL0FMcjhWUlFvWkZQc2tTbjlKWDUrdXB0cGdEVFQxTmtsdEhIZUpLb1VyWnpSWEN4cWFnZGdpUlhyc0tiVlB3K1IxVExTQ3NjU0pIM2R5OWppUEtjemI0Nm9sdWI0M2dRc3p1N1NJUXBWeWQwb1Q3aCtBMXBjVEM3MW0zVG9YKzRjNnVKYktmdWJsaUxpL0dNbmxKVnU3c003eU1BRkFORjJxQVFPbEFQNGEwYjVhMDBNREhndmxlNWpiNVpnZjdkNCtiOVNrTXNVS3hHMkt0VjRXUWtTOHFVM0xlMzVmdzBOZ3k3cnd3L2w4WGJpM0xzVkZEQVpnUzllUHBUb2ZqclVPZEpjZU9UMFFnZXBJMGh5ZU1KWkIwTXpGbmNBOEdIRlQ4QlVIVFNQQVF0WHRiZmxGYVFxc3ZFcXNnQkhFazduNTdiYVJJaFhWMUhFZWQwUW9KS1ZwdlVlbTFkTU1BOHBleDNaaVNKVDJvVktxNTZ0VTFKL0RVaG1EalRTR01OSVI2b3FkSVJlK2F5bC93Q1NlUlhkOW1KTzlsY25PK1J5Y3pEa29xUGFnVWRBUGFGWDREUVdHaXhVVmE5RUgzczd2WHVDUE1jcERqc1pEaHJGMldXUmVFeUE3TEdLY2oxUDZqdC9IVWtwWkI2SVNzSFlISlpLT1diOXJIS3hXVzdLbVNPM1JSVjVYVmR3RVgzRDBydHE2ejIxOHltcTNXOGhwOFV3eWVSZVJObEpybU93OGZ0NDVMcklTWEFYdFI0eTBVS0VsRWpVNTNKQ3hMN3YrWS93MFBseWZicDQyN2ZIK2hkanB2dlBaZnAvVSt6SGtyZVQzT1o4bThqd1FrdnJ1S08yeFZ0Ym9JTEt4aTdmWnRJNFVYOVNSUnFlS2VwQUoxTEhpKzJsV3I3eS9GK0kxcjc1czEvUUNYdUt0UjRuTGxiU1Zvcmdza0J0K05PL0Vockk3Zjd5dVFCVGJqWFV2dS84aXFTV0QvaCs1UGNIK0RlVFhQakhrTnBsTFluWTl1WkIvVWpiRUg4UnRwK1RoV2JHNnZ1UHd1VmJqWmE1SzlqcHFUeXpIM0dMZWVzaGlsUlF3dDZBSk90Q3NsQldqS1Y2bmI4TmNVK05hdDRQVDZjMmw4ZTU5V1h6NGhucFBLOERGZjJlVHQ4bGQ4STFsaWRBR1dkRkFaM05RQUdQdVdnNlUxa1plUHNjUkdvRzlpY3JvKzZEdDdjNU8rdGVOOUY5SXFzRVJVYmo3aU9xMVplYTAwSmV5V3BHbGFWdDZkZngrUUx5NndXK1NzN2tYSGFFYkF0N1dJRVpOR2JZY1IwMjlOUmJUMUNjTGJvMUI0dVN3OXplbUhIWHlwUEd2QXJVS3J0VUFVQkc5YSttbmFhWFFmWmV0WnNnQmNTMzZTenJsaC8wQ3lweWVGVzdtekFnN2VuRTlmaHB2aDFERXF0TGFUYnp5bTFsUllvNGtUdk1zaW9ya3F3USt3bXY2dnhHcVlzL2dVMDQ3VDFmUWVrcmVZbHJhWkVMS2lQTnlvbEZrV3F0MTMzK09yWFZ0Skl5SDZieXZrVWQ5NlBJYkR4ekNTeHZLRFBNcmQxZ0Y5NEJxcTlUdTc4VTFxKzI4YjdtVFRvZ3prOG43T0IyZmZSRkYvY0s1aHptWjhYelRZaTZ3dU55Mkp0TWZIa1hWbnQzbnRuYUZwa1psVlF4Y3RJVVZ2VWJqWFlZS09sYkp0T0czQnhscko1UE95Nm1xeXdPWWpqTnRkVHZ6a1NTNWtZMEZKVTk2T0pBZVJJWU5YUXQ4MUc1U09od2NiS3FiVytxbjU5dFFoRExZNUhFU0xianRVcUZsV0l5VmVLWGt0R1hja25rVkRiblVQVlcrcGU5bVRINmRIOVFSR296OW5KY2lRUlpKT0U5dkFoSHUrbGdpaFZHQzdDTlJDWEpQWFJsNzdMZVJpNHNXL0RNeGFaS2s4eHNaclROWGJTTHg1eXZ5QUZLUCtwaFQwcFdtdGZEWk9pT1o1TkhXN0NhWHpRTjR6NUNRSDdEeG82THNTYldSU04vaWVKMFh4YjdNcWE4U3ErcVRPOU1aZVdzeVJYcXVPeE1xeklldnRkUXc2ZmpySXlZM1M3cSt6ZzJxdVVtVGJqS3hNNEVaOW85ZFZFcFBIdUFWQlU5ZXVrT1I1SVJkclJqVDRhUWhldjFrczdyc3NmUUZUOGpwME1hUDdsSXJjT1IvanA0RkpKL3Y4NEhaV01ONlYwMERTWnBQSWFTc055YWthWVExNEs5U1MzWlpEeElPa09OVm5mUUlGbzRZalRFZzdqNytBc1RLd0JPa0lNcmYycXJUMnNQeDB4QjFacWt1YmFVRWUzOGRJa2swS0dZaWpta1lxd05OdFRRekZPV0dlMnVGbGpyMjJPL3cxSVl1UHdHUTNHRjV0MURFYWNHekRUMng2NlJRWVMyMEVvUE9NVjlEMDBpU3MwVnQ5NXI2NThZKzIva0daeFlCdW9iY0lnZFE2Z1RPc1RWQjI2TWV1aDgzN1k4WVgxWm9jVzgzMVV4cjlGSitiRjIvQ0tTYyt4bmtJTVorQ0NsYS9Nbld2U3FTUzhESHlXM1hiYUlVK2JQOXQvdHR4RXNrSGRFeWY1aHRRajhEcWNheVZidElGNjR1OGVJM0x4TjNTeEtVb1ZWZlFhc0t0RHJML1JoNDRxWS9QOEFsVWtmSDZtYUt6dGlmL3ZjUTdqMC93RFV3L2hybXZlOHY3YWZOblNlMFk0cGEvam9YSjVEa1VpeWwxa0VpZG50clZtUWdBOFh1WlJHck5VRVVxdTlSMDF4dFpjMk84NDJLYXFzOVdWUjl5dkpzeGV4MldIOGRoZ3RmS0w4U0Zwb3F4eC9TV3ljcDVYQzFLOHRvK1ErUHgxdiswY0wvS3pPelMyMFV2OEFnQis5Y3Y4QXdlUHRwWjdzajlNNng0bGQrS2VRMjNodVVzckxNVzhlRXZiRkVXQ0pwRElyUnIzV0RMS2RxdThuSWM2ZE5kcTdRanpCUFVldkhzdmRXTjFqNzlYYTlqamxTZEF4YnR6dlExS3lVY0p2MTYwK0doOG1QN21OMFRpVTBFWWNteklyUHN4L3ozbFdLeW5qOXpadXM5cmRPc2F4eEZRem1rcUZpa2lFb3dXbS9yOHRjbHh2YU0vSDVGTE9MVlhjNnJrZTU0Y3VDeVRhc3pqUHlneTNQa1dWdXJpUHRTelhVenZIU2xLc2ZnS2IwNmpYYVVVSlNjWmR6YVJ0OC90Ym0yOE44WWhtbEVva1IxdUkrVE1yU1FSUnJHNFUrMmdSK1BKZlhVTk4vd0FpMXA3RjRFbnd0c2ZaZUllYXJkUXRNOTVadGF6TXFnOXRYV2tUTVNSc1pOdEQ3bnMwOFEyMVBYcjRDajlzTVFIKzRXQmFNdkZIRmNMTk12NjBNYUE4cW5yNjZNWFRVejIwMmJQS1BJL0k4RDVQbjdTK2hXNnRyZklYY2ZKZHlvRTdVRlYzR3gyQkdndnMwdERUMU5KY3JKajY2b3V6eDd4ckgrVzU2MnNmSTdaY25aeFlteXVGdDdsZVhENnRUSnhEVVVnVk93QjIxays2OGpKeDlhT0didnN2SHc4aXR2dUpXZ2hlWmZhckVYVUZ6NHQ0M0hMZzVjTGRHOHM3MllOUEZJazhhQXc5ME4zVjl6Y2xPNXBYclRVc1h1anBncGt5ZXJkbzRLSDdJczNJdGl4UGJ0VXFkZnpFMjM4ZSs1WGlkcmw4cmtwbHVmN1JBdHhHOExPODF4Q0pGamZqY1JGWmZieUI0eXF3cDZVMXBZdVRnNU5mVHIvQXl1UndPVndycmZwNE5keWI0NTkyTFhMS2JTOGhZdW9MTUdRUlNCUjFQZGhReEduKy9GSC9BTVdxTS90bU8ycTBacGNUL3NmSXhhV2U5ZWZVWTF1Y2RlUjJZeDh5dkk5N2J5Umlla1JaZVZEUndYUndLLzhBdHV4K1dxdUp4TFlzcWZZTjl4OTJ4Y3JpdWlXMjBwalQ5eGNkZjNlV1JidTNRTkJhcFo4b3lXamthRWtrZ01BUlZYVS83ZFI5eXU2V1ZpWC9BRnpGWE5YSlZxWG9WM2QrUHgyenNiZUlKeEczRWNWcDhob1RIeTIrcHJjdjJldGJOMFVDbGsvRWJIS013bXR3WldVbFpsSEZ3UlhxUjEvUFdyVGt3cGs1RE43ZE5ta3RTcjdLMmtTNGx0b0lua3ZFNWNvNmNTQXY0NjFabFNjL3Rjd1JacGJ5M25wZVJ0RklmNlhCWDhEVDEwaG1qMlMvUEZsak5DZHVROVIrR2tJTFlxQmJTTDZ1UWp1MEpXdTRBK08veTB3NUJ1cnBwcGk4aDloMlJRRFVBL01mUFNFVFBGOGtiWE8yc2IrNk80a1NPUkRRMEZSUTExR3lsRm1PME11VDcrWkRNd2p4dkdTWEx0Z3BjZUx1RzJZaWdsV1JvV3EzVWdBTHNUUWFqVkVzbGlwTEdXRlZIT3AvQTFDZ2ZMVTJWQnF5OG5HS3VCWnczVkFkekU0TFJHdm9RZGdkUmlTeXQzVU1pTENYbk80aGhHSnlGd0FKTHUzcTBUYjlhRGRUOHhwbEk4cHZUUWorUTRqeVRJeDI5M2tKeG1MYTFpYUdLYU0xUEd0YTFvYS8rcmZTckM2RDNWbnF4SmEzSGU3ZlNVR25CdWcvRWFzS2c1bk1MZDRTeWhhNGhraE53cTlxWGxXT1FNT1IyK1ErQjFCTk1rNnRDd0ZJYWhCcDZVMU1oQXllTGVPWE9jdjRiUzNISzRta1NLSkc2RjVEUWF2dzArNWVKano4RjNmeUdlaDFUNFQ5cmNONGxMRmtMcWwvbFkwNHJ6QWFDSmlOeWdZYnQ4RzlQVFVNM3VOYTFkT09uVlByZC92YThOUDJyeFNtZTc3QitMaWFxMTlmTHNXT0xpdER4SDQ2d3pSUkt0THBsYmtOcUhvTklsSTFXdVlEeHFqdDdocU1DTXA4b2krM2wvUFRpSS9kYTQ1RU9mdzAwRG5pcTQySjBoR2FJQ1NGOTdhY1JGdUtxU2xLRTlScFNJaTlpVS9MVGpHVWRnLzZtTlFldWtJaVh0bXU1cHBDQWMxa2pBMVd1bmtZRTNGbkdoUEJkUElvTkt4Y1ZOUnQwcnBTUmd3WUQwMDRqU1VCYXBOZmxwREJXd3R1ZFBiVUhUU09IN2F6cVFBbTNycHBFRUVzbFVmOHZZL0hTa2NFWmZIcUFYQzFBMDhpZ3BEN3ZTd3BCQllpTjB1Qis5RmNWcXU0WmVJUUEvR3RkYkhIdmF1SFkwbW01WGl2SDZtYnllcFFUbTRLdGFNcHVyMXBTQXNZTHlFaFNRR29ENm4wMUd3R3ZBaXgrT1IyeUNmTnlxckthZlJSRU5JR1ArZGxxRS9NNmpKTlkvRTA1UzloeDZTVzF1b1QyZ0txZ3FxaGhXdnBXdngwNkUya0VQdDViRzV5SzNFaWNpWEZEL2xCMi8yNnB6dUtsbkhyTnpxRHhpMjVaTzF0MTlzWlpTU09nQTIxbDQwM0NOSE5vMnpvand6RFJUUlRMSXJMWm9IZ1ZESVEwYWlqVUE2MGIwTmRGS3N5RHBuem1PNXZNbGhNdnhubmp0R01nZ0o1MERrOFVXdTUySDQrdWg2MWRXNUNiTk5LRGwvN20rTVJ2akx2eFcrZDdxL2w1VFl1NExLeUI0MURSMFBweVV2RzRydXlnNmFsdnQya1ZxZmNyQjcvQUtPc0pMTm44OTVSUFdPOXhGb3VMUXRzRFBjTnk1VXAxV05LSDEzMWJ6YmJhYWR5SEJwdXZMN0hVSG0rZWo4UzhRejJhdUdNMHVOczN1MWF0QTBvUXFnQkpOYXVWRk5ZVlZMVlBnYmo2Ymo4OC9BZk9jcDl2L003RHkrMkR6ZGlRcmtiY0VqNm0wbU5KNHo4eVBjdndZQTY2QytOWHB0TVRjNjIzTHN6dWFjd1hTNDd6Zng2MGd5K1B2VkYxYjJsczNhZWVLVlZhTWdzeXJVazBZSFdERFRoK0pzdU1sWlhnUnJhWjdwWXNiZFF5UVdmMUFsbnRTQ0dpbVJnWVhjc0tCRC9BRlVGT3ZTbWs5SVRLSVpSUDNDeEdReUZya0pJb3F4cGU5dWVVS3BLbENSeEwvcUJKcUtlby9EVm1LME9HUGFzclFTUEQ4dEhEZHoyRitDMEZXU05TeC9icCtsalhZTFdnT2lNbGVqUVAxR1c3dHJpVGxqeFR1ekJtNWY1NkdyYjFOUjh0RE42eU90RVIvSmZIOEhseDQzbHJ1R0grN1k4aVBLT3BrWXRib3I4UTRJb3BjaXE3OVNhYU54WnJWVFNMcllhWlZWdnFpWmpjRGFYS3BiekxOYmZYemR0MWcyRWR0TnVDS2JrbjJndFd2NUdtbGJKQ0xxWWtZZmV6eHlMeC93Uzdqa2phTzl0VXM3ZVJtY1NHWDZnTzNKU09nREtScUhEczdaMFg4NUt2RnNjMXo1aVczZnQyU1JyYjhFVlZLQmlCeEJJSlBVMTEwU1J3OGtxTytnN01VdHczYWxCcUNvTElQeTMwNDVGbnpOdVpPQ3FYQTNNM1RmOE5OQXBDRVMzOTdHczRrVzN0cEJVU04xWURiWlYzL2lkSWNINXkwc0xTT0l4M2JYVngvVWhJb0Q2dHNPbnBUU1F6RjkyTEdwMDR4aWZscENQTklSNkRUU0VYZDQxbU1UTkRrTXRNd1pnZTVKM0tGbFJCUlJ4MjBKZE5hQnRXbnFpdWNyZVQ1cktTek1lTWwwNU5hYkpHUDhBWUJxMmloRkZyRXk0Rmxpb0V4cXROajcyK1FOa2JtdktDU3pjTEpDbmFweUhNcUpIcTNxQlRTck5uUGJ0OFI3TGFvNk45Unl6c01lRzhheG5nMDhVYVpmS3ZEblBJYmlJcktVdFJIU3h0bExDcTdNWkN0ZjFNSzEwRmo5ZVY1UDdhK212eC91ZjhBM0xYWlN1UCs2MnR2NElYY0Rqc3BtYzdqL0hzTE4zYjE1K3haMkY1SVk0amN5RW94aVpqeG9vSHJveTFsV3JzL3dnVEhTMTdxaS9ETDA4bisxZC9jVzZjcloreEVJN2FEdEpVdDIwb3hWUUJVQWc2NWZGejF1bnhPeXplM3AwaWVnb3cvWjZ5VkVtWW0ybmw1OXVTWkJFaDdmNjZNU2Q2ZW0yaWJlNXVZQTZlMEovRVpNVDlxY2pEZFJTV09TSFpCRENZU0pHN2NRR3FEN3dRZjZRUm9PL3VOV3RWcWFtUDI2OVhvOUMxUENWeC9oRnFXdklKWm52WGNUM3FtT01TbWNpZ0tJYU54R3c1VTlkWlBJdXN6bnk2R3BpNDdyVGJQZVN5c1hlNHU4c0xkYmE4ZUI2dHdEKzRNR2JZRUhjMTM5ZW1zaDFhMEk1S1hWbTRUUXdXRDR1TkFMbUNObGFpck5HZUtnbmNuaTNIWTlkanBrNnpxQlpGZDlHZVpQR1lhL3RKUmo0N2E2djVuU0k4djJwWWttZFVlUUhZOFVUazFGUHB0dm9panIwa2hYTGxvMU14K1FKbjhWeGVNa2UzdFhlODVsbWpXS1l5T0FlbmNqQkhMajByU3Y0NkV2WnNLcHliM1V2VDQvd0ZpM3cxN2NTcFNKR3Y3WnlWc3BReWR3Ym5qeTk0VWcwb0tqcnFkS21oYk9rdkx4RHR6NUJiVFdjc04rejR1OWlpVnBZcHpIL0FFZ0x4amtGVWs2VW9Hcjh0WGZiZnhBTWRJdnBySnlqOTVQSU1WNUl1UnRMTmxrK2phRjdDNVUwVjVJSkQzQTN0STM1bDZiVm9OZFY3WGh0aWh2KzdxWnZ1K1d1UmJWL2JHczl4NCs0RjNqdktQdGY0djQzam51bzRMVnNkZVdHTm1raGtnbE1NbjAxeE1wUXN3WHJXcTA1TUs3blU4Tm5UTGF6WGlwTXhZSGt1cXJWeXZvaEV2NTVyT3pnYThhUmJlUkwvbkdnSmRPYW5qeENrQWlOVk5mbnZxTkVyT0YxME9qeU4wcjZ1bnFNckRIdU1OWnhXY1Fna21EdEx1Q3pTQ0tTcDluRTdBajE2VTByMzlldmIrWXNlT01TMnFHLzVIdUl4Rm5kUExlY1RiUlhNUUVYRXFGWkIydVFwU3BQL3QxRzI1MHNtUjEwNnd5T1BEVyt2U1VWRjl5SW5OeEpNNkxHM2ZLbFkxQ0tTRnB5RkR2VURjL0xYUWNSNkk0bjNHc1hmeEEyT0p1L0hMbTFweWtzSisvR3U1SVdSUlVqMDI0a25SYjBzbVo2MW8wZGgrQTV5REwrSjRpN3Q1ZTZ2MDBjVXJFVS9kalVLNHA4anFIT1gvSzdmN2tyZlUwY0RtaURVc3ppWGowSHBvRXZKMXZkT0J4SnFCMDAwRGg3SHVzZ0FBOXc2MTFFY0dlUVFMY3kxVWUrSVVyOHZocDBKc1hqWXZYbWVtbkdNMVJJMzVVclRiODlPSWtHYjJnamI4ZElSdnNzajJIUEkwVS80NmFCd3paWlZTNW8zNGIwMDBDQ296SkMwTFUrZGRLQjVQdjczS0RVU21ucnZwaFNUTGZPU09QYTUzMklycERTYm51MmtCcWR6MTBoRys3N2E0KzBZamQyTlQrT3BERmkrQXh0QmoyUS9wWThnTk9ENXVnNFUwNEpKNDFLYVE2S0YvMVk1QjdUN1ZTVzhGMHNFMTNmVzhidzh3cnl3cnlMQUxVRmdEeDVmejFSZUhlaWZqK2kvbWFQRjNLdDdMdFg5V2o4OHN2OVFZSWtnak1vWmVja2ltdnVZazBBOUtEVzBqRXMyTGhlUXNlWHB2UTZjcklza0RQMUg2bUEvRGYwMU1ZL1J6N0UrUHI0cjlwTVFraWNKcElUZVMxNjg3aFRJUDhBOHBkY0o3cmwzWmJQL2JwOUR0L2I4ZTNGU3Y4QXUxK3Y5RHlGb3NobU1wYU8xWWpIQkE0TzRJNEY5L3piV0hpVTFnN0NIU2xiZDVPYy9PTXA1UmhQTTg3ZTRHekU4RThLWURIM3JBT2lReHpwSk96S1RVYzNXbkwvQUMrdXUvOEFhc0x4Y2FPbS9WL3dQUFBmZVg5L2xUMnFvK2ZjUmNoNUhnL0ticTdreWszQytCNG00WVVCVkJ4SHRQcHR0VFI4V3E5T2hpcTFiTFVzWEMrRWVMNWpId3plQitSTmI1SllveE45UE5WSkhTbGUvYk9majhWMWROV1ZRK3dWVzk4OThYWGpuTUpIbTdTRWdtOHh6bEp1SFExZ2txS24vZGI4dEsyTjltU1ZqU01uNEg1czdXMXhIQWJsUVFiVzZYNmE2UmlDU1FyY1gyOWVOUnFPNk9vOEpudm1uMnVmeUxHWXhzUGRyYlJZcUpyZUNDVGxKQ1kyWldBRHJVZzFydngvSFVkSEw4U1hndkFYbzhGbGZIdkNmS29jcmp3alN4Z0xNcFdWSkFYVGk2c0RVZHNnblE3eDJyVkx6TkQ3bGIzbnBvSW4yMGphZnpISHg5MHd3TUhGd3lzVlpvU3RHQ2tEOVJydG90cE5hbVZWd3dabkxTNGZ6UEpKZVM5MjVHUW1XOG1WaTNjQ1NrTWEvd0JRSUhYMTFXbWxSRnlyYTJTRHJIN2R5dzVUT3oza01MbzhObGo3UjBkUXRlSWtrallVcnNZMlFqWExlODJic2pzL1pGdHgzK1FWeU50SGU1SE9TUjhlL0JkeHdYR3dyelNPTUdyZm5UOHRabklvNmNQRzM0czF2YjgxZjh6SWwvdHFRODc0ekovZjhiY3lNOE1rVWQyNDRTdWdaSVFqQUVMc3dQSTFyK0dsN2ZrYTQrWmVTSDVycmt6NExUMHQvVVVNcDQzaXJLU3p5c0dIaWx2TC9uWVhWeEFZN1dabzdxSjEvVWFLekErNWVRSjVBYU05cDVlVzE3VXRhVXF5azllaFI3L3dzTzJ0NjBTYnNrMnRPcFYrUysxK1UrM09jeG1TeHVka253ODJSaHQ1clZnME1qamtXSE1BbU5oN2V0QWRiZkE5MXB5cmJOc1dTK1J6WHVmc2wrSFJaRmZkVnY1L3lMZSsrbmxrUGlweHQ1S3ArbnVia3d5Y1lrbUNoWUFSeVFsRFRiK2lSVCtPdExMZ3JrVU5HVHhlWms0MTk5SERFYkdlU1lyT3dyTEd5aUdSU3hkQThzZEFhRTA0aVpBRDFMUnN2Ky9yRnkrMnRhMGZ5T3k0di9aMDN0elYwOFVTSmNZcmNKN2RVbHRXcVk1NG5WNHlLZ1VEcVNwL2pyUHNzbFAzYUc1ait4eUxKNG1tQ2IveGkwN3p6UEhScEFVTXJic0FEVHI4dFg0K1phSUFPVDdMajNPeVFxMy9BSTlheW1XM3U0VnVJK1hzVmhXbjRIMC9MV3BqNU1xVWNybjl2MnQxZXBXM2xmanRwZ011c2Nhc0xWMFdSRmFyTHlPeEZUK0hUV2xneXJKV1RDNVdCNGI3U0RrRnlrS3JJOXM2MmdBYm5TcS95NlUxZElOREJVMXp5UmFmcVB3OU45SmpFekNJcVh0dmNTZnFXWkNuL3dCUXFkTXlTNm5RWDMrdGpkZUdmYi9NUjBEY0w2eWRqMEpVeFRDdi93QlIxQkZtVHFjLzNOd2JaUUU5c3g2Z1UrV3BsUk13T1BhOG03OXdhd3hua0J0dWZocGh4d1dlcWg0d3JSQVVBVTdpbnkwdzhuaWVUd1lxNldPSzRlRi82aWxTQVQ2TXZUK1dsRWtsZHJvRUozd21aUVhGemJKRmVPS0prclFiRS9GMC9xMUhVbE5YMUJsNzQvbkxpeWppZ3Z2N25aUU9YU0tOeTNBa1VKNE43bE5QbHA1U1luVnRlSXRTV3RKbWdrQmp1Ri9wTzFLZkxVcEt5L2ZzemhJN0svRi9jV2lOd2c3a0YyV05VWjZBVVhjVk8vNGFrOGxxNHJ3NG1GNXYrWG1YNGFwM1VsMmZWbnBVRWY0YXlEV04wZDZvR2tJMnJrRlZxalREazJLKzVBRlNRZngwdzhuaHUzTDBMRW40VjBoU0hzUGNHcDduNlRRQTZUSFREdkJIQTQveDFFY2tRMjZXOGJTS1BkcENCTXdFay9MVGlOZ1hiZlRDUklRRGhTbTJuRVFMOUZLRUlLSHBweGhlbkhiWTEwaGdKZE5WMkFOTjlPaEVGcFBRbmJUakdwNnQwNmFjYVR5TWNuQXBwQ2dQMkM4QU9QWFVSRFBqdUpVOHV1a09pZTRGUGIwMHhJRjVCUDJ5cmIxMGhITjMzYnU3UnZKSllTa3J3V3NDUjNBV1FLalRnY3hRTlFWQ3RROWRidTZ5d1k2TkxTYko5NHQyZjhESnpRN3NvbTV5MHNkdGVtMUhZU1ZpQzBaSWM3MG9XNm12cnFrR2t5OGF3ODkvSUh5VHREZ2xQZXVTVHhSeXY2Ujh5ZlRWZVMyMWFkUzNGajNkZEVEUEpvWHpXZHU3dTNIYnhvWlZTWnRsNFJvcUFEK0cycFVVS0dSeWEyYlhRY3Z0VEZBOXhkUjJ3YVNDUGdCY010QVdCNVVCUDRhQzV0b3FIZTMwM1hhT2svQzRFdUpKN2g1TzJrRVFZc1RRQWNpMWEvZ0RvWEJaZEM3azFhZXZjNlU4RmFGN2VlN2psU2FHNGtSMVVBcXlLeUtGcUdHOVF2TDhORzE2Z2xpZmNwaDRicWZLUEIyWm8wa2xtdmVCVkRFOVJSbkk2RUx1Tk5aS0NTT2F2dVBoSkwyV1dTQzFhQzdzSnBMcUxpeis2MWtvNVVjcW1vOXpBTlErbzBFMUxnTHJwREc3N1BZNnpzUEdMclAyOE1kdEI1SmZ5NVdPRkFBREdxeHdSa0ViN21ObS9QV2R5c2pjVmI2R253OGFVdGR4Yi8xUTVac2I0RWxnSlNiM1BYa2R1RVhwOUphL3Z2WC9BTllqL2pUVXVKU2NrdnNTejI5RUhHRTBNbTVOUW8zT3RwTkdQWk5IUkgrbFA3bWZVbklmYTdJeWd5MjdOa1BIMmRqVXFON21CVFhxcC9kVWY4V2hPZGhoSzYrWlBnOGoxT2orUjBMNWpidWJlWElLVlZoR1lybFNDV2Uxa1Z1NVhqN2p4UEYxcDBQNTZ6bnFhZHE2SVJQdVBKaXBvWWJqRU9qUlpsa2p5YzBhSGpIZHJHdmZVbjE1cnhrREN0QVNOVGFUaXk4QWVyYWxlWnpSbW9CWXl2ZlF6RmJscmdxVVVEdEMwb0NwYjE2OUI4dEZVY3FDdStqa2VzTmw3WEt3d1hMeE1iNkdUczNhaGllSmZibU9tMU4veitHaGJVYUpPRzlETitmRzR1bVVOWnVWanRaWkR6WDZoNWFScUVES1F0UWZ5cnBVVGt0eDVJZmtPZml4dGt1RWxFYnhDSmxMUlNNQ1lpN2JvS212RTh1bWxrYlNOV2xhc1hQOVNDd1FlQlgxOTNheTViSzJ5UVJtdTBjTWNzblE5TjIzMVo3YzV5L0lHOTNjWVBvY2Z1MVBXcE91bE9JTnEzTXNzWVNROGdteXNldFBocERtRGtMMEFxZElRZWh1WThpMWxZMkVqUlNkcWtzSk5FN282OGZqVUN1K21INm1GOVlSVDIxTGRtbHUwWTh5dENsUGh5cnB4NEIxcmhiaTVmaVdDMEZmanFGcnBFcTBiQzBIaTdiR2hJK0xEK2ROVXZNWExBMllYL2pVNGhEeEFDUlNBZVRVQkIrRmRLdVpUcUsyQnhvYW92RjVGaU54ZFhNYUl0Q1ZYM2Z6MG5uVXdrV1Y0amliT0RSWlhUTHpSU0k0bm9IcFd0QnVLMTlOVzJRTFZtWU1sdmRpNGFoQ2tIZzFlTGovQUNzTnRqNjZVNlFPNVRrZFBIbFNGTG55ZStXSytqc0ZOektseU81QlBldUNJSXVKTlBaK3FnOU50RDVYcHNXa2hlQ3NUa2VzQWVMS1N0Y1htWHZHa2p6RnhJNUVWd3ZPQ2FlUnFjbExuMjlybHlwdjZEVnUyRXFyb0R1N2JkbjFaZjMyRCszTU50WnQ1emxMSlpyWlk1cmZFck1nWlNZdHA3cWhWcUhsKzNHMVJzRzFnKzY4emIveEx2MS9rZEw3TncxLzh0dXE2ZnpMRXZhWkMreGRoUnA4TFBIUEVXRlFxL1RxdmJISU43QS9OcXQ4dFlGWVZiUG8xQjA3bDJWVjBhY2d2eUhDdEkwOFZ2TWd0SW1oYXhZVE0wb1ljdThrcFlVMzloVWdWNjhxMTFMSGV1MU9OZS84Q1N4WDNUSzI2UjQrWVN3SDFOdmFoNUxaWjR3d0E0OFdyUTBKWVUzcFRmUW1XTjJoclZVcUFtbHNieWM0bTV0b3pIVHZva2pCYWplbnRxYTA5ZFFVclZNcmNSRDFOSDltbXM2TmI4NGxqVWdLWExDb0pPM0VkUjAwN2U3cVBSS3FoZGhqeFMvdGM1THNpSXFlQ0VjbkpJclRpRlBxS1Vwb1o0OXpncnl1TzJwWU9HdG9iaUJDMXpTZCtKaGptaTRvS2VnSUJBSXFhYjc5ZmpxZjJVOUd6QnpYZGUyZ1ZGbzVaWTdLOHBKRVAzSGppL1ZVVTVCbXFwNjEvTHJxdjdDVDBCM2tVZXBkZk1uZjhtMUFra1c0a1dudUM5a0ExQURTRkR2UWcxNG44dE84bFYxZWhURTIwVWZtVlg5N3J1bmlOMUdXdDB4VTdLcVpTSXFTc3Y4QVh5V213RlNlWC9ucS9peTh5NzZtaHgxV3RiTnRwcFBUd1J3LzVCTkxrOGVicXhzNDQ4WEJheDJGdkdvb3pRUnVSSE14WC8zQ3BvenR1YUQ0YTd6SEZiUTNySnkxNjJkRzB0R2hweG1hdjd4OFZNbG9WOGZ3ZGpKSGkwcnU3WExxOGp1UVQ3MklUMjlQdzBCbXBWS3luMVdlcHM4Tk4zV1JWOU5hNmZNWVpvSS83UkJGY0wyNGFneFJFZ0YxYUprZG1CSlB1ZVdueDZhQzNQZHAxTm5hbmpTZWkvSDh6WmpwWXJXenVteHF5em13Sjc2TzJ5cndWV1NPaDNMZTNsOGY1NlZwczF1N2lwRmF2YkwyK0pLaHlNZGxHcjgwRmpIQkpEYi9BRXlON1VWR25ZKzZudTZMVDBBMVhhbTUrWmJUSnRVOWlsZlBvNFJheFJ4TVRkM04vY004WkZBcXFCUWNtTlNhdFQ0Q211aTRqZmZva2poZmMxVmFycTdNSWZhancvOEF2RDVtYS84QXFPMWJRS2kyMXZ4UnBoSnlWeHpQK1ZXNkRyV21yK1ZsZEVvQU9OaTNOeVdqOWxzdk5CZ2J6eHE4aWVISVlTNWtqbTVyeE5YZGh4cDZFRlRXdWkrUlhkaHBrODNYOUgvRWZqdUc2bGt2UEk1NUgwMW1Cc2txenV3VzRzZnoweEtSb3hreWc4d2R6NmFZY3l2N3FNR2hJSExycFFJRVNQR3lrQmdhNlVDa0h5T0RFVkFvd09uR2tnU1hEVnBVZ2ROSVI3QzdTT0VKTkNldW5GSk9sYnNjVEd4NURycGhIcTVOeVFyRTdhUWphdCs2bnFlUHJwaEJLenZ2Y0NDUjAwaHhwdENaUXZEY3RUYjhkTklnN05BMDhVTnNQNkNDUHgwNkhMTXdSaXRiS0tNa0JnbzVINTZjb3lWYkM1dm9FRlRJRHBTVWZiYjdFV1hMd0xXcmI2Uk5ZbWNnL3dDc2JPWS9JM0dBc0liaGhrck9PZDViZFFRTzFPVUtOWG9UVkNLYWJEcm0rQ0NNdE5uR2V2VzJubkhYNUhNUnZJckc3aG5palVtRXFWalllZ29EWDhmWFdyRGFNaE9BTG1EaEx1L2t1TFUvU3BMSlZvNkVxcUVWSjIrSjZEU3Fta1F2RGNvKzhjd3R2bi9MTVJnYkJtbkY3ZHhRYzJGUGF6amtTUGdGcnByMzJWZG4yVWl4NDk5MVZkM0IrbEdVaml4SGlOcmFRQ2dQQ0tOZmhHbzIvd0FCcnpYbFdicW4zczVQUnVKU2MwTHBWRlM1dnlYSCtJZVA1VHlySU1BRXVpSWVRb0hrSldKVkh4MlZtL0xVK0RoZVhKU2hyYy9QOWpEYTNaTDhmbVZEajh2bXpZaWJPNGg3bGJxc3lTV3J4dEtnbWJuMmpDL0NvVU54OXJWMjE2UHRkVkNQSjNaM2JzeU5hZUYvYjN5WEpEdXpSMjk3SjdXc3JzTllUbDIyRkJKeEJJK0lPa3JRUjJwbWpNZllhL3NiaHJyeG5KdERjeHRXS09kaWpWVTA5czBlcFRWa2RqSUtlZGZkZndRRzM4aXRKTWhqNHFxR3VWN3Z0K0luUUgvN2RkTTZ2c1B1OFE4bjNEKzFmbnR0OUhtTU1ZTXd5bjZlQ1JPYXZJTi9aTkhRajQxWURwcG5kcERwSnNXY0RjL2NPeXpVV1B3c29tc3IrYmhid3NTOXVFNjBFb3F5Z0tLVUoxQ3FWdWpKMjNWWlk5cDU3bHZHNW10Zk1zRlBqa2RHUTNpajZxMm8xUDY0bzZnVS93QThaL0hWanBaRGIweWJoOGI5dTgxa1lQSThSOVBCbXJkbGxodkxRcWtYY0pQNmdqZHBqOHRtMUhkS2hpMjl4Q3pQMmV6ZG5scm0reFRKazRwNXBMaElIL2FuS094YmpSeVZicnY3cTZydFdhd2kvRmRLOHZvWDk5cDhmS21VeVR5d0dNS3RsR1dDZHN1Nlc0cUNvMjloUGJCNmtMcm12ZDZ0M1VuVCsxV1M0OXZHVENESDJjL21Qbk10aDN2clZ1NDRaNEpHWXhFQjBMc3FuMmlyOUQxb2RadnVPNWNMRXZNSjl1dFY4dTcxbUNUNWFsL2IrYWVQUncyc2sxamNXOTdGTElYVlZoM1JwSG9mMUtGQzdEVVBiSFZjYlB1OFA5UHpINWQ3UFBoYS93QnhEdkV0OGNuai93QlVPVFhONGlxM1VVV0tSdlg0MUExRDJXcnZsdDVWWm9lOFoxOXRML3lxS1gzZ3QxVEZZdzhPSmp6TnQ3OS84c3VyL1lkT1UxNVA5U24zNjg4Vk9lNkhYeS9FMkdaWEoybVR0WXIyenBhdTBFNkNSS09yaXZ1cjYrdXRyM3pMZkhXbHFOcHBtUDhBOWN4WTh1UzlNaVZxdGRIOFNqcy85cjE4aHRtc3NPUmdKdkdybWVIR3l3dTBxU1JYRDl4VmVoRWljQUFWWUUvcXBUYlRmL2JmYXhZNzM5ZS9yK09oTC82TmNqa1phWTM5dlk5Ty9VVzc2THpYd0xGeFpLKzVaYTVXNGt0c3E5b2F5UnhoRmVOMmtqVTgxWU5UL3FJMjNGTnRhK1BOaXowVmwwdDRtRm00L0k0bVIxZjdxLzdRcml2dUpZWm5HSzg2Q0dHU1R0UlR5b2xzL2RIdUtEazNZa05PdEhpUCs3b1hMN2RSdVZvYXZILzdEbXF0dHZVdlBxRkliVzJ2N3NFT2tySDNtSGkwZHhRN1Y3VEFNUVA4eWNsK2VnTW1ESmlXaHQ4Zm5jYmszbStqTWM1NDlESmN6US9UQ1dCbzBkS29KQURTbzJQclhRbVBrWHF1c00yZVI3Zmp5cFBiS2Z6QkVuaUNzYm1FeExIUkhwRld0YWo0YU4vellnNTUreXp1am9WTDVsNHJEYVF3WDlqYW5oSUFaTzBDUUZBSU5RdnpHdHJCblY5R2NqeStLOFdzQzBsdGtIamh1NFlHZUZDRHlYY2hWUHcrR2ltMFo2cStwMFY5MlFiL0FQMCs0REpvT1J4MlhoQk5Od0xtMWRDYS9qR05SVGxsK1RvYzEyZHMxMU56bTJXdFdyNit2WFVpZ1B4M2lJRmhnYnRoZjFOMUIwaEdWemxtdG9DaUFHYWxGa1hiWSt0UGpwb0Vhc0pqWmNyT2JxNUJGc2hySkkyNVk5ZUkwaEROTmNGQWlXZEZqajJDOUJRZkRUUVNJMXRtVmp5U3lDUTI4c0ZXU1FHaWtqME5Oelg0RHJwUU9uREx4d24yeGkrNC9qY0hrZU9oaUdRNVNySmFPNnJPR2lJMjVyMEpCRGNXOUQ2NmltcGhzdHZyckF5ZUwrSnI0cGpmN1pKTkpEbkc1U1RXTjRyUXpPc2JFRHNWcWtxcjZtTmlmbHBjbkpaMFZZU3F0WjhYNXY4QVJGdkcycHR6cXdnTDBrdDI1VWRrMmtSSFZtWDhRQ2FhelUwK2hvbWFYNytySHJweGlURmV0VGZmU0hDTnBlZEsrdWtPSHJhMVUwbFUxcnFBNGJ0NkJBQUtIMTBpU0NVVjBVb0RwRGsvNno5bW5ycGhBN3VrdHlwdHBDTnd1RlFpaC9qcENOMzFLOGV0TklZZ1hNd2FvOU5PSVg3MTZzVHBDQU55d0ROdjExSkVZSVRiN2pUaVBxMDIvanBER3lKcUVDbnIxMGhCZTFrU0lDclZPbUhEVnJkcW9yV2xkTU9pY2IxSEZLNlljaVR5aDlxbmM2UXh5MzkyY2xZU2VSWDkzQmpwTzhUMlplNndvMGtZNDl3Y2VnSUE5dGYvQUExMFdXOXR0TVZvbkdvbGVIV0g4T2ttTmthZG0vRXFRVzgyV2FHR0cxYVNSd2VTd0o3YTFOUHkzNm40YUVlaFdsSTEzUWh4R050VG5SSGJSUTcyMk5KTXp2OEFGaWdOQ1NSMVkwSHcwUFpTOUF0UGJYWFR5RUxQWjMrKzVCRWd0K3pqZ1Y1d294WWNhK3BGUDVhdHBUYjhRYkprM2RGQ0xYeEw0M3hLUEhlT3dUSmQ1UzZaWkpJcmFoamhNbEtWYjE5dlhldXN6TFI1RzdQb2pWdzVsaHFxclZzdTN4UVc1a3Rsa2RqQ3poWm9Sc3JHbFZEZkZUN3Z6MCtLbmNobnlONkhUZmlEeEs2dHg0QzlDTkdsT3J4b1FhbW5TZ0ZORkswQXJSb3RaWHUxc2ZHYzlDbk4xSURKVDNFTHlOQlJ0bFBINTFHbDVFL01VUEtiZThsd2QvYnM5dkF0eERNTHVYaXlUU0hHMFlPMVZBYVhpdXpiVi9sb1RMcDNDY0tsOUNGNFlZbDhiOGRYSHFzT01pdG9PekcxT1VjZmJXZ1lqb3dZOWRZV1RkYXpueE9nckZWQ09iLzlUL2trK1M4eXNmSDZBUjRXMUlZS2EvdTNiZHcxK2ZFSnJTNGRmUzJ6UDVWdFlSUWw3SjJiWnpJZDZWSStTN25XbmpVc3pNcmlvRDhPeUdaeEhrbU44aXdrclJaaXl1NDVyTXBXclRjaFJUVHFIcnhJOVFhYU50VldXM3hNdFdkWHU4RDlOczE5VEI5TU1pcTk0TkMwa0MxWlQzRUFkRkJBcnVlUHU2MDF6UE40OXVPMG5xbjBPbzRQSnJ5Y2UrdlJsVStSMkRXTjR1SXZGLzhBdU5mTE5QaWJrRlEwVVlJUXB4QkZYZ2RneHJYOXBqOE5WVWNxZnIrUE1sbVNUMEtXdmZIcjBaRVFrVW5qa21odXVRVTBRKzE5bTJKK0h6MFNyYUF6ckJFd3VTdHJLOWVOSGxTUGxJTWd6Z3NWbGFWK2dBR3hRUjAxSzlXME5UdjRoMDkyQm9XYURzMjBhcGRNazlBOGpPeE1TdFJxY2FHdnIrR294Q1l5MVkyZUo1QVQ1SU5mZXp2QXZIRVZYdHlSb2Y4QWxnamNPT1Jvd3I3VDh0VVhmcGhHdHhiYjdhNkN4L3FkZVN5OEV3T1B1TGhiaVdmS1MzS3VoQlVKOU92cVBYZjRmSFJmdG11Ui9Bbzk3LzhBaFhoSnlleDlCcm9EamphZ29nOWFtdjhBRFRpTjF0YUc1cXhZZ0Q0RC9icUxhUTZVaHJINDVJd1praURTSldnYmN0NkVBZlBWTnJzSXJqa21aU2xuZHFGVklvcGdIWDRLcE5PSkErQkdySzJsU1ZXcTZ1R2VXOTVEQ083SlJJMTl5U0hmY2VsUjAzNmFoa3BQUXR4WkV1cDlMNUl0Q1ZEeXQwVmtIQkNPbjU2cVdJdmZJVFQ4VFdoOGd5VVpGckFJWURzWlpENmZuLzRhWi9icjFZOWJaYnIwbzNRZUxQSVErVHVta29kMFU3ZnhPb1c1S1hSRnVQaFd2clppMjhRalJnc25NRVZyOE5HSm1hMFoyZVp1N1k4V2xaNC84amhaVi9nNFA4anBXb21NcnRCNjN6NjM1dHNVOEVNT09FdmNqQVVvZ25ZY2VUclVnalZQMjlyM1M1REZuKzVWWTJra0dyYkgzL2tHZnRzUGlQOEFxTWNBMXZCSGRLVlVSSVAzWlFDYUNwcWV2dzFHMlJZNk8xdEJZOE5zMlZVcnFkSlA1UGYrRCtNNHp4N0gyNld0amJyMkVXQ1IySEExSVFocXR5SWIzN0VmbnJrN1lhNThydlk3VnY4QXg4ZGFwQi94N0pXVmxqWXJ5Q0ZaMnVBNnM1YUxtV05TeWI4V3F2V2xmbG9Ia1ZjdXBwWVg2RXdkbExlSnlaY2RkR0M5YjNSVzZ4dFdVSy91SlVxZmJ0NnNmNDZXTjZ3K2hmYlhWZFE3aWI4V0JXRXdwOUlJMEN2S0NXQk5SeElwc2RnZWgyMzBMaytvWFNqdjVCRjRXdkplL0lBbkUxUXVLbXZvUjBwdDhOVTcyV0tLcU9wRHViaWF6bllQTHprSnFFRlZYZ1IxMkkvR21tdDBMS1ZsR0J1NzZHM1pYa1NhM05TRkQ4SDJOUGI2MTBsOFIybFBRa1dHU2thNGp0TVZMenVaZ0d1bHVLaFFwSlVxNytnSUhxZFQydnErZ05rVmRaWDQ3RnBZek1RV2RsRE8weXdWUXdDMXRncFZBaTlRcS9wRmY4dy84ZEp2dzdtRGt3dTFtb252TEJXYzh3aS9mN2x6SGo3UU1GZVJxdkdTUWYzUW9HeEkyTmRSaVhxRTRPSkNUaVg5RGxiN3NlZkRPWDhHTyt0bXVjTDNmb3BJYmVrUUxPVVdUdFNsVzM3Ymlob2V1K3VqOXQ0Ym90eld2WDhJQTkyNU9OTDdkWDE2eC9NcDdJM0NXVjhjWTA1RWNNUFlFZ0o3aEtYRE9TQUF0YUw4UU5kSFdzcWZNNVMrVGExV1kwR1RGM1RyaG83eUtVeHl6UXpJbGdvNUtyU1NORVNBQWFFTHg0OHQ2Yi9BNno4dGZYSHcxTjdqNVg5bVY0UFQ1aGZLWGtOdGMydHd4TTFsWlJ3clBCRzNHT1YxSEJ3dE5pRUZCdnRVVXJ0b2ZIVnROZDJ3ek0xanNuMVZZbU9rL3dCUHgwQ0dKQXg3WkNiTFhjeTNWNm9lSjJMZm9hSnh5SUlvV1BCUTFmOEF6MUhJOTBiVjBKNDA2YnR6ZnFDb3NZTHRJVnRsRUtSU2hydUFFS2pLNWVKWXdhZER3NU44dHZYUTdicTlkZkFMVlZlcTI2UTlSVDh6OE15SGx1VXhhWWlaSUZVWER2Tk1Hb2pod09ORVUxTEVpbTI1cm8vaWNpdUtyZHZJd2ZjK0hiUGV1eU80QysyM25sNzRUa3JyRjMzdVVYTnU4aWNBQXBXYU5KeTFldjdTbW0zWFd2ZkhYSldmRTVtdHJWczZzc3ZIdzMvai93Qnl2TGNkZFJoWWNxSU16YnVEdVZtcXBQNXNXMUhIL3dEQXF2clYvaitCZFA4QXlPTzQ0UlhaTmZkK1dvUVhFaTN1MUQ3OWRSZ2VRN2JaQmdCd2ZVWUptVXR4Sk02bG1xUHgwaEVwUkVFclVhWWNoekJGTEVHZzlCcENCa2pLU2FkZE9NZlFPUTQrWHcwaEc2NG4zQjB3NUdlVU1kalE2UWo2S1NWV29TU0RwRGhxd0R1NjEvVHNkTU1QMkRETVE3TitnYmY0YVljYmJKUWYzQ2ZjTkllQXN1UmVNVXIwMHd4R256bkhZdFRUamtDWE44djYrdW5FY2QvZnp5Tk0vd0NmdkNzQWhteHdXeTdoSkljVzdOSnpOUlFiSFZuRXJhYldmUnY5QWZtNUtiS1ZYVmF6OFgwS0l5ZDdjVFhic3daT1IxcEdTM0lQYVU3bHErbFQrT3BJcmt1TC9URGdKTXo5eVk3eDBKanhzTHlqNVBNUkNwLysyVHJLOTB2SEhhWFcwSTJmWjhlN2tKLzdVMmR0K2EzaWZVSllLM3NnUU0zSDBvdGFmeTE1L3dBbXlkNDhEdmZiNmFiL0FCT1RmdmRlWE9heE52aUxhV3RoNCtZYnZLUjlPNWVaUm5lT0kvOEFEQ2hQNHRycmZZK1B0cThyNyttdnlNTC9BTE55ZFZocS93RHl0L0FXdkZyM3lZK2V0ajRXTng5WE9KTHZHRnVVQkV2dWRTRzJCUUdoSTlScnBhVjNIRzdvZXZRdTNGNDdGNXptdDFhUTVMR1RLajJNeFVNeGhkYWlqN0Uwb1YzMUdTZTBqeTRlSER6Ump4YTR2clV0S09kbUttRTlUUlZrRElTS2V1bUhQTXpucnJFSk9jcmFHU0syaWFlNEZJUVdnalRrMnlTRk9kQnNCVDhOTjl5T2pGdDBLdXU0UEFQTG1mSWVOeVE0N05UcTBaQkF0NTFNb29hTHNHcjh0TzcrT2hGMVhZSFdQMjcrNjJIdExpOXdGeTZTV2JyMlpVY3hTc2hCclRrQ3JWcnZVNmRWcTlTRGRsb0dyZjc2ZVlZSWpGZmNueDFiOEw3V2xaUHBaVHYxT3pSdDhpdE5TVzZ2UjZDbGR3empKUHRCNXZOSmVZZklTZU1lUU9wWlVoaytpbmMwSkttcEVjbjRWMzArNVA4QWNpVVQwTldleXZtZjJ6K2pXVy9neWtFL0NXSzNNZmF1Qkd5MUlrQ1ZoMkJweVZRU2ZXbXEyazNveVdxV28wWUQ3NTRsNUk1R3VwTVRkZ2dSTVNZbGR6UUZHUi9ZU1BsSWZqVDAxWGt4L2NVV1VvdHg1blQ5cmdzM0I1ekh0ZlpES1JYSnVteVpTNnVsNXFrcXlwVGRZbUNuanhGUDh1c2JuZTExellxMG85dTF5alQ0bnVEeDVIYSt1NUh0L2w4ZDVMNUppTWpqTG01RnRhUVg5bmRDUzNlTlZ1VklZSTNjRzNkSHQ1TFZTS1VPc3pCd3N2SDQyYXQ2ekswOC93QWRROThxbVhOajJQOEF1NkVUek95eHN2alhqVWVRdEpMeFpiK0RuREh5RHAreElUN1FRZHd0QjhhYUI5ajNMUGFIL2F6UzkyYWRmVXY3a0J2OVFsb3R0NDdqSklDV1NUT1d2cFE4aWt4TzJwK3d2LzhBZkwvQi9xRGU3NU4zR1MrQTRxbjFOL2xvNlVSTGUxSmIvaExqMS9IV3AvMlcwWWEvK3dIL0FOZnZ0elcrQUR3aVcrUW04aHRvaURKWjVJcTBmOVhGSVVoSkk2N3NwMzFoOHVqcndzTGY0azZMaWNpT1hsWHdJZHY0N2JSNXpOWDBFYXJkeVJXb2xaRjl4V1ZSWGthK3ZiWDAvd0RON1piUGdVMWY3Mlg0WFZjK3o3dXY4Uko4aSszMk44a3VyL0JYMXFsdGdtV0hKSkpacTBOekhkY1doRGJLWXlHUFBrR0cvd0NXdFhpKzQzeGNUZjhBdWF0R3BtOHoydkZ5ZWJzYVZVNno2ZE5SQ3UvdHJtZkZyVzV3L2pHVU9helFlRzhzTVZkaFVEMnA3b2xWWVpXS2MxNEJ1VVpVbmVtdHZqZTQwellua3N0cVdqT2U1bnRHVGo1bGpvL3VOcVVqWGl2TmZJOGJiWGQ3NU5pcmpIcGpaSVlMdHJ0SkpsUXpraU9uTWk0VlNSUUVQS3YrN3EyL0d3NWxLaC9BaHgvZE9YdzdSTFVkckRCWVpqQ2VRM0QzdHBkQ0NDNEZMcVNKKy9FbGZpeUtHUWI3OTZPUFdkZmdXcW9xNU9pd2UvMHZmMXJiUFZvMFhxWURFc21GdWJoVjdrWWt0cjE2TmF6UnlNeG9zcTFITDRpdWgxVE4rNkRRV2Zodi9qYjBhNjloUXpIaTBrYkM1aTdmMHNySkhBSXlOMjQ4alNocG8zSHlPejZtUHkvYk52cXJHMStBOXo0eTU4ai9BTk4va1dNdDRqTGRXVnhaM01VUzA1RXhYaFEwcjY4WDFyVWNKTTVQTGpzM3RYVTV1WEFaaFlYUllUYnpJZUJnbUJSeU9oNmpVL3VWOFFiN04xMVFKdklyN0hzMFYxQzhSOU9RMi9JK3VyQ3VHalBHMmozMHl0TXhXSS9xSTlRVDAwaERXY2xieFJDemhYamJyN2FqOU5QbC90MGlTY0ErOHlIdDdjWkJKTkFlaEEwaHBQc1RZZlVTcmQzVEZZVW80MzNhbnFEcG1JdTc3SitSM2tIa2YwdVB1bWF5dkpFaHVJRmtDSWp0dEhJb1BWZ2E3N0hqVWFwdldRbkhiUW5mZGI3cUR5VE5mMmExdW14OGVFZjZTV1ErNk80bnQyWkdsQTZveWtzdTNYcjhOTXFQdXRDTnJMdDFCMkE4NU9MamhXYU9LNXNpck1rUnJXUndwWGVWYVBUZXBCSVhwcFh4dU5QNkQxeVFObUs4aXRNajN4UExEQ1k2UEhJaFlLd3BVcHZVRWowSU8raHJZOWk3djhlUWJUTXJka2czamIreHlLTkxZWEszQ1JuaktxL3FSajBCSDVkUnFEVFhWUVhWc21wVGtLMjdlOEN1a1NHdkgzaUlpb3gycFRVR09GNDdoQ0txZDlNSWtpVWlQbHVUcERvelc3SVdoSitlK21KbXA3dnFGSnBweGlPOTZSdlhwcENQUDdtU0tWMzBoR3Q3NGtVSjBoQTI3dWFxZDk5T2lJRWxjdXhKT3BDTVZZVXJwRFNheTFUOC9qcENNZzlDQjEwaGlTa3hyK0dtZ2NteDNaVVVPNTBvRkp2VytiU2djK042YTdFMTlOOU5BcE9jUHVVMk51L0tMNkhFaVM2a25wUlZhc1lsSzFrQzE2S0QvdDNwcm91UmwzMXB1VVhTaTNuNGFlTVJKajNYcWFYVHNJYVovTVdkZ0xUQ0lrU1JxSXBMZ0tIYm1DUVFoNkgrZWdXaytwRGMwdEFWQmdyekxUeVhtWHUzbGtCUGRQTGt3QTY5eHpVSlQ0Ym41YVRzcWpLcnN3WmZTNDJFTmE0MTFhT0lrUEl2NmEvSW5yK09wSWk0UWUrMkVNOTU1VkcxeXhhS0NKcG95d294SUlVVjlmWFFuTXZ0eHNPNEdQN21WSm5WdmpBaUVETW9KS21Nc0FOMUhJSGx0NmpRZkdzM1FNNWxLMXllbm9YbDRkZnl6Mkh1SS91RnE4YUUvd0NRUkpUbFN2dy9qWFJQUURRV254NnJucmp6YStpN21FaHQ0N2FHMlNwZnV5dFdlVTcvQU5ORkFwODlTZXVvNmZZVXZKSkxHeHdUSmJUVFhkeGxHdnUzQ3hMSldGMlF5QU9DeStsUUJ1ZngwSG5za2czaXAyc3ZBeXdpMkZrTFBHV2psTE9LSmhJaENoVllqbXhCQlBVa2tMWDI2eUc1V3ZVMlhvemh2enJPbnl6elRPZVFsdVMzMTVPOExOdlNGVHdpQS9CRlhXcmlydG9rQVgxdEtLNzhwa1dDRVJJZmM5RlAvcTNQOGhyUXdhbVJ5OU5DUGdMQzdrc3JtOHRpVk5wd201b2FPckExNUtSMEswcm9sdUdCVVVwcG42Ry9iVHpsUHV0OXNjZjVPV0I4a3cvL0FFT2RpVSs3dndxUDNlUHFIQldVZjhUZkRVK1RnWEl4T3E2OVY4ZkQ1bEh0ZkkveE9ROEwvYmJWQTN6SER6M3VFaHRoRWpaV0dRelc4b0JBU09OYVRWQk81a2phbkVFZW0rdVNVVjBaMjExdVdnQ3hlUHd0MU5hNWUrdUVUdVE5cnN6Y1Zra1BhcmJ0UlFSN2dTcm5ja3F1bjFob0JsSmxRWHNGeEJuTTVOWjQrUkxhVUYxUkFxdUlMY0FSeWdPVHpCbFFoZ3REUWZPbWlOTmlsbGxWYTEzdFJqSGY0dnRwWXlUR1paSUlxM0hKaUoxa2ovYzlyVUE3YnN5Q2plblRUN1cxb1VOdzRZWWhzNS83TDlaQWtpUzJjeXBiM0sxUm8zVmFxUjAyWWdEYlZjYTZsbExSMEJIM054Tjk5d3NGajdTRXdXME9Ma2xtV1FTbVNTU1dXSldLRU1GQ0RadUMvSGJxZFg4U3l4MmZtVDl3czgyTkpkaWo1dkJMcUtkck9JaVdRZ2NIb1FUWGZvZHdSclorNGM1OXNHcjRmbkpYTVVNTlZVMDVrOGErblRVdnUxZ2I3VmdxMktzdkhvRUY3Y3JMZlU0dmFwUTBZL0dsVHFwdDNlaGFrcUxVSFI1RzdkbkdQdFM1Y0VNemcwRmZoOGhwM1JMcXhsZTM5cU4wbGhtTG15a2ErWGswQURRVnBVRCtvZkhUMXZST0VOZkhkcVdnV2s2dWpST29wV3BQeitIWFJCUU8rRXNyQ2V3aW50NFVqa3BSd0J5WU1Pb1Byckh6dTliUXpvZUZYSGFuVFVJMjFuRGJqOXFFSWFsaWdwMS9BZkhWRnJOOXpReFlxMTFqVUY0aTV6dDVmTkhmV0FodHdTVllnQUQ4UGpxek5YSFdzcGdmRnlaNzVJMjZDTjlCZUpDd01FaEo2RGlhMC9LdXRhVkp6c09DRTFyS1NGVmF5RHJIMGNmK2s3L3cxT1N1REtJT2twaGtyR3dOQ0cySVlhWFlkRngvYXE3VzdXNG5Xa3VZaU1jUGJmMWlVMUhHbitadjFhdy9jWlVMKzA2MzJOVXRML3YvQUlGb1dxWXp5WExRd1NRVkZ2emQrQklUdkFrc09MYkRrVHJBdGUrS2srSjBxcGp6Wk9uUWU1WUlXc1Jhdk5Fc2R1RVdQZ1VRZDRNV2RsQkRLSzhxYmF6MWR6SnFMRW9TYUk4YTRxMHR5NXUybG1pSDdLcS83SmtMQVVWaDFhZ0hLaC9IVHQyZlFaVjdoV0JaN1dCRElYRndTTzhIRlZET0NDZUxFMUczb2RVMlNDS09lcGpCZTNyU0lzWkx3QWh1S2loRlQ2Y3Q2YW9lUFh6Q0xWcjFDTjU5QmRwREpMTC9BTlRjT3NTTno0QXYvVFhsc0R0UWI5ZHRPc2RydUtyb0J2S3NQN3RFYk1kWmQ4dkF0WTRoKzNJOG9NbkxmYzBxUU9tL3JxaGs4bDRVamRGNHRiUzIvQ1didDI4MWU2SStLQ2czVUVlMzI3YXZyV3JNeTNMc25vdFVTb3NMaDhkRExIYXNRenFGTnoxNUhxT2hGUitHK3JLcEphTXB0bnlYY3Y2RkYvZlBMcmlzZExqSUhjcGN4Z3ZHRklKYVBZcXIxSlVucFE5ZlRXajdmalY4c3gwTE9WazJjZHQ5K24rcHpmbVkxeDk3aS9ITE9TYVJNVUROa2d4NWhiMlF0SkpGR3dGQ05sU3Z4WGZZYTdHcjNWZG5HdlQrWjUvdGRicXE3ZGY1R2o2TzJ5ZC9EZlkrQUV6eS9ScGJ6VWxLSWhLQjJRa2loWGVsVCtPbVYzVk5OOU5RbjdOY3RsYXE2dmJEN2VZMGVOMkV0aWIrMHRvR1I3QU05MkdZczh5ekZTVkIyRkY0OVRvTFBkV2h0OWZ5TmJoWTltNnFYN2V2bklReGx2YXkybGxmU2ppSGlodDdTRUtHQ3dxZTVNOGdBQnArM1d2VTFwcW05bW0wRTRxVnRXdHZLRjVkMjM5Q2Q0dFp2bHJxeG5rdUZudUdjdXhCcThjYW81cVFlaWtyeElPM3Bxdk5iWW1rdEVFY2V1L2EyNWIvQUNRelJyQTBkM2N4T1dna2Q1akdvS3BTM2R3QnlJQjkzcy9ub096Nkx1SFVYcGI3Ry9HaERCSExZcTZ5cmJDNFoyYlpWdXBxSUtHb0tyVGZjNmE3MTFLRXBXbjRrb2I3bVlac0Y1Z3hqa0hhdkZFM05CeFNzbTdxQjhLbmI1YTZYZzVkK1A0SEVlNDRmdFovaVhCNUZsM3Yvd0Q4VjNsdHJYLzdwNDA0TEpiZzhwTGNLeWsxL3dCL24vRFZtQzliWk1sTGRVcEtiVWRWV3k3akhhRnk1RENtMWRNV29rOTVneG9PbnJwb0hKY042NitsUWZUVVlIa214WHhrMmJiNTExR0NVa3RMaHVOQWR2eDBvSGsxVFQ4elN0S2FZUkhvek54WGZmU0VtVExlM2RhbGh2cEVqS1NCNUNCVFlhUWpXTEVzMUswT2tJbXdXQVVpdW1IQ3RuYjBuVUN2SDEwd2hueHg3WjRnNllReDJ0K1lodnRwUU9hcnpNY1FTU05JWVc3ek15U01RaDBoRWFHOG1rSloyNG91N016VVVENGtub05KaVp4NzVmbUwzSytSWkc1eWNuTzY1eVZrVWozRlQyd05nTnFEUm5HcWxTZTdBZVRkdHBOUUFseVdQZkYzZGpmd0s3TXl2WnpLS1BHOWFOWDVFYUtoZ3FkWWNnaVpjVWlUc0xtdkZxUXFRYWxSdFUvRFVsSlE0T3F2OUdtQnJhWmp5TmtvbHpkSmJRTjhWdDBMbi83VGZ5MXp2dkdUMVVwOFdkTDdQU01kNytPbjh5M1BOTTNaWTcrNzVxK2tDMlZsYnp5eXQvdW90QU4vVTlCOHpyaUtWZVc4VjYyY0k3dmp4anhKdlJMVi9MVTRveE9leStmeUdUdWIyY3hZeU9aODVreXUzZG1RQ09DRW4xQkpDQWVncWRlcDRzTmNXTlZYOXVpK0o1WHl1VGJrNXJYZjk3L0xzUXJQeUMrd09UYnlHQzQ0MzRNcUNXcE5mcVVlSit1MVNIYW1ybDZWQzdndDdTNUxkOEZ5RjNEWjJWdmpMWTVPeGtoRThjc0pZTWt4SVo0MVpXRFZXcSszMFBwcW15ZmJvaStzZCtvUDg1KzhReGRoUGo4VTd2ZE1zaVROYzBaa2RqU2lHaU1XQkovVjhCcXBLMS9KRXJOVTgyVVEyZXZzdGNyRkFaUHFaTmpJN2NtUHE1WSt0UnE5VVM3QTd2WmsyNXRXaVZwUS9FUmlyRTlBS1Y5ZFMwWkVZUEUvdTE1bjR3cXg0Zk15TlpqL0FQUWJvL1VRMCtBU1d0UC9BRWthaTZKazYzWmFOcjk5dkcvSWJkY2Y1dmdJNGkyeG50bCtvdGpYMWVGeUhHNS9wYy9ocHZVdWhPYXZRMFQvQUd5KzNmbTJPa3lQaUdRanRMc1ZMMnRwS0pLRWRHN0V0SFVINGFrc2k2TWk4YmlVSk9SdC9JdkYydGNSTmF5M3RsQ0JFR0lacEpKR0lxUURYOEZYMEdvUEh1NmRSOTdxaDE4Vis3M2llSnhFM2hQbVBpejI5a1pKZVZ3WWttbS9lTzdTUXpLQ0NLRG9UMDZhdTNYcW9JVFZzZXNmNGQ5dS9KVStyKzB2bHpZcS93Qm1PTGVUdndEZXREYlQrOUtWNngwMG02V1dxZ2VHdWhLa2wrNmZnd2NaM0ZSWnZHSUZhVyt4YkdmZ2dKSWFTSjJXVlI4K1RqNWFyZElXakxGYnhKK0wrNVBqbm1kaUxXWEl5V3M5bk9yeHhHUXYyWm9xaFc2VjQ3bWxWNGFFK3hqVjl6cXBla2huK1ZrZGR1N1FLZmNXM3lubkdCdExMQnhKY0piWk8zeURYQ1RLOERKR3NnWUtlb1B2NmJqNTZ6T0I3VFhqWjNldHRIcEFmemZjRm53cXJyRnZ5TER3aVdVMDExd3Q1SXBab2tNcVNxeXllMlFVTzVvUUsrbWh2K3hwL3dDT3YvWkUvWm5HVng0QURDMk5yRjVaNXU5dlpOQmV4M1VJbnVXVThaNHhFbFJ5clFjeXdrQTFoYzVXL3dEcnNUblNXYlBFdlgvTHZwMVI3akxYSVcvbkdZRHhSeVlpYkgydHhJRlltNFJrQ3dxQUNmMGdxNVByMDBuZXYvMWNkMVluNnY4QU9tZEhVOFc3eC84QTNYZFlxUWlHUzZ4a0wyeVNzQnlDVHp5TUF2VTBBci9IVU9OUlc5dXUzMnRJUmZMYXZOb3YvRm9pU1l1RWVSd0NFTDlUSllUdXUyN0xIS29JRmQ2bFpIb2RTNGJ2Ymg1VXVpYUNPUmV2K1hpZHV1cS9JQzVyeDJMS1paTFBKQTNtTHVyS1Jiakd6b2p3VGRpUU92SUVWOXJTaGh4cCttdWlPQnlMVTQyVForNnNNano4Rk0zSnhiMU5YS2EvTVJNejluY0hZejNXSjhWaXVNWGVadTNpdThma2dYbFN6bXQ1QTdMekJFaUtWOWhveC9VRHJiNGZ1dHJZYlh5YTdmcWM5ei9hTWF6VXBobXUrZXVxVC9VU0xqRWVjZUpZYks1RHlXTzJ5dG5ZbTNaMXQ2YzU0YmlUdEdVc0ZLdHhKRmUvQ3gzNjYxdU55c1hKck5IOVRINWZDejhTMFpGOUNMaDh2NHZsN1pwN0dTVEd4bDFpbGptQWloTXBCS3FWbFl3RTdIOU1zUi8zZFR5WUUrbzJEblhwb25LTGcrM3VKeUV2aFhsbU90cElaQzhLQXdtT1JXWmJpVG5ISlZ5T1B2am9LS3k3MTVIcUdkSnB0a2RaMTkxWGp1SXVXc2NibVZXNXg4cU04WldPWmVQdlU4dHdSMUZQV3VzT2p2aWNXTzA1Rk1QS29yVWFrVFBJZkYzdjdTNHRDdkc0YXFSc1I3ZVNIWUdsVFhXamg1TWZBNXZrKzNYdEtTMUV4ZkJjNUJFeVRSOWxRU2tieGtPcElvZmo2ZzYwVnlLUG96RXZ3czFQM0tBTGY0dks0eENIanFnLzl4ZDEvUDRhdVZrd1MxWFhxUmJHRVNOM0p6UkJ2UTlDQnFUSW9JWFdRZGlJZ2pKQ1FPQnB4RFY2SGYwK0dtSEdUN1paTnNmNWRaRUduSnRxL0VIYi9IVVdpekc5UmgrN2VNanN2dWJtNFRTQ3h2cFk4cEc2aXBLNUNKSjl2d1oyMDVGOVJWZSthT2RmcEorOExRQ05KbFhpR1VEK3BPdnkwb0VUYmJ5SzQ3aWlZY0VIUW9BOFlQeDRIL2IwMG1oNUczRGVVQ0NUOW00a2hEQ3RZcWMzWnFGUXpiaFFPdnVyK0dxTW1OVzZxUzZtVjE2T0MwTUI1UERjeHdXMThaWkx5Z0VsMlZUalJ6UmVlNDkxZmgxSHBvS3lhZWtRYWRjdGJmdTZ2eTBIaUNPZEFlU0VBVXIxOVJVZngxV3IxdG9tV3VyU21BcFp5T3V4NmFrUkRVWW90T28wdzhuanB0dHZwb0pFV1JqVFRpSU04akxYMFBwcENJVFR0WGZiVW9HaytGeVNhVjBvRkpoSzVLazZjWmtKaDhOSWlZVklGS2FRakE5ZElSOHV4Sk9rSTJDUWFRallKZElSdFdVbmNtaDBoR005MWIya0wzTjFLc0VFWXE4cm1palRxcmVpR3RaSmFsQWVWQzB5T1N5NytNbFJGTXhsZVM1WVJqM0E4aFVtb1VrblliMDY2MitSeWZ2T3RyS0xiVW5IZHJTZjVtVEdyZ3JKWm81TFlxOG9DeHo5a0pFLzdZaENFMEJORDdpT3VoMlZTQnNsbHJ1NGhGcUQyYlVFZ1F4SGl0QjhlbGRNa0tYRUFkYmhvZ3dRRG55RkJzYS9scVJFZC90aGxoWitWSWwyZUVkNUd5QmowUmhSbC9pUm9QbVUzWTJIOERKc3pKbldIaGx6QjlZc01udnQ1aVV1RlU4V0lQcUtiMTFsY1c3VDJzM1BjY1ZiZXV2ekxmeFpreEdZamxuUlk4VGZ4aEJjOHVRa1BjWkY1Q2dwdngvK3I1YTB6RFEyVDU0UjVQOEFzZHVUZFdaaUZpM0VNd2l5RWdOT1oyMjRPbzIrSHkwejZFbDFGRHlHNVM2emxzcXlSUXkyZ2pzYnU5ajVCQ0pmWkV5QW5vSkU5NU8rd3JyTjViVCtSc2NTcnJWK1lzNWJKNW5JK0xaQ3g4VGlpdWNsZHd6d251c2tmYmtZTWdrVTcwVkFHNi8xZncxbVl2OEF5Nkdya29xOURuTWZadnk2MmpKWkxjOEVEc3Njbk1oZW5XZ0ZkRlBtNDJPdUZlT3hTLzNDd1dVeDJaVzB2SXdnb1dEZEFmUS93cHJjNG1TdDZTamxmY2NGOGVTR1dyOWtjWmo3M3Q0VzhpTHgzL0sydTVGR3dMSFlzS0dxMEsva2ZscTY3MUFhamI5cmNyTjloUHZVUEdjbkt6ZUVlWFJ4UnczRTJ5ZHVabVczbGIwNVJTODRKZnpQU21qTU50SU03bllYZXU2djdxNm90Ynpiek8xOFg4MXptQnRMbFpMdGJhSy9zN1lPazRqOXl4N0xHeDRNQnNRMVAwMXBUZldGN2p4bDl6ZlhwYnI4ZTUxZnQzTis5aFc3U3lYUUgvOEFiZU51Y0hkZVNRWFZ5dUpuamE4dUxhRHR1RVJwQkoyd3pxeFZoSjdnNm5rdjZRZGhUT1dWcnF0VUcyd3ExdEdaWmZBaVR4QzB6ZUdUdTVLTTNOMVlST25JU29WRGRoMXJWZ3hBWUQvTVBoWFVOeWVqNkJGUFE5T3BTZVRsT1lrdGJ1SzI3R1huWlk3ckgybHZKY0UzUVdwY3BFR1BGd0N6Y2YwdDFIcm83RlRXTzM4QURsWFRydWlHUFZ0a0d5M2kxOUJFUXFNc0VzcnllMTJqams1SlVtbkYwSjZVNkhwdHFtOVhXeFhWcTFaTmRzR05qSG1HUGFuaWtqOXdBWmlZV0Vpa0wxTzQ1ZlBVSmh3V2Z1UldQbGZsV0Z0L0pickpTMnF5eHpoWkxTMnQvWUpKWDl6T1ZPNEJldEJyVndWczZhbVhuZEszMEZxZXk4cDhnbWtlNzRZU3hZY3hiVzQ0eU55TmZjUnZXbXJYa3BSYWVwa0s0cjVIcjZVYmJIeERIV3dNalJDV0ttOHIxTHM0SkJyVWRQejFWZk80Q2NmRnJQU1RZY1BISEtYamRZb1cyNGdmcCtmcHFsNWZGQnE0M2cwamJiMnpTMjVWNk9WcXJsZmNDQjh4MTAyNkhLSCsxcEQxSzV6dU9iRjMwa0FIR00rOURYcXArR3RiSGZkV1RuczJOMHRBUzhTeXdzYjhXY3pmOU5ja0lUNksvd0RTMyt6VlhJeDc2K2FMK0huKzNrOG1XWU1heklHYzdqOEtuL1pyQ3RjN0NtTjNKRU9PVzRJanFWWFlydjhBTDVhR3U0TkRGU2ZTeFJIMGtwTGNBb3JzQnQvRFhTTnM4K1NTMUFma3NkdUxLWUJRVzRuaXpEY1UzMk9wVW1TTnVnaDFJTmZYNDZLQlJtOFV6cytDeWNPUWlKN2IxanVBTnYxSDVkRDBJMEx5TVN5VWFEK0R5WHg4cXNpKzhCNVJackxFc2tLd0lBRldaU3BqNXNEeGRnbENSVHJYK2V1U3o4ZTBkVDBmamNxamV0WW52L0VaN3lWcDdHMmd4d1Q2aTRrQVJvd0NPRk5oeVlFSGJjQ3VnS1ZTczNib2FtVnQxU3IxZlExMnRyazRrV2tnbHVJNnN6VUlqVlFOZ1AxYm11NTFKMnEzNUUxaHZWYTlRdDlSbHBKbzQzaUhCRjVOY2NtS2l0RkswOURUVmFWWWtuV2w2dUYwOFNRTWdnV09KNVNKT0I0UWhhbGdnMjVVcVFEOHhxblpPcGU3S3NJYjhOMnBZUkpFZ1c1S0IzQTZoVHY3Vk81RmZUZlExazNJTmtiWFhvTVdIakVjYU9xY1N2dlZWQkROdWFDbnhHcU91akE4emtaUmhMdklpSnBYQmovL0FFam0yNmtrMG9OSlVjeWpPKy9Xa3gxN0gwL2oxbGF4VFNKS3lGVkxJM3VyeUJyN3ZrYStnMWRDVmRSVjVGck5LRGxuN296WXE2OHB0aFBmaUt5dDVvWkx0NUFYV01MSW9KUHJzd0ZRTjlqcmY5c3JiYTJsMUg5M3NsanFyTmVNRlFaSmJyQmVYWkZNcGFQWjI4T1RsbW54Q1NPOG43c0JhMkFaaVM2a01kejFydjExMGlpK05iWExqcjg5VGk2WGRNamRsNlZiOXZ4V2d5K0twaEhsc3ByS3orangwd2llZmpLMDBrVnhGSElrcXlrbW9Za0ZnT25IaWFEUWZKZG9jdVg4RFg5dFZlcVVLZnAxQnRzN1M1UzZ2WjVDMHM5bExNR0xOVGhNenhsV0VkQ0FSd3A2L2xYVW5wUkplSXNibks3VzcxL1g0RE5kWFZqYlkrUEhTU1Z1QklzQ1c2bGgyNFkwQUoyQzFRczlXMzZONjZEVlczSnFYeVZWVlg0S1BCTDhhaDN4dTFoczhwSGN2YmxabmllTkFwQzFMTzA3RGdkeHR3OWFmTFZXYTcyd0VZY1NWdHpYYitNaGhiUURIM2R0YlJxOFhMM05JT0hOWkNHWVZxYWNWM0hwVWpRYnRxbXczYm80MU1zWGFXbHBGbGJXQ1ZrbEtRMjhDT3hrWUJTZXZJbWlobkJJci9qcDdXZG9iQnJVVlpqUVh2djM0TGIzSGlkaDVYam8zN21ObHRMYTVWMG9wanVRVURWRk9WU0lxL2pvcjJ2bFJtZU4vd0J5Y2ZJd1BkK01yWTFaZFUveWY5VFI1RGlMbkMvYlRGNU9OREltRDhoK29uNEFCVWlkNUVZS3U1VlEwZ0cvK2JVdUx5bGJtN1ovZFQrSTN1SEUyWU5QN2I5dk5CNks3UnVNa1o1SXdxcmZJNjZKcU5EQUpIZEJOUjY5ZE1Pak5TeDNVMDAwRG0yS1FxUUR1VHFJNFR0NU9vcnBtaFNidUhJajU2WWNsMjhBUWsrcDB6SklLVzBha2dOUW5URGhQNkZYVUZhRDQ2UWlUYTRpQSsrVTFIeTB3NUlOaGJuWkJ1UGpwRG4wZG9zTGhtOWRJUkpVOEdxTmhwRG5rbDl4YjlWUjh0TU1DY2prR3IrcmI0YVFtQ0Jjc1g2blRqRWZ5ZkwydU44V3lzdDR6SkM5dThSWktjZzBvNEtmY1FPcDAwU1J1OURqcTZ1NWUzY3V2S2Q1SENSdFVHZ0FKYmY4U05hbEZDTXE5bTI5WkFNMDEySk8wVkliMUI2LytXcG9vWm9sRWp5KzVldFB5L0hVeUorakgrbjdCTjR2OXA4U1hVUnp6d05jdUtVUE82UEwvd0RKWWE0VDNYTk9hNzhORHV2YjhXM0JTdmo2bjlRZDVsRGI1RENadUs1OTlyTENJWFZnR0I1dUdwUWoxcHJDNHRuVEpXeTdNN09tRlhyOXRyOXlmNkhKK2N0OFBnSUd4bUZadU41SjlYZm1Tb0tkbXFSeEFkU0FTN2E5TnhYdGVxazhpellhNDd0SVI4dmE1Vzl0cmVXQzFrZXo5emlWUWFNYTAyMWRLblVEZFcxMExzK3dNSmh4c2Nrb1pWUnJpNUpwVGZtc2REWDVSNm5rNkNvVWw1ZGw0cm55VE1HZUlTcTE1UHhiclJRNS93RERWV05SVkN1NXN6VjQySW9wTGk2akJCWWR1UDFJSHJ1ZW1wVzZFVkpuNURkWERXNHRZbEo1VWFVci9sSFFmbWRWWTE5Q2Jla0N2eWRkalVFYXVJRzlNaFBHUGFhL0k3aW1rSU80MjV1blZiaUpURk1LRkhSaUNLYlZCRkNOTTFKTldoeVdCNDM5MWZLTURkd1NYSmd6RVZ1VmRMYkpMM2pVZW9rQkRnL21kUjJ4MGNFdnVlT3BjMFAzYSswLzNFdGx0Zk84SXVQdkRRZHlSQmRXd0I2bFpZd0pVMytJL1BVZDEwVDlEQmVYK3dIajJXRFpqN2JlUktrUUFraWpNdjFVU24wcExHZTRuL3FxUnFTdlY2TWk4YlhRUjczeVQ3bytGMnQ3aWZNOHBOZVlmaXNkc2tjZ3VIbElyeHBPYVNCRjlWWTc2YTFFK2dsZHJxUi90L2UvYWFiT3gzUG0wMGk0cVNLU0VSaFpRSTdoK05KSGFMM3FGSFNucnA2TjEwYWtleXJaeW1YclorQjN6UnlaYjdTZWFSWm0xQUR4Mk9Sa0Z3WFFIOUMzbHVWbEcyMUpnMm5WcVc4aE5XWG1lVGZjbnl6eGFYcytmK08zZUxoakJNZCtnYWEwYy84QSt4Ym9VLzRTNlIvTTZqZkMyb2NXUk9tZmE1VXBqTjQzNWpocnJJWG1TaHZJNUpNbVZqbit1bTdZZDR3QW9XUU0wYlNCT05LTjA5TlkzTTl1eDU4WDIvMnBPZERUNC9Qdmp5YjM2cERHTFNKZktMdktYa1V0dGEzZG9rRHl5dU9BbGdKQTVoZHVMSnhDdjByK09zelA3ZGt4OEcyR3NYY3orUE0xY2ZOcGs1U3ZxdElKZHhDcDg2eHNTMnNFdHJQamJrSmVFcnpWQTdsaUR1V0NqanN2VU9mbnJKNDJKMTRHWldtcm5vdzdObS8vQUhqRzBwOHp6S1dmL3dEZVBpdDNEZkpESTl2ZVEzRnNFRGR5S1BpNFdwUHRxWG9UMTZhWHRkMitMbXJFNlNOelAvbm8yNDEvZ1laV1Y3RHl6eEpQcFpKWXJpVzZzNVJDcGs1TGM5b0tXMzJBQVppZmdOV2UwUThlV3R2OXBQM0M3cTZXVC91L2dlWmUxdGpuTUdxU1VhYUM3aWpXaDlwalJEUTFwL1VvMVg3Wlg3bVBLbC90Q09WbVZiNDNiL2VWSDkzcmNXUGl0NWxsaWQ1YlMzYnVoVHhQR0s3dHl3b05pQXN6bldsLzE5N2xlcjhRWC9zZHRycGNxVEM1TENlVGVDZVFXbllSYk5ibXhudXBDZTFORklYS0k2a2JIOVJVMTY4dGRSNjhhOFRrbDl2TFpka1cvd0Q2V3JFNGlmeWpFZlV2Y1dkeFpDNnR3N0U4ZnBwUjBGYUFVZjAwdnViOVloa2JZZnRwNnlJZDE1TXA4ajhpeHVXeFV0dStHbnVubHlDOGp4dDRKekh6N2kwbHBTbjZoTVBscWRzU3V2RWpqNVY4VDBiUVV4c3VPeXJDNnQ4aGJ5MlJCWTNUa01GYW15bVNQMnIrTXF4bjVhek0vRXNrOWgwdkQ5M1R1dnUvVVBYZUVhV0JHaWdJVGtEVThURzVZZFVLazFGTlpIM0hqY1cwT250eDF5VnVwRFU2UUwrWjhCVytodUxXWldqV1ZLYzBBNUtUdlgrT2lzWFAyd3pNeit3V3Ntbm9WcFA5dXJ6RlRxaFpidU55ZUxzdEY0S1IxQnJ2dnJicnpLM3JQUTQ3TDdaa3hXaDZvSlpYeDYzS0tKWWkwSldrTEVjbEI5SzA2YWhUTkwwWStiaU9xVGEwRXlHem53dWVzTGhrWlkxbG9hN3FDRHRSdEhWc21qTWRYV3haZitvQzJNNitHK1VRb2V6a2NXMW5jU3JVZ1M0K1pnQVNQL3pjcWFlbzExcVV4SGRHSWNSdXA5RC9BTERxUldGN0NWQXlUM3RVdDFxVVVidTdlZzlOdngwaEdxNHlJVzVZMjdzSWErMWlhTWZYZW5ycERoN0ZlVHoyNFcza0hmNUdxamV2SStwK09xN1VrbXJ3V0RodlBwYks1UzVFaUxORXgya1Zta0hLaWtBRWtqcDZmblhRMXNPa0JOTTdxNUxBOGMrNTBWemU5M0wzS1EyYkFtV0NPQWxJZ0JYa3NnYXRRZXE4YWZQUTlzYnI0dGhlUE51NndrV3RnY3ZZWjZ5RjlqWlRKYnNlTlNDdTRBTk4vd0FkVnFlNmdJMDdPVUZHalpkT1NJanhrazE2NlFpQmRSY3Q5T0lGVG95bmJZZnkxSWlSaTFEdWRJWXhhNEJIWFRqR3N5clRycERHU2xTSzFINGFRakZ5bzBoelVIQkpIOE5JWTlEVVBXdWtJeURWNmFRNXVCcnBEQ1Q5MUJlRHg1SklaR0VLeUNzYXNCV1RmZmoxUHRQcDAxcThiN2J4TlRGMC93RDhxLzBmWUM1TTlleHpSbEd5Qlp3TGhsVm1DeW9wSUErSFRycWNBQVk4QXVNQlladjZUeU8yUzR0SmlxeHZKUUl0eFgybHE5UGhvZkxNT0N6SENlcGw5M3ZIb3NONWhOSmF4Q0N3eUVhWFZzSTFvbTRDdng5UDFDdjU2aGh2dXFUejAyMjBLK240UVJDVlFwcTNDbnJ0dVRYVjRPTlhnY1ZyTmRwM2VMWkFsdDY4bU1aWFlVOUthb3pOcGVSZmhVMkw4KzNubE1WNWRUV2FscmE5eFYwdG4zbW9LbllxNEoySjI0L2xySnZoMjJUbnFiZE9WTlhXT25VNml4R1Zpem5qMFdQdUk0NU1qYVVMclQyc2hqOTlDZW01clNueDBUaXliMUhkQTJiSHN0SzZNbXoyOTlqV3NMYTFNcnl3eHRleDI3UFV6TkFmZlZ6V3A3WmVncnYvQUExWVVRSW5sRGo5ejZlWkh0OHJLa3Jka2NXWjVLQnUzMUo5akJhamJyWFdIeTdldlE2ZmdVYm9teVg0ampMZkhlUDNXWHNUTk9zRnpKYlNGUUk0VmloNEdPVmFEYzdjbVB1NThqdHFibzdZNWdwZVRibTJzSjVhMytsdWxqdFVWY1hsSVJORWFmcExLSDRqalVtbFExQjZheE05ZGx2STNlTmZmVHpxVUw5K1B0eEprTUErWnNyWGpjMlA3N1VYaWUyUlJoVGZiYmxyUjl1NUxwazJ2cFlDOTA0MWMyR2EvdXFjKytKZVVaYkFYMW91TG1OdmZQSUJKTUl4S3l3eGdua2diMjgvZHdYbHR1TmRkQ3NqZ25LTHo4NyszVWYzRysyZVE4bHgrWHlXZjhrd0kvdVZzMTlNcE1sbzBmZHU0NG9ZZ2lBTkdGbVZndkl0RzQxYmhpM3BHc1BQMndsd1gzZSswT1B5Rm5ZMjF2NW40WkZManIwMnNTUVBKQzhZL2MvYlVBZDJOUS9Jai9tSzJpTW1OWnNleXo2OVBKcitZRHhNL3dEaThxSCsyNHllSVIzMWhhU3d6eExMaDhwQ1ZrU3A1S0hBSzhWSkFKK0kyMXh0cTZ4NEhkMWUzVXk4cXVud0tSVytMVTIrT1ZaSlJ3b09DSXRHQ3JRZWdyMS8yYUF5UGQ2VWFXQ3FhM05GTitQekM2eG1aczNna3M3bVoxdXNRWVZZTVVhVUhrc2g0a2tjZ0crWm9OYTlWRFdzbUZtOVRiaU5TSmgrRnBkbXp5ckMya3lwZHJDWnBHblZRa3hqQ3pFMVlEMnFkL2NOVHV0QWVyTS91RDVBM2pPR3VjbFpEdFdGekRFdGlIUGRXV1ZHQ3NxVUlwVmdhMTlCMDAyREVzbGtoOHVSMHBKVXZodUlPUXpGMWs4ckw5UmtWWHVKSWZlZ240OHlxK20zNmR0YUhJdnRyQ00vajQ5OXBzTXkzY2x4Y0xEWUJvQmMxZ1VYRHF6bTVoSkxrRWdBOG1QL0FNZE5VclJhaGJmcWhHVElKMml0NWlzYVRuZ2swWkJFY29Cb0RUYmlkVnZRSnh6MFpsRGliMlF2RWVMSkdwRWhSZVJJL1BjSFZUY0J5cnVOQXRKOGZMKzZuY2hjamx6Qlg5ZTZ0dlNnTk4vbnFMdEpPdU5wOUFSNXJoQmxzSTk3QkJ4dkxBQmw0Q2dhUHF3cjZuMTBSeGN1MjBQb3dQM0RpN3NlNWRhbFNxekNqRURmY0VlaEI5TmJKeXhlL3dCdXBENWRoKzZicU9QSTJSRU4wa3JCR2M4U1VZVjJQSUExK2V1YzV0Rml2NU03YjJiTTgxZHJldFJ1VEQzc05TWDdjeXRWbyswSFVlZy9VRDhkWU44OFBwb2R4aTRTdFdaaC9BNTliTzJGdkswYUNSWkVKQkNDaWxoNkdwNlYrV3U4MWFQRjVVZzZXOXU3eEpvcjVxeVUvYUZBQnhZMTJwK0dsQzdEejRnT2FObzJvUnNkd2RXSnlVdEdkdktGSlJpZURkUjh4cDJNV0w0dGt4TFlFYzZYMW9lUEUvMXhOUVU2anBySDVXT0xlVE9yOXU1S3RpYWZXdjVvYnNObjU3VzVFY0xDRnBnMGZiZHlCeXFHM1VFZW8yUHgvam9ETHgxWmFtcHgrYnN2b1dEQm40SUlaWlluamd5REtaS2N5QklsSzdBSDRHcDYvaHJJL3dBZHQrS09udHpsR3NLMzZnbks1N0ltQ0dXMDVJa2c1T1FoQjQxSUFQSFlpZ0ZkdEU0c05aMUFlUnpidXNvRlczbE9RN0l1cmlQakJFVlNKaVRzRnExYWtnanB0cSszR3JNSUNYUHZ0M05hZEN3UERmdVhJOTE5TGZSY0FpQlk1QUtraDZFNzlkcVZHL1hXZnlPSHRVb053OHhaYlJaZk11aTJ2a3VVVzl0bVFDbkl5cUdYbFQxVWo1ZWgxaTVQTmRDNTE3QnpFNXhqeXQ1Q29kdjBzd1BPbldwT3FzZDViVFFMbTQvZEE3eW55RnNaaWJ5NVc0QmRFY2xTdTFOOXdUOE5TVTJjRnZHd0oyVXJSYW5MOG1BWEo0YWZ5Qzh1bFhLenlSNWhVdUtvdjl1RFR3UmxGSzhKQTdvWlBldzZkTndkZGxqYXgxMnJwMCtaejNLeVBObjNUNS9KZmlTdC9KSk1oNXhlVzJjbnVVZTl1cksxVzhkNTRsaVEyTEcyVXpLU0JDQ3NhY1Flb29SWFduU01LMngzZjUvcVl2MjdacHN2S2ZEVDlKTlZnNlJabVNEQzIvWTUyYlhFRUtTQjE1TVQzT1FhbSsrd3JXZ3BxTjlhVFo5dzNDNHlSalVlbVZyOVRXOTA0RnRhTkdPekZCOUs5MHZ2Vk8rL0lzblQrbEtDdnhydHFTcXRYNTlQZ1FkM0tYWktKK0w3RERZTEZrSW51NUFWanlzZ1dHZWNzWkFzWlZRdEFObFBFQWIvQU9HaGJ0MWhmN1RTeFZXUk8zYS9kbGtZUUZsaHU1QUpiNExKRTdJcFNrMDFmZXc2MENKeHFQWDVheWNyaWZBM3NhMFU2czJQSmUvV1MyMHcvd0NobUVVb21KTE1PM0d5eTBBRkF2S0lFZkxmVE5MYW11d3FXdHVhZlRRT1lhQ1pNNUxBSWw3bDQ4Y2tUTUZkbGpFclBJMVRVYmhWMk85RHFqSkd3ZzVkbjhSL25zYlh5TEFYR0N2MTcrS3lrVDJra2Jyc2ozS2lKSkFTRFRpekNWVDhWR3NPMlcyTE5XeS90MVJaeWNOYjRyTHBLS1ArMEYvZCtXWTN5ejdVZVVYQlRPSkZlVzZtYXRXN2lHTGthLzVabGphdnpycm9QZE1kY1ZzWEt4L3QwZjQrUnpmSDVGODFMNGNuN2xwOGZNaWVQeXl5WWkxRTZHTzRoVTIxeEdTQ1ZsdG1NVGlvNis1VHJyVlpXU2E2TXdMTGEybjJES05RZkxUaWszTEllaS94MUVlVGVrZzJyMTBoeVZIY1VwUTZhQkUyTzlYYmZjYWFCRTZLNjVVMzAwRXBKOFV0U0NEcGg1Q2NkMDVVVTFFY21RWHhVRU1ldWtPU1Z2OEFpZHFhWWM5bHlRY0FNZW1sQXBJODJScXZFR21uZ1VrRjd3QWs4dC9ocFFOSU51cmxuYnJYNGFVQ05VVEV0WDEwaHBGSDdxMzg5dDRkY3BFRWI2cVNPM2RYSXJ4TldxdGZVRlJ1Tk91cUs3L0NUbVM2bU1LeGlUMmh1VGtlZzVIMC9oclNSbVdNY2ptN0M5ZEpaWXVNNFJZM2tqcFJ1UDhBV1I4YWFkS0NGbW1lNE8wdC9JZklNWmhNY3NobXlGMURBT1ZPc2pxcE8ycE95U2I4QnFVZDdLcTd1RDlNNTRFeE9CdHJDRUJJbzBLb0IwQ3hnS1A1RFhsL0l1N1A0dHM5TndVVzZQQkpGVytSenlIQVpBUWdOUE5OQ3FLVFFWNWtmblFLVHBzRlU3cWVoMGlkcXVhcVh0WnpYNTc5dmZLWU1sUGZ3dEhjd1hCN3RWckd5QnY2U0RVVUg0NjdYaWM3RTZwUFE4Mzl5OW41Tkx1eWl5ZXVoQXhWNWtzWlp4NDdJeDk2M2pYaWhwUmxId0JIV21qTFdyZHlqSXBTK05SWkZwK0VHS0N4dXJoQUZodDdHTnVKMm8wd2VZN0QvaTBUYWRvSi9jYy9lVCtNMm4xRXQ0a25hbXVKSGNSazFEc3pWTksvanZwc2Q1aEVjdFlJTm54dFlWZ2pUdU5RbWlpcEo2N0RWdHA3RktZRGt2TGczRWp1eFZ5YThUMUh5cHF3WTJHNmduV2x4R0NmODFOeDg5TUkwQzN0cDVsUzM1VXI3Z2ZoWDQ2WVF6SjJyU0FuY0pFS2tMNjA2RFVQM0tVV1JBcHozY3N0dzg3a3E3R29Id0hvTlNJRXUyemQxYlU2U3FPaXYvNGpmU0VNK0I4MnVMQzVXNHNMbTR4dCtLQlo3ZHlwUHlKVWpiOGRSZFV5ZGJORmt3L2NtOHlNWnR2SzhkYjUyMVlVZVVnUVhBcjZoMEhFbjhWMURhK3pMazFicWl3dkZyUC9BRTVlZVcxcDRuUFpTWWJ5S2NtTzBrbUxSWEVrcDNJV2VPcVA4Z3cvTFRyTGJvMW9RZEt2b3lMbXY5TnZtWGlWMjJiKzNlZGtJaE5VcEtiVzVHK3c3c1h0Yi8xZ0RWbnBzUjIycjBJK1ArOUgzbjhkbHZQR2Z1RmJyQllDUGxObUwyQlV1a2pxRlBiZUk5dVZuSHRCSyt0ZFYycEhSazFlZXFFLzdmV21KeW5tS1hWOTVVdmptRnlqVG0rdm1kQXJ5U0l4U0lySUdqSkxFVUxqWURUSnIrNUQyci90WmVSOEErN2ZpMWtML3dBVXlObjVqZ2pVeGl4a1cxbVpQbEVlZHM5YWI4QWhQeDBvcGJveGJyTHFSTWY5MTdLenlDV3ZrdUlreGVmZ1A3VWJvYks3RGtjU0VndUNZNUsxcCsxTS9MNGFyeVlacTYyVXBsMU03cFpOT0dpeGJUTDRqeUMvdytVc3IrM2E0c0pIbUVVc1hadUhTVUtzaU5HNFVxVjRWQkM5UnJKeGUyNDhOYnFrcmV1bmFUVHZ6N1pYVjJqMHNuZVNzOGszajEzajdpU00yV1Jqa25Zd3NTc2JJNmgyWDRLVDFyVGZXUjdkN2Zsd1pMNzF1VHEvZ2FYSzVsTWxQUzRjbzArVjI5b3QzNDIyUnRtWllNdktrWmk1a2lwZHlDRTNPNkkxUFhpZlRRWHN5dE9TcTcxWVh6dHUydG4xVHFKbjNhdEo0ZkhiNVlJUmQyNXRNbmIzRWRTR2RwcmRXRG9GQnJ4N1ROK0kwUi8xeS9ydXUraEgzNnplS3JmUTV0OEN4R091L0UvTXJhOGxXRTMrSlYxZW9YOSswWXp4a2ZNc2dYODlkbjl6MU5NNUsyTmZiVExZL3dCS3N2SEtXdG9YWnhjV3VSdENYNmtVRWdyK0FYVmQ5TGxsWHV4QUhPNUc3UDNpOHU4T0VDY2J1QzdmOTVlYVN3WE5vdHc2NzBwVU1kNjlkSjBkVTdKaXgzKzQxamFQVSsyZUd0WTdtMHdFbHhpOHRsSUk1Y2ZsSWc4cXdTMjBxbHh5VWhsUjFiaTIrczdCN2kzUzFycWRwdTg3Mld0TXRLWW5EdjQ5RHhiUDdsZUU0Njh2TWhFTXdMT1dFdW1LV3JTV2szY1UzREp3S0hpeVVibkJ5RlI3dDY2S3hac0hLcEs2ZE5UTnlZdVh3TWtkL3dEeDErWXhZSDdwWVRNUVFUWkNCclpia3ZGRE1WRnM3U1IwNUFSeXYyM0sxMzdjMWY4QWQxbjUvYUZFMGNHL3d2OEF0RjZ3c3EzZWZjS1plM3hGMDF2ZTQ2OFc1ajd6Qzd0Z0dXWkE4ZGF5UXVGZFJWZXBXbnowSGp3NXFTclZOTEp5K05udFcxYmZGR3BQSDdISTIvT3paWFdJZnR0K29NQ3hGQlRvUm9WNXJWZXBwVTR1TzllekF0OTRhclMzRWNrWWFPU01xRXBWUVFEdUJUY2c2Sng4MXFETjVQdFZXbTQ3ZlEyd1dnOGwrejFpa3k4NThOa1RCSXAzSWl1NGpHd1AvcmdHdWh5NU5sZHh3L0h3ZmR5YkNpL0svRGppN3FLZkgya2p3c0NIalFGaHpydDBPdzFQajhsWFdySytad2I0TGFMUVdyNjB5c05HbWdZeDFvV2o5d1g1RURwb3ROTXpYVnJzRGx1QlhpUGNUUWdmK05kUEJHUWpaelNXN2lWanNmWDlKL0krbWtJMlMzTGlkbUhOVS84QWJESDNjZngwaHdqWVptOUpLaDJraEh1azNvVlVkZmtkTkNKYm1QM2puM1B6V0Jna3RNZGtaRml1cWQ1UVF6b0FmL2JEVjRzUi9VTlVYd1ZzRVU1RnFxQzN2RS92SGpyYkF5UlhOdmN6NUdKMmFLMkVwbkppNGc4bWxtTlFBYTFyMDBKYkhaT0VnMm5JVHJMZW80WUQ3aFluTzJQMUZ6SkZqN3hYTWNsdEpNakFqcUpFWUgzUmtmMWROTmFzT0NkYzFXRnJtN0MxRmQ5UkxwQjgxeUdRZ244dE9SQkUwd0pORCtPbkdJclRVOWZ4MDhDTlluL2pweGpaOVF3TlJwREh4bjViazZRNTZKQWR6cENNK1kwaHpOSENuVERTU0VrK0Iwb0hFcjduMnNzK0lndm9oelcxWmtrUTFJQWxIdFlnRVZvUlRmV3p3TVZjdUxKVmZ2cjYxNXBhV1h5Ni9VQjVVNlBzYzR6V1VseGsyVXpjdzlTOHBBUmFMdUFvNkFBL2xxRGNBS1BYeGJaT1VXSW1qV1dRc1ZaRkpBcDcrUklwVW5WTHRHcE90ZDJoWm1Wc204NisxY3lRUlBlK1IrSHR3a2tPejlwQU9ZTmYxVlFjcURmYlE5ZlJmeVlSZGJxZWFLUnh2aStkenIvOUZiTVlnUnluYmFOYS9FbmIxNmFKZGxYcURWcGEzUWQ4RDQ3WitNeHlYbDVrYVNJNnd6eTJzVFR1anNLaEZBSDZqLzhBQjBOZSsvUklJcFRhNWJHKzR6MXhaMjJOdGZIWWZwemV6UEZQZDVFczkzYnVLT0tKL3dBc05JUGN2WDhkQ3Fpcy9WMjhBemZ0WHA3K1A0N25TLzI4OGlOMElDMHdSYjVVak1vRlFKd0txRHYwWWtxQi92YXJxdHQ1K3BQZHZwdGZXdlF0VE15bkpSUVU1UXkyMXJKY1A3aWhjVkM4UVJ1dk1CdC9RalYrUnBWbGxPTk4yaGRSRnU3UzNrOGV2YnFBOEh0TG0zc2JPdEdISzRsNHpFUFNxa0szRVUzcWE2NTZ0NjVieXpyYjF0aFNvdkNTMkxQeDYyeDNqMXA0L2JoVXMxdDRveDZzZTNRQVVyV3BBM0pPdHpZdHNlSnk5c2pkdDNlUll0N0c3bngxL2pKMmtoZkRTZzI4Um9SSUF2TlFqVUo0OFR3RkJYYjhOWWZJdzlhczM4R2RTckpkUUhtUmJYb2x0VlVTMjF6SFdSWkZweVFnVkRFL0VIcHJGdGFMUW4wTnpGWFQxSTRJODJ4VUhpWDNEekdQczM3dU1zNXphS1JYWVNxc3BTcC9xVGtGUHpHdS93Q0hrZDhOYlBxMGVmOEF1R0pVejJyWG9tWHo5alBQNWJPSCt5eTNLS0xSbnU3UHU5c1JtTnFkMVNaQVFGUmp6cDE0U2tEcG9oNlczQVBWUVZKOXc4ZXYyOSs1ZmszalhqTjNQWitQNUYxa2d0K1VrU0l0d29tU0dRQWdTTEM3bU1FMUJHNDY2S3kzVjNLNzlmajNLa282bCtmWlh6MmZ5anhlUzB2bkF6dU5rV0M0UUJ1NDlBYXRYb1BkdnVQalRycm1PYmkrMjVYUm5UY0ROOTFLcjZvbitaUjUvTmVQWE0rTnRaTGJLdkZKYjQrS2ZkRlc0WUtaSEtBdldsU0RRL2xyT3gxb3Npbm9iRjdYZUd5cjFJUThmZ3VZcjZLMkIrcXg5dXQ3aTdHTGl0Yjl4U1NQL015dXNRZWgySFhSS3llcjR1UGtCV3hPSTh2ekY3RmVQeVpjUzNycVVtdHNlODRhVmVTcTBob2toUHB6WTdHblgrT2psMDFNZm95bi91VGtyZko1ckJZMlFFNCszZTV1SEVnQUpNWUhKZUovU0twK25SZkZydHJaZy9KdExTWnY4TnR6YTI1a2dlTkxocXREQzhmTVNTU1ZKVWRRS0tHTkNLZlBWR2Q3dXBmaFcxSmt1MXg2WlhNUXdJN3BiMzZUVFJKSFFGTHFBQWtia0FCbHJzVDY2alcrMnMrSDZGdHF6WmVER2pNeG4rM2kvbHRZK01ISzF2bnRVcktza1pxa2l4cnNRby9WUStwR2cwNXRDWnV1aWVQZEh4Q1hqRC8zeUtLY1FxdDFKRThNcmdtS2pmME1ZeUFhbnBxT1JiZE94ZnhZdnIrUG9hbjhIdTVoSkZjU3UxbEVWV0daU3BwRkp5OWhEbmNvM0VpcDNYVlR6S3FrdmZGdGZSZmhHL0YybHRkV2xqRE5GS2I2R0dUNjZPNVpWaGthTW4yeEtsU0ZDMEo3aDNyVWFweVo5cjlJUmg0dHJhWC9BQjRuUEhuM2l0eDQxblpZdnBqQlkzL0s2c0Fkd0krUkRLRDhGTzM0VTExUEZ6ckxqVDc5emdmY3VJK1BsYWpSNm95KzJuazBmalBsbGxjM3AvOEF1VmR0OUhrQXhJUVJUZTNtYWY1Q2VXb2M3ai9leE9xNjlWOFJ2YmVYL2paMWZ0MGZ3T3pZclcxU1R1RzJFdHR4VXJjclI0MldtekJneERpblExT3ZPODJPemNOd3oxM0hsVnFKMGVqT0JKbVdSRW0vOTJuR1VIMUk2TitZMTZlZUpzKytwZHloWTE0RGlCOHRLQlNiNVZXYTNLamVRR3FIMXA2NlpkUjJEcUZTSy9qcXdyQzJNdlh0THRab3QwWUFPdS9RK241YXJ0VGNvTHNXUjBjajdpTHd6WFN6Qm1hN1lVaVVjZjFINDl6MXA4TnhyT3lVaFFhMkhOTnA3aHl6dXZxejNybWpkbGVLZW9WVkg5Uk85VDByb0M5ZHVpN20xanlPN1RmWXpueTE1SGJreFJrd0llMmc1QmlHMlBUYW9IeHJwMWlxMmhXNUZxcHd0T2hJdFJiUzI0bGxaU3JOUjRXVTFvcWd1VkZLamNrZlBUT1V4VTIyUXdlTDJObXQyanBiTkhCVWdEZ3hkV08zSHB0OGQ5RFpuYmIxMURlTnNWa28wT2kvRWJaUHBVbmhUZzdVWlF4WlRRZ1ZvUDhBYnJuTFR1Ti9QWlJwMEhJUjI1dTBMQ3R5VWJkVjlvVVVHNTlhNlpKUzMzTTV0N2ZJcVA3NCtRZHFHTEJZeVJJV25BV1hoVU93S2w1RDZiS29MSFYvQ29zbVYyalJCRHQ5bmp1emZxdG92NkZBMkhrZVh5bHdKc2dZL3dDMTJpM05wQ0ZUM3hGSUl4R0N3NWV5S0ZkZ2RnYS9FNjZuSmpyV3NMcTRaelBGZHZ1TzcvYXR5L0wrUU55dU9zN1BOUzJ6eXBGYXhXc1YxZlNNd0x1bHpJSkNudEFVVjVxdnRIb050OVRwZDJwUGVZWHkwRmZIU21WcHVGQ2I4NWMvbVJyQzMvNkxMNUJlUzVHT014RWNsRkd1TGlnS2tWNWNVV2pVMDkzclZkdjZDdzA5TjdMOTNUNnYrQnA4ajdJeDF0WVJwUzZ0b1ZFMFNrQ2pORXhhclZxd0FPMUQvSFU4Q2JzN2RtVTh1RlJVL3VYWDZEWExpUkhpY1BpTGVWcmo2aWNxMHZjM2FPMUxIbkdVcDdhRGlkdW9xTkIvYzlkcmREV2VHTWRLZGZQNGVBKytOUlRISXpSUk1VdWJraEhPNWthT1JlWTVMdHc3UzhSK2VzN05EUnI0dEhCdHZ4Mzh1NjQ1cVFKSEUwQ1VDcktJWXpESnhBQTJERDMrdnUxVW42WmZpV1BSdElhOEhqclIrTnlPU3JKR3h0cEdBWm1WUFp6SXFXRktFa2V0TkM1YmFRaHFWWFZqYlpMSmVZNUZ0bkhCSEhkaUZDcUh0cTZpbzM2SGJXRnlxdFhRUW5YdjRITlhsdVRrd1A4QXFUdE1sNHlrazEvRXRzK1d0NEtSN20zQW5vZVFyKzF4ZHEwOTJ1MjRPUDczdHJyZlJPZHY4UHpPRjVUV0wzQlIvd0RxWHg2L2xxRjRwb1g4ejh0eGVPUm1zNDd4TWhhRWdpc2Q5R0hjcUNBZVBjRGZ4MXBlM3F5NDFGYnFsSDA2QW5NZGZ2Mmp4bjZoVHR6RFprSS9FYU9CVExpeURwcERHYXQ4djQ2WVJsM0I2NlFqWXM0WDEvaHBDSmNWMlFRUnNOTkJLUWhGZWlsUTJtZ2VTUkhrYUg5UjBvSGttUjVLTmdPVGU3VFFQSnQvdUNEbzFmblhTZ1NaZytRQi9xcjhLNllVbW81R3UxZFBBcE1EZW40L3gwb0drMS9VRnZjVHBRS1ROYnBRZXRmdzBvRkpWLzN3eWR0L2JjWllrdXN6UExOeVUrM2h4QzBwV3RhNmZIWDEvSXF5TlJxVVRlV0Yza3BXanMvNkkrU3diY2lxZ1ZwOFQ2NlBiZ3pvYjBRdXNqcDdXRkNOdDlTS3k1djlMdmpKei8zWnhzOGlFMjJKamt2cERUWU1vNEpYL3dCVGpXZjdqayszeDdlZW4xTlAyekh2NUZYL0FMZGZvZDFlWDNYWmlDSnNxUkhrUG0ydlBNa3RubzNBcHVldmlWZDVKS1lzYlkyd3J6bW1FalY2dHdRbXUzemtHcFkxcWRMeC93QjlyZUNJK1l0eEpEeDRLZTJsQ056eTQ3SHJvN0M5WU0vbFMxUFVRczE0M2JUd3M4VVFXVGp5Rk52VDVhT3BsdFJyVXhzbUxIbVhRd2hwanNSbTRFNklSYkt3M3FZMGppcDhxRWE2MXY4QTR6eml5bksxNWxYK1I0SEk1Q3lTTzBTTnJxSjZnU2UwZ0VVSVUvSFFXSGxWVDFOSGtlMzVIWFJhb1djUmdyKzNua2UraE1SUTBSVHZYNGtFVjFvUE5WclF5Rmd0VitwUUZwY1JhWEljWE1DUHlIOVEzL0k5UnFsWkdpMTQweGZ2dkRZMll5V2NuYmdvV1pUVnFINGl2cCtlcmFaWjBaUmJFMTBBVm5hQzFtZmt5c1FhSzNRSDVnYXZLSlBMKy9DdUlZalFLUVdyWGMrbWtQSkhhNnQ1RlBmUlQ2VkFxYWZMVERFV2FPMEk1UU9lVmRrTytrT0ZzVFpvcWlWeDBJNDE5VzlUL3dDR21ZNmVwR3llVWsrbzdkbzVSSWp1NmtnbHYvTFRJazNJd2VFZVd6NGpMUTVtVm9wY2hqdmRaTE9ObUxWREFnVXJVZm5wbjVEMGFUbG5hZjIrKzR3ODd4VUYvWk0xcmtJaEhCbExHWDN5UXVSeFNTTjFLYzRaS2NUeTl5dDFycW1ZYlRDRjBrODgwOFB0L0krVnI1RlkvVXdQSXNmZlZ3c3FBKzBDaDQwcFdvOXRQaWRTcXhyS2VvSW0vd0JMZjIxdC9IbGh1TCs4dE1sTEw3Y24zb3dna2NrSkUwWjVSbWxRdXhxVHFielZYWWg5bGlUTDludnZYOXBycDcvd0RNejNGaXA1TEhaemRvdXE3MWUxbUpqYXYveTBvcGNqRnFrTzQrL3ZsZmtGcmY4QWhYM0Q4VXNaTWp3SmZNWGxxWVdoQUlETzBFb1pTMVAwbENCWGVtbWRMTG85Q1N1bjFRRSszSGpHVzhqOG1hd3gvbDBGbGlMaUtlNTUzUVdlQXlqZU5QcDVHRkN4SS9RYWdDbzAyNnY5MmcreDluS0xmbHMvdjU0RXIzRWRwSDVKaUVqYVZKYlNRM1Nkb2pvc2R3WTdxUHBzTzVLUGdOTjlxdHRVeHQxbDFDK0QrOEhqWGs2UTQvSmQrMXZyS1ZibFVnTWtyd3p3ajlUd0ZWbVFnRWdsb2VQek9oYmNaS3pjZG9ERnliTkpTTlhrbU90L09jTjNzQk5DOXpXVmxlT1gyY2JtQ1NJMC93RHJSZ0MzcHJMNFB0eTQyWjJxL1RaZEdhSEs1LzM4VzFyVkhNM2pIZzJiOGJueUdFOHF3OXhiUFBqYjYxWGFzTW5zTERoS2daU1RUMi9QVzFzYXZQWmdEc3JZVXU2Q1ArbXZJUjJQbFdJZDI0cXQ4OFRrOU9OeEFWOVBtZExOKzVGZkgxeHRCYjdpTFo0TC9VVmo4dGNveHRyeXpoTDhWTEdTTXFiY2hWSFdxeG1tbHVoTk1XcWFZOTQyQ05Hd01WT1hmZTVzNEdZZTRpVzNka3I4RFZWUHkxeStDdTYyU2k4R2Q5ejc3S1lNbHVxYUd2R1lXMWJQWXJKdEdvdVpNYmNvamdOeUxSTEhKUUFHZ0lFMG5wLzVZK0hMYi9HelUvMnd4dVZhditWUzNmVkM3bnZ0bmkvTXNqbHNYbjdWRGp3c0dTc094enQ3cU80dUZGdktSSXRVSmJzTlVNcmN0dlVhUHdlNTVNUENyYXJscHc1MWt6YzN0K0xOeWJLNjlMV20zU0dWYmwvdHY1UmpyYWQvQVp2cUkvR0paYkMveHVTVmtlZGxtY3hUUXV3QzhqR1J6RWJvZWhHeDEwdGZjY2V5anllbjdpK1J6cjl0eXUxbGk5V3o2a2FMN2g1THhMSjIrSHpOcTZ5WGNVRTl0TVlXbWhtTnlnYjl1UlFaUVFUeE5SS2FqZlZ1YmhZODJ2ZnlMT0w3dG40dW5id1pZT0U4MzhleXA1VDNTMmhQSlorNlZhQXlsdW5kV3FvUjBwSndQeTF6L0k5dHlZOWErcEhZOFQzL0FBWlZ0eWVsL2tSdkE0cmVPYno3dytkR2EzN291TFdSQVpJd1RjSk5DM0lmMHR5WlF3cU5iTjkxdUw1d2NwUzFhYzdSK25kMStJTDhqOGRhMU1wanBKR3AvcUJBQVBweUExeldEUDJPOTVIRlRVb1JMN0NoeEtxUjhFSnJ6cHVDUG1QVFczaTVQVFU1VGtjQ1pVRmZabncrOStvRTlwREdlWkN6UFduRWduM1VwNmpycll4OGlyV3B6T2JoM3E5RUx1V3dlU3NmY3dNMElxQUVGQ0Q4eDY2SXJrVmdPK0sxZW9LdHUvT09wV0JENzNZZnBGZDZEVnBVVG55OE5xSkxLeEk3SmIzTTZqazNwVWs2akE4a1Jad3Z1RGRDTndmWFNnVWhiRzNreWw1Skdic0xRczI1M0hvZjRhWWRNYWNKNWc5bGNKY3hKR0owSENONTE1QlJXcDl1d2F2KzlYOE5WMnBLTGE1SUxKeDMzVHlkejJJcEpZN2FLQUtzY2FSVkV0UFNUOVJDQVVBSzAwTzhNRjZ6UHhIMnk4b3gyWWthS3hrWjM5M0JTamU3aHV3RzNwODZhcTJ0QlZjeWJnMlRYUitISHJTdW1MU0s5MVdwNWROU0dOUXVIQnFPbWtJMkxjbjQ3ZkRUaU5xM0RhWVVtWXVUV25wNmFRamNrNG9DVHBDazlhNUErSHlHa0k4K3JOVHZUVFFQSkh2MVhKV1Z4WlNzUWs4Ykt4QUxFVTNCb090Q05hSHQ5M1RQVnBOOVUwdXJUVFQvQUNLYzFkMUdqbTNQRCsxNVZ5bzR5OFc0eEhweEh4L0dtcmNpVXRWY3FkRE1XblVoWUMvTjE1WGJ5QlFrTE8zQlJVTDBJSDVhR3lMMHNzeHYxb3NuN1ZYbVB0L052STdESTNMVzl2TmN4WEVkR0M4cGxlaXJUZXZMa1ZJOVJxbHFhSmx0ZEx0QzdtUUxMN2haVHdyTHp2SGpXV2VIRE5icTNCWkpsTFFPc1lOQ1dyeDFaR2tvanVtMFBvZStEWWVlMEUwRjJyUlJTeUczdlJJdGVFcXNBc25FblprY0FFL0N1aHMrUk1KNDJKOXhvekdFdUxyRHp5OXRlMUd5cmNMMFpHUnYyNUZiME1iSGYvZEowRml6SlpOcHFjbkE5bTc2aC83WitVaDU1TVJkUFdkWkdBREQ5TXNCOXdKRzFRZHdSOGRFWmF3cE0zRmFMSFNxZVNaRzQ4ZUZ2RGFKTE54Vm9aNVhDbzZtcThCWCtvT0tuNERmV1RsNUwyN1B6T2o0M0NUeWZjN2RZTlBqZUVTNnk4L2pOL09ZN0tNdGZUcVFIQlMzSTRsWG9Obm9QblN1aCtKalR5UjJEUGNNNysxdlM5VDBMVHNMNk5tdVpKaVpqYkZsaWJweVVBT3A1YmJrZnoxdUt5WHlPU3NtTDBtWTcvazY0a3cvVHIyUTh4U3ZiRHVvZWhjanJTbEIxMWpaN3UyVHlOM2o0bFhEUGNXdktGc01TdDVscmtCTVphd1BlWFRSbjJBUUJubUErRk9KYitQdzFtWmNPNjZxdTdOZkR5SW8yK3lPUjg5NExlZVQrQ1czazBQT2ZLNWVXK3lkNHJweGtoeXZKN3U0dFF2V2pXekxMR0QxN1JwK29hNnltWDdkM1dOS3BMNWVQMU9VdGgrNWozVDZyTnY0UHcraFhYaFdYbnNjbmI4UUd1b0pGYU9LUTBEeUpVZHR2bElDMFIvNHErbXRONm1LMURMYisrbUtzdkxmR01QNXJoWUdCdG9ZNEpKS2t1MXF5MWdNbXg5OUZlTnVUMXFnMkhyWFJ4b3hXOFN1dnRwNXpONFA1WGp2Skc5OWpjbGJUTlFuOUpxUGEvd3F5Ny84UTAyZkVzdEd2b1dZTXJ4WFZrZGpXY2ozYUpjRC9xTWJPbkczdUkyby9BeHRJdkVVcDZnRDQ2NU82OGV4MmVPKzZHS2tzc3ZqZmtOcGM5a3JkZlFPalJFaWpwSHhsVnBDU1JRSG12eDNwcFZ0dXEwK3NsdDhhVmxaUFFFMzF6R3JtMmdtbFVYUUVqcVNZb0V0RVluZ1ZYb081KzJ2UlZBcU91dExqdmRYVXcrYmpWTDZkR2M0L2NYeDZXQ0JzK2p5U2ZTWktXRjR6VXNiZVpCT0c1ZXBCTEEveDFxWUxyOXZpWk9mRzJ0M2dITU5MZExhdzNtTDU5M2lHajl1NTVyc0tmQWo4dENaRjZvWVhpMVVvT2l5dHBjVmFOYVROOVhQS3dXUkVDeFFLRkJMRW5xVmZpdEI2RWpWSzBaZTNLTFA4VXdjczlvMXpOY0prWkdRcGVYUEVOSkpHdFYvNWJWQ3FHQkJLZzhxZGV1czNOYlkraDBudDcrNVNHK2g4OXBhK09TUlhNaFdheng1TXM4MHRlVWxoSVZWdGdCVm9INHN3OVZvZFMzNzFwMy9BQitaYmt3dkUvZy94OUE1bmZIOFhJNjU2MXVIY3hLdjB5Q1plMlZjMXJFckFnczFkMXBvWjJ0RUJ1T2xXMDM5UVMySG54d2U3V0Z1U1NKTjNFNU5JWTI1YzFQZEJUbUtCV1pTVFQ0ZGRWWmExckVoV0YydEtrUy91SjRQa3ZPZkYybGl0b2t5VnJ6dWJTUjNVM0RzcTFhSWtiVVplZytJMGJ3ZWRURmVHOUgrSk1uM1gyKy9JeHdrdDFkVjQvRDVuS01zTTZTT2txRldVa09yamlRdzJJSStJMTJLUE5XbW5ET3Yvc2g1SS9tdmg5bmpHdVVUSlltTk1WY1Iza3F4OTlWWXRDWWdUN2dGTkRzRFg0NjQzM1RnMis3dVhSNi9NOUE5ajl5eHJDcVcvZFU1QTQ3VXBycnpnaU0xVlA4QWhxWkFsVzB4RERmY2ROUmFIVEpOdFlKY00wc2xlTmZhQjAxRjJna3F5RnJhMGp0elZSeFVldncxVGE4aFZNY0REaTFobEo1QmFPVkRzNDlvSDRuUWVWd2EzR1NmekQzWWFPM1ZJaTRVbFl6R0J1VC9BRmJsVDE2K21ncGw2bXE4ZTJ1aFBqczdoTG1KQXhodCtRVnpKRDNHb0FOeUIvU1NlbW9iMDE0c3MreTl5N0w0QnUyeGh0aURCYkxMUEpUOXdFZ0JSVW1vTlJWUUtVOWRWTzg5V1hyRnQxcXRTei9Eb3Y3ZXBra0RpSkZNalMxNXQyeURSaUNUUTc5YWF6czk1ZWhvWWFiVjNMQXdPZmdaRmhsRUF1SlNmcHdaQUtnZTBrVTY3VStHczkwNndnckpWUXRRK2wvS1pHVW5zS213OVcvcUxVTlR0dC9QVkxTU2dyMktDaGZKTHkzOG92TS9tcnRKbDhldFp2N1FzOFlMcXNrbkV6ek1Ra2hiZ0FrWlFMN2xkcW1sZGEvRXh2R3FwZnV0NnZsMk0vM0hNckowL3RvbytmZC9McEJVMTVqOGppaFlSWmFGWkRMZTNSdTdDeENsdUxocGVhRkRSZjIzNUwvbEZCK0c5dXE3T1BCYXN3MVc2eDFuV2JPVWlkNXdzY25rMGw4aGk3TjlidGFRT3hQY2prdDFWUXFCdG1BS2ZEYXY0YXE0L3dEOGJYZzVDdVkvK2FmOTFXbDVORUMwdFVseDhWbmtFQzNYR0oxSlBGaEwzQmNjZ29OVkxCaUNmaU5TdGFMTjFKVnBORlcvWFQ5WlBjdk5ESERqY2RIQkVmcUxubERVVW1tbmhlQXlseVNLb0JDT08zOVRmSFVzVGVyOEVVNTYxVHI0MmFYelRVaDZLMFM0OHJzOG5ic28rbEV2ZnNVWm1TSlIzSGNEZWxBZnpLNkZkb3hOTTBkaWVldGsva08rQm5uc1RrSGpraVNha2M1YVNScFJKSEhHZ2IvbUFFTFFmMWI2enNrTkkxOGEydC9BaTJzZHdMaUlxZTdiZlJ5eC9TS3A3cnVseTlWaUFOQjNGNnMzcDAyMU43WWp2UDhBQXFUdHVYaEg4ZXc1MmJRb3pTMjdOYjJqUXlPM01nbGU0L2Nrb0ZQdDM1SUs5UGxvR3kzTFh4TGs5ckczeE80bWJFWDkxTEh3SnVTcUtRT1JBaVJCejRrZ2tjYVZydnJLNTlZMndOWFcwRlIzZjJ2L0FMZjl5TXg1YmMzc1Y3WjVpM2xTZXdramRaWVRjS2dJV1FOL1R4b0R0UUhYb1B0bXhjT2xiS2ROUER5WndmdUZiZjVkN0o5UnZMUWZxWkY1Y1FoZWc1RURmYzlUdnY4QWpveTluWjZncThlNUNudHJlWGRCdnFJZ2JjVzFPbWtNQzVTSTJJUFRUaUk3emIwR2tJMTh6V3ZMU0ViRXVHWGJscHhFaEx3Z2lwMDBDTi8xMVI3VHY2YWFCR0J2SjFOUTM4TlBBaklaUjBHN2FhQjVQRGt5L3dEVWRQQXhrbDkxcS9YMTBvRkptTWdRYUsxZEtCRWhyNWd1NTAwRG1DWHBCMmJTZ1VsVGZkL0l6WE9VczdReUliYUdFTUF0QzZ0SzN1RFUzcjdSUUhVc0ttelpWbG1DcUpzazFyY2R5RnlKa1BzSzdFZm5vd0FscGtSOHJjTVNTRUxNS0VsQlhxVFg4VHA1SXZVNjUvMFQrTzl5THlIeWFkYXZNOFZuQzMrNUVESTlQeks2d1BlTWs3YWZGblIrejQ0cmZKOHY1bDArWjVGWm5sUm1OV2RVWGYwM0oxeFU3bWVpOERGQ1h3RXpOaDdqeUhEWTlEWHR4Y3BnQlduY1pEL2dORTQxMVlkUnZhMmVYcVRON1htcUdkbmhpalViN2tubWZUclRycTJtaFRlR29ZRXY3YVg2cElDUURLNnJJbFI3U1NCdFRXamlhczBjOW1wYkZJbGlWNTRwb1E0SzVQTEVFRHB4a3VDMWY0RFhWNWRNVStSNTloVzdPbDQyL2lHc3BnWWttN2NTa00rd0lVMHFOY1hYSTBlc0xCUnJSUklzM09JQmtkR0I1Q2dxVFdocFgvRFIrUE80TW5rOEt0M0VBZTV3enBWbEZRRFhwdm82bkpUME1ETDdjMXFnVmZZNjVuczU0NGw5N293VlQ3UWRxVXFmbm91dVZTakx2eEx0T0VWNURnOHFMMUlMMjFlRk9yUFQya0E5QWVoMXFMTFJxWk1UN04wNGFHZDhSYVhNUWl1TFpaRUZBcThSdCtCNmpWTHlscXhDL2tQRExaMmRyQ1JvM3J0Ry91WCtQWFVxNVUrcEcySnJvTEl4elc5MjhNaksvQWxXZEswMjY3L0hWNlJRMlM3dS9GdkVJNEQ3bUZCVG9GQW9kS0NjNlFEVE5ES0tTSU92NmgxQTB4QXdsaXR3QTF2SVMxZjBIcU5LQjVMWSsySG1tV3dXUXRwa2tZV3pMOU5sa0c0bXRYSUJGTnFzT3EvN3dycUZxb3Z4MmIwT3RWODd4T1B4RTJSeWR4RStHdG9ETXNsd3BKRU96Y0JVdVNXQW9QZlhiUSs2QzlJNW8rNGYrb2FieWVQSVlxeXNyU1B4eThsVlliZUczN1U2UlF1R2prWnlhZHc4UldnNmJhblhHK3JaWGJLbm9rUWZEL3ZwNVZnRWp0Y1ZucGxzMXBYSFh4Nzl2UWVpcktTQi93Q2tqVHZGWHRvS3VaOUhxT2VVOCs4Vis0VnUxdjV0anBjZmR5ZXc1TEZIa2xEdDdvWElOUDhBaGI4dEpLMWZNbHRyWmVBYnczK25iN2MrUjRLRi9GZk96Y2VRdEl4S3NGQ3FUWGdyMjdjSlZvQlF1RDEwL3dCK25ScG9nOERYUTB1UDlSdjJsRENHU1RQNFMySUFpUXRrSU9LLy9tcENKbEZQOG1uV0tyMXFRMzJXakllVys5Tmg5dzhYMjg3NGxaWXpPWTJRTzJZbWpUdUk2SWFCR0tyS0dKM28xZngwelYxcE9oSldxKzBFL3dDejNqSG4vbDBtUWp4L2xVRnFiRkVreHh1ekk4anRJelZXS1dDUlo0MVVDcHB6WHBWTkwwZDlCMnJKbG1UK1ZmYzN3T043ZnpqeDVzeGhlUkRaQ05Gdm9peTlTYml5ajVMN2YvdjFwWDRuMTB2dE42MVlsa2ZkRWJ4MWZzem5NeGpmSVBHSkU4Wnl2MVNYSDAzSlk3YWE1allGVlV4bDRhbWpBclZHK1dvWHMvN2tXMGorMGpmZlB4dnlMTCtmK0orVzRYRlNYTnRqNElJcDNnNHlVS3p5c0hVS2ZjT0pOQ1BocUZhN2kxMlNVTUlaV3p0emhZSkxtTjNqdHIyMmxyYXEwWlh1U21NOFFEeUFLdlRqWDREWE5ZYTJyekxMcE1uWmNxOWNuQXBhWmFnY1pJTWhITjRWbGNmTkNoaXlFbVB1aGNCa0RSM1FOU0ZXbnU0UmxhZWhZZkRXZnd0cXlacVByYXIvQUNLZmNiTzFxMlhTVS9xUzdoelplZFkzR1NySUljemo3bTJnbENtUWZVMjF4OVFBeDJBNGc3MS96YXplSGhWK0JsVGV0YkovUWJMbWRlUlY5b1o4MW5iM25rUGxXRmtqSXVtdGJIS3F4Ry9QdHZIL0FJb21qTVZXK0ZTNy9zcy96SjR1UXNmSWE3TmZrVndjQWtIaHVVeGNOc2s5emEzRjJMWU1Ha1dPZXprcXRDM0lxZVBBZ2dqcjA2NjFjdWExYzJLOHdta21OaHdVdmd6VVNscDJpZnlFUFBmYmZ4YXhGbjVuYlhVK055ZVZiamQydHVaQkgzNzZHV1FTeFJ0UnlvWUJ1UElxZmdOdGEySG5YdHlMWXJKUXZxWVhJOXR4MDR0YzlXMDdkZkFYL3NMNVZrci9BTXR1TVJrMFNlSzdzYm0xc2lnN2RiaE9NOFpLS1JIK3VMWWhSdnJXdWtZVkxNdnJ5QkkxdUwwVkRSWEtNVVdsSDJxYSsyb3JUK1d2T3M5ZG1heThHZXg4UEo5M2owZmtJTTJGZVNka2VIaHozRW9vcXNWb1c1SzFQam9tbVR6Rmt4THBBczVQRHBESklWS0dOaUFIalBLT3BGUjh4bzJtWm1WZmpWYmJpQmJsd2RTN0NwaWNWZGYxeHNQaVBoclFyeW9Nako3Y20vSVJjdDRUY1NYYnpMTVV0cENUMlRzcEo5UVI4ZGErTGwxZFRtTS90OTYyZmdLT1Q4U3VyWm1hMllzaTlVZnFkcTdIMTBWWElyR2ZiRmF2VUJKT2ErNGhZeDFBMjFjVUUrREovdFBDSE1jYjBETC9BRW1ocU50TU9Tb0xweFdKQ0hqWWJnMElIL2dkTkFneEZrSmJLQ09ONnZHeHFtK3dBNmpiY2RkTVNrWmNINVRMYXlWaGtraEVpTkM3cEl5a0k0b1FDS2JINEhiVmRxU1NyYUMwTUg1bkhJYlcweVFNdGtyY3VUU3N6S2dGS1YrZndVZmdOQzNvMTBDNjVZMEhlUER3NWE2NVlLNmdsdFpFV1JWa2s0TW5QYmlWY0J1dTFTTkMvZVMwY3o4QTFWVDZNR3ZFOEVyd1NqakpHeFIxNjBaVFE2S0lIaE5PaDBoSGhrK0hUU2dSajM2Zmo4ZElSOGJnK2gwb0VZQzVZK3Awd2p4N2ducWQ5TUkxUGVTd0pKTXNwUmtSaUpBQ2VKNG1ob29KL2xvdmlVdmZOVlUxdE9uNmtNalNxNUtFeWlRVFpxVzd1VklnZmtYTWpFeXlHaDVON2lhZm5xOTlOVExKZU92UEhianlhenNzWkEzMG5IM1hMVjUxU05tSVg0Vk8yMnFMcXlxNUw4YnJ1UlBzYlA4QS91RE8zaFpFRnZjWTl4SE9wWU4zblVDdE9oL3luMGFoMVhWK2xJbTE2MlBIMzF4RW1XOFF3UDNBdEZFR1l3OGkyZVFkYWMxamM4b1habDIyWWY4QTJ0Tmh2S2diUFYxY24zaUZ4YmVSUGEzQVlkM0tRR1MvaFZTcUpkSlJaTnl6R3JqMzlCOHRaZk9UcFdWMk5yMjZ5dmVIM1E4WTIxaGE5dnNIa3dranpSVW1qSW9zc0JBVHVVWWJrZzcwcnZYV2UxTVhYVCtKcFdzcHRUdVZKZTQvSitNK2N6WTJ4aDdsN2JFenBEQ0dYdlcwVVpidUxWbTVsNHhROVBjcDF2cUxVbG5OVzlONFIwVjREbGNkblV0WnJodzlxNFU5cDYxVlhweUlCUHRjVUZDTjlxYXdlU2xTMnAwbkF2ZTZpaFlXRSt2dFB1WEdsOWR2ZVFHQ2EzdFM2cUVralpCSUZZTFE4bDl5MTFSeDF0eTZCbk9xcmNhWWo4ZFIra2ZoZU5hMnhNTVVyT3JDUVZYM1VOSzBJSHQxcDVMT3ZRNXpIWGRxTEluZ3Zid3o4VEhlM2MwdHo2TXFSd3QyNHlkaFQ5TmV1c2ExbGJWblIwVnFWanNWejkrYnhvdkdWczcyZHJXTHltN3Q4UGVwQVMzYnRLOSs4blNPbFFSYlJ5Y205Szc2TjRWTitSVy8ycWZuMkFPYmtWTVd4ZjNhZnpBc01keVpwOGZNUXMxNTJjZFBMSFF4TG5iRlJMaDc3aVNGNDNjQVNONmJOK2pVbmsydE5kcGZ5L3VYeTZvZDR0eTJ6NVQ1cjlyK2ZRNWUrNEhqaDhiOGxXOHRyZHJTd3lYY3VMYTFKcVlTSkdTUzNKL3pReUs4Si80YStvMXZZY2txUEE1N2s0bW5QaitwYm4ybnlOaDVIYVgzaldZdTVFc01sYTNEeFc5QzhabklEWENxb096OHUzZElRSy9ySHBxMjJtb0lsSlJ2bEdBdThCbXN0Z0dqNFR5T1lvNG1CNEFLNUxVNVVOVVA2TnR3ZFd6R3BXbFB4TDcvQU5QUDNDdDhsNDNMNGZtNUM5OWlWYVMxamtiOVZvd0FDcUtWNVIvcHJXdE5jOXo4V3krOWRMZnFkSjdkbTMxMlBxaXdMK2JINVcreDRsVXRkVzdyR0xzVjdUd1RPUkdEUWlsQXgyK1dzK2kraHIydEZZN29yRHl5K3ZzZmtickpLVEpCREpJSWJhVmVVVXFSTUNiYnBUaklGUExiYWxSb3pCcGFGMEJ1VlJXeFMrcURIaksybmsvamtkL2ZyQXlPazBOdGpvSXVDeDl4L3dCNGxaT1JhUS9xNmZvRlBYUzVOM1c4THNSOXZ3cDQ5ejFrcitYSDI5bDVCL2FzWkc5ckJqWlYrcVdad3F4R1pod1ZUWDlLaXRBZW5UUlZidTFOMXU1blpzVmNlVGJYb2duWVpGTEdjV00xejNaVDNUYjJpQUFva3JGNVZWZ0R5RE1PVysrK21kWjFSVnVod0YvSFBKejQ5bEk3Mlc0a0dJUkVsdklvT0xOL3pPMmVWS0VleDJxZC9UYlZHYkY5eXNkd25qNTNqc24yTG95bHBqUEk4R3VReEFpc1pJSmYraEV4YWNYYkJTc2tMMUFQN3k4azlvK2Z3MW00ZW11ak9xeXQycW9lN3ZNZmpTQ0I0QmlzRGtyQzFnZFZ1Y2hpM0gwOE56N1poWjNBYVNGNDFINm1FYXFDQ09vM08ycmJKcTN4S0taWXFrdTM0UVl2Y1hQRFp0YzM1Vm9FbzBTd3NZVVczZllGK1paU1RRVkFKMy9xK0FXWGpPMXBzelF4OGlGcEFCZ3RNVXQ4bGhQYnlTNDY5QWpnZTU1TUduTzdFQWtBRlNLYjlkaU9taXE0NjExU0kzek83MVp6RC9xSjhacy9GdlBYdU1mYmxMZkxRaTdNcGZtR25MRVNnYmUzanR0K2ZycnFPRGVjVVB0K2h3ZnZHTlZ6N2t2M2ZxVkhaM2Q1WTMwR1NzNVdodnJhVlpyYVpDUTZTUnR5VXJUb1FSbzFxVkRNVk9IS1BBcFA0NnJMWU0waUxHblhTa1cwbEpqb21DdXc5eFBRYlUrZW91NVlzU1pQU0VSQUpXcHFBRjJGUDltcTI1TDYxN0JHSzNidE1vUUZ6UUNocjEycWFWNmFvdFlPcmpoZVkwMmVDbXQ3T0I1SVN3TENXTnc1RFVwdXByUmR6VDVqUUdUT20yYkdIaVdxbG9XQzNqc2NWdEdGc0NaZTRpajNqa1hIdVpoVFlxQjZiNzExai9mYmY3anJiY09pcXZUclA0K1FWa3NEOUhFc3RacjUrTXNNa2FxeEpOZVRKWHAvNnV1cTYzMThoc21LSzY2djhkQ1RaZDFMcUc3dWJaYmV4bVZTSHBXUmhIUUZqc1J5M08xTlN0RFdqbGxOWlZ0VkNnZHJYKzMzMXRORUJKYlRYRWZCSllrYzhvb3dhcFFiMUlwWDEwRzVUVGFMYnBSNldFTVA0dFpYNXQ3d0Z4M0pGbFNOdjJwa01iYmtBaXBxQnRYcHExM2RkQUMwV1NKZWN2YlRBWXJONUdabmU2RWJ5R1FDaFk5c1VVSDBId08zNGFIdGplU0tydXdxbDlxM1BvdFNpY1hsNVk1TGJ4K09EKzZRU3FiZ3dGdTFGY1hsMEVkNC9lVTVGcEFVaWREVnRsb1E1MTBmMmxHN28xcDhFamtlUnladHRldmY1c2g0KzFOMWZSdGZWeGR3dGlaMlNjdXM4a2wwSVlFZGlvQ3VZZy9DcWowQWIzY3RTeldoYWVyWCt2NWhIQXBQVjdkRy9ycFB5RkxKMlhrSGpFdGxrc1RmQ1M1eFNORGZ4ZTZXSmpkenRFL2NxdnZqSUE1cXg5UjZhT3daYXR2VDkzOGpQNWZHdXFxSE8zcjgzMU4xNGJyNmFBOXo2N0xyS1IzTFFDWHVDSlpJaFZoVGp6K0ZlZytlaGtsTDdWOHpTdHUyclhkZnkxOFYrWkk4b3M4akRjWVlTOXY2L2hjUks4Nmd5aWNRTE1GUHJ4cHRSdmRWdncwMkIxaTNocDlDUExWNXAwM2EvR2V2MENtRFdOczVqVDMzVjdOWStRTE1yRjJkMmRmYUFSUUx1VzlLOWRVNUcxUzJuVVB3VnE4dE5lZzkyazMwOS9kV3QxSXRTdkVCeHZOVldpN2pmRTFrWDlKOU4vVFdjMUtsR3grMjBOLzFQdkd2Mzhpc005d1lvWVpwcmJ0ZEpCelJKRTkxQlZmY3dIWGNWNmpTeTZVMDZ0RmVPYjJjOUV4c1dGR241eHQ5VEdJbVI0NUtVbHQrWEdxS1JRZ3l0MUkvVHRvVmRKZWhPNzlTUTBlS1BHMWpMWjEvUTZ1eTlLSCtvbjhQWFdkbXgyeTJyVmRXNCtvMlcxY2N2c2tKR1J5VFhlUXVwdzFFa2tZclRZY2EwSDh0ZWkxcXExVlYwcW8raDU1a3U3M2RuM1o1RzNNZGR0SXJONFZkZ0QrZWtPYVo0bHBVa2Y3ZElZWHNwQ0ZVc09vMDRnSVczcWRTR1BoS1MzSFR3Tko3ek9tZ2FUd1NVOWRQQTU3My9ucFFLVDQzRlBYU2dhVFUweCtPblNGSnJFL3ozMUxhTkprdHpUYlRiUlNia3V5Q1BqcU8wZVRlTHhtb0NhRFRRT2JsbldnR21Ia3BQenU0RS9sR1NmdDlzd1NHTmxKcVAyd0VyK0pJcnF6RCswRnk5UlFmSFd0eGJDZUtYdDNJWWg0bjZFSGNGZmw4ZEVkd2VOQWJMYlBDRlp5S01LamVwcCtHcFFRUDBVLzAzZVBqeFQ3U1kyU1VGSjcyT1M5a1ArOWNJWkIvQmVJMXhYdVdYZm10L3dDT2gzUEF3dXVDbGU5dlY5WC9BQ0ltU3VCZDVaWW5MY0ZrYVFuMHBHRFg0MHJyQm90RDBERlRiUUJXYlRYdm5EeW9ESmNXbHBFeUlDVlVNM0pqeUNuMEIwWmpYbytZUG5hVGc5dk1ma3VMeE0wVFdxc0pYY2xsRVlMVVVucHVRYUgrV3JOcTZvRWVWcDlESE13ckF5eXl4QlBwVmFacFZVaFQyVTdsU1c5YURSZkVVNUVaM1B1L3RNcmJ4L25OZWVPUmtndTl4M20vOUVic1RUODlkWHkzR0ovQTg4NEMzY2l2eExRbmpTUlhCRlpSMEEyTyt1SGs5Y3hwUm9CWnNiRGNzenVwSGNQTHAxMkErZm9CcVN2QksxRmJxZ1plNEJvcEdNQUwwM0tIZmI0N2VtckZuOFNHVGd6clVEVFlrR29NZE9YOVA5SkZmaG91dVptUmw0aTdvSFRZaFpGa1FvUlFlMEgzVS9BL0RSTmM4UkptNU9JbW1vQTB1R3VVVHU4Q1Vyc1Yzb1I4ZEdyTXBpVER2d3JKU2xvYVZ4VXhYdXBHYXNHSU8zVDEvbnEzN3k2TW8veExOVEJXRjE0dm5yZTk3TXRuSkhGTTIweSsrTUwxNnIvdDFxMHpVc3VwaDVPUGtxNGFDallDRXhyRE5Dckl1d0xEcDhkUWVWQyswd2JlZUlXNTVHMWQ0U0R1Rzl5L3ozMU5XVEZiRzBCYnJHMmNkLzI3RnBIdGtBTFN2VDNIb2FVSFNvMVlWU0dNUGMvVDVyR3dSKzB5VFJLUU9uQXNBYS9IVVNTZXVoZVgrcDVraThlOEZkNjlpYUM4V1JVSkFiaEluRXRTbGFWTk5SYTliTEx2UTVrbmh0dVBLM2xMRWYwbjRmbnFSVUVNUGpsZGx1YmtmdC8rMnA5VDhUcENOOTk1RlBGY0ttUGs0Ung3TTQzRG44RDZhUTZiWFFJWTd6dTV0NUkydUVQSkNPTTBKNFNLQWZUZmI4aU5NMG1XMXl0RnkrSS82aS9NTWZBTElaSk16anoxc3NzZ21ZcjBvSGIzai82enFuN1hnNExWbVQ2b2w1bklmYno3azFoeTh0eDRya0pTWDcvQTNkcDNEOFNnN2dId3FwMUpPeTY2a1hXdHVnZXV2OU5VTStJdE05OXIvTWhrYm0yalV1ZTRyS0pTQVdNY3R1UThWVC9TNjExWnZ4MjBLL3QzV29OdHZ1ei9BS2lQdEhLSS9JTGViTTR1QUZXYStYNnVQZ052YmN3VWtYNWM5USt5bHJYVDRDM3Z2cVIvUC9QclR6aUMxeXFZeXo4VjhudmtpQVcxVkV2R1FVa2FTU2VOVVk4aUY0MUZScUc2eS9kcWl4S3I2YU1zM3dQeDM3bDVIdyswenZqM2tHTno5KzBsY3RnT1gwMXlGaUxCS1hVWmtVU2hkenpoRzUzSk9rbFJ2ckRGTmwya3d5UG1sOWdtYkdlZjRYSitQUjNmN1ltdjA1MkxNcERLUmR3RmtvR0grWWZnTko0KzhKL0FuWFBhSVRhRHNubDJKOGp3VnJpb0xlTzlhTEl3M2NWekJPSGlxbkpaT1pVcTNGMUpSaW9xQzFhYXlhZTNxbWY3bEhFcHlqU3k4OTVLSlhXcWpYNEQzbC9JNEwzSitNWlhGNUtKcmFQTGR1L2hsVmhJbHZmUmNITGdBRUt2RXFUV2xXVSttc0RoKzNaTVZzMU1xMHNudERzM0pyYlk2ZFNkbHJMSFEvZEh4NmNyTkprTW5qYjdHaTRqQktvWVdEcUpBTmlWVjNGVDBCR2hPRXJaT0Rrb24wZnpYaVdYYXBtVm1pdHZJTTdqL0JibnpGdktaTy9pamRXdDlpN1cwREM3bXVycUpnVXFSMjFUOXB1WEtnb0EyK3RDbGJjdmpZbGlYN1hEYjdSMVpkajVQK0xueVdzOUxLZmlVcGxMYnlIeVc2d2ZsbUxGeGRlT2VOV0Z0TGxKWHFMUzJaWlRFVWpKb0daMDRscWIwQko5bzExS3RpeHVIQ3RiNnM1cTMzY2kwbDFyK1FSZngreisyMzNMOEl1c1RDWWNaZXZESkhNemxqTjNKeWp5RmlBSzhaVjZkS2Fqanl1N3NuMXF5ZWZEV2lxNjlMTDh5L2NqWXd5WEVjTXJjWjRpWTVKV1FtcXh0MldBNC84QUQwUHgxeVh1dGRtZVYvY2p1L1pNMXY4QUc4WTBORi80bW1SeFhCcFVhU0J1RnJPeElvYThTQ3dGUlhiWTZ6TWQzUm1wa3lxemlPd2c1d0xpQUlyNjBVeHlMSEZidWhETnlFZ1J5c2lpbFFQY0F4M0dqOGEzOUdKdFY2b2tQNHpqNW10cDRFZHU5VzNMaGUxUm9sUTl4cUFBMUxxSzAxSDdqaUdPcUpXMDhCYnozaGQzWXVWS0JsRXBRc29OUjBOTit2NnZodm9qSG1RTmx4SitBaDUzRFc5bS93QzdEN1djS3pLTmdEL1YrV3RUajU3UHVZUEs0bEZyR2tpbGZlQ1k5SkhrdDRRWW4zWlBRL2tkYVdQblQxNm1MbjlwMnYwOUJMei9BSWViTXROWUsxRW9YaW9Xb3A5UWRINDhxc1l1YmoyeGdjaWZIMnF0OU8vdjZTRUhqK1A1NklZSWJiZTY3djZsUE1iaGdkdEtCQmExZU9KMWt1R0tnK29wV240YWpCSU5XbWFLUzhvWFBFSGl0ZHFqMEpHbWFrZVJ6d2ZtRjNhVHBQRFBMRkt0UGZFNVFrS2EwcVA2ZmwwK1dxTDRWWlFYVnlOT1N3N0w3anBkMjR0Y2hCRzl2SnlMc2hBY3lPMVF3TkdJSy96K0dnZjhaMGMxZW9iWGt6MTZCeHBNQmY4QTA0eFYySTVYSEdWTGh3M3Y5QU9BSkJOSzhmaHFOTXRscGRhK1FURmJKT3JJVTBMeE9ZMkhRbWhHNEkrSVBxTkVweVZ0UXpUMi9YVGpHdDFZZmhwcEVZaFNQeDlkTU9mY0dQUVYwaEd5S0U5eGFuaXBOR1kxcHhQWHA4dEZjWGY5NnV6VzBxUGlRdWs2dE1wUHpqSHZZNVM4Z2pUa1E3SXpxYXFvQkkrSnJ0bzdrV3JmSTdWVzFUb24xWGtaVzJOQll3aWRuTzQweEtYa1dkU2VPOUtkUlQxME5mb3lkUDNJY3NORTkvNVJuSUwzdWhyNUlEU0ZhdnU0VlBZYWtnTW81RHJ4cm9mKzFRV3luZHlXOWlJNHZML0hjdDRsRXl0RGxiZDdSZGk5dWs4WDdpTWhYZXZML044NmFIck5iQk5tclZLMiszREd5dm14bDhaSWI2MGV0cUFXNHJlUlZUM0owUElBb1Q2QTZYSlRjcnhINGxsVno0RjJlVHg0OUh4UGtjZHdscmtMU040Y3BhTTFITnRLaGJpd1dvVmxiOVBQanN4MWw0cTJVMGEwTlRKWk5xNmV2Y3I3eUQ3bFlPM3VyYTVzTE0zZVN0RU1NZDBDR2NxQ1NpdElLTHRVOU9mNGEwTWVHOWxIUkdka3pZNnVWcXpQN2VmY1ZKdkpZTG5NWE52YVJ5MXRZc2JiUkpHN1RPS3BJV2JkeU53SzBGVDAwUHl1TEZHa3BET0R6WXlxWEU2Ri9ZSDYvd0FnOGdmSVdDc21TVkh1WXJwQVhnQlFxeUsvTDE1VlZoK0ZOWitEQzNxYlBOejFxdHZ5TEZ1OHpCZTRlYksyaEN5V3BpaHlNZFBmYjgyS3NTT29Dc0Fha2ZwT3JPVmwzVmhkVjFNN2o0Tm1SYnVqNkVDMXQ4aUJqOC9aeHhTeDJGcjlMYzJ6Vkx2RVR0SlVLYWRUV3VzbFNxejRHelpWbDBlazZsYytiM0QrUS9kS3dzTEdDYW5pMkdsdUxhem9EYjNXVHlvYVJyRjJxUnlteDl2TXNYemI4dGJuRnFsZ24vZCtTOGZxWVBLcy92UjEyL3FMOEF4MWxEY1dGNWNsOERKYjIrTit0cldiKzEzaGE0d3Q4cEcvTzJsNVc3bjBQWFVNcWExUzE2L05mdVh6UVJoYXNvZncrVDZQNU1TZnV6NDQvaytCa3ZudC9wOHhHMDBsMUFxa0NITTJVWUY3R29JcUZ1WUkwdkloL3VIMWZWdkV2czBXcTdmK3Iva3l2bDQ5eWw5ZS93RDdMK2FLWDhNejl6akw2STJzZ2l1NHBFbXQzSjlxM01aSVhsL3V0eWFOdjl4enJhZzU1bS96enlhMDhuOG5seUZyYkxCWnh3cmFRUjhPMjBYWlVHWnlLL3FWaXNJSjZoVHFMMFVEMVNlb0c4Vmg4a3QvSkxmSzRDQjVKb1hBdnBCUlkwaWM4WERGaUJSZ2FqVlhJMk9qVnVoZHgzZXQxYXZVdXpDWjY0anlSc1liMFNYZVBuYTVXS0pneS9UeElYSEVnbmVuUk9xbldJNmFUMlowbjNVNTExUko4K3RiMmUyZUs3Q2lhVmcrUGlFZ01uZWtsQ3FPUFVqaHlZOU5xNmxocnR0STJYSnZ4N2ZvR0pIdHZFOExhVHJNTHV4dzFxUk5NVUVmR1o0eVJKV3BKcS90cFE3ZE5DeThsbjR0bWxXaXhVVGZTcUtIOGc4aXZzSDViRmZJM0s1amo1WkpXQUlsYTZXc2lzTnhRQWp0L0NnUFhXNWh4cTFJK255T1k1bVNMcng2djVoMys1L1hSWTc2Sm96ZlEyNkdDWnFLV2pydDBQVUQ4OVFkWW1laFNyVEVHYzExYTNNVjdEa2VZczViVHMzUFpabEljTlNPUWJEMmswQjVkYVU2YVpKcHBvbkthYVpabjI0ODd1ODVpN0xEWTJPU1B5WEh4QW02UW1UdXlSKzFHS2hlS29UN1dJOURYYnJyUHo4WlV5YjEwWnUrMjgxMnA5cTNib1BkdmtNemdmSjdEeURJWXVMRXlHT0pMOVVIdGF6bVBFeVNBTXhVcEx2NmRkTkNzb0RXbTlXaTFMN0ZMYXlUWHMwN1I0OVl1NUZGSUVWQ3JrdisyQVNXWVVxb29GMzlldWxhbXNqMHlTb2lXSStlZUJQYmR0YWxRb2tnS3QrOWJ6dWFobU1acnljRnFpdW1ka3RVRjB4ZmNmY3FMN3RZUC92end5NjdSWCsvWWZuZlF4c1ZZSzBDL3ZSckpYY1BIdjhBQ3E2anhPVGJIblN0MHRwL0lwOTE5dldYalBhdGFhcitKeUhLd0lIdjJZVkFHMUs2NjA4MUNjTUlMQldJRmV1aFhhRFNwalZtSExHenhFMGdqdUZkR05GRHExT3ZyL0RmUXQ3M1MwRHFZY1RjUHFHcmZDK1BwYVhON0pkeUJPWWhzNkJUM0NBZVpibHRUMEdoM255U2xIeERLOFBGdGR0M2tpRERpN2VXV0pZWnBFRWowVnYxZXprQlVLTnY0NnRlWnBhbFZPRW0xRDdqaGJlRHh3em9iZC9xcGlBWlZsa2Fna05RRCsxUWtDby9QV2RibXRyd1J2WXZaOXRsM2ZuL0FFSGJ4L0c1YXlnaUYwTFM3bGhNcWlTTnl3N2RhQlNEeEZWSXB0dnY4UnJNelpLV2NxVWRGdytObHBWSnc0a1kyenRsamJkWjdxQjVGaFVCNUlrWjNRa0hremRlUHczNjZFV0oyY0poK1hLc2RaYWZ5SXNWNWozVTNPUGxTNFJXWitNWEtRcE4xcHNlUWNqZmZZMFB3MFFxMldsak52a3IrNmpudjh4dThVeGtVMXFralNwS3dZQU5QeW9DNDUvRUFnOHExMEpudjZ0RkJaVFNtdW8zVFdsdmFXVnhMYnhUbWFPTXNiaFZBalJTd0RKRVc1YjlLVUg1alVLMmJVYUFqL2RJWnhzaHRjUjlQZFJNa25hS3M4WTVNL0VBN050MUEzNGlsUWRTdmVGNUE2bzdQUXEzN2tlUXdZbkdEQ1d6Q1hKWGl5M0JpdUt5TVlvRk1pOGdkdUxNQlUxNmROWGNURmExNWZSQlBLeWJNYlhkcHd2MUtidGZKUlA0bGJZTllKZXkwSUJ2UW9qZEF2YmxFY1pZdXA1aHV6SWZhVHQvbDEwcXg3Y2pzMmNUbWYzS1ZTVC9BRU1iekpaN0VZNnd6bDdOUGRCc3JOYnpUZHNSbzBOdk1qS3F5Y2FvU0l5dkd2cFducnFDcFM5M1ZKTDB6OHc5WHlZTU5iT2YzeDA3Si8wTkdjbHlFMkp2SXA1cDQ1THl5a3VjakFxQWlPNG12MVpZZ3dBSU5JUityZW5UYlN4S3RiSnFOSEMraExrYnIwYWN5MUwrTzdSVDhncmg4VDlSR2w1Y1NkcEx3ckNudTZPa2NuZEpDaXBxbzUvaFRWR1M4T1BBT3c0dE56Y1QvRHFZM3VITWxyRGxDSkw2TzVrLzZlU1YrM1h1MmJCRFhsNktCdjEyNmFldVNIdDZmNmtiY2RPdjNQM1QvSXg4Y2t3dHBrYnpOeXpyZFF6UVJYTENKV0xReXJEVml3cFFCd3piL2lEcVdaWGFWWThmbVI0bHNTdThreW1xdjRPUHhxTUR3eldGeFp0QlM3NzBkeXR6TXg1RlVXVHVVVkNHcnM2MDNwK0kwSk81T2RJZzBicDB0V1BWTS96SGV4eHo0ckpMWld6cE91U2pmaEhLbTZ5OFZlZzlyRUlDRytROU91Z3JXVmxycEFadHRUcHJKRmp2SnIzeWU1dXBFa25qc1lWdG5WWVY0b3M0SWZzdlhrS3V3V200b3RPb3JxeHBMRkhpRHRPMlQvMUdDTEl3WW5ENWVlQThublhzZzdnbVNkUXZMY0RZRGJiUmZ0WEdlUzlzbHVtUHA4WDAvaVovdk9iWmlWVi9jSklsYWczK1IxMFp4cE5odU9LRGtkTU1FcmR3NDVBL2hwaEdNektkd045T0lBWlFzUWE5Tk9JQ1AxM0dwSWl6V2lzeEJwdHB5QnZNVEFnSDEwdzhHcVZDbGRqcVNZaUtXTzRwcVl4cjVFZmpwRVpNU3hQVTZsQTBud08rbUVqTlNQWFRFa2JVSXFEcG1PYmh0dnFBa1pyTkhFR21tREdHRldsbENmcUtSZ3MxUG5RYWEyaUhrNSt5bHhKTkpjU3J5bGFSOW1ZN25rU2Z6UFRWOUZDUUprczIrb3ZTR1RrVmtxQ3A2SDAxTXBDUGplSWx6M2tHTHdzSUprdjdxRzJBRzUvZGNLZjVIVFdzcXAyZlJFOGRIZXlxdTdnL1R1K2UxOGQ4UHRMR0FjUXNCamhVVW9FVmVJL3cxNXRtczdPZTl0ZnFlbzhiRHV6UXVsWVgwS3hnWkpaZTh5a3M0L1R2dWg5eHIvRFQxcTBqcDNic0R2SElaTHZ5Yk5aUkpvbzVZTGxiYUVNNFU4SW93R0ZDS3NDUGg2NnZiMjFxak55Tk96SGUweGtPWm5XV2RqQzVESkMvRlcyQnFDcDMySDlJMUhkNmdaK21zOVJXKzV0bmw4VjR6bDhoTEtqMk1kcE9nYXA1RjdnZGxkbTMyTGJiNk80R3VaSXl2ZE1pZkdzMXBDS3c4UWhCem1IamMvOEFJdDdtYXV3QTR4cW5yK091bzl3MHhNNG4ybFR5S2xwVDJvYjNNL05LQTFGQ1IrSHlwcmljbWg2dmdXLzRueVJRRlFxc3BSVFNnRkNEVHB0b2UxMGFTcENNakNIRE5UM0QyazdialVTeXIyZzY3dFEvc0lvZjgxUGdmVFU2M2hrN1VWMFFKY1ZHODFTQU50L1Q4U0thSXJtanFEWk9IV3psSWlQaFdGYUo3YUQwMjM2ajhhNnVXWkdaazRNZEFmY1lXUzM1TXE5a01hMElGSzZKV2VZTXZKd01sWE1RZ1hjMmx6Q1NzZHNnajM1YjFVbjhLRFJWTXE4UUcrRzlWRzFRTGN1SUxzWHBzQVdOUjY5T28wYXNzR0piaE5nKzV4WmNOR3FVZGdRQnY2Ly9BRDFmWEo0Z2wrSTQ2RmVyNGptNEoxZ3VyVm80YS84QU9VaGs0ajU2MDFsbzExTVMzSHlWY05EQmE0bUNDNXRXS0E5bVJDdklicVZZYmc2alhJbVA5cU9wYWY4QXFOc0Z2L0NQREpaWk9DMjMxakxJQldvWXJzZE9uNmhyTDB5Y3cyMWdyU2NtTllnZXA5UnExb29rbTNsK1lSMll3UUFQZFhhZ1BvTk1Ka0tXNXRIQUU4UHVJSHZYcU5JUkhGdWtyL3MxS2FRNHcya050Wlc1dUxnMFZCVURxYTAyL1BTRVFXOG95QzNKbGliaEVOa2pPNHA4Nit1a09uQWJ3djNDdjhaZExkV2swOWhlS0tKZFdjalJ2V3ZyUWcwL1BVWFZQcVNyZHJvV2xqUDlRM2wwdHNNZDVCRkI1QlpTY1lpOG83TjBCWDBrakFESC9pVTZoOXVPakovY25xUE1IMlI4VDh1eWtPZXkrVHVzTFlUUWlRb3dVTzByaXFLSlJ6UUFmeDIxS3RrbnFLMVBBU1BLUHRqbS90bDVNRThXOHFMWGZiUzlzTDZDUnJaNUlaQ3dINzBERVZxcDZqVFpMVUZYSGJzRWNMOTZmdTNqVXZjSjVLWUx2SDNNVGZVNVM4aVNhUUtCdCs0dFk1RDhPYTFIWFVGUkxXcmdsdXQvY2dWNG5kK1A1enpVNWE0OG9meDNHeWhsbWFObFYyRWNaN1VhaVJXak5XVmFtUVUxSzNUVlNScXBlakwxSGhYbjl0WlI1ZnhpN3NmTDhiY0tUYk5hM01lSnlDTi9rTVR0SkJKK2svOEFMbFd2OHRWcTFIb25IeExrcjE2cjZHTUgzVHViTEsyRWZrOE45aHMxZzVZNXJJNVpKYlpRMHZHT1JTVHlSMFlleGlqVStHaHJjU2tXMFhxNnRGMWVUWnZWOUFibGZ0NUY1cm1NaGVlWmVTVHk0REkzbHZlMzk1R2lSend4SURTM2lWU1VFYkFxcXR4OW85MUNlclZwWGo0ZHVHc3RkRjVqWkc4MTV1NFJZSGgrQ3RiWEhlYmZidkZ0OVI0dGI5NmJESW9kbk9QdW9XRE1ydlRseDVLakZkK1FKUFhXQjduVEpaNGMyMkxwNm1wdzcwcnZvM3BHaFNYbnNNRjU5b3ZCUEpjY2pwSmlyNld5bGtZa2xwTG1FWFBOU1RXaGFQOEFKcWowMXI0SnB5c2kvd0I2VC9nQ1pyYnNGSC90YlJmVHBZK1NXc2Q3WUYvcTcyT0s0U1lFTmIwdW9JNXdKZC9hZWJTSDByMDFsKzcwL2JZNkQySGs3RmF2YVpQTFpaYlc2dmJDK2lNRDNTS2VXOHNRZFVYM2xSdVBTdEsvR3V1WjI5R21kUmF5c2xaZGhkeVhqRnJlOEk0SXJpS1VyM0Y3VkRESmJ5RWlRSUhxcjBaaVI2aXZ3MXAwdHRVOWloNUZadE53TU9Ed0ZpK0lqaHhONEpaSUFlMjRRckp5TGZvWkhZN2tqcUthSHY2ck9SL3V1alVyUUdYZUVONjEzTGVySlp6d0dGN2lONlhNVGRvbGpXTmR3ZUk5ckxRL0RTcmRyUXV2WmFOUFJpVjViNDNHL2pUM01IYk52YnExR0ZUeW83SGtBMVhCSUlyWFJlRzhYSVo2cTJNVU1GanptWUh0MkFhUllCSUdqb3lqdGtBNzErQjIvaHE3SjZYSlZpOWRWOEFSa2NCSkZLVmtoWW1oSyswcVNCc1J1Tlg0K1ExM0I4L0ZyZTNRVmNuNDNBeE5Gb2pVS3A4S2RlbjQ2MWNQTGZjNTNsZTExMWFFakxlR1hjTnl0MWpZMVdCNkdSYTA0c09yQWV1dFRIeWEyNnZVNTdQd2NsSEtXZ0J2c1hsclFHVjFNeUQzVlhZaFIxTkRvbFdUQVhWcnFhN1dkcGZkK2xQOHgyMUlnbUVobVFzQWdocDhlNERVMXJ2VFRRU2ttV3VjdUlxR0k3bllBZnBQeXBwbWg1R1N5OHV5RmxQeGdNdjFTTHlZeGtJOGJqYjIrdFFOd1JxcTJLcjZsbGNqWFFaTWQ5eElmcVltdnlHbFdRRis4WE05RkFvcXNPZ05LTnlIcnFoNE52UUlXZHQ2ajdoc25iWmkxZWUzTlhSZ0pGQUtoZVZhS0s5YVUvVURUVUhWcnFFMHNyTFFLTGFzL3dDa2RlbGRNV1Fia3hjamZEYlRTS0NUSGlpRDd0Ni9EVFNQQktUR1I4aHlVc2Z3MUtyMUZCUVAzTm5tanpjM0NHUldhVG5HNEN4eDFCSUpDS1RVMStKMXM1dDlzajN1V3UvdzBNWnd1Z2g0WEl4WTN5Ykg1SytSM3Q3U2RaYmlHTUJYS29mY0FEUVZPaGIxMGFGVnc1TFdHT3hNUG1VV1RzMmtseHVZeDhOMmtrbHh4YzlxNVdycktEVktMUnZsb1NqZTJPNllaZXFkcFhkRnFYRFczaUhrc0dUZEFMVjJsdVhlZWx1c1Z3Z0lrSGJJb29jTTNEZjErZWgzTnVoZFhiWHFoSnlmbStLc3M3ZFhPRnRUYVhHYm5tdUh5UmhlTkVoTHNxeUxRQmlqYk00RDByVTZ2ZU96UlNzaVRncUhQZVhkK1NacnZJOThzU3hodGh3aEovelVIRWZuU3Z4MFZXaVhZRnRkdnF4UXVmSTUyTkxZZHV2OVozUDg5V0ZjaEh3MjZWTXZCbEwrc3EyMDZPR0pxVjRucU4vU3RkVlprM1ZwRitCcFhUWjNGNEw1WEhqSm9KMHBKWjN5Qm1DZ21zaTA0MElCNm1tdVpyayswOVVkcGw0MytUVldyMS9nV1JaNFhINWhwTWdKRGpMeThNclRyRVEwUmFTclJFamZqdWZkeDNyMTFWZFZ6SnRhTXFXVy9HYXEvWFFNZUx5dmFXaHM3b29aVmlYdUJEeVNSbTNCREVDb0s5SzZDcHVVMWZZSXo3YnhhdlJsUVgvaVhra1Btdmw3L3dEY1J4MDJaeWxsZjJ5Mjl1b01DdEdJc1JPSlpqSnhFTnhEOUpOd2pCSExyUnRkQlMxUHQxaFRDLzFPZnZTMzNMUyt2NFJYRnpnOGJmeFpHRE8vVlhsNWl6L2NYK3F1SkhrL3N0NUswVjJxeEtWaldTd3UrVWo4RUEyWTA2YUpzM0MyOS8xL3FVMVNUOVg0WGY2ZFE5Y1MzdDkyeGs3bFk4dE8wZUl5TjBVTHBIbThjdmN4dDdWUWFwY1I4WXovQUpneWpXZHQyL3Q2TFZmRCs1ZkkyVlpXVVBxOUg4ZjdiSE1ubk9KZkJaODNHUGphRzB2ZVVrRnU0b1ltTEdPV0VnK3NNZ2FMOEZCOWRiV0c4MU9kNVdQYmY0a2V5ek56NDllTmk4VFoybHhmTEhFczE3ZXcvVVBIZE9vTXFSOGp4RkNkejhkTmZIdlV0dVBJaFhKOXR3bDlRUDVObWM5a2J1T082djVKYnFmOVlqQ3hMd0d3MlFDbzlOenFXUEZTcTBSSExtdlo2c3NQd1hIMjFsajRWaEJhK2pCa2VNSGlKZVI5Nm4xTlJ0VDExUmxXN1VKdytuUWMvSjcyK3lPYnhkamR5QXpTOXZJWGdxT2NhME1jY1NoZU5PU2s3RDhkQXJIQ2JOT3VTV2c5NVJtc1Zsc0hmNC82Z1crT3hFMXBMY1NvRUhjaWRRd1JnTngyM1U3S054U3RkRDB4dWxrMTFab1pNNnlWdFJ1RW9PZEpCZWVUNXlWb2tCbXZKS3BFbjlLVjRxdjVEL3gxdUpLbGZnY3JmSThsbS9FdFNQeG14eGVIT1liamJUWXlRMnR4YmxpREkxUU82ak1LRUFNRDhEb0IzYnRIaUUxcWtrQlZIMGtkL1BOdkhjS1lwUWg5eWhsQnFhSGI0Nm40RGRKSU9JbEl2UkxpR005dFlOYVhFWUxDUGhLang4MzdpQU1pbjNLUUs3c091cDVGSzFGaHRGdE94MWZmV01Oemp4OXdmQjdybjQxbkloSDlGSXdhWnBuOWp4Rm5EcUZCUEZ0L2F3SlhycmtxOGkxYlBIay9jbitSM0hFeVZ5cnpnSDR3M2w0bHhheTNVa041YkNPTzFNbjd4alFCUWlCbDRxU0FPR3k3anFkOUZaTXFUNnlqVXBUYXVnYXkwY2NOcEZEZDhCTThYRjFrNEt5dVNPNDVhb0pWbEg2eHRUVGZhMGxNZkhhWFA0L0hrVko5K2ZKY2Y0LzRsa1JpNzBObWNtNzRWdUZWWVJIL0FKb0lZc1RTTUZlZGY2aDh6by9nNEhiTW5HaTFNTDNubTdPTzZKNjIwL21jaEtBK3piQTdmaDhEcnFEenRoMEkwamNsRkNhRDI3MDlPblhRVXdhK3h2b0U0NFpGQ3BHV1dTUTl1UDBKWTdOdDEyOWREdXhvWThUMGp2MERiV0VFa3NWdGJsMWpoNHJIY1VvcEpwenFCV28wSXNqMWI3OWpXL3hhdHBLZE80eldtS2hVdFBaM2RlU0RtM0VHdENLQU42SGF1Z0hsYjBhTnovRVV6UzNZSnhSVHozSTVjWkpwR0JWMGtvU2dVaWhCYWxTUC9IVlRza2lheDNkdGRXL01lWUFMZXl0K01VaXlSUDIzclNXTlBVQ3E4Z3RTYUF0WFdkWlMyYStQSkNTK1g0L2dFZnBEY3lJTFVKSEhKd0lWbEtzSFN1OWRnM1hmYlErN2FGdHlIYlR4dTJ1WXU0WVYrc0xCelB4b3pmaXdCUFQxSjlkVnZMYnN3ZTdxbjBRWXhmaEVWbEhGL2I4aTlvR0c5WExJQWZpaEpKL0lqVFBJN0tiQWJ6VnFvVlJuT0Y4bnM3TzJFa1ZubEliZGVSa2pabzFkUjFKVmlONmswSEwvQUEweWx1VUJWejQ3UFdhdGpCYlpIR214aVMvUnNlc0lIS1M2b1lTM3F2T3BVbmJvU05QdmJRTGZIWlcwY3o0SEtuM0U4bXNQSWMzbkxyQ1pIdFphMnVvMWhFU0FxdHZ4YUpWTFZHeEZmMGpxMnQvaFlMWTZWM0xTd0x5OHFzM1RIYjEwWHkvSFVYTEdQSDVIQmhWaGl1SWJXTkpwVEZVb3IzVWNNVWdZa2dwUjRYRkQ3ZVIyNjZPdTdVdjEvQzZmcUM0SzB5WStrd3ZwT255MVJOOHJ2Y2hQYno0bTJ0NG9GeGw2OXg5SzRidFNUUTI3U3N3SU5DZVVnVnVuTFkrdTBNQ1NlNXVaWDhTM21XZHFPcVNXMnowODBwL2pBU2h1TGZOMjF6NUptWkZpZSt0MGxrc1ZUdXdyY1hVa2dTS1FrbmlFS2NUNmdlbW9XcnN0c3IwWGN0eFdXVEg5eS9WclZkcGI3aThUUGkvN1BjMnlpU0N4YVdPNmdMTVM3Rko3WVBJUTM2Z0tVSUc0MWVvczdUMy9BS01HdFYwVkd2N1puejZyVUllS3l2Zkpsc1pMTEsxbmo3akZLVUxsWWxrWlhWblVFRUE4QnhIcVQ4OVY1MXQyMjhkeGJ4TGI3V3ByNmR2NC9nRXNKWlkyMHRJQmNvRm55ZHFybXRPNFlZZ1ZrSHVHN0JnRm9mUWRkVTViV2Jma0c4YkhTdFZLMXN2bm9NZHJaWGR2ZVZ2MFY4SkhjV1Z6YU9HNFNDVzZ1clV4cTN1b1NxRWduNGFyeHV0dW43b2Y2TVhKZDZiWi9idVg2aHVHQ084VCs1WGdrZkl6UWxiV1Rpa2FpSzY0RjJIYmFoSUNtdjRhQmJoUXVocGJKK0lYYkNuSExOZUtESk16UWk2NEFFTVloelJkK203bDZWNjE2YXJlVGNvWS93QnRLMDl4Ujg2OGlnd1J4TnBmaWRiRytrLzZ5N2lpRHFraUIxWG1xcXpmdU1mYncvUGJXdjdUbHV0MVYwNjdmRXdmZk1lTnFtNmV2VmRwOFJldC9JY0RrQXJZKzhabllsV2dsaWtqbFNuK2NjU1A0SFhSS0gwT1B0V0g0L2p3SjBkeWpnTWpCZ2VqQWdqK1dtSVNFN2VaK0lJTzN5MGh5UjM2S1NUdjg5SWNHM2JvNm5rZElSQkN4cWZjSzZSRm1ZTVZLcW9GTk9SUE5pUWFkTk9OQnNDb2R6dU5JY2czOW1nSWtpNkhxTlNUSWc4d01UVFVwR2FNSGhaZGh2cVNaR0RBd3ZTdW5rVzArRVVoNktUK1drMmhvWnVTSnY2cWo4dFFiSm8zS3JBZXRQdzFFY2dlUXp0YTRESXlwSVlwT3lWVmw2KzVnQ1B3SUpHcTdxZnFLWTFLR3ZKekFQYXhMTWFyK1hyVFJZRTJScm5JaThaWHVJVk1ncHlaZmJ5b0tWUHpPbldoRnVTMS93RFRKNDZjL3dEZGJIM0pTdHZpWXBiNXpTb0RLdkZQNXRyTzl6eWJlUGJ6MCtwcSswNDkzSXJQOXVwMlg5dzc4Ulc4VmtCV1ZZSWxVZEJWNjdmalU2NGRxYkhwL3Q5R2s3K1lrMlZ3QmVYSVZUd2hWb3ExcUE1WlZQNDFJTk5YTlFqUldyUVk4TXg4T1V3a1U4NmhVdUpaN2xUNmt6U3RRMUJCQnBwc2pod0FaYjZqUkJaNUsxeWFMYk04M3NUa0pDUGFxN0dtM3JYZXUvcG9XN2M2Rkc2am8yeFQrODh4aSszdVl0THNPSmJtNHNZb1M0QUJFbHlyRWJlb0NNZW5UV3g3TzNia1EreU9lOTZzbHh0TzdLLyswMlBYSmVZWEljY2haWXAyRmVnYWFkRkIyK1NuVzc3eGVNRWVhTUQySkwvSWw5a1hGZDRpU3hzemJ4cHlqVnc2QUQzVmNua0tuZWcvcDF4RjhsbXRUMFhCZXU2Vm9RbHgxbWxHalhqS1NUN3ZhcFkvaHNkUTNTZ3o3dGpWYzJyeHlVV01FRVVJV20vekRhZVpMS1hsZFNESmFGalVmcUlvT1FGZndPbWVxTDFjaUxaQ3A1OHFxZGpTblgwMDZzWFBKcG9iNWNjZzNVbGxJSHBYOHpxYVpWOXlWRElVOXFPTzYxNmtEY2o0VnAxMUt1U0N5RTFCQ3VNYkhjUUVjQno0KzVQVDhqb2o3Z0xmanBxSUFFdUJrVm5BVUVIK25iWmRHVXptVGZndE53Z1BQaURieUZ3aFZtcVdmMEgvQU05RTF6U2pPeWNSMDFScG5za0VaaWVMbXJEMm1tNCtPNTFkWEk1MEJjbUJKYXFSYXpHSzdVYjNhaWloZTRhOVJRMTJHajhHYVdsM01UbGNUYlZ0RDU5NGNYSm12dDE0cmF4TU9idGRpT3RkajdDS2o4dGFPUjdMeVlXTEc4aTJycWMvV2ZobVRodS8vdWhFQmJ4MDQ4R0JEbjhPb0h4cnF4OGlrYUZTNHQwOVVGN25EVzgwWmh1SWc4UkZQY0s5SzlLamI4dFErOG9KMndpSjVKZ3JUR1BIMldjTkxYaEdkMTl2VS9HbXI2VzNJRnZYYXlIWXg4ZUlweWIwVlJVazZtMFZtRnpmVGlRaVJUR3E5STNCcnNQVWFZY2d2TkRNZUxRcWpucXkxL3cwaHlWWTJTeU51S0lQMU9mU3ZvTk94a0VueXE0eVdJUXhjeWczTzFGQi9qdnBpU1owVjlsL3VPYjZTMjhlek4yWnJTOFF3NCs4bmNSc3JxTnJXVmlSeVNUaUVUa2FvL0hpYVZHaHJ2YXd5bnJXcGQrZjhBeG1VUU85azF4YWNTNVVLbmNDTVFFWlhQRXF4TExzekgxMDZ1bVJkV2lndk9yZkIrSDVDREZaQVNTMmQ4c3F5UnE4VXNzRWtUY1dTV05YSjNCQkc1MUhaT3RTVzlMU3dMc1BDUHQ5bklRTVBlTkZkOFNlNWJ5bFpRU2VqUXlnMUh5NDZiN3Q2OVVPOEZYMFpIazhXKzR2aEVweUhoUGtUSzZrSGhBeldrckQ0U1JrbUo5UzMwdjFSWHN5VTZNSCtZK2Q1UFBDMnhQbkY3TGQzL3NhUmdnaWhqcjA0UnJSUlVtcG9OK3VwcXNMMGxidkw5Ull2aEorM21hdytPd3VEODB1L0Z2STRJeEhkcGttNzlqZHlLZVhOSXJnaFVOYUx4aGtXbzFGdVAzTDZFMXIrMWp0azgzOXcvQ0xhTC91S3pzc3ZoSTJDdzVmRFhBaUE1VjJrZ21NYnFDS2s4T2Z5MUZxdHVqa2VYWHFoY2o4bSszL0FKeDRoTjRQaXI0WTNIWEZ4RGtPelFHUzJ1b1NWTElwL1NoVSs4QWNTTlJlTmIxZHJWS0NTdk5YVlBRdkQ3UXh4WWJIUWVMNUNlenZ3a2F4eFhsdklpTlA5S1FFNUN2dVpVYmNLelUxaCs5cWNFcnMwYVh0OXJWdkM2d085MTR6QXlmc1RUeFJQUlkyZENzU3lNUTIzVTBxdGFucHJrS1UwbUdkTlRsdnVrQmJqSDVPNWVWbmpsaG1iMno5c0xKQVN3Q3MxQTN0NWRkdXVyRmUwVDI4Z3VtU2xmQVZIc01oaCsvWVcxWklvVk1VVHpSK3dxQ0NrbFVISXJTdng2YUtWVTR0NGhsYzFiTDRHbkc1L3NSOTVJM2QzRG9MS1J3cm9pRWxPTE1UVUFWcHhZNmUyS0xDL2ZXZkJranlGYk84c1pycU5vM2h2V1NLYTBtSGJLdVNBM3U2QjYvR21sV3JyYWZBYkhmY3RyNmVKVEhpbHBQaS9JdjdiRkFaWnU1YzJzc0JQRU1rc1pLa21wMjZHdjRhMU02M1UzQWZIdHN5N2V3MFpKUytLYnVKeTdhVXRwNWdZUnZVRWU2bnVXbXMrdlUyMnF0YWdmeUR4MklZeUcraEJaV0N4VUNlNEdNVVl0UWREVFk2dXgzZTRIeVk0RTg0NUdIQUtLaXRmanQxMFQ5eXlCdnQxYTFRRXkzakRQSU96N2h1R1g0cjBQOEFqby9Celkwc1pQTTlxVmtuUXIrLzhFVzE3djYrMERzSDZjU09ncFRwcmF4OHBYUnlHYjIrMk5zVk1oaHJyRlNLcXhtU0tTcnFhRWhPSjNyOGR0R1Z1bVoxNk92VThUdThDSWxIZTlVWThHSS8zYWloL2pxUkEzMmJ0TXdXUWZ1ZzFMRWtTYkN2UUg1ZGFqVVJ5eGNQSmdNZmF3WCtadGZycmt0M0dReUZaUXRQYUFXM3AvbUFHL3gxVFoybjBsOWRxL2NYZjRaZDRieW13V2ZGRlkyakh2c2dBR1FEYW9BQXFQbm9XN3RNV05LbXhxYWRCNHNQR0pKalZsNHFQaUthcmtzZ05KNGpiQWU2V2grRk5OSWpYSjR3cVY0dlVmaHBEbWoreG1QY3RwNWE2Q09iZnUvaVBwZklMbnRSdUFyRjFEallLd0RCZ1RRQWIrM1hSOGh1MjNJMHZYVk9WM2ZmNXoxOHpGdW9zMVBjcGU0S0c0VUFIdUZqemtKclgwL2pvQmtDeVB0bGw3YzRlL3Rid3MxM2k0NVRaeUlna2xXQ2RlVDhVT3pjV2o2SGJlbWhjdGZWSVZpc29obCsrYVltMThwOGVtczVSMkpyVTh3MGZJeUlMZEtpVXpFaW50clN2VFlVTmRVMDlMTGI2bzV2dFpzMTVYamJhVjcrUy92b1dsdDIrdG1XS0dHQ0lxa2FMV2hJTlFUVHFXK05kR2FWN0FhVHNWdjVCaTJ4T1Nuc1pHRHl4dFRrZ1BFZzcxSEtocHF4RmJVQXFSZ0RSYVUrUHFkT0laZkdVRDJsMDIvTXNBUDRhcHl2b1hZbDFMNiswdmtQMStOZkJUeWtYZVBQN1JydTBEN0QrQjIvaHJENTJPR3JIV2V6NTVUeHQ2blNuaVBrbmFuanNzak55RngreEZPQUNBTjNDTVN3cXhGYWF6c09TR3cvM0RpYVRYb2h0dkZtUzROc0luYTl0bys3Q0VZQnBJRkZTb085U0F2SmZXbzQ2aGxXNjNtQjhlK3l2a0x2bWMwRWtVV2VrQnVjYlp3eVIzMHNOUzgyR3ZRRnUvVDljQkVkMGg5R2kyNjZueE1yV1RZLzd1bnhSTG1jZGJONjYxNi9BckQ3aGkveFYxYmVYaUtPNXlGaE5jUGxvVUZVdVpJb2xqeWNRSFFwZVdwaXY0aDBxSDlUcmJvNVRyNDlQeDVNeGNxYWkzaCtIOVVMK0xPTWU4dWNUUGR1K0Zsamd4azE0cmtPTWRkL3VZbStKMzN0NUNJR1AvQ2ZRYXF1bkU5K3Z6WDdsOHdyRGFzdytuVDVQOXIrVEZMN2xXbHFNV2ZJc21nanVzVk1WeVZ2MjZyL0FIMjJDSXlkUjdMeFJIS0tmNWY5N1V1UGJYYXVqNmZEK2d1YlJiZDl1cTBmL3N2L0FQSW94cm00c1lVRjNJc1V4N2ozS09SemVXWThtSnAvNTYxRG5tQjhVRGQ1RXpzZmFEeFRZRGI4cWFsYlJEVVUyTFJ4VXR6Wk5GY3AvUzFhaWdJNDcxK0cxTkNvTHNGMThsVy96VW5rV1FBUllnWlVMZXhXV05Ba1lOUFU4ZHRWM1hZSXhXL3VaQjg0dkk3UHh1d3gxMkJKbTh2ZFNaYklUZ2dnUXN0RWo2a2pjOU9sQnFHRnphVjBSWnlFNjAxNjIxK1I1OXFraXNMcHM2OXJMSmNPNGl0bGpXdjdMQWh1b1A2alFWOU5TNUZuRzFBV0NxbVdXcEo0ZTJVeU9Tc0xJQld6Rm5KTGFXck96bWVTRGpFeUloRzYrL2lyRDEzMEQ5eEtQSU0yUy9pSS9rOWhhWTJHWEcyY3EvVlc2U2ZVMEI1U0NNY1BkVUNoSDZhSCtHcjZOdlVqWlFWN2FpU3dzdTNibGhOSXpMTTBoVTFOT1FLZ3JRaHVoWDVEUmoxNmdxMDZIVDMyZjh6d043aXNQOW83KzNFc00wTjIwVURGekxEZUtmcUkyRXBrb0VZQjI0aFNhaW5xVHJtdWZqcmkzY2l5bVBBM3VEeUxVYVZYRExQYndsc0hhdGRwTVpyU09KKzc3M1NScEFReUdOVklVYkRvYWl1c0RCeWxtVzVLRHExelB1VzJ2cVYzZTVHYTd1M3Y4Z2h1OFM3UnZOR1kwVklsTzQ1b0ZEQlJRb1NPaCtHdEdtZE8yM1ExYjQ2MHBIZjZuTW4rb0h5MlhQZVpEQVcwN1BoUEhrTnZaUUVxd1NXYWtrdnVVRGtSN1VxZC9icnNlRGlWY2M5N0hsL3ZXWGR5SFZQU3Y2OXlwNFZMc3dGVFJTVDY3RHJyUU1Jc2F4c2NjSTZ5eGNwbklTSWdqa0dib1RVMEFwODlZRjhsNTZuZVlzT0dOVnEveElReCtPdEd2V3VaZ1V0N05Rc1ljMVo1UjEyM3JVa0RWRjh0dHNMcXd2RnhhYjl6NlYwWG1UUWt5Q1lRQXlvMzdzamxhRXV0TmhRYkNvMitRMVRLMGswYTFkYXVGSzZrekd6WkszbVphYytHOGtiZ2NRcC9VV08xYUNuVFVicWpRc05zcXRIVVk3Uzl1R0VpU0FrdXU4a1NjUUgzQUZkeDhob08xRWFkY2pXajEwN0laY1g5VExERGNDZnN5OGVMUjIremI3Y1dSdGpVZEtiL0FEMEprZFZwRWhPT3RycE9ZK0g4UnFzYnJHMjZ3eVhkdklWakJLdTQ1S0pkbEc0WGtPVmZRNkh0NnRDTHJhcmxCdXpuRWtTTXM4YlRWS3lDSnp1V1kxSEZ3cG9Cb2U2VmVnMVphMVF4NFRNR29XUjJrWUVyR09GZDY4YVZZR28vSFZTczVCczJGTlNody91VjZnaWppQ1JvbkpwZW9BU2xOMUFwdjh0VFdSeDBNcjdWWExZbC9jTHlJWXp4cStqZmdvWkdNcGtaVWpKYllBOHh4QXFmVWRkTEJWNWNsVjVobUt0YUo1TGRLcnVjZDJ5eXp6WE02Mjd3WHVTYTJ1R1FEOWxGNXRJb1BicWVQRUx4TzJ1OGNLRk9sWk9NeHpiZFpKemZhL0xyNUczd2ZrdU96TTBxeGZVcmJDS0szWWttUlpIRndHL1VLcXF3dFg0MXBwY3ZyVkxwSS90czdidnZHaThaYy9Rc0RHejVTZnlXL0Y5Rzg5cTJUTWR5RHdNcmlXM0FkaVJSUWlzcU1UVDI2enJxcW9vNngvRTM4TnNtK3l0MDNmcXRmNGZBR3dXMFZ0WXpTUk83MkRSTEpGQXZSaERLVmxuNUVtbFc0N2VvK0hYVTNadHBkeU5NYXBWdFAwOXY0czhrR05sdmJmQzVySVBFVytwdklwQVZTS2FLRkRKRUdjR3A5ekZBYW5mYW1ucXJiWGFpNlFpdTlxN3E0OGxucTIvbCtOQ1A0N2dzOWoyOGl2aGRCYkM0Z1Z5Vm9FZTVTUlZVSHJUdGN1UFdsVDExWm15MHNxcU5aL0lwNDNHeTQ3WkxOK2xyOC82RFpnc1BkK1N4WTIwdVpaRk0xdGR3elhycUMxdU9STHBSQ1FTcGRmaHR1YTEwSGx1c2N2dG9hWEh4dkxXcWM5SDhqZjVwZW1HK3ZjTGJ6SkovY2NVOTZ5RmxjZGkwRUlWMjlROWE3ZzE5cHA4ck9EVGRWMmE2TUc5NjVIMjNYRi91MWZ5TER4V0h0WVliY0xEMlpDaVdxeUJqN29ZKzRDUzdFZy84UG9XMWo1Yk55ZEhpcXF4OEF6Y0pjdkdMcWQ2Q0JaSlhqYm9XVmdZcTlQOEFLSy8rZWhOdzdYZ1o1anh4a2lGd2lySk5NbzVKTW9jSzVHeDRrR2xLL0gwMUpXZFhCaWNqS3IzZmdpck1wOXM1Wjh0TG5ZNzAyTnhiekdTQ1czalh1dXF4MGtSNjdFRWpaZUoxcjR1YnNwdGlUTHljZmZkV21JK29uWmZKK1NXTXRzem96WXE0amtZM2tVQ3ZJSkVJL3dDWWpNd1UvSGp0L3U2MXVMeUUwMDNyNGRnUG1ZdDFrOXVqN3Bhb200WHkrenVaVXRMaWVFRi8wenhreC9oeWpjbnIvdXQvNmRhVytyNjZmbWpLK3cyL1MwL3lZd21WSlVkb3BWbFZObWFOZzFEOERUcCtlcGVaUzAwNGZVaFNFRSs3U0lzOFVSSFk5ZElZODdHL3RPMnBFVEpnRjIrR2tNYW1rQ2lsZGoxMGhqVzhpdnNEcENJOGpLQ0tmbnFRajRGVFFhUWp5UkNocjZIU0dNb0pEWGo2SHBwTkRoZUJnb0JjQnZ4b2RSRVQxbWpuVHRsRkE2ZEJwQ1JYbjNRdUZ4K0c3RWI5dVM2a0M4Ui9WR2c1R3Y1OGRSU215UXJPRXlrWG1zZnF6RGVBOWtvRUxnZTVTUjEvSSttaXdIdnFESklJbDVsSmxZTCtrYmd0VSttcEVUc1AvUmI0MEljVDVCNWRPaEJta1d6dDJQcWtTOG4vQUpzTmM3N3hrL2JYNW5UK3pZNHJhM2kwdjRqL0FPYVpUNm55RmtRZ3BGS2pHcDJJaFd2NTFKMXplTmF0bm8yQmJNVlVLaVhuYml2Sm1xR0JSeVR0eVdJTXg2VjlmNDZ1YUw2RnBlRzR3V2ZqOWpES2hhTVFvdkdoTFZwNzYwK2VnY2xtN016TTF2Vm9Ha1RLOTVlMEM4YXlEZzB2c0JHNUE1VU5LVkh5MVZMblVwYnh4citSVm4zNHlFcytDc0xOeVZMNWVCV0RBMWJzUVNzZHlLVUJQb2RkRDdENnNscmVSemZ2c1Z3Vlhpd2Q5aUxhYTQ4ajhsdllEKzFiV1ZsQVZPeWt6U1N5QTFGRDdlSDg5YUh2dDBzZFY0c3kvWTEveVdiOERvQzhzbStpaTdOQk96cFhsUUNvUHFUNkhYR1c2YVBVNnZIazlibm9jYitWZmNIeWZCZmNYeWVQRFphYUt4R1JuUVc5ZTVDZTAzRC9BSmNuSmZRK211dTRuRHg1T1BWMldzR1B5ZWJseDUycXZSUnA4aGp3djN4eUtHTmMxaklyaFU2VDJqRzNrMjJyeFBORCtBQTBMbDlucjFxMmczRDd6YnBkRC9pL3VYNE5sblZYdVh4MTExYU84UXhqL3dDdEM2Ly9BRlUxbFpQYnN0ZFlrMk1YdU9PK2lZNDJObEJmUnROYlR4M0ZvRHlFc0RyTXJEOFVMVS9QUUZxT3ZWQnJ6OUNWL2JiZDZtRnFzMjFBYUZkUlRYVWo5NjNjQzVDemRISUNrS29LdFg0ajFxSzZkUHNHNHNpYUlIMFlBQkc5U1FSODlUVFNDZnVFQzdzanVlUEYwb2E5UVIxOU5YMXZBN1NzdENMYzJRbVVzNEJXbTZBZGRUcmtncHk0dHkxQUU5aWc5elJrclVVSitYeDBaWEwyTXUrQk5BRHlPeUg5cnZpRUlaWUpIRk4raWsvenBvM2paZjhBa1h4TWozREJHSzJuWVl2SVJQZCtIK0s4R0JaSHVUeXJ1UVZCb2Zscm9QY0xiZFRqL2FxTytTRjRGZVhjOUU3WmdMT0RUbXg5cHA4eFhXZFhyS1pyWmRxVVJxQnJ3Y1ZMUEdWSjZFYmlucjhORjExNkFHU3NkaGF6M2pCejZ3UGJ6aUc0anFBWEJLc0RUcVIwcG9ySGsyZFRQeThaNVAyOVNKamZHR3hhOXU0QWt1VCt0eDAyOUI4dFR0bW5vRHJqT3ZVa1hPTHQ1RVpaNFZrb0srNEEvd0F6cExMcVJ0aTBLM2xqaCtyY3hwMm93eDRyOGdhVjMwVWdTUWpMRGZHMUQyc1I0ZGExQUlYNGdhWWtub0JUUGNSbmcxUVJ0eGIvQU05TU5BYThadm9VdjQ3ZTlkNDdOMzVjbzlpc25vYSttazVqUW5TSjFPbmJ2N3FlZC9iend5MXpVa2FDOXljY3RqaVpvNUF5aVpJMVBPV0xkS2hXQjZWT2h2dFN3cTJXRWNvM3o1T2E0YTZ1dWZkYzh5L3pKcnNSODlFcEFaS3NjdGxJbUJyM1ZYY0NRR3Rma3czR21ha2RPQ3g4VDUxbjdDMVdXNnVHTnNCVXczZEprNC9HcFBJVjlOOVZXeFZhMEw2Wm5Pb3hZM3kveEhKM1NYbVh4Y1Uwb1hnWm93dHhFRlBYOXQ5eC9FNmhXbHE5Qzl1bHVwTXUvRGZ0ejVMR1h3czVzTGg2Y29yV1NnOTFPc0UzVC8wNmRaV3VxS3JZVStncDVERWVTK0cyTWx2UGN6NVcwUnFXY0phUXBHckdtMGJWQy9QanF5cnJiVkZkbGFpMUNQaTNrL2grQ3Q3ckMrZWVIUzhMNWxsK3JLaU82aElXaXRHSENOUWRSd2NmbnA5dGtSM1Y3cUFyakpzYmhMeUx6SDdjK1pXMXpsYmFVelIyT1RqTTdveEJRS1ZscElTVlBBa2hnZmpxbk5pcG1vNlhXakxjZVMyTzI2cjZGNWZhei9WZjVKbnZPTFB3YnlMSFJkeTVtamhobnNZSEZ0QzZKUjJjTTdPWXlhNy9BTk8zVWJhNTdrKzByQmozWTdQMDltYVdEbHJMZmJkYXZ3T3RIaXgyWXNCT2tiVzdTcXpxZjBFRmR3ZHVvT3NmYmp6NC9CaHF0ZkZlT29qWjJ5UzZza1dxdGNSS3pyT29WUzBaVWxGYWxhaXBvSy9qckZWM2pXMXZRMjhGNHRQYndGQzd4cldFRWRza1VjMWpKRVdxOFI1QlVha2dZcWdxZDl2OE5YVjVMYTZtbFJxemI2TVdibkIzVTloTGJZMjZZV3M5SmZvbmRaWW9aRjZOQ1FvY0x2V2xQYitHanFjcWpodlJqdWpVcDZpZEpqOG5hMzFyWTNOdEhIazdnODQ3bUZqRU83R3k4R1NRbmk1ZFE0S2JmQ2cxcWJ0MVg0QVNTclplSTVYMTFZeVM5clBTUkY0SGxqSmpxeXlJc2ZkUXV0VFYxcFdxVjlSck5kV242VWF0YlF1dWh0dnNIWTViRnlSNFc2NUpMR3pwSUtPQVNnSUJJb3czUEtueDFGV2F0NmlTdTRLMnpXTS90MXRCZXRBR2xsaVdhUng3MUFOVmJqVGVuTCtHaTZ3MzVEMnNrYmJqRzJWNmx0Y1F3bTA3cWR1VWx3Njk1U1I3Q28zQkFycXR0cGwxVktGN00rT0ZhRXFHaGxJRVQralZVUHQrUkdpc2VYYVoyWEFyT0dKK1I4Wml1SDQwTzRLRlZvRHR1S0RvYWEwTVhMdFZHVHl2YnFYY2loNUw0WlAycFh0RkhJb2UwRjlwQjlhMDFxY2ZtSzNVNTNtZTJXeDZwYUZhb2w3aWJsSTBnSzNia3FKcGh5OXk3SGlPbTN4T3RUcVlMMEo5dlBMM1RCZVpBcVFUS3pGNmtFZGFrYmtub0JYU2dZc3J3THp4Y1ZtN1BLMkNsZXdWaXVvbmFna1VqaVdvUFZ4czN6MVJla29LdzVkdHZJN2d3a2x2bDhWYVpXeU5iUzhpV2FLcEhJQnZRMEozQjJPczQxdE8zUW1TMnNhN3QxMHBFUTVncUlRT3A2YWVSZ1ZQSnhVMTlkS1JIUEgzdnQ0NHJwNVkxbGxhZFJJeTFacUhwdVRzRUZOdC9scm9QMzRjYmlQUzFwM2gvcjQrSmxjbFJZb0tURXhLMEgxRndxM1U4aXh4eElRN0p6UFZnUHgwUGEwZzhCSHhtR0hEZVZMakwrY3FseEhKYTNFaXFUeFM0VXJVcUtFZ1YzRlFhZE5WWDZFcTZNNjRDV3RzdG1MNkVTMmQ1WnpXcjl0dUhCSTQzalZnZ0pCSUlLOHZVTlhxTkFWYzZoOXZBNDNzN3g4Zmk3VEpXcEFNVi9keG1QcnlqS1JNVklPeEZEL0hXaVovUUovY1h4LzZqSFdubEZpN1R3T2ltZVE3bG81ZDBjMCtCOXAwa1BaTjZsWmxTT3VwRUJzOFB0WnBJYnFSUnlqSUczd0lQWFErVnBRRjhla3lHY1Y1SFA0cm00c3ZDcGRiYzB1SWwvcmhZMGNmN1JxcTJOWkZ0WmJqelBGZmN1eDFqNFhrWk02Z25zZ3B0b2wrcGpmaFdvdVl3SStOTjZrRW5sVGIxMXozMlhTelIxT2ZrNzhTc3VqTEx0TXpmU3JIbUpHNVRxVVhydXFSMEI0Z2ZFaXZyb1cwekpUVnBTdXdVc2JoSWNoL2IvcFVsc2IrTHVRQno3Q3Jrck5HQWZUcVB3T2htblczeE5DcldUSDhDc3ZLc2ZKaGJmSWVNVWFhOXNIZ3NzYy82KzVRdkxoTGhnZjFBb0pjYk1UL0FKVnJycEt0V2l5Ny9pMzh6bnJMYW1uMi9DL2tVaDQxZHdXTXoybHhDWHh0bEhPODBEZTJXWEFYbnNtUk9wWnJXVlNSOE9HaThsSlh4L1ZmekFjVjl0dkwrRDYvUUJmZWpLUzN1UnN2SEx1WS9VMjhNZHpuTHVOcXJkbTA1cFozQzBKQWFTRndXUFg4Z05OeGF3bmI2ZVhpWCs0WkphcStzYXZ4OEg5Q29NcExiUVFkaTBqVVBPQVJJTjJJYnJVa2Y3ZEhWTWl3YjhkeElDSXhGYWJuOGZYVk9XNFRpcHBKWnVERUVtTXlQN1F1SkxYZ0k0S0RseWw5cWs5TnFtbWhtNGFZVldzeWdTTVMwa0Qyc3pNMFNCSXJseWVLUXFzbkluNTEzSzAwenZySVZYanpTR0ttWW1meVB5UmJhT1hsRExLa0VKUHQ0d1JqaUsvQUFEVjJKYmF5QThxKys4TG9kQitFWWpGMitKeWN0c1BjWXpaeE1CN3h3a0g2QTFBT1lGUXgyMzMxblo3V2xCR0NxN2xzZUwzbUM4YnhkMjJRdEhsa3hTUjI4VjVPQVh0RVFndENzaWhtTlRYWU1SdDZhejliTDRocTJwcnlLYnkxbGk4aGZlVVp5MVpKTHhZNGhMdWRvd3hsYVpLcnV6TFRiOHRHNDdOYmE5Z2F5bHV4V2t1UEdTaHZMbTJqNFcvMUtxc3JVVGVSREtBQjhhQS9sbzVPRnFCdlhvYU1INWEvMi96bGo1SmlrV2ZOUXpSU2lLVGx3NFF5Y2l0QjFMVTRnLzVXNmROVjVjSDM2T2o2TkVxNUZqYXNkNng1S3l6L0FJZkZmeVROWVdseGF3NUdlSzdBUm82RU5WcUZxRkNPUld2dzZnNjgrdGh2eDhtMnJVSFdZTDdtclJKenI1ajU3aGZINWNpMGhodmJNSlBjV3oyNnR4U1FWS3VyUFNxVEhhbTNYYlhRNE9FOGtkbnAvVVB5KzVyRXA4dnhKeGxlM1Z4a0x1NHlOM0laTHE1bGFhWjJOV2FTUWxtUDhUcnQ2cEpRanpLOTNlenMrck45aFBMalpyVEtMRUpVU1EvdHVLeHljS2M0MitJWlRSaDhEcFBWUVJUalVmSHlidER4dFZXSlI3YWRlTE1LYkVqclRiV0NzY1BVN3g4bHRlbFFpYlkzTVZ2YXBaeWtNcEJiblhxNjFvYS81cTZIeVZiYmFEK1BrclNpcmJYOGZxTStLRVRxd053ZVpBbE1DcUNRVzlkenNCb0xKOERVeDJsUW41d1NiZXdXNGpubGtnRFJ6dVk0M1FBVUFlaG9WcjgvVDg5UnRlSVVrS1ltNWNhTTJ5M010czZZdTNEeXhBY21scCtsM0ZBQWFDaS9QMHJxS3FyZXA5UzYxN1VleFMxMUdiR1hOeXpmU20ya0k0cXBuZE9TTXdZaXJBY2VJL1BRMTZycklUOTlweHRmeEcrMmp5SWFPTzB0eEpNS2lTR00wNDBwdUEzeUcrK2c5dFgxQ0xaV3ZQeUdQQzJNendJSlkwZ3VIOXdpVmxkaXc5dENUdDFCRzJoY21QOEEyc3JlYmNwWXpXMW5KWUZyeGdBc1ZTR1FNYUZUUVZKR3dPaDBuVUZ0ZFg5Szdteis4NU1xNXZGUkdCNHBMYkRuVnQ2Rmd3RkZwMTY2YXpUWkJZSzl2ek9iUHZmNUpsTDYxdUk0VFdLYWFHMEtJVzVHWmcvS3ZyUnFEOVFwK2V1cTlsNDlVOXo2clV5dit4WnJZY0N4VmVsaXQ3U2JKNHJONHJKV3ptU1dKYldJUlNGSGtGMVk4VHdwc09JN1ZCMW9OdXV1Z3R0dFd5Zm45R2NualY2M3ExcnVTVWVhN0R6aEVzN2lXYUg2cTNodHJmTHhtMWE3VGhMSkJkTHdlQ1pnUXFtTXExUGpUODlaMlJ0SmFPWFh0K3AwSEdyVjJoTkpLeWllc1B0OGcva1VoRVZvSkdqVDZ5WTNBVUVTR1paUkZiajlMY2w1dHpicDFHaHFmd05ISW9hZlp2OEFrdng1aG13UkxyTllxd3Nvb29FdUxHOUVEQ3FkeTFXUkU3aWM2MEpkbnJVR2czMzFVMUZXMzRvdDNKM3JWZDArbmg1QUxLWW0xeVdTZnlLM1NFWXF5amFDQVN5VjdjMFBhbUpPMUJ4b1BiNmxqVTlOWDB5dWxkdmRndHVPc2wza1ViYXFQZytwT2lnZGJISVllMVY3UEZ5SkUxMWRTeE1MaDVibHkxZU5HUHNMQ2crRmVpNnJmVldlcm41YUJWYXJhNkxTc2F2dkxEbUhpZ3d0bm1yY21HQzVndGt1WW8vK1hNYnE5SWQxUWdrVXJHckNvMjM5TlU1Vzd0UHovUXV3MXJoVCtINXNwdUx5dUxNL2VhNmUxQ3o0OXNkZVlhekFXbFZpeDhpcVFDU0ttVmE2NlhqNE5uSGg5WHEvbWVlKzRjdjczTGI3TDByNWYxT2diVzZHVnk5cC9iWE53dUl0b0x0QnllSkpiaktCWXBDNWo1Q3FScVR4YmNFOU5jcGFtMmxwMDNOcjVMK3A2RlMvM0wxYTEyMVQrYjhSb3lVQ3NMZTBqbFl4M3QxRll4T1ZZc1ZVRm5ZQmEwSVhsMUZLNkR3TGRkSjlGcVg4akw5dWpzdEhBLzM5a2JtN2RWOXJBazhnQnNvUFRWSGZVNThWTS9iUXBKRmJMRzhrczVEZG1Qa0EwYU1BN082MDRpaG9hR3AwVHgzck1kQjlsckpwTVNyL0FBRmtJWjdkemNXY0VwUEdOb0drUVZPNTVVTkswRlNXMWVyZHlYcFdpRURJL2E3Q1R4VFRBdjN4eEo3SU1oUlZINldLclQ4ZDlIVjVtU3NlQUZiaVk3QUhEZU01bkc0eTd1UklzaTJwYzJzQmxSWndxR2hvVllNTjZiRnRiSCtTdHF0M01yN05sZDFpVVQ3VEpQZFFMTGMyeUJFSDczR1plNENPdENWVkNCL3ZGZnhPaTY1Nk54WncvTG9WWk9KZFYzVldubUZQcExlUlJKRTVxUUR3WVVjZmwvNFZHcm5YdzFBbjU2RWQzRVZWcnVEcUpGc2l5WFBYNDZuQkVpTlAxRmZYVW9FWXE1UFRTZ1I4MVdQeTBoR1lGT21tRkJ2VlJLQUcyK0dtRVoyOXFXazk1NHFPaDBwRWd2YjJham85YTZqSktDV3Rvd0ZBUWRNT2tWVDk0cHBZN3JGNC9uVU5HWjJTbFJWM0tWcitDblQ0dGJ2eUtzcjBLYnVMSTNBbnU0SkJJVmY5eUxvNERkRytZcnRvc0NnSHRISWdCZFNvYmRTUlN2NGFReCtoUDJKc0U4VCt4K0xXVWNibStTYTZjZERXUm1JL2xUWEhlNzVKeXRmQTczMlhBM2pxdk5zVkpyejYzT003ZzhZK2JrMXBRUktTYWVuWHJvSEhXS25ZNUxMZG9ScmFKcmkxdWw0ZnVFeDI4UmMwUEs2WUlhQWY4ZW50cHFYVmFndTdEM1FzclBqUFJvNG82MFVNYVVGVzJJM29BZFp1NlRJNUZOMXBKT0w4Z3RieUJidEpaRGF6Ujl5QlRFVWJqV2hEYy9kVVU2VTFWa2UxdFc2Z3p4U3BxVXgvcUZuaU41NGpid2hWU2VXK3ZqR3RkcUxGR0NSNmREcnJQK3YxVzI5dkZuS2UrMmMwcSt5RFArbmUxWnNmNWRlT2lrUzNsbmJ4aytwaHRpL0dsUGpMcW4vc1Y0KzJ2aVI5a1VibjhDKzdkRExGYVJ1dnZWdys0MkREMFA4QUhYTFMwamRiOVQ4ejgzYzlscmZKK1daNjdXWldlYkkzY25HdEc5MDdub2RlajhlanBob24vdFJ5bkt6SzJlelhpU3JTVlNmY1NEMUorT3JHVHBaTmhWV2hZamtDUlRjMTZmUFZEcTRDZEF6aVpiM0h1THl4dTU3ZVlWNFNReU1oTyt4cXROQzNyVzJqUWZodGtxcFRZOTR6N2tlWDJmQmI2N2h5MFpJUEM1U3M1SFFmdUtWYitMYXk4M0N3MjZLRFV3OHJKVktZZjYveUhLeCs2ZGxPeS8zTzF1TE5xMVpvaXQxRlg0Y1NWWWZsWFFGdUJaZnRhTkt2SnAzUXlZL01ZRExxcXdaR0EzQlA3YU5XSnpYZjlNdkFuOGdkQnZqNUs2TkJhekxxdWhqa2JkYlozVmlDU0tqNEhWTXc0N2grSys0RXp4S1U0bGRqdWFhdFRDbEQ2ZzZlQ3JWVktrQ2xLaWxLNm1yNmpXdzFlcUY3eUsxRFlUS3VpbGFXczUvZ2plbWp1TmYvQUpLL0ZHWDdqaC80THY4QThXU0xCRnV2R3ZIb1dOVlJKU3ErdEdRZi9QWFVlN2ZzK2g1MS93QmZyUElTOG1LK1V4RWdDS3ZGbFZqekIyRks3RTZ3c1dhT3AyWEk0UGgwRkhMbksyK1N0ckdMSHRQWVNxVExjZ1ZDVXFlbjQwMXA0TDFkVzNhR2M3eThXV21SVlZKcXpBMnRFRHBWT0d6aW44L2xxWDNKSzNoYTZhUVJuajRrN1ZCRmFOdnExWGJLYllpRzhMTXdOUFFnL0dtcmQ2QlhoYkYyNzhQeDNlUzdoTGpma1VMVlVucjBOYWFKV2RnT1RocGFvbHZpZ0U2QWlncHB2dlN5cDRJRkR5dkh2YXJibFZvc2hZTWVtL3B2b2pIZmNEWktiUWJqTWU4b0xLS0FkWCtmd0dyQ292Nzdndy8zYjdHNE9aUnphd3lVUElqWWdTMnpvUnY4MUdvSjZsbGxvVU5IM0c5a2xTb05PQU5lbXJHVkJlM2d0cmRCYzNCclRjUi9QOFBqcUk1Q3lnT1U5ME53b1JPa0I5bzI2ay9FNmNRdlZsdDVPVWJHT1JlcktTQ1A0YVRFaGx4OXhrNDdZM1dSbEFnVVZqN2dvOVBqVVVwOHRNVFZtRjhWOXpjbmpuQ1Ezc3ZaUSt5TzVBbmlvUGsxU1B5MUIwUkpaTEZtZUwvZE9QeXVjWURQWUNMSVc1VXNzNHBKR2ZiV25DUUU3MDY4dFFkWFh1VFZsYnFnTjVINGJpNHJ5YktlSTJhMk4xSXA3VUk1Y0UrTkZldi9BTmswMVpXM2lSZFBBYnZ0aDRqNUg0dEJkK1M1NldLVEtTeExQYm9oUm5qU09SWmlaR3IxWUxzQU5BY3luM0s3VUc4Uyt5MHZxZHlES3kybU94czBJSWhlT09RUXBSZ3NiZ01CdHVCNjY4N3pLK05LcS9JNmV1T3VTMW1Bc3hrRGVXMHpSTUVsaWVXQjM0MFZRUVdVc2VsT2hCQjBOWnUvVVB3NHRyaDl3UkZlNXUrdkxTMmhoZWQyNzExMzFWZ3dWalZObU80QmJpMit3MFBURzdQMDlmQUlkYVVxMjlPeEtqdUxiR3l5MjgwTWl4R1Y0VDdRV1NhaGVsZXA5akJ1VlNQanFWc2RxT0dpTVBJazAxSnB5Rms4a00xeERCM3pHNHBBcXB4OXk4dVZXb0FhOGFVWVZIOE5IWXVSZEpxZEJxS2pzcEV6SjRUQzNWM2JYTnM3WWpLNCtSVWxqZm4yWmtRRjZNaDVDZ0lOR1VmTFI5T1RwNmdqN1ZwbGVwRzAzRnZqYmUyNVFOUE1IN01jdG1USXFsL2J6YVJRSHJ4cFhrS2ZucWRWdjZOTkUyOXVqVzBYYjdNNDZPNWFOb0ljamdKUVlvTHF0Q1dtSWRsWmpYZENDUGN2NTZzKzFwSzBZNnl5NGZRVHIrMnMxbHVUWmZXd3dwSnlnQVplSnFPVE1La2U0YmJlcTlOWFZscldDMzdpV2lITnNSWmkxR083UWExUzNSb0hkbGpZWEliaTNGd0NDS0ZXM09obGJXU2RxcVFEay9HWW9yTTNFdHNDRzVGcFZvR2lDbmlBUlhpZHQ2bHRXVXZyb3lxOVUrb2w1ZkhJd1V3VktSR2hKSHVCSStCM3B0bzNGWm9DejAzTFI5Q2hQdVZqN20weVJ1RldsdGM4WFlVNk9vS25mNTAxMVBHdnVvZWU4M0c2NVhQY1dyS2tjSEpKVjR5QUFxUU9WUjZHdWl3RU9ZdThzTWFoS3AzYmlkU04ySU1acUtFVTJPb01kSFZYMkw4emMyVW1CbW1aMXA5UlprdDhoelVENWozVS9IUU9la09UVjQxOTFZOEM3ZjdsM0ZyeTIrT2hnb2dYTit2cTM0YVFnVkpjOTVxVjIwNGlqL3ZSTVpiZ3dxMHpSZ0lydzBLcVdRYm12S2hVZmxyb0sxYXhZL1RIcDY5bkwwK2ZpWk9leWQyVUhLMEJ5dHJjQkNIRTBSWkFhcUFDS244cWFGS0NTc056ZjNHVDhnRlZOcTZLc3lramozSk9DQ29GYW11NTFCMlNhWGlUVlcwN2RrZEs0M041SzY4Q2x1Y05iUVM1TEVSVkVFNmxIRnBIRldZTHlvV093YWhJcVJ0b1NpVzZHRlhtSk9aTXBOam53MEF4YU10bTE1TklDNEFKZDQwQm9Lc2FDbStqZ0ZzYmZCc2dtYThVbXd0MG5kVzBMVzF5aElyMko2dEU2MS95c0dGTlUzV3N5RVlYS2FLaHk5bExqY2hjNCs0SDd0dkl5RS9FQTdIOHhvZ0hhaHdQWGdOaEpkMkwyYUdqWE85UjFvRDg5QThtKzNYd05QZzQzZDdWM0dxSHd3SVpZNTR1UW9VWlFPcE8xU1Q4dFo5dVYzVE55dnRqVXl1ZzIvWkR5Uy93T1huOFV1SkNtVHc1TFdSWS93RFBzSGJsdzM2OEsxSDVmRFQ4cjFWV1JkeWppWTJuYmozNnJWRjlqS0tiU0hKV1lTVEYzMFRPRlQzVWxSbURsZUoyQUMwTmZsck56WTAxNWhHQ3phYWVyUTRZZVdPL3cwME1BVjViZGUvYnN4WW1nWUZ3dndxQnQvQTlkQ1JOWFV2cGVMcG9UL1ByYUdXNHR2SUp0OFpqTFJvTXRNaWt2SFpYc2dSWjBJNk5hektsd3ArQWFtdFAyeXoxVC9EQnZkcUpWcStqNy9Bb1h5TnBZczFiWnFHM1JaNDdpUmI2MmpBRVRPQXNlUmlIRUFjSkVwZFJqcFRsclZXcWo4ZVJndlJwL2p6S1Z5R1YvdVdSdmJ1TzNlV09SKzFCTEkzRlZzNEFJb1VETVRYMmdhS1ZZU0JyV2xpL0hITGZaSXRRY1lUN2l2dUZhK3A5ZFdkRVZMVmxrNHkxYTNzTzRyQlpOdmN4QXBYWW4veTBDM0wxTkZLRUZMTzJTYWEwU3dpTnZOY3lSdTVEMWtESVNHSlBRbzFRVHk2SFViVzAxSjBxcFRRVnZjM2U0MkxONUNXTkpzYmJvMWxhS2tZcElaQ1ZUazYxcFRseUI2R2xCcWpZck5KZFRTV2E5RmF6NkZhZU1keHN2SE9JZVlnVXMzRVZHKzIrdEMvUXdFMjdTWDc0UE5rR3lFTnREYVJqeHk3Q1MzQmptN0xJYTBvR0oyZWlWWC94MW5ab1M4dzNGTStSZE1PSHNNamg3YnhpeXZZcnlPNmhqU1MycXNjOFZwYXJ4MkFVaWpHckZ2MU94K1dzbDNhMTdtbldpYk9iZjlRV2RHSHZyN0FZNlYyZkpNa2R6SnkyV0sxb1NvQU81NUhqVS9BNjB2YnNlOWIzMktmY245cGJGMXQxRmZ4elBMZGVOQnJDaTVDS0V3WHNVbklSR1ZGS0syM0t2Y2pKSk8xS0hSdVdzVzhqTHcybGVab2Z4OXNsZTR1d2FORmx1SEtTb0hTTUtrZ0xSbmszRlExT254MHl2RWszU1lIL0FPM0hrMzFjL2szMjl5UC9BTjBNM21vNFQ0dGVwTWJXUjcrS0FRTGJ2TkdRU2tpeHFpaDM0aDE2KzdXYnpPUE8zSlZmdDYvRHhOWGdjcDQ3MnBaNk5lZldOT2hRdm1COG54K1Fsd0hrVnZOWVhWZ2UzTlpURTFWdXUrNUJxRDFCMzF1WUZqZGQxR25QY3hlVmt5enR1bXZJVzZBMEtlZ3FkRWdKTGltSmphMGNoTGFZaHdLVjR5QUVLM3hGYTBOTkllU3lwTEMyS0xib3Zja0d3SnF2SmdmMWtuNC9ucm1sZDlUMFY0YXRLc2FrZUZiY3VZNWdnbDVxZUFIRlFQVWNpUnFWcGlWMEZUWk1XanFGNHJlVzJDei9BRTd1dDBDNE83Y1VCb05nZi9ucW1kMms5QzJ5ZFBWSDd0ZmdNTm5KM0xtM3RiQ1FRU0twZWVaaWVKVlZKb0J1Rm9lbytmeDBIZXVqZGcvSGw5U3JYUUl0RkpjT3NkMnNNY2ZJUFFvSlBhQWZlNHFUdVRVamw4dFZhTHBJWExzb3RFZlVsNHhKSGpNTnN4RWlKM3JaQ3Y4QXpVcVZLa2tnamZjaGo2YWhlRjFIb25aZGVpMExBOGZXK3NOcnMwa2tDS3BBTFJ0WGM3MTYraDI2bldYbnZWOU9nVmp4UCs3cVdGWnh1d2hrdjUwV0JDT0NvS2dCaFdqMXJYcWQvVFFxdWdhOGE3VnFHYnUvdFVVV2pSa05JUWtaVWR4U29wVWI5QitXazdidEFXbU8weUxIbG1XVEQ0cTRsWm5GQTVRMW9TV0hTcTA2Z2IxMUd0WGUwSVA0OU56bDl2NEhJUG1sL2ZlUjU2SjRMWnhGYXpGTHNWSkprTEdWQXdJVTFDZy83TmVoOExFc09QcnF6enYzYmsyNVhJMDZWMERPUnh1VDhSdG5RT3NrNFZYc083RWFLbkdTZVJwa2VvV1VxYU5HZHgrR3FsYXVaK1hmK2hmVzE4TllYWHQrcitZS2lqU0MyZXl5cUlKcFpvVlJ6N2lJMEhzQU83VkRTZTQ5S244dFd2VnpYd1kxVnRvMWtqVnI4aDkvdGdheGhJbEVsdkd0bERhbmp5ZnYzSE81a1VxVFZ1SWxValliYXpuYjFSMzEraDBEb25YcnA2WStMMURYanVVeHNFdGkwVU1yeTMwRXRsYlRSSXJ0YjI5dUlrNHF6RlY0dVhNajlLME8rcU10TE5QNGwySEpWT3NKOU5INEpFSEwyanlxTFRHVUZzWjFsbG5rRFN4T3R6SzBhQVY0bzNOQ1g1ZEs3ZW1yYU5kWDEvSDZGZVZPM3ByMG5yMW4rY2pWYkpMSmpzcmtsdXVVc2NGdkZOTEdXTElZSlFXNGhoVUFyR1VKL3dEVCtJamNOS0EzSEVQWC9VdzhnOGx4Mk04UjhoOGh0VldTK3RicVdNVHNDN2NvNCszQ1RYZGVWZUs3YjEwc09HMXN0S2RuK0dSNVBKcFRqNUw5MXAvQkhNLzIxeFdUdS9NTVpKQVJHcVBKTk5MSWFBUkpFN1NuNWtJR05QWFhhM2FWV2VVNDFaMlRSMTM0Zlp5MkhpZGpldUNiN0xPdDFNQ25iQ3JOR0NSeHFUK29uYzcvQU10Y0J6N3A1ZHZnZXUrMVkvOEFpVGZkSi9VODhrODVzdkhjN2g3WVd2MXIyVVVrak1DQkpFMXdnVU1nSkFMMFg5TFU2Nm53OE5yMXM1aWRBRDNYTHNkVTFxOVN4UEhQdkw5cy9KNngyMllTeXZtTkh0c2tqV3JoNjdyeWFzWlA0UHFqTHdjMk9acm9aTk9SVEowWWZ5a05oY1FyUEdCUEVpbFJORklycHhiY21xRTdWR2dsZU93ZFdyRkd6RVVra3YxMGlKR3hFY1F1R0Z1akhseG92dGNyUVY0L0U2TGVOYlY1a0hrdHVqc2lGbDhWYnczSng5amNUUDJ1WEpKT0RCU2ZjM0VzZDltNk1QejFRc3VzUjBDUHR0MTN0cEZPWmJ5VHpmeHZNM1Bqc0MyZHhERkllekZjUkF0eGRSSXE4OWhWUXdyVTY2ZmpiTW1KVzFNUGtVdDkxZE5lbllCdDU3ZkpOY1cwdUd4ODE5YzFXVDZhcXl1R0ZDdktOeTNTdFFQVFJDd3RyUnVQZ1VYc2szVnczNEpnMS9JUHBaVmovc2JqR2JCcldOcFdqQnBTdjdvcUR2VWRRTkdVNmRkUUhKU3kwalFoSHpTV3d1RWh2SUpKclNia0lra1k5eGFtZ0ZHTlNSL3V1Qjh0RjBiZGVzZzFuVk9MVmdaK1VGelkydVJ0K1lodXc1Q1NLVlpUR3hVOWRpTnZUUldUajJ4MHBhMzk2bjVmMUtOeWRtbDJJelYxU09mTHBDTmdxUnQxMUZpTm5DU2xhN2FhVUl5QmNBZWxOTU9TSTVpYUtUWDRhYUJRRW9KU0VBL2hxSklsaVVqY0hUd05KUzMzU3VwTGp5V1NJSzNLMGdDOFpEUVZLMXFBTjZlN1Q0VnEzNWxXZDlFdXhVOXhCZFdzdkdkV2prWUJoWGFvTzRJMFVCRXJEMmt1VnkxaGppeGI2aWVPRVZxYUt6QUgrQTA4anBTNFAwTHljcVlmeEhHNG1KZ3NOdGpZbVlIYWhsS25wL0hYbm5LYnljaXpQVy9hOFNyalQvSFFyYkJxa3EzODhoNXQ5S2R0OXUreGJZLzhJMFM5RUd6TmlYaTJhNWl4d2ZjWEYzR1M2OVNZU1NwMy93Q0QrV3FNamdOcWxzTHd3Ti9hM043WjJ0MldnV1ZvNHBoSXRTUSt4SnB1VFgxVTZ6c0xuSWt6QzVPTzFhV3RYV05RNzV0OXpQcy80em1YOGI4bXUxdytUTVVNOGVUbWdtRm02cUNWQXVBaFFrVTk2MXFOYVY4VnM2ZjI4Y3BPSlRYNmRUa3FjakppYzJ0QzEwZm4rTkRuRC9VYjlOLytNTEE0dXpkbXRyWERDOGplb05SZVN0SXBxbXhCQUZENmpYUit6NEhpeDJUOFRNOXp6L2RkWDVENy9wNVdGUERza0djQjdyTlhUQUgxV0MzZ2lGUHdJMWcvOWp1bm1wWHlmNm1sN1BSckhhM21YRkJMTmI0NjhsbUFwWm84c1ZhMTRvaGRpZmowMXoxZGFOZHpXdkc5UjNQeWJ5Q2QrN3VicGd5dE03eWwxOTN1ZHVYKzNYcStQOXFSdythTjl1MnJNN0xJNWEwSUZ2Y2wwL3BVbmtQNEhVclZSQ3JhNk1aTFR6VzR0dUl5Tm9UUTd1bnFmd09xZnRwOUdHVjVOcTlSdXhIbXVBdUNxdEtJWE5CU1NvRmE2RHlZYnlhT0htNCs0MzJPUmhlTXpXOXhISlUxWGpSd1IrUjBIYkg0bzFjZklUMVRSUGp5RVJjUnlKd05EeTQxNC9IZlZEcEFaanpwdEprL0V3dm44cGJZbXhZRGx0TklCeUNJVFdvNjcvRFZWbHQxWVp1VjRyVTZFbXdOdEhCQmJXcUhzd1Fvc0hLcFBGVUhVbmY4ZGM3bXMzZHRtaGd6T2lTQlRXRTBYYzdocTZnOVBUOE5WVUQxbFRpQVRQWmhTQ0dwSjFBMnBYOHRTU0RLNUFMNURZTTJEeXBaZ1NMTzRMQVVwL3ltT2lNRnR1U3MrS0tlWGRQQmRmOEFpLzBBSGh5eVhHRDhlaUJCWlZrM0kyTllUNmE3UDNiVEN6eS8vcnRvNWRmbUU3L0R1eFppNEtVcElpaWcvTFhIMXl3ejFPK0IzMUUyOXNaRFNGRllyK2xxaWhJK0dqcVpFM0xNakxqZTF3RHBMRUlvdDFWaXhQSXlVcXRSVHIvQ21ydnVkd0w3Rlc5dmlRSmJKakl3SzFGS2ZJa0hWOWNrSW92Z1RjR2syTkZvd293cVJVR3VyRm1CWHg0N0ErNXhoQXB4UEt2cDBxZEUwekFXWGlOcm9hQmJjRjdFaW1xN0s1K0h3MWZ2blVEdmhoUTBSNy9FMnNzVVNYOEt6Vy9jSE1FVjlyQ2xmeU9ucmxoK2twdnhsSHFXZ09uOGZ0WURKRmFzRVJhbU9QNGo1SDhkRVZ6V2ExQUw4ZXRXNEgyVGxrdnNiazdCYXRQWnpRdXFEcldPY2piOG0wVXJhSUJ2VmxKMkdHdld1QkRMQzBKWDliT3BGQjh2anFidWtpcFVjd0Y1c0FzcjhYNThxYk1EMCtIWFVWZFJKSjQyTEYzWmkzbE1TTjNlcTlLRUViYXNSVWE0b3JXeWI2MjlISngraU1DbzVVNmZEU1lqVmNaYUxLVWh1b1NBRCszd2FsSy9FYVNRbUJuUXJJWTFGVFdnQTNQOHRNT08vaEdBOHF5TTh0dDQ1YXpUNUNHTjd4emJ0d2FHS0ZTek03a2dBVUd3SjNPd3FUVFVsWGMwaFRHcGFmaFBrZGg1TGFsTDhKTmxJRlAxTVlUZ2ZsTXZHbkVOWDM4ZHVXL3JvYXlkWEFUV3lZUXZybTh4dDNaMjJPa2Z1WE1oNFJ3MWxZSjBaaXhQRUtvTkt0MTZhYTJpbGtxNnRKSGNmaERXOXo0RGljbmxPVFFQYUxieThhbGtraUFqcHQxb1ZOZGNJNnBYdEtsVCtwMHJ1OXlWT29yMlYvYVJYdDdaU1NVcXZNMjB0WW5TTldaWEJWalVnaW5GbEZOWWJxNk9ZT2h2VnV0WCtQeDRrL3hhOE1lUVMyUzRTWXBjUGJSSWt2dWEyRGU0eUpXdFJVZWxOdm5xR0t6cGtWcXlrRGNxazBiYTdUMDduTjMrcU9mT2VGZmVHWEllT1pHNHh0djVCanJhNm1qUmlJWkpiZmxhdVdqTlZhb2pUcUs2OUh3NHNlYkN0MVpqUTVSY2pMaHZOYlEzcUMvQ3Y5UmZrV0VSYkh5Q3lPUXQrQWlGemJ5dXJLQ2ZjeGhrUEVrK3BCSDRheXVSN0pWdWNWbzhqV3hlN0s3L0FPYXVzOVVXaGkvdUw0cG1qTGNZL0pSNUNabGtXM3RMcUdseURKV2lOQy9MMW9DNmdnZGRZT1RoWnNMMVcxZmtkSmk1R0xOVDBQWHVwaGpQZHJnOFU4cHVVYXdra2xOTG51c2dVTWFjWW5OYWdHdTFSMTBPblp2VFVJbTlsMWxmanFLK1U4TUdRdDJmRjNrdVJpWmFkaVczU3puUXgrNFNxZjB5OEswY0gzVTZIV3BqNUttTEtBRzlMcnFoUHpQaU9YWm1udFpGdTVZNUMwNlFyd1diaitzZ1UyWlQ3ZmlSdUJvK2w2TmVFbE50NjE2NjZ3TmZqMmNudTJ0MHZKZm8rMmdpdUxTZ2tqbmNWWDNjcWtFVVhlbzIwSGt4N1o3aGl5YnRaZ2tTZVFaWmx2N0xGWTZCNXJZeFhjeHVIUHVnb3ZjUUx4NVZLTjByOGRQWEN1clpYZk0yOUZxYW04ZXh0OWJOSWtrQnY1bzVRaFZKTGFNRW5tQXBrUEVnRWpia05qWDVhWjJkYmVRcTJUWFFwMzduK0ZXdDFoYkM3Y09peXN0dmRwTXZDV0c1SUd6S1RXaEkyYnByZjRHWnB0SE0rN1lxMnJXeHpGa2JHWEYzODFyS1NqeE1WM0c1RmV1dWhUblU1S3lhMEp0amQyZHZMRUdVeW9OMlUrNmxmanBERmorRStZWEdPeVVNdHU1aSttWW0zY1VHM0t0RDZmbCtPcWIwVmtYNDhqbzVSMU5oUEtZODdZUjNsdW9pSkhHYUVOeUN5RDFIeWJxTlpxVFdqNm13ckt5bGRDZExjc1FLNzc2Y1JPczRLcUdiMTMwbUlwVDc3WGQ2YjFiTjFaYlNDTlRGUWdxeXZ2eUErSk5RYS9EWFI0c08zajQ3cHpXOC9LeTBhK2tSNUdQeTdldURucTZTNGNxeU9VVlhyRUdvTi84QWkwSGJxVkp5aTNvTFBCeWZhYk1qRVJQRzBxVzJSam1rYms4a2lUb2s4ZFZBbzBiVW9PdENEckxzcmZmclo5RFh4MnIvQUk5NnJ2REN2anVYbWhreWxyZXdMSFpYMkl1dnBtNEZXTXd0dVpxL0pxRTFJM1gxK2ROV0pSclBjR2RtOUkwZ29kWHA0N1lBVkNwYzNWYTBvV0t4N2oxNlVCMGNBRVR4SHlQK3c1Mk83azNzWngyTDFQakd4QkRBVkc2c0F3MHJLVVNwYUhJZCs0dUhtdmNwYTVMR1F2T3Q3R0FVaVF0UmxGUjBydFRVYStsYWxtVDFPVjNEbmdtTnkyT2EzWElRUGF5cVIybEpGWFVHdlN2VVYxbmNuSld5Y00xL2I4ZDYyVDZNdHJKWlB4L0VSQzl5MlFodGxtRlJDVzVUY2dLRWRzVlkvd0FOWVZlUGt2cFZObmMzNS9Id3AydXlwczk1alpYSGxtUHovaVVNaVpISHE2dEpPQXF5cDZCMFUxcFFucVJyZDQzRXRYRzYzZWpPTDl4OXpwbXoxeVlVMDY5L0V2UDdJK1g1cktXTnhpL0lyUkV1b1pueVdObEFSWTdnVGdGNEFpRXFxdlhjSHIvSFZIS3hWV2laVnh1UmszYjJpOHZFMWl4MldnYTFrWVlxNDRQWXlTOFN3aGNVU092K2JsVlRYV00zNnA2RzFsUzJwcm94M3ZmRnNQYVMzTThzS1RXMlZ0NUxTNnRqK2tST0tPU2gycFZqc3RQWFIrT3lwYVpNL0szbHJEN0hDWDNRVzg4V3NzcjRzOHdseVgxUzR2ay9WbzBYL3A3dFdIcTFxV2lrUHhYV3JpYXUxWmRPdjlESnlUVk5GT1ptN2lqdCtDeUJpOGFSeFJDaFZRZ29PSTMwVlhVRXQwUHZHYlZqV0tSR1NWbURNcktRU1BUcnBzdG9KWWxMTEVzN1pybG9ySHROSXNoNFNCUlZnQ05tRmFldTJnM29wRGtwY0RmNHZaeDk1cisvdFVudXBvWmpIYjlzR3NVRVlxSGpJcFFxYVZyV3BIWFExMit4cFlhMW1HdFdMWDNSeXVIU1BIK05ZVm5Kc0lWZk5NckFRdGRNT1N4S0YyUGI1Ym4vQURHZzZhczRsYk9iVzc5Q3IzSEpXc1k2ZHVvOGZhbjdYd3I0dXVXeVR4VytWOGh0cDJ3TWtzZ2pBa2dZRDNnOVZmbHgxWmx5YXg0R1ppby9xRS90NWgvSzhkM1RmWVo3bEJjaXh1cmVXUVc4VEtITE0vSnp1b0pyVlFmMDZENU42dm96UjQzRnl2OEF0Ry9LK2RZenhDVHlqSVc2SjNwWUVGem1yVk83SEd6cVlUR3ZHZzdnY014cXhxUDQ2RVdONUZWZmthZXl1R3p0WjZWNytaeGpuY3hkNTdKVFpTL2NsMzlzU01TUkhFdGVLQ3BKb0FkZEpqb3FWMm81VE5sdGx1N016OFM4bG53bVpmdFRkbXp2NC9vN3BqWGlFWmdRN0FWcnhJcjA2VjArU202cFhTKzJ4WVdTeDB2ME0rVitvRThkbWtKbmtDdHdaS0VMUXNBQ3lqNFYyMW4xZlkwWFdWTWkxZG5JdmVSM3VNdUdlZU5WdW9taXFwb2xHNm5vUXcyK2VybEVReXF6Y3ltUG5uU1o3N3VXTnQ1eEhhVzExY1k2MittejEyclEyOGdudHFBaVFWVWNhTXZGeUFXSnA2YUJ3Yk9LM1NZVGZwTlhKVjh2SHVTWHA2K0pXcWVJU1pERHJmNHNyTmVFTTB0bEdHTTZLblZpS1U0MDlhNjFhNUl0RE11M0hUcE5lb25VSXFqRGM3Q3ZvZEVtYVBhbG80QXBDOW8rOHVDUzNYcHNhZ2F4SHF6czYyaXNhUjFKZU5qaXVDSXFzSlNVRWJGbFVIajFCcld2eC8yYWhrbGFsdUYxZW1veDQxc2dXbVVvMHBqUFpnNEtHb0VHNEpMVTZiMW9kQlhWUStsOGpsTVBRWEhidVpUYndxcVNNcEJhakF4MUZTQWZhT1o5U0NQNTZHc3BXb1hTMFdsZFB4K29TdTc1N285Z09YTW5PR0dLUThna1Fmay91VFlxQnQ3VjJBNjZoWEhHcGZiTnJDREhqaVNQUERjRUpjUnpBU1R1T0t0R3ZSUTM1bXBQWDEwTm5XalhTQTNqNVdvZldTMk1KQmJYVnM3U2gydDFBSEtsQTFUUThTeEc0MzNIeDFpWHEyd3JOZHBxT29VdElaSVFBenJIYWxnZWJ1QXFxS2tBaW5JbitSMUJhQTk3VDIxSjhVMW1IaGtrU29Ua29kalFNQnVXQUpxTng2NzZUNlNWTldjbFgvZFB5V1BzSWpTSmJScFNLR1NZbFZhV1VoUXJVWUhjSGNnOVBuclE5dnd1K1RvV2NqSi9pOGExcGkxdEVWSGFSbTJ6V05pdklmb2JoTHVJeTJ6eHJHVEZKN0F3UTBiZHBhb3djaW5YZlhZTlRScGRJUE9xMmU5UHpHTE0yZHBuUElySER5c3oyS3ZQOVd0MWNNbGtacnExYUFBU003MFpXQzhxT1crQTY2Q3dOMXh1M2Z0SFh4TlBOVld1cXowbnE5TlZBbHZhVDMyVnU3T1NTQ1EySFpFUWlidXFZMi8rOWlRQmlDUWpoZU93MFh1VkVucnI4aDhkYmNpMWxwNlVvNy9qeEQySmh1TG1HeXVjd0ZXNWl5TTFyQWlGZVN6TGFKRzBybGlLdHhwUU1LYmVuWFErU0ZPM3BIOFE3RXJYUzM5VmFGOFk2L0VmTGpDWXpFWUx4dVh1ZHVlNnFwbGpQTXZIQW5jQ0gvTldHSjFIcFU2QXJrdGU5dkw4ZnFiSDJxWTZwVDEwbngwbjlBWGw1U2J2Q3dKZzRyaVdhMnRiZWVDVWdTd20waWxNWmpxdEN4L1VCUTE0L3dBYnNTL2Q2b0E4MW9kSHRUNmZMNGVmZ1RjQjRsRmR6NDJBeUQ2WmNiTk1XNHloUzhzaUNTT1ZDUnlLRnVPOUtFN0RWZWZrUW0vTUk0dkg5UzNlRC9QeCtRcGZmSEpSNDIyZzhXdGJZbTR2cFV2YnU1Q0VjeEM4aWtHbEZweUNIcC9Ub3oycW05dkkzMDBNai9zZklWYVZ3MVhYVUYvWmZBd1h1VXlzOTJsY2ZCWVRSUysxZ2U3ZG9ZdUlLOVAyeSsraS9jc3pwalVQV2YwTXIyUGpMSmxlNWVtTmZtZEM1cG83YVdOVW1STEsxV1BqQ3pEOXlJKzFRcEo2amtuSDhkY2ZXYldiYTFQUjhNVlNYeU9YZktQSk01SjVYbGIrMnNKci9GOS9qQ3dha2dNUUMxQkFQdzEyZkU0OVZocW00WjV2N3B6YnZsM2FVMVRqNkVTODg1eG1TN1l6T0puanVJdHZxcU9zM1FpakVGQWRFVjQ5cVBSbWRrNWVQS3ZWV0g0aGJBL2NlVHg2NVNmQjUyNnRuY2tTVzhsTzJWcFVWNDhsYjU4aHFHYmgxeUtMMVEyUG0yeDYxcy9neTIvSGZ2dGpab0pMWElTaVc2WmtrdTVyYVJJUVdvRkhDTWdBQWRhSVJVNnhzL3RlUlI5dlN2WTIrTjdwaWY4QTh2VXQvd0FieUZ2NWZjV3VSa2xubG8wZ2U0QWpoWHRvbklwU0ptclNsV0ttdXMyK0I0Mjl5N0dnOGxMVjlEazVqKzVWdmxNaDVUa3NsQmNPbGpkeXRJYk9nNGdWSVdoWUVydFRXMTdYbHFzU1RXcFY3eHdNbGJxMVc5c0lyL0UrVXhZTEtGb3JSWXA3ZHVLeVNSeHZLckRZaW9BcUcxdTN4UEpTSk9UeDU2NHI2TG9QdHQ5ellNaEkwRDJsdkU3eFM5bThTTnlVa1liVmpMTXBVa1VPMVIxR2dIdzNWYU0xYTg2bDdhaVI1UmtKZkpMNHpSeE5hMjdudVdWdTFEMnA2QXRHSEJyeExWQzE5TkdjWEY5cXNOeXpQNTJkNTdKeEdpK3Y5Um84UHkwVjVaSll6VHVaVkhHS0o0OStZRzQ1S04rbnIwMXAwcjl5bXhWOVd0cDhrdFZINWdhYTZ5TVFqNWVteDBCSllmTmJrYnFOdXAwOGlOZGVKM0ZOT0lsMjd4bWdZYWl4RTBRTEthZjBuNGFZYzJKaWdUV3A0OWE2YVJRYlpJSTQxQ1JIa1IxcnBEbXR3OGJMVDE2NlVqRkFlYVh2TE41dTlZS3NqM1RwR29OYUhrVDdUOE9tck1GWW9nYk5hYkNkTGs3bWVLS0dYaThjQXBHR0ZhQW10Sy9EVjhGRGNqdjltc1ovY3ZPYk9ad09Gb0RLS2pidXYrM0dLZmkxZnkxUnlMUlJobkNyT2FzOWpycjduWkJZcDd5eWhOUkdZclJTcDY4RjQveUpPdUV4MTNaRy9ObnJXTDBZSytZcFJUckhoTHU4Z1A4QXpwZXlyVUlKTVJXRk4vUVVxZEZOUG94NldVdG9ZUEVyUHYzR0xEdVFrSmtrS21oQ01zYXI2L0R1SFFtZHhWaExjVkxueG1Qank5MUJqNG43VndTT0U0SkJVaWhWbDQwb1RYWTZDcGorNVpJdzgyVjRxdXo2ZUFOOHM4ZGx4MzNiKzJPTXVBY210MUptY2kxdGRJaktza0ZqMi9mV29LMWV1K3RmaVliWWxtMnZYWitaelhMNU5NNnFtb1N0MjhJT2NQdS9kRys4L3dBbmMzZ2xueVZyRkRaTUkzYUpJaGJvQTBhQUdnQzdqNW5iWWE2TDJpanJ4cXQ5YmFzeFBjM1g3elZlaVJiZjJWeFN2OXY3VTI3Ri93RHE3MlZycmwrNmp2THlITUtkeHg0MExDdlhYSS85am4vSTFXbTA2VDJTNldDSjFub1dubDhqTkg0bG41VUpsdVlzVmVOQ0ZISjNkYmR3dEtia2srbXNqaWJzbDFSS1haMS9VTHlxdFh1ZWlrL05COFJOR2UxSU8zT285ME1nS3NDUFNob1JyMWE5WFMwV1RUT0YvZnFuMUJsM2ptSEl1bkZnTmlOV0xJVVhxK294SjQ3TTJQQmtqSlBCYWtpcG9Jd2ZoODlCV3VsWTFjZkd0YWtpOWRXY01GMjl1OXM1V0krNlNNN2xRTjlqb3VzdXN5WitTSzIydEgwQ1QyamQ3SDVCcmVRRWtKSnpqTlBUZmNWMG5xdFZJeWFXcWNCV0h6ZnlxeVBZbmNUTE1PUEpxRWtEYlpsMVM4R08zeUM2ODNOWHVkWS9abkNOWTJpNUdlUGxjU1JMSzVJcnVVNVVHdVk1OTFMWGdkdjdmU01hL3dES0M4cm1GYm1KVEpKMm1FS3VBVDdpR0EySHg2NjVySy9VMHd2SGFIb3AxRk80Z2N5TVlKR0hLZ0FjRmFpdld1bzEwUnJWdW8xUUp1YmVhS1lHUkhZeDdkc0NsYSt2OGRYSmhsTHByUWk1MkpaUEc4bEtVS0Y3SzZHNCtFRGc3NnR4Vy81Sy9GQXZKZjhBeDNYL0FJdjlCQSsycnlYbHRnNHFrc0VrS2dkS0xiTVJydC9kdi9nc2ViZXdPT1hVc0s2dDQ0MFZxZTQrMXFldGVtdUMzU2VzNDd0Z1BJNDlXN2I4QWFnMUk5Q0RTdjhBUFYxYms0cXdGbE1ZaWtxRWNVK0cxS2V0TkUweUFHZkFucWdVY2FhR1JUVCtvazlhRFY2dVVQR3UzWHVlUGlKQ080eUVLQjFQcWFWMjAvM0VQOW1RYmNZOHBRQUVFN2dnMDMxYXJnMlNrUm9RcnUwUkZhWHQxbDQva3grZnIvRFJOTFBwSUJueFYxYlI5YTJzVjlaMUtmdUZTUS9vQ0J1RDh4cTIyUjFZSlhEVzlUVFBpQXRGWkFXY0xYbCtmL2hxeXVjRHljWmRPNFc4WnNrbDhVOHF4N0xVcno0VTIzNHJKVVUvRFcxUzI3R21jcmxwdHpPb3VTV3lOYm96eGdsRkhFK3AyK09nSzMxTmkrQ0ZJT25zb3BPMnlEazRxV0E2N2JhSWxnRnNTYkZxODhLdW5ua3ZJWjAra2tjc1NRUTYxM3B2VVYwVXM2aUdCMjRkdXE2RWVmRHJid2hXUWNOd1FkNjErTmRTKzk1Rk5zRUNKbUxQdDVINlczaEVaQ2crM2FvUHI4dFhKeUR0UVBuMjcrMWVWOHBZWGlLWU1URzZyY1pOaHNLOVZpQjYvd0RGMEg4dERaK1RURjE2aFdEaTN6ZEZwNG5ZWGp2ajMyNXMvRDhQNHBZUVJRV01sMkV6U3k4UkpkTktWaWtGeEpXckJsS3NwcnR0UURXTmc1R1I4cXRyS1ZLK0JyY2pqMXJ4cnFtamo1bk0zbDNnOEhpSDNVdXNSWVhFdGhhbTZ1RXQreWVMQUJlYUtDZW9ZYmI2NjdtWTZySTQ2TTVYaFpYZkZXejZ4cVdQaG9vOFpZUlhOeEpKZjNianVyY1NHamlPUUVoUjFyUUgvRTY1emt0dHdkRngzQ2s2TisxbWV0Nzc3ZTVLemluS0RGWC9BQmFUbVNXamxLdlFENE0waFVINWE1Zm0wZGJPTzZScjhkcTFrL2lnemR4Rzh5VVVjMC9jdFpBWXJtQ1dOWkpFcUtjdzdLVFRrYThSMTFtMnBEU1VteW50bzNFZk1Kdjl2c3VNK3VRd2QxSGJoZ2t0MnN5TTBVaFVVQW8yNm5icXBiNTZNZnQzM0lWUGpJR3ZjNlBIdHlLU2dQOEFYVEFZOE40ZDVYTkVIZXl2THJGWEx4YmUyNWlXWk4rbXpRdjExMUh0dVIyVnFQclU1bmxKVWl5Nk01U3hPY3htUUVTUnpnVDdBd3lIZ2Z4MzZuOE5hTnF0RU1kNnNZV3M0R1VzdTBvM0RDcXNENkVIVkRzRnBScXVvVWo4ejh2ak1QakVkMVBsNFpTckN5dUNiZ0EvMGdOWGtEOHE2QnljVEMvWEczNEduaDUyWlBaKy93REhpZG1lT2VGWmVQd3pGK1J4M1RmWFFXZy91bU9ra2FaVmxCNU9ZcEJ4Sm9QMUJodjZiNjV1M0dXU3J2UjlIOVRWWE9heWZheUpLZkRzYWJyRVdkODloZlhFQ3l2WjNaRHBJT2FRdktDdlFnVi9IMC9MUXVMSlpWMVlkdTFhN3hLQUdaOFV0cm5MTWFFWlEwdEVuaFVXL2NnRlZqQ3lKeDR1T2dCNURiZFQ2Ni9INUMyN1daK1hCUHJycEl0NWUyemYyeHlNWGtkL2NISVlIdW5GejNFYUVYYXFWSWplV051SVoxRlVKUStsYWFLdmlwZGJhYVc2Z21QTmV0cHZyWHkvV0NQa283WHlFWFdXOEJsRjdoRllTM25acUo0eXdCWlRIUldVcnVlTExVaXBCTk5WMFczUzZobGw3dHJkVmdUS1lySmVYNGJNZVA1cTFtVEw0Mko1Yks2b3g3bHJDNit3OHQ5cXE2RDBvUU5qb3JFMWp5VmM2TUc1U2VYRlpOYW9vUHl6eEtmSjQ4eTNFUlhMMnljSldJbzVhUFkxSHgxdVk3YlhIWTVyTlRkVlB1VkFPMWJrcXdKa0hwNmROR3N6dzFqOHM2S3NhUjhHQkJFaUhmOEFQNDZZY3Y4QSswdmtZYWNXTXJCSTdvY0FyN0htUDBrSDhkdnowSG5yMFpvY2EvV3ZpWFJFcms5dW0xZlhRd2NNVnM0N1lVbmNEVENLbSsra2NjMk5pYjZ4TzRrWnBabEQzRlFzYXlCaDZFZ0xUNDlOYjNEYS93QVpwcXk5V2ovdGVuUitEUzZQdWpNNWFjcDZmeE9ZcG9yaU5XSWdEdzFJUXZWdUxEZXV4NjZIdDFCRVBuaGZrbG5KNGY1RDRuY0szMU13Uzd0VnFBRlp1TU05T1JINnh4YW55cnFpOWRVd2lsNFRRVHZWc2JORmxuczJyRXZPUlVOZTNIY1JLQng0dHlCSDZnQ0hDL0RWVlpiYVRMYkpKSndWbmxyZXp0TU5ZVytNYzNNUW11R2VWdWhkaXZRVUIyWGpYNTZMWFZnYkhieFg3T1l5NnNiZkpaSnBic3pxSEVhL3RSQ3ZTdEtzZjRqV1B5ZmNObG5WUWJmRjlzZVNxczVoanBsck5mSEpNVEZhMmF6WTlJMXQ3bEZQRXhLcDRxd0c1MzlkTng4aTVGRzJ5WEl3dmpYU1NGeklSL2NueUdHNHViREZyajhIWm1SMHVZd0lPNHNaUHVpYVF0SXhJSDlJQStlbFczRndXU3RhYk1zc3VieWFPMWF4U3ZkYUdqQ2ZiaXl5K01reVUxN0pjWmU0Unhhd0FLc1MzRktoSkNlVE9XNlZMZFRxZVhuV3BrVlkwTE9KN1BYUHgzazNOMjdMekd6eEhDNG5PK0VUNDR3UjJ0N2JzOXJlcEdpeHlGeHVyc2Fic2ZuclA1ZVMyUE1ycHVIcWJ2dE9IRm40dHNOcXBXV2o4ZklDL2J2S1Q0TEx5WWU1ZDQzc1orU01EN2d1NDlwK081L2pyVHpSZXF5STVyQ25qdGJEWTZ3bnQrTmhGZDJ6cmNXVjJ2MTlpWTI0KzZRajZxb3FUVlNlOG9IU3ArR3Nqa1ZVU2pSNHIzTDdiNnJvV1JZaTR5TVZyTmNCakRIQUpJNUNRWTVHbS9TZlErMGNqWC9lR3FxS0t5K3ZRcHRFN1YwT2UvOEFVVjlzY0hsczdoODdrRmtqaFpXTHdST1loMmw2eU1ZeHlOVHQxQTMrZWplTm50Vk5SMUI4K0d0NGw5Q29jVGhmR01hOHNHUHNJTGU0bGhMeHNzUWtjaGR6NzNxUWFmNzJpclpMMitCUlhIUmFKYWl2YzRTNHlCanlFVUo0dE1ZUk1wSExrQldqRDRlb3IxcHFWcnhvVHhWVnV3U3Y4WGNyYTQyM3RvcGhlemt5UEpFcHI5UDBvUlQxSTNIeTFWVEttbklWbDR0cTJyQzZoM3lmekc2eG1ER2J4VXB0cnhFYkhMQVFyRXZUaTFRQUFWTzdWcDhOUng0MDN0WlpseTJvdDYwN0ZONEhFWG1memVQeHppc21TbVNLTUx1U3hiaUFhbjFPdEt6VmF0K0JoVGE5bzhUdG02d0ZyanNRQm1NVkE1c0xFdFpTeUpWVUhaQ0I0eUtLaExNdklBMDVWNjZ4L3V6OHpUeGNlTElTWndKNE1qZjkxRE5aQ1NzY3dhWGx4QittVXJ5RExIVG1rbnpWUnBxcE5CMTg5NldldjQ4Q0w1ejQ5Z3ZLZkZjTFlaYkx0SEJKSWh1ckRGc3FtUGorNEg0VFVOV0RWOXpVcFQxR2x4N1BIa2JhSWNuSXMyR09qbm9qZGwvOUdQaWtmamc4ZzhZemQ1bHVhSTZKSXNkS1BUYzhRQ0FLNzYySzVYWlNqbjNpU09TL3VSNEZsZnQxNU0rRXlhKzEwVzR0SmdQWkxDNUlxUHdZTXArWTBWUzI1U0QzcnRZOGVCNWlmTjRhZkF5T3BoWllqSkdUeWFZeHRWYUtmOHFpbnoxblo2YmJTSFlMeW9ORjliSEQzZmVpNVJQRWV3NW9WVWh3Q0g0K29CNjZqVjdrV1dTV29ZOEg4N204RmJLWTNMQk1oNGg1SExDY25BNkZDSkVQSVhNVFVhaHJSSDVLZVNucHNOVmNuai9mcW8wdFhwL0lKNGZKL3dBYkp1ZXRYMS9tUFBpdmk5ako1SjllNEJ3RjJqVzNlczVoRGE4SG95MGMvd0JYRGJuc1FGcDhOQnJPNjFoL3VUT2t0Z3E3N3FyMDJYWW9YN29lTXI0eDVaZTIxdFUyVWtwZUF0UTlkNmJmR3RSWFhRWWNpdldUaXVaaCsza2ZnSDVjWlpUaTVleWtNZHVaR0NxUDA5cFRVMHFDZGdSdDhUckVXU3lhM2RUcmJZcU5QYm9nM1pZQ0ZrV0NzVWwwQXNVVUk1Q1VPM3U1ZjFBay9EUTlzcm1ld1pYRlZRdE5DZGE0TEw0dWY2Rkl6RGtaREpETXowVUJscTdyeDZWRlJxdTJXdDFQWW5qdzJwcDNmNDZCZi9xOFROMjc2RVJHOE5JcHViY0NJNmxscUJ4YjNVUEdsQnQrT2gwbGRhUG9FdWNlajdrZkh6WEwyMXpjV05vSnJ1ZXRuYXFrWlBFeUVCeXZ1T3hGZlhyOGRYWFNsSnZUcUM0N1dhYlMxZWlMTThheDlyaFlyYUF3STZSeGR5NmpMN016a0VzL0hqdXBHMi9UV1JseTcyelp4NHRpU1QvMUh5MnVybHhGYjNGbk9wZENFU0pGY0xVZnFJNUFnQ28zRmRaN1MxUmEzR3YxTnB2NXJpeFpPYldzMFlvR2xIRUVkT0pCQjVLYUgxcU5SM2ZNZjdlcENteUZuQmpCZTNnYU8yaUFqNW9EM1U0c1NLTlVBMHAvSFRKTjZJdjJ2ZG9jM2ZjL3lhMHlXWCtudDVpY2ZBck5GREpWcEpiaUlxNFZ1Mk5odjFxRHJydmF1TTZVM05hdjlEa1Ard2N4WHVzYWFpcTdmN2phaTNXUFlaS0pGdFk3U2ZnTEY0Z2Jja3lva2s3emNlUVZsNEZrNUFqbFViQTZNYlg3ZXMvaUlNV2xHblBnL3dBTmtLRGhMa0xrM21ORjdjUXRLSmxoZm0wc0VsclY2UXVUd0s4K2ZLZy9SdHFVeFZRNFg4WkozVTJjcVd2RHVvOENOamNsZU9JYmk4dEVzODdQRUoydUtyRkpMVjQ0UlRrUU9QN1FvakVWSk5DTlN5MVQwVG1wZnhMdXNOcmJkcjRkL3dDblFJd0NPMjd0MWxib1M1RzlqT1l4ZnM0aDd1ZEpVWktVVW9LS052OEF4MVM5ZEtyUmVsL0FPcjZkYnViV1crdi9BTFEwV1poMHRZUEE3RHlPNXRicU9hYXh0amEyck94RE5Dc1NTek1DVHhWaXpBZko2NnpjMC9lZFZIVTFlSzZ2Qlc3NjdaQkRRSzJCdFBJSlNSUEZiU1g5ek9zbGV6TEZITUZxUUtLV0RJZm1kV0p0WDIvSWJJbGJIdmZaUy9KbGg0MmE0TTNlQUgxRVhaV1BidEJrbFl6eUFVcURRaFVJOWRadVdFb05ySDZucjRMVXBMN2czVnhtUExyL0FDTUQ4c2ZiY1lZUTVBS3dML201VUJMUHk5YTY2RGcwV1BFbDNad251MlMyWGt2d3JwOUMwUHRQaURqZkVwTW9JekhQa0xpUzRiYW43QlFMR0FLSFloYTZ4ZmRjMjdJcXowUjBmc2ZHVk1XNTlia1g3ZzNRV3lpc1lwdTA3eHZDRUhDcks3S3FxdTFBQ285T2cxSGhWbTh2VTB2ZEh0d2FPRG1meXFYNkx5SzRYSE5OYnFoQ3lHQ1J3RE10T1Q3SCtyWFo0WnRTWCtFZVVjbjBaR2wyL1UzMlBrT2NqUlQvQUhCM1hZQVhjYVRLUGw3MXIvUFVMVlQ3RDF5MlhmNmttNnpVOGdhSzR4ZU5lZHYwM1BhWlQ4NktyOGEvanBvOEd5YnlUMXFnWENJdTh2ZWhwM0tyR1l3Q0NBZmg2L3gwVW5LMDdBcmhQVmRUdUQvVEpldmxiZTF3MXVzVDR1eVJYNFJpclJBc3JzWEkvcWVoVTh0Y3o3cFZLcnlQcTlEYzR1WGJqZGVuNmdQNzIrQlhlRjhudjV1d1JqN3FScDdXVlFlQlNVOHFWK0trME9zSDI3TThUKzNaNjEvQ08rd1pLODNpVmo5MVZET1RmTDhYT2MvTWxwQTVhTlVEc2dKcXhGYW44dGVnOGU4MFRQTC9BSERDNlo3VlM2QXkzdGMxQ1VLeE1qQTFYbUtHdjU2dGJxQ1ZwZGRndERhZVFOS0ltc1hrN3pCd1FwMmNmRFVVNitJVHR5ZDZoYkNYMHVIeTRmdW1PRzVIZWpNTkpBWkNlTENoSDZxZ240L2xxMmpTc20xSytrb3BUaC9IOVMxNHZwYmlKYmkwWXl3dnVIS2xkL1hTNU9MYTFhSXJlYlZYZ3BlaE9qbjVHWWkzMEtXR200dGtJM1hmNWFTWXhIV0ZJeitHazJLQ2RieXhnZ1YzMnBwQ0NLeUhoc2FqVVNTTmJGUnVWcWZqcFFNMmFMcGdGRC9EMCtlbmdhU2lmTzdPSzM4anZoTkdzdHU4Z3VlSDZmYkt2TGFuUTc2dHcvdGdEeWRSQmxUSDk2VHRTU0NIZnQxVUZ2bFhmVnhVWFA4QTZkY2Ewbmt1T245TG0vVTBQVHRXS0YySitYS1JkQTh5MFkyL0JNMlBiS3prWG00TGI4eXkzMU4xM25QT3R3OHpqcXU3aFFHMXlQR3h3ajFETmFFdklnVzEzeThadDEyYWFhNVlLRHNCVlNkeCtPK3I3clVyeE9WNWp6NDVCS3QxYlR4SDlxemdlTm82SGZ1eUNwUDVSNno4dGxBZnMvUXQvd0FTdTd5enlObk5icXYxTTdNaUxLMndSbEJveE5QaDhmV3VxT1BacStoZzgraXZTeWZSRVh5bjdkbXc4anYvQUxzV1gzSXZjWEw0OUplWGNscGswaXlGcmEyc29WN3UzZ2ltRWJScktxVVVLeHAvVHJSNHZJcmpUbzYxaHVORzFlM2g4VGtjMUxXMjllbW5TUGljcCtTNUtYeVB5bk1aMEtZTGZKM0V0MjlvM3VLTE83VEVWTyt3T3U0cFQ3ZFZYd09kdmJkWnNUY2xscm54M055M1VWeGxzRzNzK215bGtIRnRNcUlGNUx5NDFHMUtxVHFMcFhJb2FUSjF2ZW5SdER2aGZ2aDl4SVlHZ3QvSmNmbjdWME1EUlpKRGJYSEYxb1ZFamdHcEgrL29MSDdmZ3hacTVxVjIybzVRWGJuWmJVZU96VFZsQVdQM0d4RjlCMnZPUEVabWhPMzFIWlMvaUh6VndDdy8rclhkcjM2dVJSbXgxdDhQNU01TC93Q3J2ai8rTEk2L0graEJ1ZkUvc2g1ZEczOWl6allpOUlyOVAzQ200Qk5PM2NCZ2Z5Y2FyZjhBOVptbHc4Yi9BQjhVUzM4L0hvMHJvOFRFMnk0Q0Zwb1NIRUYwR3FPTFZqaVJSWDhEcnpmTHUrNTh6MUxpdXYya3ZKL29WUGtzYWsza0dTdFltQ3JCT3lLR1gvS1QxTzJ0V3RvcWMzbHg3OHRrdkVrU2VPWFhaN2txbzBZOVZYcnQ4dFZyS3BndGZEdkV1SUlzdmozN3lRbURqSnpXaTAzOTRYMC9QVm03VVpjYjBUQjJkNGpicmJlUDNGRUlFY0NyeUFwK2xLSGY1YTVqazFteloxL0dzbFN2bEJZTFdZTVZsY3llK0lXa1NTVUZXOTBhKzRWNmJhd09SLzhBSXl6SGswYTd5RFpzWGNocFlvdDFVOUhveXN0ZmFRZGowMVFsTERLNWxvMkQ1NDdTTW1KU3liMDdhKzVUeTYwUHhycTFhNkJGYldlb3UrV1NSUzRUSXd4eHZHdjBkMXg2MS81TDFxdGQvd0E5V1luT1N2eFJPNi80cnovdGY2RlEvYXkrZTJ1ZkhuSkpVd3NDcWdGdUxXamVuK091L3dEZGxQSHNlY2V4L3dEOFZSUHVYbytQanZJNFk0aDNiaHh6YzBCS2JtZzI5YWE4NlRuUkhwYXpPamJlaU1jMWdvWTN0N2RXV05peDRVTlRXZ0pCMitQVFU1SDQvS21XeGZ5K0N1WWU3Y2hTNEI3Y3ZRMGNiZEJxeXRnN0hucmZRWDVNZTlGNElBRjlrcCtGRHZYVjZ2S0xIVTNHMktMSjNRR2ljR20zOVI2ZjQ2YmVoTEc1OGdXMk9BNTk5ZURVb0dib2FmN2RYNzlDbTJMcklJbXhpeVM4WTZySitwUlRhaEg0ZXVyNjVOQU8yQk5uMlB4UnNpd2tocGJ6TWVOYWdjbTlCODlQYSs0aFNpcEtoUXoxN0FUS0k2bmlkaW9HMWRQWEswUnR4VmRFRHg1eGJYL2tkbS82bUVQczIvclJrUDhBR211cDR0dDJFODU5eXA5dmxQNUcyZkVzSVlJMmpIQmxwdFFmTDhxbldEdml6T3hlRldWWlhWRUc0d0UxdjczaUZPZzlUVFYxZVRQY0Z2d050dEZvUXhqUU83RUFRcDk0VHFPbE5FZmY2TXBYRTZxQmR2OEFHTEt4amtVMU5hUFNvMFRYTVoyWGpLM1g2bVdDKzJ0cDVEbGxueWNSN1VNWWtxb0laMWpZVkJvUlVVTmFhV1RtL2JVSXI0L3RLeXViZEMzc2JOWXRCWTJzc1BDR0tBanRSQll1QWpGS0tOZ1JWZjBuYldKbGRuWnZ4TnZCanBXcVVhSWRzYlpacTJndFBJQ3ZjV1NaSjVsZmc2UnkxRFJkeVA4QVVhMEEzOXY2UjEwenlKdlIvdEt2czZOTmZ1S3YrOFBpMlp6YzAvM01tYTNqdk1kSkJkNUswdGtjUmlJdUltWkM3R3RCK3VsUUthNmpIN2k4MWtyZkJIRzVQYS84YXJWZW44d0xqQzkxalh1STQ1TGhiTXlRaUJBVzR4OHdXZGd1OUFyMDFET2tyRXNMZTB0RDdRWm9XOFdmbGtWMHhmMHNWRmhVdXF5OCsycEcxVCtvRGI5Tk5ZWE5vbmFyZzNPSGZSb1piZjdqWmFLYVMya2hkbU03S0pFcHdaWk9OT1JCNVZiZW5xdEtydnJNdTRlaDBWZU45eExRYzQvOVFQaW1BZ3hGcmNRelNXVnhiRmhjMjdMTHdaRzQrK3JjdDIvVnk5dzlmbVhocmxjdEpKcnNjNW13SlBWOVNtLzlUWDNNOGErNS93QnQvSnZGdkRNVk5tWmZIcnUyeTJRenRrWXpqTENGV0c4a3pFYzVYN3pwMm93U3U1SjJPdHZnMWRidDJTcnUrck1ybDYxaFBkSFh5T0g3M3g3SjJOdEJlM0Z1NldseXZPQ2NVZEdIVHF1NDMrV3RwTlBSR1U2dGFoUHhLL3ZUbTdERzNWektjZk5LSXBFREUwRGJBRDFHK2h1UlQwTnBhaGZGdTNrVlc5R3p0RDdQZmJ2RFEyaDhwN2FyZWk1VkxhSmp5S2hsNDhqdC9tb2RjWHlPUmV5MjJaM3VIRFREKzFhczZiOFVqbGdzc2hqNTI1UGJrU0xFZDZyU240ZTRhcTRxYWRsUG1aZk5hdGF0bDNFenlSYmJEM2J3SG5IaWNreXlJaFRuR3NpTW9jVXBzd0cvRWZpTkJXcDF0WG96WDQyUjVFdjk5Uk44a3lrd3NrZXdoa3VMOUkzVzN1STA0eFBJcmxTR0FxZmRTckQ5UjJLNkp4UzM1QmV6MHY2d0srZFhGdDRZbUV1NFpiTkxxRlpiaWU4Sm1DdkszS0ZPWmRuTkpQME5TbjhUclJ4MHQ5emNqT3lYcERxekQ3ZGVGWnJIUjRYeUxHdzFlT1pQcUxpM25BanZiTjVBbkVnbjlTZzg2TUtyVDU2am55YjI2djhBMFkxVldsVkhYdjVvVVBJdkxjMzlwL012SU1WNVBQSmtiRy9uYWUyTXlDUnJpR2VYM0kwdktxaGtIdEE2TjBHdEpjZFpxVnRUUm94bHl2dFd0WEorMTlBWmx2SXZIdk1KYlY4TmlzcGJTbUhqYzNOMWFzdHMwa2NZRk80cFlBc0ZydlRldXRPdGJyOXlNaTdwMXF6bTc3allrWXJ5T2FOSTZSeXFKby9tcjlmNEVIV2hUV3BtMzBzTE5yZFNSdUNwcHg2TFNvUDRqVWlBOCtONTI1anZZNVFXRlR1RTJBSStGZmpUVVdrK3BLcmE2SFUzaDNrMGVkeGtWd1hCdTRWQ3pyV3JIMERuOGZYNTZ6WFRhNE5tdVJYVS9VYmhlZ0NvMHhNVC91RllwbE1LYmlSdmRaMUpvbk1tT1Npa1ZHNG9hSDRhM1Bhcnp2d3YrOVN0WTlWZFY5VktBdVhTYTd2QTVzeVZoZTJ5WEsyS0hnek5FU3dxeEREcUtkRHRvZXhucHowSXZqQ1JZN3lqSEhLV3h1SUpXN0YxQkllQ05GTWpJMVNhVVBSZ2ZscU50VVNybzlTNk1oam9iZk9YVnZRL1JUS2JuSHl5QWN1MDhESG1BeERWMllld2V2UWFDYTZNT25xbVVuajd1eXU4Rmp2SDhpc29qN3QxZDJ6d3VxTVdsb2pJeElKb1Npa2ZnZEh4cklCMk92dnMvZ3NabGZ0eGlMZ3QzTGlORGEzQklZVmxoTkR4NUNwRktiNjgzOTZ5V3g4aCtCNkw3VHlGL2oxUWovZWkxbHhQa09COGZpSWp0OHphWFRFcnN5dkhJZ1ZpRFEvRWJhMWYrdjMzNHIyZlpvelBmc3F2a3BIZE1sZmFDN2d5ZGplZUwzWlVYT05jdkZDOUt0Qnk0U0x2MW81SDVOb2IzK2xzYnJsWFI5ZjRCdnNITVNwYkRiWDhhZ2FUeG1ieFR6YkllS3ArM1lYeUxrY013TkQybUo1SW9GZDBJSy8rblJOZVIva2NhdVh2WFN3dU1seHVUZkV2MjMxci9JMTQ0dytPK2VKSGRxSThmNVFqV3QwZ29GanlTRVVhbEtEbld0VC9BSmpveHhuNC9uVFg1Q3BiL0U1cWMrbkxvL2lML3dCemNMY2VMK1NXSGtpeDhiYVU5aTdwVUtlTktucHZVR28vNGRGZTI1ZDlIUmdQdi9IZE1xelY2UDhBVXV6N2MrWnlYdUpzOFRJb21udEpUZDJEMERJMUZJa2hjK2dkV1lWK2VvM3AxcXdOTlYyNWE5em9IeEs2Z3VNWmJRV3ptNHQxUUJMbWc0TkVEVDBJOXdCT3dHMURvTldsUkdxTGN0WWU1UHFKdjNJZ0djamx5MXNHdXJTOHMxaFNKRUFDdzJyZDllTFZOU3pjbTlPbytHcTY1SmFnZW1QVFU1cXpXSXVzZm1aTCtKaTlwREt2YmNBdWdpdXdRcEpIU3RQMGtlbWo2NUZDUlM4VnBkbDBRTzhjZ3RPeGxMVWhwQUpJSkpTMUNxTGJySjNLazFLdnVwSEdoTzQ5ZFN5TjZGZUtxa2F2RVBHc3BuYmJLWkc1bFNEc0ZSQkRGR0I3SG9FWnlBS2trKzRBOVB5MERsdXFOSkkzTUZiWHE5emdxZjcwNU5qblk4SmM5bU81eHE5dVJMQ290bWxHMVFHSklQRUNvcjExcDhPcjJ5aks5eHlLZHI2cnc4UkhqdE1sRGo3YStaWGhqbkx2WXpuK3A0bUhLamRSMUIwZW1ub1lWazFxZGorRi9jSzQ4eSsxdGtjdmFwRTl5OGx2TnVzc0N5MkxqbnpTZ1BGNkkvQTdrOU5ZT2FqdzJkVTVYVkhSOGEzK1JUZDBzdEgvQURGUHlDL2hzL0s2MnBOaGo3Z0d4TVVqVlJWdUc1eE42OFRITHhjaXRRdTN4MDFIbys1Wm14L2tNMkQ4R3gzOXZrLzdsbXRyMU1wY1RDR3dnWVJPbmIybWpBS0J4d3BWVkpIVFN2bGZic0FMSEg3dTQ3L1ovd0FsL3QvL0FOeHNoU1hIeTFzWXAyZXNuY3RtS2NKSTFBVFpDUGRUY1ZxVFRSV0xMdGNkZ2JMamJYd0ZQL1Y5OW1JZkpmdDdMNWhnNCs5blBGaWJsbzR3Q3o0eVRlWkJ4NjhEU1VmTGxyWXBaSm1iZE5yNEhCSGltWGt4V1VoY1B3Um1Dc3gzQVZqdWZ5NjZubHB1UlZpdnRzV2htTWl5QzhUSVZjeXlCOGU4VlhYZ1R4TktVSlVxU0tnZE9QWFFDcXV4b08zV1FIa0laTWpqMnMrQ3JZcS9HeUpYOTllUExpcG9OZ0NUV28xT3JoK1pDM3FVZGkzUHQ3bkpicjdVelhkNk93bUhyWlFRMnl4S2s2RWlza3pHcmlSUkwrdnB4QUZQWFdSeXNGZnY2ZjNhblMrMmN2SXNEbUdxNlFWdDl5Qmo4amg3SElYRXF3Wkc0NU9iTkE3ME5BRll1S3J1QWZuVDhkYWZFbXNycUFlNTJybFN2KzJTZkpodkpURmtYc2xOc2JSa1JsN2ZNOEdmY01LRUVFR3RScklXWEhLM2F6SnUvWXpOVzI2UXhranRiUzVGakZERzF1WU9GeFBKei9YT0FHV2xOMTNIK0dobGRxWCtJQzcwVUpMUmRmbU1VK1plZTNzN1dVU0dOSTBqZ01rYVN6ckxNLzZ6S2FNQ3RDM1NsUUs2SCszMWYraFpXOFA4TTEzbHNCTXNibUtlT2JsYlJwT2dSM1pTT2JHUDNLVFFoZ1kyWGNEVDBjZUpaWlN1MzhTZFllTjI5Z1JLaXUxaUNSSXNTOXhoVFlNYVY1SWZtRlplbEIxMUMrZWRPLzQvTW5pd0pkZWhZT0x4V0prdG83V1JXdm1CQk1YYmVMZ3JFaWxYQUsvbVRyUHZaeklXdjJwZEJ6c0xPMmptU2U0VXVDT01hOFFGajJOYWtEZmZwV2xOVnVzb0h2ZTJxUkh6Tm5CazdvUnd2SEowQ1Fsd0Y1RVU1ZTJwOUtEUTFsTnRDekJkMHJMSzQrNHQ0K0R4Yi9WeUk0aFFsb0Myd0NpcFBFZFJYMmpSWEVwOXk2UVk4MWFZclpQRFU1d3NzZGs4bWtQa0Z6QkRITDljc2M2OXloVkxobENFUlVwUUFVWWsxNmJhN25kV25vVDdmb2VZMjM1TExKWlEyLzE4aGtFOXMxdlBhM3FtZWJINU9TQ0p6YzlsVmZ0T2FPb1ZnNVVMUW4rcWdGZEROTnVWcE5mQU5VVm1zenR0SFdPeEY4WUdXbHlNTi9KUEpiNVV4U1FXeHMyK2xmbkt0eUltWnEwWUZtN1pxQlZXcHE3TzY3WVhUNitCVHg2M2RwdDE4dFBFSVczaStIdThmazdQR1QzRjEvWSszOVJrOXBQK2JOTTVtaUpDbFVmaWlPVFVBL0kxMVhiTlpOT0ZyMkNNV0NsbHRsK252K2MvTUxuRTQvSkR4K3haVXZZYm42ZXl1SmllVHd5M0FNRUpaZGo3R1l0c3hIcVJ2b2F0N1Ricy93QXZGbTNseFUyMG4xclJUMzhFV2Q5emMzYVlUeFU0VEVTOHJxemhtYVJsb0J3eDhDcXdZbnFESng1QWROeDExbThmRzhtVGMxMWY2c0t5WlB0NDdLdjl0WDlGK05RZmdjT2wzaG9wcmVLRzMvdVdOdEZrV1VFV3ltN0NjbUhIbFZZL2VHVngxcDhkV1pidFhkWjBUTHF4OXBaRlhWMTZmRTh0dkl4NC93RGIrRE16Uk45ZDlOYnUwYkFvb21ZS2VOS25ibDdUWFZWOGYzT1JzWFNTMVpyWWVJc3R1cVg1OWpuNmE5dmNqUERqa21XK3Y3dHV5a2thKzVYbmJwUWRUVS9qcnFhMFZWUFJJODRkN1pMUk81MmY2blZ0ckpIajdDSEdZOXU3RkVpUVc5QXpJZUVYYlVxYW1udGpBcnNLMStPdUc1RTN5TnY4YW5xZkR3ckhqcW41RlNmY3JJM2hsRWFSUGJYVm12R1VzVlBFb0FhclNvMzVmK1oxdCsyNDBuMTBaaSsvNTdiRXErWlFlVk15enZjcXZkYmRpR0pQSSt2UTY2cXNSQjV0a2Jiazl4L2tNQ2xlZVA1cVNQNjFxYWVudUEyMDE4VDhTVk1pOEEwbDk0emR0VzVFa0N4QThrZU1zQVY2N2pscWgxdWdoT2o2NkdNelkxalBiNHljU010WGhVUnNnNWRTS3YxMnFOaCtlcDEzVmFka1YyU3Nta3k4UDlOdmw4T0g4enhjZVJ1V3gyUEUzTzhrRE1rQWpLMHJLS2trc2ZhUDhOUG14MDJ2Y3A5TGp2cjVFc09TM1JkK3AzaDVuNHZhZWUrSnlZeUthTmZxa2prdGJ5bk5kaUdEQWplaEh3MXlYUDRUdlJXcjZiVTE2ZGROVWJYdDNOZkV6cS9WZUh4T0EvSzhDdU95OXlyeGxieTJkNEdrWDJ0N0dLNks5dTVYM01hOEdkUDd0dzZ0ckpYdXAwOEdWSGNlYStVWW5JWE5oSmRpYnN1UU8vRWpncjZIcDhOZElzR095bURnN2M3UGlzNnpNZUpOaCs0OS9JQzF3SVV1RUtQREtrWlVySWpCZ1FBYVYyL0NsUnFIK0pWZEd5NSs2WHYrOUx5MEkwdVZneVVseE1KUTE1UEtidTNJVVI4Wndha0RnQUFEOEJvakhUWlZWWFlFeTV2dTJkbjFaWTNndmtENU8wL3Q4OGp1YWNyZGUxVWwxQlpxbFJYNWY0Nk54NC91NDdWUzFVM2x2dFZQMGxYM09qZndHWnlvcHlQWFdXRUlqU3U0SHQ2YWRETWlQTXhORHB4algzTjl1dW5FU1lidmhzVHBvRkp2L3VBK09rTkpHdUxydVYzcjY2Y1JWLzNMdEJMZVc5MGE4WmJaWTNaTmpXTnlLVitOTlBpMGJSUm1YY3JHN3g4RVRLYmU1UjRuM0hJaFdYYm93OUNLYUpCam9IN0ZXYldsMVpUaWxMVEVYTjB6Q29KZTdtY0tkNmYweHJyRzl6dC93Mjg0UjAvc1dQZHljZnpZYnpGNUs4TWpPT0tTaDJVQTFQRU13RysyeFk2eGNkVHVzbDNJUVNHUzNnZ2dsUmhMR1VFWlJSWGNBc1R0NjA2YXJzOVFqRlhvV2Y0dTRqdFVZa0Y3Z2hWMjJLeGdBVUIvM3ExMWw1N2F3R1pLeXZnTTJZeTFyaUxLYkpUY21saGpBamdnRGR4bko5Z0FYNG4rR2hWNm5DNmdGS042ZGloUHZsOXo3cTh4ZG40b3FTUVpIeU9lQ1hKeEZ1VWd0VmNBSVRSZDNZYjdkQjg5ZEQ3SDdmdXovY2VxcjArSnozL1lNOWVMZ1dLdjdyZmt1LzhBSUNTUTBOd0F2c1ppcTcwcVQ3UnJzOGo5VFBQYUxRNlQ4UXRaSVBEY0xheXFza1M0K0RsREp3a2lQY1htZmF3SS9xclE2OHU5MnpYWEx5V280YzlqMFhnWXF2alVyWlNWWmhmQXZ0djl4L3Z2ZWVBNVBIdmJXenZjRzV0Y2NEWnhOTloyUTV5cjJnRlVHU2piRGY4QVBYZSt5dkpiaXE5M3ZjVHI1dUlPTzkxcFJabldpMmhEN2xmNlJMN3dMRlpQeWJ3enlpOXRzWllSdE9iYWFSVzlvSTloS2hLRTlGUEZ0L1RXKzN4NzBsVFczaDFYMTZuT1Z0eXFYU3RWV3ErNjZyNG9yYTYrMVgzaHlHTGw4anRQSExIeWp4dGU2UXpkdjZ0VnRnZTR4Y2RsL1FuMU9xLzhhS2J0eThZN3dYVzVWYTVQdHRPZmc0K29tMldhaHNZN2xyeXl5L2pQMHlqdkNPZjZtQmxlb29zTnlCeUd4MkIwRTByZURORDEwZmVwUHNNdDQ1a3AydXJlK3cyUnVaeVhmNnNTNGE2ZHZtMVRDVy85T21lSVN6dE9lNHh4ckRDMXRjWFdEdkxleGprN3NrMXNpWlNGNkt3QTdscy82YWtIZVBWRnVQM1FiWG1Od3V4bG03ekNaenlFMytDdTdlYUpwWUNMZG5XM3VGRVNJckF3eWxIclZUMEIwUDhBWXVyUytocDE1dUw3TzJmVk0vb2RIWWx3dUFuV0ZsY0JLQWdodjFINWF4Y3VON21iT0RLckphanZjMnhteDhCdHBPMU0wY2FMdld2c1dnSUZkYzl5YXQzY0YrSysxK3BTQ0xhNHljVXZKNFRORHVzcktOeHhGRHNUb2JIRXlHM3JSclJ3YTNtdDdsbFY3WVFSQUZVNHJ4RlQwcUNCL0hVdDBNbXF1cTBjZ1h5S3hpa3RNbDJsaklGbGMvdGcwZGFXOGhxSzFIODk5WFk0ZVN2eFEyWEkvc1htZWovUW9EN1RQeXZ2RjA0bG5aS1VGQlVmU1BUcnIwTDNULzhBaDcvQTgrOXAvd0Q0bW54T2xNWll6UXU4eTJ6UzhmZEVnUEVqaWFjOStvL0hYbXltWVBSTTJSV1VUQnN5MFgxVVZvcXVzZDczVUtzRzkvSW1wSUlxQjh2WFQ3U09HMjF2d2dGM2pYRnRMSWx5NDR5SzhrL2RiM0Z3QUFLK3RTUjZqVXE2UFVKcERTMi9oQVNTMU52SkdaSERMY3FSSjhRMUtkUG1EcTVPQTlYM1Q1R1VGamJ5SzNIY1ZLa0gwTktiRTBINDZya1ZzclJGdjhOSzdWQ2wrQW9TdzlEMDIxUGN5ekhscStvS2ZITXpGNUFGWmFFSDFwNjZ0clpsMXR0aUhucy80OTRsRFlTZVJ6UGIyRi9LMFZ0TkhFWmtXV0pBM3Y0MUlxRHNRcDBWaDQrVE5PenFqTTVmTnc4V04vZGt2R3orSmVTU1FqQjVTenYya05XaWprQ3pBbXY5RDhYL0FQczZqa3haY2Y3azBMRHpzR1ZOMWFZc2VRWW1iQ2VielJwSDJ4ZjQxSmxVOVNZWlhSdHZYcUthNmoybSsvRTAvRTRUMytxWElWbDNReWl3dDU0b0RQeVdLVlkzQ2dVL1dnSnI4dlVhNTNOZDF5V1htZHh4Y0N5NGFXOGp5ZkJSbWx1RzdzU1VBcDEzNmFqOTRKV0R4NkFtNThhS0FtTk4xcVFEdFVOdFNuKzNUclBxUWZGVU9DR3ZpbFZTU1NNODEzTlJVZGRXZjVNYUxVRS94SjdEcDQxNC9GRzB3SzBkN2VWWTlxYm1PdTJoWG5tME10eVlhNDZLT29zSml1L2RCZVVpT2wwNnBVVmlaR1lTaFJYb3g1L3cwZGJKQzFNZDRZczB1b3hZSzl2WG5henVKbUdIa2wvNjZPUWtSb1Y0dVZZRURpRkxBRDhQaHF2SkMxZ2pSV2ZtTi9tUGhNZWF3ZWN4cUVwY1gyTXVtc21nYzhKWVhSKzJ1d29TRFhydnEvaTVkbVZKOUowTS9tMVdYRzQ2OXlzUDlPczArVmJMMkZ0S2tWNVBhV2VVaFpsVGx5b1laVlZpT1FyVmEwK0c0MXYrNEtOck9hNEZkemFIZUxDTjQvTkxkd1R4bTRVeXh5MnBVSUxoRUJtRE54WUlRcEtmcDRuZldKZTFicmF6Y3JSNG51aGFBTFBXbU91TENQeW0wN3YwalFKSlBCRlI1QVN0U1FHSURFTUtkYS93MEpYV3pvMXFhdGNscVZWNnZRcEcvaHpmbWR1cjNpTmhmSEhpbU5uYVJVVzl1ZTI0UnUreWY4dGVSQjRMdWZVNjN1UFdtRnhPNjNmd1J6L0p5WDVQYlpWZEYzZjhoMDhOd2tlUnRicnd2RXgvVEo1VGhiaXl0YldBSXNJbFNNeUtwR3dKWlhmZnJxUEpzMDYzZjlsa1Q0K3hVdFR0YXIrcUtyOFl1bHVQRWJhM3krR3U1OGZaTThGMWtvVUZ4REd6cVR3ZU5mZWpCNlVQcitPdFcxSHZicWMvVzYycE1RODdqTWNtYytveDB3bHNabWltamxqTEl5OG1NUitCQkRVT2lhdWE2OVFleWl4MUg0Ykw1M2d2Rlk3bnhUeXNYTmd0Z3VTajhmOEFJYllYYVB4a0t5SWwzRDI1NDZWUXJYbDExekdhdURKYmJldTE3b21wMWRNZkp4MVY2VzNWMnlsYjgvb1d2aWZ2dGRlTjVPYy9kTHhlOThmUUNLM3VjN2pPV1l3cjl4UVkyYVNCZTdHR0hUbkdmbm9XbkNic3I0YksvWFRwWXB5NTJxN01sWFdPL1ZGbExtUER2dURpcExqQ1pheXplSWFrNlhsak1rM1pjZ2doZ3RTbXhwN3dOQzhoL2F0RmxFK0lUeGN1cXRWeXlzN3RYbWl2YkNaYmhMaXdCbHQwbkFWb21GR0VxMTNwVGRhOVFkQlJhalM3TTYyclZrcnFOZngvcUxOL2pNVGU0UDhBc3Qza1kxeWRzaXVoaUlRT2VYSWNsL1N5L3BLajQxT3RmRGthMWd4T1ZST3poNmtieEx5Tzl4ZmJ3L0FKQmo1VmFRZ3FlMnZ0L1FvQVVoU09YcWRUellGWjdpbkhsYXB0YUdQN3BlT1lyeW5CSm5MV0FSZVFOY3JLbDhuRWxadTNSUzdqa1ZSZUE0aXBIdzZuVDRNMXFXaWRBUGtZRTZ6R3FIdnhwajV0OXRZYnU0VXRlVHdKTGN3Vk5GdnJHZ2NENHEvRGtQazJ0Q2w0Y0daWlNwT012OVNIaEVtTnViVE1ZNjJaWVlwRGI5djlSNFRLR1ViZFJVSFd4aHRLTWZOV0dVRm1NWmNZUy9hMWRUdWlTS1NLYk1vSkg1ZE5XcHlWT3JUaGt2R3lYRndZN1czVmkwektFcHRSK2xLK2xkT01XeDl0L0twc1JmcEJLNUtuOXVXTlFLTjhRVDhkVVphU3BDc0dUWmJYb2RCSmVMSkdraU5XT1FCbFliZ2c2RE5ORUxNNDJiTVk1N08zbTdOeFVQQzVyd0xML1M0SFZTRFE2UDRPZW1ISk9TdTZsbEZsM2p4cjROZGlyTmpkcXducUQ4WjlzRmtzWnBiMjUra3lNNkVRbEtTTEZKNkZ6dHlIeEFwdG9pbkk0K1BLcFR5WTUxL3RjZVhtQVY0bVNIckRFSzc4R2pzN3lPN3ZGYU81dEpnMHFnbGxKams0dlJpQVN2cXJEcnE3bDRLNHNrVWU2clUxZmsrbno4U3ZZNi91NmpUNUFKbzhGWTM1dDJ1YnJFODdhWklUNzVJSlVNc2JjankyWDNWcDhOWmlvVzJ0M09hOHhBbHNiWnJFc1liY00wTHRzeDk1YmVuejBTRE02UDhBOVBYbWNtSHo1OFh1WnpKaC9KWTFueDBqZnBqdXl0UUFLajlRREoveEFhNWozN2hmZHhmY1M5VmYwTi8ybms3TDdIMFljLzFRakM0Njg4UDdqTmRaYVZMKzV0N3hmMndrS1JnQ01oZ1NheVVhdnBRajEwTC9BTmR3N1ZkMXROWEgxQ1BlY3lzNnBxR3BLMXcza3g4WjhxeEhtZHVnZTB1T0p2bzFCb3lFR09kQ1BYa3BKRzNVVjF0Y3ZpcmtZclluMy9DTTNCbisxZXVSRjdmZVR4cTRQak9OODl4THF5ZVB5UjM4VTZNU3M5aGNNaGNmRGp1cmo4VHJoUFk3V3haYmNlL1M4ci85U09sNTE2M3JYTFYrcXV2eUs5ODZzQm1mR0ljMWo0cWlTS0xJV2puWjBrWDNxMy9GU28xMGZCdjlySzhiZmt4K1ZWNStQdlMvOGt6eks1S3orNHYyK2plWWc1RzRnUDFCcC95NytBQldVYm10VDZuME9pYTFlRFBLNmZ3TExaYTh6aVEvM1IrYUszKzNmbDkxamNoYVlScERCa29TeGdkd2FHU0EwNGpjYmxDUWZ3MXJjbkduRjBjdHhNajF4UDVmRTZJKzFmM0FXYTh1N0J1OHVSdDdoSVk3VVB3Qjd6ODJqUEpndEMxYW40SCtPWG14TnRQdEJvNDgzcHRWOVVXeVpsa3RiekdXOWxKQTFwRFNCSnVMUEc4YVZXcnF5amtVcFQwL2pvSzFiSmhGTEtQTXJ2d20zeEYxaWZJYkc4akt2RkpITjJpcXN4aUtGQVNwcUQ3Z1FkcWFia0xvMzRHaHdyOWt2aUplV3cyTzhNeUVXWHhNbDJrZDkvMUVzTWFyTXFUVFJoSEpTbkxpRlpnRjM5emRkdFBpelBOVjBmYnVUeThhbUczM0ZPcjZFektadit4NW1LNFZlemliVzFlM3k5dXFPZnA1SklneWN3cHE3SWFjditMNVUwcVlsYXZ6MEh2bmRieXVpNm5MK0d4dVMrNUhtaldWZ2loNzJZMWtua1dNS0NTekYzYllHbGR5ZGRHcS9ib2NobHpmZHl0b3QzN3BlSldmakgyeHh1ZHk4VXNNbHhkckhoN0paa0NRd3NvSWN4VXFTd1VrNzdBaW1oOERidCtwTGt3NnlLWDJ1OHRmeDNML0FQYm1SdkhpOGZ5OGlUd0twSmkrcDRsWStTOUtNYUt4K1ErZW41V0xkWGN1cUg0UElXTzBONldIL0o0cTZ1OFRjdlB6a21pbmtpbjdMVmZuR2xVWXN3SjZmMGdMVUg1YXkwMU1vM2xOcXVSdThYdXBQSWJOOG04RWpYbHJhclBKZEZHblNTOHR5cERoUVZJZi9seWZxK0lJSXJxRmx0K2JBNzY2ZGdpUElzYlBsclQrNVJMWlhiUnJjMzF4Ym9wZm00RElWS2djeW5MZFQxWFk3SFVWamhlS0kvZGx6MFpiMWxuTHE0eHh4MHdDWW50ZlJMSmRKM0ZhWjFKa1NXbzdaaXB0VWNhK20yaWNXWnpIWUh5WWwxOFQ4OFA5UUgyM2krMkgzSHZjWmk2bngrL1ZjbGhKS2UwVzg1Sk1ZUHFJM0RJUDkyaDlkZEJpeWI2eVkyYW0yeHU4UXlNSGsxaEhaNUZpYm5HUkJJaUQ3bnR2MGxLYmZwcitxdFJ0OE5DNXF1cmxkd25GZFdVUHNFTFNMOTZTemtsTWkya2pGRUJCRWhBWW1vb0NUUnExMzFUWXU4dkFtZUo1ZHNHbmtGbEJqbXZjTmxyU1N5dXVZUjBTNXVHRWxyTXUzSkJDL1BtVUlQRnQ5dHRWWnE3dHJiMVg0ZjFMY0VwdDFXbmNKK1I0K3hPTFR4cTFXUVppWVJvOXhJWWV3R3QzWlpLZDZKS0t0QnhrakpKRlF4cHF2RGtkdlUwYkdmRHRxcUpweXZtTTE3Wk5hTXN1UGwrcm10Mlo3cUR1TmJuNmFScWhTa29xZUpOS0ZUOEJ0cm5hMm1WYlJQcDMxT3VpVk5OWE9xNmFBV0cydjdxNVc1R09rYTJ1dVlubTd5SThieG5jUnhHcFlMUTBMVTBRN1ZTaWRWNUZQMjdYdk8xdFByci9BQUQvQUkvaWJ5NUx5M1AxUDFBa2toalFpSTFBNmx2Yy9GbUh0V2ovQUphcHk1VjBVQ3J4bis2MHpQNC9FaHI2cU9jSWJyRzNHT1FTT3JTWHNTd2hRbjZTaWsxSkozNWJjanFEckhScC9BZkcwM01OZkVtWTN5ZTBqTU9PaGd5TXEzaFpGdURheVN3c3lFa2t0eEpBTmZZRzlOVlh4UHJwcDVvbXN5bnBhUEdIK281WXZ5NVV1V2ludHB4RUZxQ0xkd1JRZ2RzQmdEem9SN1QrUTBLNnRGbVNxZjBHVjh0SmtBVGEyOHl3azBEU2poN3VBTkdEQWswNmZMVlAzT3BHdUpWaVdmUTQxM3RaV1cwSVdFSzdzb05lSUEzTlA4TlV3OVNUeUpOS1RtZjd5Wlo1YnlHeXhqbUthZWRZektLRmxpSjVzM3VCb050dGRKN1BoWDdyZEVaL3YvSnRqeFZ4VmZxczlmZ0xONklycjZ5RzNFblp1SUxjVzBjUjdnK3BtaVZ5ck4vWFErL29DTjliT1AwcGVNL2tqbGN5M3R4MGhmVTE1SzB1N3lHM3lzVkxLMnUyYTRodUptTVVQMUN4TEhkVzFVOTVZU0ZpVHQrcjUwMVpWMVZ0dldPM2wyWlhaV3RSVzZTNW56Nk5lSkt6K0t1SWJ5UHlPRmJpMXNvNGJZM3FOUm9oYVhxMWpCaEh1STVJeXRUNEQ4ZFF3NUZEcHBNL21YY25GYmNycVVvVS9ENEJ2RHc1WHpPNXlzTThuOXB4MEdOanUvck9CK2pGdGk3WXhTQXhsU2hWaWR4eUFMQTBQcG9mSnR4SlBxNStjdGhGTFd5YmszdFVmTFJmb0hmRnJiR2l4dzEzWWlCTUphWE5qUGN5b0M5Ukx5UmtKQkxBRjFxVzZLUHcwTG50WlhhdDFhWnZjV2xIaXE2UXFxSFBYeWo2alpuOERpWmpmd2RoVW55NTUzUEhrN3ZIY1c4cmtlMnByVlFXK05OQllzbGxIL2lhT1hEU3lla2J1dm4vQUNCclJ6UDQ3Z3hEYkZwb1pEZDNUbWdaRkVFc2dDaDl0bTRENE0yaUUxOXl6YjZxQWU5YmZZcEhaeS9vd0o5eExYTy85Z1ppQzNWVXdtRk5pMHJmcWVWTCs4bEN4c3BvVVBKUTNGaFhqVDBJMGJ3OGRGbFZuMWVuNWZ5T2U5MjVOL3MvYVNoZGZpVm45dGNWTmUrUjIxM2JGb250bld0Mm9vSW1Lc3hhZ0lxUWlzYVY5TmFYTnlSamE4VEo5cXc3OHlmaDNPcHJVVGwyNU5DVzdKbWptZ0JVRG5RZ0JXSkM3bW11SXNwMVg1bnAyT05xVDhTZ3ZMN21hOHlsMjkxSVhNaENGaVBWVnBUOHdCcnFlRFNLS0VjWDd6ZmRuYW5SRmFaQ3g1YzJpUEpGM0pwMUpOZjl1dGhNNUhKUko2Q3pjMkVjYmxXUXhtcG94NlZIb0tVL0xSRkxnMjFlQmhEempGSXBWQ3VwRDh1VlJUclVkT3VwTlQySkx5WVR4c01ObldsMm9aS01lYTA0bW8rT3FzcnM5SUxLVjI5eGp3T1JseE9TaWVLOFV4U2tTS3pEa3ZiTFZGQnVLZ2lnMC9WZENwelczeFAweit4L215K1YrSjI4VDIzMGo0eU9HelZXa0VqU0lzU3R5Tk5ndy9xVVYxazhpN3JrMzNhOVU2ZUVHbTZyYk5VNDBLSysrZmlsdkJuci9MNDhmOVBkeXZLeTA2U2srK2hIb1RVNjRyMi9sUmQxN051UGhKNlR3ZjhBOTU0aXBaZXFpL0k1S3puakxESjN0OWZUR0t6NUZ4Skd2T2lVRmFxTjl0ZWg0YzZkVWtlYzgzaFdwbHM3ZENEQjQxaEx2akpEbm9XVmorbDBkR3IrWXBxOTViTCswQ1dESFpmdlFhdHZFOEJGQVRQZmhYSWxFRG9PNkRPaUJrVmxGRHhlaFd0ZmFldTJxNzVyTHBXV0U0K0hTZGJRZmVQWGo0VE93U3hHU09DNlBkaldBaWlrR3NpMGFvMkg1Nk54WlZTNnRDZTNzK2pBZGtPUEV1V0t3c3JzcE5iM1JQZGpFOGNNeUdOK0xkZHR3YUg0YXlyOG1pYjNlblg4YW1sWGk1R2xDM1Q0ZnlOTTlwS3FGMVhuSC9tRzQvaU5YZzdVYVBxREhoTDFxcFUvTWFrVnNoU1E3bGVXK25UR0k1VjFQNnFqVTVHUHVUajBycFFPZmNtWWZocG9HRmZ6eTNFdUhobkFvNlNNaFBLaG82Z2pZL0NoMUd1bVQ0b2prVGRQZ3luNzdHeFJScmNRM0tTRnRuaVkwa1YvV28rRyt4MFV1b0YwT25mdDdaTGhjZjVKTkpRLzIvSDQ3RnJYL3dDK0NDTjNBLzhBVXphd2ZjTHpSTHh0K2gyM3NlUGJtYi8yMVgxWkZ1QkpQMkxVRWtmdFJyVWYwVjVOdjY3bXVzenVkVkc1NkRmYzJ6eUxKY015aG1veTFVMFVzZHFrQWJlNDZEdGJVMXNWSUxWd2RyWlc4RUs4S3ZEVldaOTFZN2JtcDY3K21zN0xiVUV6T3pmeEFIbk9kd1ZrelhkeVloYlk2RjJtbmdKYVJSL1dqYjhhbWdBcjYvanFHR2xyT0V0V0VjZXJ4NG5rczRTbVo4RGxISDNzdmxubU0va0YrVmphN3ViZiszVzlRYVJySnNGK1NLdkgrZXZUT0Z4MWhwV2k2bmpmdVhNZkx6MnlkbjA4bDJMR01GRkxzUUFlYnF2b1hyeUZLL0lhWnNHcXRUcXJINDFGeEZqWkJRMDBObmJMNy8waFZoVkNQeUkxNVZ6VnV6WGE3Mlo2UHhiT21LdndCWDJJeEVkeDk5L01zOFlyZHZwTFpyT0taWWlzd1lDR05xdHlJT3lVWTBxU1BUWG9IdEUxNGRGNHIrSnlmdWIzY2l6OEM1UHZwalk4bjlwZkxiWjVYdDZXUGVqbWlVdXl5VzhpU3A3VkJKcXlnSFJtVzIycytabjQ2N25BbmZhakJQNDEvcHhCbHZYdnJpK3hPUXliWEVvY0VOZXh5TUVBa1ZXb3E4Vjl3MFI3bGV1T3JTMFZheCtYOHlQQ3hPK1N2ZHV5ZzQveitXdVluVEZqRkM0dGIrT0tGYjBra0lyenM5ZWxLcVVyUW5RbkRTZmZ1alU5eGIrNzBPalB1UDhBWUg3WXY5dGNubnNoNDlhUTVPMHhjZHd0OUZHdHZOSEtrYURrV2lDaGhVMWJuV3V0cmw4dmNub3RINEhIOFhqWlB2TnV6MnVkSC9BcFd4K3lOcjVINGRmK2YrSWVXMytPdmNLMzBrMzBSamExUm9raW9yQ014dFdzaDNxZHFhcmF4MXhibjFDWGJJK1FzZGErbng4Qkx5V0o4OHhrbWF4bWNqc1BNbXhrVUVzRXM4RWFrck9hVmtabFIyNjBQdjI2MU9oS1pLdFNnKzJHMWV1b0R1YnJOZUp0M2NyNHZuZkZKQUFmcU1UY1NOYTlkaUVsRHhVLy9lYWw2TGVESXRaTWZab2RNSjk5UExzRmNpMXQvTGJLL21pVkYraThocyszSnhHNnA5VGI5eE5xL0hiV2ZtOXA0K1hWMWgrS0M2ZTVacTZOeWl4OGIvcUp5WnJKbnZEcFhGZVVtUThldUV2b1Q4K0ZTMVBsWFdYbDloWC9BUFR0QnBZdmQ5SXRXUnF4SDN1KzFlYmtXQzR6NXhkNDM2cmJLUVNXYnFTZWgyWmZUV1RrOW41Rk8yNUdsVDNYQyttbnhHbklXV0J5dUd5RjFnNytQSnJKYTNQYlcybGltM01Ma2U1VzJHL3JyTy94cjB5VmJxMXFnLzhBek4rTnBSMFp6WDlvb3AzenZobHRKYmdpVUJnZTZyVUMyenFRNmppUi93Q211K3ZRdmNOZVBkZVJ4dnQ3MmNpdnhPcHBmN3JpNFpHanQxamhsVGlKRkJZQkg2L2dkZVlUYXZRN3l2MjhqVXZVQVh3dXBKNHJpbytqakpxT0JrNEViZ3N2R3BXdjlRMU5JT3BGVTEzTitPZ2d2YmM4eUpWVWxsYVZnd0RWSW9wTzRXbTlQVFZ0WHJCREpaMGVobGVlUDlvSTBqQmtaU0FDb0pKb0JVYitvMU8xZkVXUGxUMEJlTHg5d3d1WVkzNVJKTHlFZlJhMDNQcWVoMDFWSVZseTFVTjlRaC9iNXhHQTRNck9OaWR3UjYwL0E2YU5QTXArNnBGeVcya1ZpNVVGbElEUmtWcUJYcnR0cGxacEdpcnBsVS82akxFU2VDWWUrVlF2MCtVVkdGS0g5NjNrNi84QTA2NkwyUzMvQUNXWGtjai9BTmtXN0ZYeXNjN1dyUFNvWXF3Nkd0Q0Q4UnJxMmNSanUxM0xLKzNXVHl1UnppVytVdlpyMUlMZVJMUlo1V2s0SWZjVlVzVFFFaXROUXg0NjFmcFVGdWJMa3lmdmNsalIvZVlZZklUK081dkNKZFd0cjJvSUx5MmthSzQ3Y2FBb3hWd3lscUhlaEdzSGwrMTc3TzFiYXZ4T3A0SHU5cVZyVnJvTmVNKzRIZ0dYblNTTEt0anJxVDlVZVJSb2d4K1VpY2wvaVJySXZ3TTFQN1orQjBlUDNUSFpiWkh2RzRXeXZHYS9pbWh2b3BSU0o0SEVzVkJYK3BUUW5XZmJkVnd5Ni9NbEpJMnY0L0FqTHlYbEo2eGl0Tno4ZFVPd2x5bXpOY2VMVnFvbzlra1o0SGJaL2FSVWZEbHBsWWk4dTVmSVdtWkxIT0pabU1jcFhpazU4Z1I3Rk1UZTNyLzdWZEc3bmFpOGhxSmErWUlDRzF6ZDVaZ0xIRFBkS1VDdFVjbUxCbTMyV3FsTmhUVmxtM1ZNaFdrT3k2Snd5MHNlWkk4ZkJlOG8zanNwVmpsVGtHSEZKUDhBTnQ2MXJ2cDVoVDRHZmRwdHJ4S0ErenNpK01mZE5zVmNFd3dtNHpQajdoQnpaT0VqelFsZm1vVVUxMlBMaS9IVnZnemllSk5PUTZyelJidGs1bHpkMms0WXFZK0x0RUNKUFlER1dwUVVGV0o5S2E1dm96cWJMZFRVaFlyd24rM3h2alpMbExySFpFTlBheUk3c1FXZjNoNDNvS2I3MFBwODlXY3hwcXRxOVoxSThCdWp0VjlJSzZ5LzBWaGFXVmplS0RsY2ZlWEVNcVJwMmtNRDFqVmVaSURWa1ZLL0QxMFp4dlhMQXVXL3RYWG4vRWdlSTVmSFcyWHc5MWJTOWk3eGVWVlFIOXJSdzNNdmFEZkQyOTVhOVJ0b3prVSs1UzFmRkF1RElxdE45RTRmd1pvOEI4RnRyL3ozN3IrSElaN1BONG96NW54M3R0eElQZCtvV05sR3pDa2lEcG95bVRkVEhaOTBaT1RIc3Zlbmd5dVB2TjQ5ZFdlVXRMMlJJeEhmUVJTV3R6R3ZBenczRVN5UnlFRG9hbGVROUNkR1kzS0JMcUdXMTlvcnlQSy9ickZYQ3lMOVRZWkNUSDNLSGNpM3ZRcnFDUDhBS1g3WS9qcm4rZmoyM3MxNEszME94OXF5SzJLazlFM1Yvd0Q2dWhZRTJWdW9NUGJTVzdmL0FIUmpzdXlpQTBKdXZIN2dTcFU5YXNva09zZis2WjBUL3dENWJyK1lZc0VyYS9DUG5YK2hqbC9FL3RkbnNqYitUUVFUK08zOS9rN1daUEtNRExKakxuNlhKeE5BZTVMRjdPS1hNYk1ESWhYYmpYZld4ajVPUjRZc2xhRjBmaXY2SE81K0hzeXRMUjlkUEI5QmM4eHhmM2E4SEZwNUltWnRmT0xTYTJ1clM2VEpSREhaQ0JzYzVpbGphYTNQYmxJSHVWblFGbC9EVHZqY2JOcFgwTlB0NWx2RzV2SXd5dExycnFMUytiWWJIUXRpdkxZN2p4TEkyYzZ4MjFqbExNVDJkWjBBTEprWTJkRHhWZzYxNDdBVTByY0d5VTA5WHcva0YxOXpyYTIzSXR2eDdmTWs0UVI5L3dDb3RwVXlNTTVsYUc0NWg0WE1ZTG9lNGhLOFdweDY2cVNjYXFHRXZhNWh5TTFoZFhGLzQ5bTR6RlBidzQ2RmJudHhTbVVKR0dQRmtOQVNJaUZZKzRHbTJxTXJTdW1sMUowVTBkV1dGOXJMK1hCNS9OK056VHh5V0xyWjVySHFvNHFZcGsrbnVlSHB4cVVZRDA2YU5xMVpKOStoalphdWwzWHNEZnZSNGhIbGNMZlJXY1FhNWlSMFJCK3J1V3JkNk1pdm9VTGFNeFhqUUN5MW5VNDQrNG5pelpMQndaZXpXdDFacUdtU203UXR0L0lqUldHelRoZzNJcXJLZTVWdGpmWENzMGJ5TTBSMzIzcFQxRmRHQUk0NEc5c3JjbVZsWnBYUEFBTUFSWG9RTk01Skk2SThGeUgxZUxOdEtlVFEwWlArRnY4QXowRGtyRE5EQmZzT0Ztb0wvSWVtcTJGeUZWdkFGb3dyVGJUQ2swellHMnpWaGRYTUtjcG9XUGZCSlk4WkZvQ1BnQVI2YVB3NVc0cSt4bWN1c2VwQ2hMWUMyc01nczhRa2MyazBTN1ZJY0FzakFrN1UzQitXakZqbXkwQXE1UFNjNitWWW93V2Rvd0FJS1NBRDRVYzlkU3kwZ2pTMHNpK0o1R1ZJaEJDeGl5ZU1rRjFaVGpZcWl1SEczcHhmZjg5Q1dxbW9ZUlN6VGxGbGZmWHlxTHp2eXJ4ZksyMUc3bUF0cFhWUGNJN3A1cHU4dEsrMHE5VitZMW1lMjhiL0FCOGRxLzhBa3cvbTV2dTJxMS90Rld5bFdTei9BTFlyRHN0eGFFeUtlS3VLOVRVZjFhMEhUMVNnV3RrdE94MU45a3ZKbDh5KzNWejRka0c3MzltQnM1b0FmYzJMdkZaVkE5YW9TOGZ5b3V2TlAreDhlL0h6MXowV2t6OExMK2FPbzl0eVZ2VjBmV0JKOGZoRmxqYzE0TmxKUUwzeFM1a0NTU2tKM01lOHZGVzkxUDB1d1A0U0Q0YTI4Nys2NmNqSDB1dnpHd1pYU3RzTnY3WHA4Q3RNVjVoaC9EYzNrN0o1R3ZzZmNjcFlZN1FDWmUvV2dBQUlGZUo0bWg5TmREOXEyV2ljUS9NemNQTXJndmJ1bVYvNUpMZXo1bVRONCt6L0FMVmFTT3NzVXQ5TEhFUS82cWdmcU80M0NnNk5wVkt1MTZtZG55N3NtNUtKSlhobmx0eEI1a2x4a0w1cnlXK2FOWlpsUXhwM1ZJNGxlUVUxRkJROFJxR1hFblNFb2dmRHlMTEp1Ym1UdWJHejNOOUZZM0p1Zy9PM1dBZG1ndVRHNDRxcmNTYWNRcmNxOWVtdWR5Vms2VG94SHRMWHlTeDhreVBsVnZFc21GdWx1TE40SXlUT3JrdUFuYmpVKzdrZ0o1R3U5VHFyTTA2N080YndxZXZmYm9LMlp5bDlaNFpicS9DeHoyMEViMjdNVmtsVnVSMms1Y2lINUdsS0E4ZnkxWmd4TGRvWDhya05VYy9JVC91ejUxUGl2QUxmeDlGamZ5RFB5U1BmWFVjbktvVWhaWFlmcUxsOWxadW8yUFRSdkd3VGtiN1ZNWGw4clpoalRkY0pmNmUvdG1Zc2UyY3lxS3NGMGpwU1VCbGFLZ2FVbXZvVURKWDU2SjVPVnR3akt3WWtxdHNSUDlUM25NWGxQbDZZZXdQSEY0U01LMGFnQU5kU0FWQTQwQjRMeFViRDEwVHhxUXA4UWZrMmx4NEZVMkV4bXRFdEdCTjlaMG5CcjdndE4xRlBVZGRYMkJxblFtRDh6dlBKdkc3aTVmak5PcXdDNnRnM0RuUEQ3VmYyKzRGMWFtd05EMTIxaDVjTzI2UjBQRzVEdFI5d3o0RG5MWHhEeVNLR2RwQmg1M09QekZ2SVMwU3ZPV0ltRmR3MGJjVjZiamw2YXF5VmQxcjE2b3RzdHY3Zm1NMlp3ZDNENVdjVnhlT0svbTcwVnhNZ2RBM0pTWllpTndJdVBHZ3JzeDB0M3BCbis3cDFMQnNMMnp1OGpkK0lYTTF0TmdKN1ZQOEFvN3hSTjNSeUlSUWZhMUVJS2xGZmIyL1BWS3M2dy9GNmx0a25vSVgrcXo3VDJmbDNqYStRWU82WTVmeHEyYzIrTlhlRnJhUGozb29oVGJpQnlVYTBlUHlsU3lUL0FMZ1hMeGQ5RzEyNmVaeUQ5dXNGbExtOGErdEVidHdJOHN6bW5iU0lLeEpjdFFVYWhBQjY5TmFlZXlpREx3VmN5UE9YaGE1Tmxtc1p5WmdpOTNpZ0VsT0ljT1YzM1BUUXEwMFlaYldHaUJrSGVBeTNWdEoyWXBpejNDTDdBNm1xeURqVFphRThmejAzVXNwZDFjb3M2VEgzdm5IMnp5RER0ejVQd2UzNFFvRldHNWtlRmxsamxqUWdJWTVZUnZ4OTdPcmZubFZmMnN5OE1uNC9VM055eVluU0h1eDlQMVgxRHQ1bEpQSWJMczMxb0pwSWUzY3BNRmFGb1Zha1lWbkMrOGxUK2cvaDg5Yy9TcnBiUi8xTzB5Vng5ZS8wSXRMYnVUUVdzTXNjdklXdzdqVmlSU1ZxU0VqRGU0cWY2aUJxU2I3L0FCSDFXcytRWFJMM0VOZEtJbUVZU01yUHc0d2xsNnN2S25wVTFydlg0NnFqYzBXV3VrdmdNZmp1WGd2NHByWEpySGRRVEJnalhNZFRDRFJWUmd3VWxmYnRRMStKR281RnRhMUJiVWRuS1FkVEhSUk12YllHNmVNY1JFbmJTUkdKRlZCTGJFZW1oYldtMEQxczQxSjFyaEh2R0x5Z1BJZ3BMRkVhOGpYaU9mSTlhQ242dFNxL1VRdmxWVkFVbXMzTnRHTE5saktOV1lNL3U1Vk5PUHhHcVlWbEpSVyt2cUF2bCtkR0V3bmF1cm1sOWRxWVk0bGFnNU51eDlPZzA5S3U5b1FWeE1LeVpKN0x4T1RzbGtreXVmdmJrWE1uWVNkTFppc2ZkVktjanlvU0NOZ1ZGUDVhN1RqNC90NGtvOHpsK2R5UHZjcTdUY0o3UXY0dmJTNVhLWS9CVHVzTTg5L0lVVW9IQVNLS1JSSXdYWTlWZnI4TlY4bTZwUjNXdW40UXVMUjVMcWovQU4zVDRkd3A5eXZGWkxheThSRnV2SzN0OGJjTFpUOTAxV3R5ZVhkVlFlTGQycml0UGFWM0o2TGc4bVhkMmVyYW42QWZNNDlkeVZGcFdkZng1Z1hNbVM4TmxjK1EzNUgvQU55N2Fhd3M3bFpFYTVTelN2TG5HS0VWTEFMVDNVQk9pTWVrcWkvdTE4cExNa05xMlMzOXFhVG5XUHgwN2gvN2FoWWg1RmgwaWVLYTh4eTQrMU5XN2twYThhWjB0NG40ME1rTXRRcHA2ZEsxMVR6VW5zdDJyYWZ5Rnc2TmJxOUpYOFowK1RDWGpZeEp3SGsyUHRZeGlyMHBlM2k0YU9Mak90dTgxTGVXSldQNkZIdFpUVW5yeTlORDhuYzdVdjhBdTZhem9hZnQxb3JreGZ0NnVJMStKTHNjdko1UStCenRwQ0dqZWFPemtTaGpSMUNTOVF2dGpXRUowWDQ2aGtvc2J2Vi9FMHNlWDd1T2xxYTY2L0wrUTNXMDE1ZlpxOVpiWXkyVXB0MHZod2J1UXRBSlJ5Q0QwWm93dGRoL0hRdHFKVTE2bDljazMwNmZpV0NQTTRoY1FmZFhGU3hNVlR4L0czY055S0FNMk52VjVLUUtWSkoycDBYOHRhWEQvYlMzL2wrcU9XOTQxeVAvQU5VL3o2Qzk5cGZHSTdIeEZNdGNoTzdrNS9xLzNLRm80WUdLQm82VnF4Q3R2OENkUTl5NURlVGF1MmhyZXhjUkxqNzJ0YlA4aDh5K2FTenhGMWtiaHlzRVlXSXlSajNLS0FldSs3VWJXUml4VFpMdXpwY21TdU9scnQ2SW9MeWE1aGpsdU9LdXNkc3ZkZWFTb2NScjdoN2ZTdXV1d1ZhUjVyek1pdFp2NWlwaXhIa0lJbjVIZzU1aGV1eDNvUjh0RjIwY0dYU3F1cEIrZHhpcmJjRFVzeEJZTHVSdjdmNDZsanREa3B5WTQwRk43WmJlWmxFd1VpZ1pXQlFtdnBRNk5WcFFKdGp1WlF4aVU4QzRWeWFFdFJpRi9PbWtQVk9ZREVmZXRvTzZ4alpLZ0pYNE4rb0NoclRhdncxVk5XNExMMWJySjAvL0FLWi9QcE1ibHJLeURTckFBeUZFUEtKZnFCMnczR3RHQ2toelhjYjAxbTg3Qjl5bG8wYlVTSGNQTnBzZlE2Ujh5dzBlV3Q1YmFaYTBVZ0gvQUh0dW44enJ6TzlYaXRwL2JwOUR2T0JuZUpwbkpubXZqOXhqTHE0dDdxRmtQdTVJeWtBcVI2ZkdvMTJYdC9KM1ZVbG51L0dyYXJ5VjZQOEFIMUtCdGJITENOakJCSzBZWTBVSXpEalg0Z2E2MTVLeWVYckhiV0NTbDFtNHEyeUsvdlAvQUN5dEtrZjdScFJWaW05ZENhc09idXJhc3RzVEdYWjRtYjI4bWlBTHF0ZlVnaW8wN2RVeC9VMTBMZCszZHBiK1hXd3gvd0JkRmpyOVFaTE4xWjVwSkhjZjhvRDlVZEZVdC80Nnh1Y25WYjB0M2l2NG5TZTNYclo3YmFUM1QxbjVqUmtyUHlqeHU1aVc2V1hzS2VYZFpPL0d5MHBRdW52cC93QVNOck00L0xxbk03V2JQSTRGcjFpc1pGOUxmajRIaVo2enVZbCt1dHVFVFZEM2NSUXdvZmdXWFphLzc0VS9MV2hUbE9xOVhxK0JpWmVBNWl2cDhtUUxqR0c0WDZ6R3lMYzJqR2xVWUZnZmdSby9IbXJibzlYMjdtWmt3WG8zSzBYZGFvR3l4UEM1U1FGV0hWV0ZEL0E2dkJ6eFpDcEZRS2FRNUlXL2pqV2l4TFgxSkEwOENBbmxyTGYrTzNxY0IzSWVFeThRUDZXNG5iOEcxWGJTMVg1L3FPLzIyWGtVcGJZUmNubGJLM2lsQm51cnFHM2VCNkJ2M1hDZ3I4UnZvMlkxOERPcXBjSFIrS2NueFR5UElQOEE4bko1MHdXd0I2Z09ZeC9JL3dBdGM3eS9WYkhYeWJPLzlvWDI2WmJ2cE8xZm9UWHRlNWZ3Um9hZHNBTHR0VngvTHJySWR1cDF5eGFKanhqc2ZGZFh5cklLeFJGQUNOd1ZBNC9DbWc3V0R2MjBIYUs2dEZ4VXM5MlZnNGR4MWRxKzBCbW9TR0hwVDAwRGtTYk01MXR2ME9UZnVka3J5K3ZMWEMyMDRGcGs1M0RoU1JJNVZ4eEpIVGp2WDRrL2hyclBaK1BYOXpXcU9iLzdWejhsVXNOWEZYMTgvd0NuaWF2RGJJcGQyY1gwSGFpeGxzcDc4bkxtL3dEektzb0hFVVltdTRPdXBUNnM4NGdjMnNXK25namtxMGptS0JhVjNhUThmdzlkQldzdW9iU2pjSFVOdGVRT2d1SlBiSEFwZW9ydWtZSlA1Y1JyeTNJblp0K01ucHRzYm9vUUsvMG9aV1BLZVNlVVhiU0NTN250VnZyd3FhaEh2Ymt5cXUzeUoxNm5pd3JIZ3JIYUYrUjV6bnkvY3kyZmkveTZJdDc3KzVsY1Q5cXM5UnFUWDZSNCtENGxybHdwcC82ZVIwSnlYTzJ2KzZ5L21Ud0tHMzRKczE1Szhpait3djFjUUFSdkhZa1VEcFdTRlk2ZmtUcC9lN3pYSTMzZjZzdjlscE9mRXZCcjhqaWVTMStwamptWjNFMFJ0b28wRE1vYnV5OGFGUWVKM05lbXJlS3RhcnhzaWZOdXJaTGVTWjJqOTc0aW4yZThodC9wVGM4N09DM052eUtsZzhzU0VWQXFBQjEwL0pjZFA5MzhUTTQxWnRxdTM4Q3VQdHpqb01OL3B6elVZdDBoK3J2SjNic0ZuRGlTNWhqVnF5YjlBTmlUU20ycmZjSHV4VlhrdjFJOExUTzMrT2h6L3dDWkc4azgxbml0OGtiUzJkclJMaTFqVnFUN01Tck1FWVVJSFJuWHBvWEMvU3pSeTBtMUlmVXVqTTl5RHhETTNpUmQrWCsyenhyYmtWRWlDTThoUTlTUVdwckQzZjhBSXZpZFJzakUrOElXdkRmQy9HUE8vRGJUSmVRK0pXUmFhYTZWVm1nSDFUcEhJVVZ6TkdFbEhJcVIrclEvdTNQejhma0pZN1A5dXE2bWI3ZHhzT1hDOTlWTTlSRHZmc3I0ZS9tdDU0ZDQ3bWJqeHRaaEhkeFFRT2x4T0xnV29tYU5IbFlTRkFQZCt2b1NOYTNGOXh5VzRyelpGTFQ3YWFBR2YyL0V1UXNkSEc0RitWL2FIN2hlSHdXOXhlWjIxOHF3THpMQzl0ZVdpbTdReUs1UUFUYzEzWmVOUkoxT3IrSDdyaTVOOWxVNjIvSUc1UHR0OFZkMHF5RWZKZU9lYmVJMjhtVHpQZ3VVeFZqR2hsa3ltQW5ic0xBeWhxeXhLYmlKZmFmZHlJMGZYUGh5T0ZaTitIY0N0Z3kwVzUxYVFYOGV2cDdmRVlQeUd4Y0pmV0ViWFZsY3pxRTRPak80TW9UMjhhcXBZQWVtcjcwVmsxNDZGV096VVB3TFU4Zi9BTlZ2a2FRTC93QjArSHg1T3lZRHVYL2p0d2s2VTlXTVE1MC9DZzF6ZVgyR2puWmFQSm1yajl5Zjl5SHJ4Ny9VYjlwYzZ5d2pMLzJxOXIvK0NaV0kyNVhsc1FHRlIvR21zYmtlejhpbXRmVjhEVnhlNDRyOVhCWjlqYmVOZVNXN1htR210NTZxcnBQQThkd2pNUjFKako2RWV1Z3I0TEorcXJxSFU1VmwwZTVFZkk0bTl0TFZpWEV0cnVxdUR1bEJVMUo5QnYxMVJEanhDOFdlbHJlREJFRWRoalZ0MGFZeENkbUZTQzFkaFg1anJxdXJTNmhsbmZJM3BNRTlzWERQSXN0amRjNC8xY3gxRGZNZW55MWZDZXFCMW1hVVdRQ3ZqRkRLOGNzSlNWWFB3OS96SDU3YXJiN00wTWN0YU1wei9VbEhLLzJydjJncXJXVjVaWE5hYmdjekYvRDkzVzc3TlpMUEhpbVkzdmxHK0szNE5IRzl0NUJkd0NraUNSZmlQYWRkcTZJODhWMldUOXBzM2IzbmwxcWdxajBKNHR0MUhIL2JxS1cxbDFiVG9IdlBybURIK1gzWGViajNvWVpWVTAzOXBXdlg0cnFtOUpEc09SVmVvT3h0NCtTa2h0TWZiRjVTU29rSTlxbHZXdlhRMlgwcVd6VDQ5bmtzcTFSMUw5bThKRDQ4NzJicURlWGtCa3VKQ092RmxvQUIwQXFkY2Z6Y3p5UHlPd3k4ZjdXQmZFdDI0dE8yOVF2czVDakNoTmRaYlVHYlM4Z2U0V3Nzek1sUUExUXcvcWpJYXRmeTFOTlY2QmRIb2hQOHJ0bXRjdGpwVmVrTFRGR0xmcHJWWkNDZlQvbUhWOU5hc0t3NU5OZXY0WDhBZmYySWlhV1JZaHlsamlvejhlSkVkR2VqZkhyVWFxVm0xQWZSMWwyWXc0eS9TUkorVnBLTEoxZVRzcWFjaktmaXJVcW85T3VqZHNRWlYxUFQ2bEFabWIrdy9kVEozaEVndDRzdGpjeFc0QTVtQzlSWVptSUd4Qm8ydXk0Nys1eFk4amd1VXZ0Y3lmTXZ4cmlFWlM2UzVWVWE3alJFZFhNUHRBcUNoSVpTUVdKcnQ4dGNobXRaeEIybUtpMUkwMlN0OFJseGF3T0VOdEdKZU04aFpLT0dMTEdGQm9YQURINS9qVFJXVEpGSVlOajR6dGJkVHIzSzQrNDlqUFlwY1plR0xrMFVwdmJObENtT1JWbFJwRllxeEd4WHBXdnhGZEg4SmFLT2pNbjNGejE2MUJJdHNQbEx2S1JZbU5YTi9hVzl4WTI0UTFTWWNvWkFpRWdnaGxpY0VWcHQ2YU5kclZTbnN3YkRXbDNaZUtEM2ptWU9HLzFSZUtlUXl6Rm9mTnNZbHZkbDZWNzg4YlI4SHBzU0QydjVhbGd0T0YxWFdsZ2ZtVWpLckxwZXFadi9BTlJ2aHl3ZUJMSkFEM3ZHcis2eGdlbnVGdUhNdHZVOWRvakFCclN4VzErSmxaRm9WQjlsY3ZOSGIrU1lLMlltUzR0ZnJMSURxWjdadTdIVDUxWlA0YUQ1MUpkYmVjUDVtLzdMYmVzbUx1MXVYeHJxWFJmNWdReDNkM0dBOXJITFllUVdyTFJqOUpkcUlMa2ZrcXVXL3dDTFhPMHd0UlgvQU5xZlRXcDBkcjZ1My9yZjVQU3dQdExXOGx4aitNUnlxUzAxMWczYVZ1Q1J5Slc2czJQdUE2TFVHbEtNZEZZMUQzZkMzOEdSNVZhdW1uWFdqL1dwWU5yUFp6NEMzanpzMHR4RGNOWVplZDFYbDJvc2hIOUpkaXFqWVJFU3N6VStSMEZqdXFjbWFxTjAwZjhBK25XdjVHSmV1NmsrR3Y4QUJpamxMdkZlTlkyV2Z5aTR0NDVNZHd0cjZMSWU2T1crd0YxMldpQ09kMnViV1gyTC9VTmJlSzFuYjAvaFArUlRsMmJFM0hUODEvTkZKV3VHaWw4clMvOEFEYlc0OGNzTEthVythVlJMYVNaS3pEUGNSb2JNRWhBMENuZHh1QjAwZGEzcDlmcWY0N2dGTWZxbW5wUy9QNUhRUDI0bTQ1dFd1TzNjNCs2a1plQTl4RWJ4bnQ4ZUJvUWYwMFllNEdtc0xrSnF2VG9iOVhPbW1vMTIvaitKd2VXdzA5bEdGeHd1WmJHV0pveUVFVjB2ZVZPSjl3WGtxQ2hPeDZhZmo1WjZsSEx4ZHhrems4ejJXUllBUGVSUWZWUXdiRHV2Q1NTalZCSEpvengxb3BHVnAzT2NmKzM0THVlVEhvdmJzOGt0eERhZHlnOWt3WjdjN1YvcVhnZmdkRjFhQmJUTUhOWG1QaDgrSXZuYUdMakNoWXRIVGlReUdqcitOZEYwdk9nSGtwR3BEd0ptN3FUSWdvTmhVai80MjFhVkk2RSsyUU0rUXQwbWFrYjBTUUE5VmJZNkM1RGhTWDQ1bEZuNU96bndlU3VNYmRmODJGcUJ2UmtiZFdIeVlFSFEyUElyMVZrYWhEa3ZLN0E3bjAxWVJDL2gyVlMweWt0cys4TjlDOExBOU9YNmwvbU5XNHYzSUY1YS93Q05nM1Bxb1diaHhEbm43ZlNnQnFEK1BUYlc5RFduY3djTnBSUW5teVEzZG1KNGgyNVVESXNDZ3NUdjhodDE2blVjdW5WbDlGTEtmK3ZseCtRaXVrSURJd0REMDRuWmdkQUY2ZW8xWkV5cm5lS1NGa2p0ZVVWTndGbDR2N2ZRYm1wMHlKZHduYUdZeUk0UnVaTWJJdkgydEpRMUZUdlExNmpTWTg2ano0L2w4LzhBYm5JWFhrV1B1djdUZXl4UEEwTWtVZHh6dDVXVnlHajl5OGdRQ3BQVFdmeXVMVGtWMlhXNVRJWml6UEc5eWNDUjVINVJsL0k4dE5ucytmN2pkWEFxMHQyN0tzbFBhcGFPTW9QYW9DaFFhYUl3OGVtR2lwVlFrRDVNMXJ1WHFDLzdubERBMzByQ3dzMi9WTEQyN0NHdlQ5WUNraW56T3JvUlZ1WUJ1N3JCVzZ5UGNaRVhWMnhveTJzYlRzYTdtczhwQS9nRHAwL0lZSFdsNFd1N2ViSFdqUnVrcVBGUEpJWGNGV0JxQU9JclVhZDlCTHFkeWZiYk4zV2Y4YnR6YkRsZFFzb3lFNnVGYzlsbmxDMEJCSVlHdXc2ZzY1M0l0dDQ3SFZLenlZMWJ1dXBKejE3ZHlXNkY1dUdNRnc3RklTc0swaVBNTkkwWW9BWDNGU2FqMCtBbDZyZW1hdkhzbmhhOHhRdTd1eHlrNHNjbUFjQmJJYjZhNkNoM1JoN1lYQmtYa3JoUWFpdTZnZkxSZEpxcDdnT2F5dGJiL2FVZGlzVGYvZDc3cHJaNHNtU0dlY1EyalNEaURIR1R4TFVCSS9xZHZuclZYL0hUVTUzSy91NUhIUTZGODQrNjJNOEt4d3Q3VEd5MldZeE5pTEo3UGlCWlMzWlpsRXFmNWxaRkRlbTdIUWRjU3U1Q0hrMnFEaks0dUpMeTZ1Y2prRDNuTE5jenU5ZmRNN0UwUHpxYTYxT21pTXg2dVdEY1plelJaSCs0alljcU1vNkVOMUdwV1NpQ0tlc2xsZUQzOE9LOHF0bGRJM3M3NDloV21GUXNkejdTUlRvUlVqUXVhczBZWng3N2JvdEh5QzVreHNHYmdsV1JHaGtEUVdmczR5eE9oajd2Y0ZSeVZTcDQvRW5ZYXk2VVRnMjdaR3AvUXMzN1VlZC85d1lQKzMrVVFLK1F4MEVweGR6S3BhZGw3WkFLSGZpYTBYclE2b3pVMldsRUt0dFN6WDQ5aU1YWXBGbUxmUEM5dnA0MGc3VURBeFd3bVpBOE1uVWZyNCs4bjIrdFJxR1Z0cUlGVlZtWkV6N2xmZG5NTkxrdkRNS2l4Wm02TW1NdjQyRlJBNGtvekx0VldIWDRiazZiQnh0elY3ZEZyOFMza1o5aTIxaVhwOENEWStOeTRqRkpoTUFuMU5vWGhqeTF5dmJyY1RxdEhpVWxxOXBRNWIzR25JMXBYV29yVHF6SXNvMFFIdjd2eG54L3pINkhFVHAyZnBaWXBMTUtwVkdTaXVWSTQwYWhyMDlPdXBPWFdSNk5LMENQZlkxckdhZU9iOUVMVU8vRm5pbE5RVUJvTjYwTmQ5U1ZwV2dvMUlObGRaYXhXYWFOSlhndFVIMU5semFzOWxJM0VSdUJRa294VmxwNlZwcUY2MWNKOS95WWRneVhTYnJMMjlWNDFmOEFKbGdXUnRyUXpKUE95UU1VSng4Y3hFZmRPd0RTRXNXTzNLaEhYK2ZQV1RmYlh4TzUwU2ZxalZhRFRnWVFiaG83eUp6TmtHNFF3dnhWNG9ZK1BJaVJVVTFydlFEYyttaE1uVFRvdW9UV1Zaem8ydFBsOUJzbGVTNXZqalRkdmN3OFJDcXlPdzNPNFZsQ2dNZnc2NkZWWXJ1NkNybFV4M0d6eG5CMnlxNkg5SXB4Q3VPSVdnWUZRekhqWFlVOU5DM2NpelpIVmFEWExCaURISWJsSkFrRVJaTGVudWNtb3BzS2tucDFPcTVRQ3JYblFGWmZNMmVHcys1UU5KRWhFRmpEN3VMcjFCQm9kdVZDU3UyMjJsdHMzb1hZcU83Z3AvTmZjL1BTNU5yZEMxaFlSRGpDMGFNV1kvN3ZMZ2ZXZ05LYTBxOFN1Mlc1WWJpb200alR6Ri95UFAzVnhoNU1qbDVwSnBLa3g5MVZWMGlYWnl0UUNCNlZyNjZJNDJCUElsWFFzOXh5MDQzR3RaQ0RZeDJ0M2ZYY2QyOFVKdjBhOGUxaTdnQWhCcTZBTjBvdnZGZVh0SnBYWFEzVHFsSDl1aDUzZ3RTMW52OEE3djBHM00rSTRyeExENG5JV3VUdGNDOXhESmRRenpYalF6OFROS3pCUGF5dUhqN2FLUU4rTktWMzBOVE5iTmQxZGQwZVduNFJMSnN3T2FXMi9QVVNKZk04UE5qcHJkbmxTNWhNbHhnN3FhM1pJWnBwekZ5WG13TDBSMTVVYjJrVi9xNjZWZUhaT2ZxZ08vdUdQYkVOK0QrSlkwL2l2aWVVOGR3K2Z0ZklMbUxPVG91T3RZY3RFNFNXNGxTTko1MFFNNmlLdlB0OEY0am9RQ0JyTXRueVV5T2lwNmV1bmg1bWxpeFZ5VlZuWjdscHIvQkMxYlQzUGpYbGN1YW1rdVlzZWVGN2FaV09NelR3SkhidkFIcVdOWDl3cHlPekFWTlJUVjZmM01VS0oxMC9NbmVuMnNydGFkcmpYdzBqNi94SHMyVnBkZVh4bUpzaGtvNy9BQjluRE5jWkpVUjNnUVNYTW5aa1FJVHVha0VidHkrR3dGc2pXTFdGdGZiNkd0dzhTKy8zOVNYWHdCSzRHODhJOGF5MkpzM25ON2ZYMEZ0ajVHLzVYYW11bzBEcVFhaVFoU3JJUC9IVnYzYTU3MXMreTErbjZEUGozNHVLMWF0NjJVZUdyWDVscFlhUEhTU1pHeHQrK2kyUWh4NHJJL0I0b3BGWHVIZnFlWlZkNm44dFo5MWJhcmVMbjRHalZwWCszRWJWQkhteHNrMHVkOGF4Nnl5WDNrWGplVGhpUm1RZjhnSlBieDhXTmYxU0hpVHVQWHBvM2pYM2EyaUsyUmkrNjQxV3FWVTVhSXQvamJUQmhjTGFVYVBDaGJlemNNYXF5dXNEc0NPVzlYcXkwb2E5TjladGJQSloyZmQva2RMaFN4NGFWU1hTUU5KOU5sN01SdmRVRjFOWnBSM2JqSEk2Z1NNaWROdTMwSG9UWFJlSmJiVEhTUVRuV1R4dFRyYUNtUHVqT0k3Zkl6MmlOSEhrSEZyREhKdXl3eFVkdCttKzIzb05idkRVdEo5dFRoL2NMTkp2L2RwOUN0L0Y4cDlQT3R2Vmd3Ym5FSzBIekFxZlhXbmxyT3BqNGNpV2c2WFNKYzJ5M3FJT054eEhTdkduWDhhVTY2R1hnRjVQVXR3bFp5d1VPOXpNeERsZmFSdUNQU3ZYUldLejZJQnlVWFVDY0dMZ3F5bGwvVU5nQ0Ivam9rcDFZVXQ3Wlo0MlJsNFZCSVlpaEZOL2lCUWFIdmJhOUFtdFpXb3plRTVpNzhheWFYTnRjU0MxUjFFa2x2c1hIVUdoUHVvVHA4aVZsRDdsZEhiSGFVZm9QNHA1QmFlUWVOWW1mKzRMa0owRWNkL2NCKzQ2U09YSVdVOWVRVVVyOHRjSjdseGwva1Y5TVZiU2s3VGc1TjJOdFBXSkQzMzMrMzlqbWZESmMya2J5WkxCMjRXMVJDQWdnRHAzQ3dwVThWRzIrbHljVnNGMWxUNnRKK1MvMWdzOWs1ZTdLOEZvMlpXLy93QW9jZm1jQitYUjNPSHNwN213bWV6bGhQY0hhUEd0VFFpZytOZGRSeGJxOFRxWm51ZUI0Rzl2cFl0MkhuK1o3Ymk2bWFWeW9DdElxT1EzeU5OSFpPUFRxWkdQblpWM2t4UGxrMXdzcHVRVzVGWFJrVUlxeXFvWG54RzNJZ0FFK3Vrc2E3RlgrVTVjb00rRmVVeVlYeUtLYkhYUDAzZVl5d08wSmRvcFg5a2xHRkNCU3Z5cHBzMkxkWFZmSDRGM0h6N2J4VnhPdlNkVHI3NjZ5enVMVHRSTkhIZVc0bWhlVGFxRUFvUjAzUFhYQ1oxdHZhalVOSGZjWDFVcmRPVUFCNFRhNW1FM2hqTWQzUmtrdTRtS1N0UTBQdVNuSWZJMUdvNDNhdlI2Qk9YS242WHFLdVErMjJSeDF3WHNKKzRXQU1kQ3RyY0dtMjRRR0tTbi93Q2NqQlArYldndVk5TnlNNThXbG5OWHQvVCtmNmdtN2d5c1NDMXk5bUpHQzBUWVcweFlEMjhDeE1iZlBqSitXdEhEejUwVCt2NGt6ZVI3VW9sL1ZBeE1mYVhFeldhM1l4K1VXZ09QeWdOckl4SXI3R2NCVy9qclpwbnJaSTUzSng3VmJqK1FQdkxLOHNKamIzY0xSU2pxRzZINWdqWWo4TkVnaEhlM04zQmNXaHAvMUVFc1lydUtsU1IwK1lHcU16aXMrR3BPcTExS3g4UXNJVDV4aXJtYVVtUzBtK3M3YkNxbExSR2xJSHpIRHBvckphS05yd1lKeDZ6bHFuNGw3WE5qSmo4YjR4NHZVYzRaWmNsZmY4VU1LS2VWUGpNN2Z3MXpkN0o1TDM3VlVmd1BST0xWckZpeDk4bHR6K0M5WDZ3SExHMjcrU2Vib3ErMEtONmtFVVB5MWoyZWgyTzBjY2VnaWVHZFJSV2RpNUZLRUE4cW4rR2hiTWxmbzBiSHlWbmtMQ0tMajJWbFprSUtWVGYwb2Y4QU1QaG9adHlWL2FkYmVKWGVVOFRqbDhMekdVWnhISllvMDhVaXhsbVNSWFZUd1ZRU2Z4K0h3MXJjTGsyKzdWTHV6Rjk3NDJONGJTcGNOaWQ0dmF0WVk3dTFhYWRyRnBINU16RXVGQUJvKzQvVW0ydTZiaEhrYWZpRXNGM0w3TzR1Mm1WaXFYY01qeGcwSjRPR0lyWDREUWZJV3pIWitUTkhpVjM1YVY4V2pwZUNTQ0MzZStuS2pIb2p2SzJ4VUtGSmF0ZW0zeDE1cTFhVkhWbnBXWHVuMU5uK2tUeFhIWUhDK1QzMXB6TnhmWFVDU05JaUk0aGlqWXhMV05pQ0tNVCtPdlRVN2ZiU2Y0WjV0a1ZON2RlN1l3ZjZyTFBKM1AyemhteEtOTGRXdVNoWVFxT1JZeVJTeHI3ZVMxSVpoVFEyM2RueHJ4Y2ZWRXEyakhmNGZvNURYbE9JdVBHUDlQOEEvWWJ5UXkzbGhpTE8xdUpLVUptNVJCOXYrSW5VZmZNaXVuSFIzWDZoWHNTMjU2ZlA5R2NiNC9MV3ErU1kvd0FmaHQ1WkxxYS90ZnFKU2hDUnBESkd3OTNRbHVXMU5hSEV4L2N0V3ZRRDVWdHVTelIyMy9xQW1GcjlzTXR4Mk1zdHZDdnpMeXJ0L0xXZHk5ZGk4YjFMZUpvN1B3cmI5QkJ3VXFmL0FQUEhHRWhoOVIybXB2djlhbFJvdm5OcWkrWDZnM0MxeS9YOUNoTHVEdjhBa0dlY24ydk5iTVFldkpaWWxGUGxTdXFLTC9qYkQ4bGw5eWk4aTBiMTZlTVpScm5tMFMyczJ5c1FTREUzUXFRUWE5Q05ZalUzWHhPazNMWTU4Q2I0VXR2WmVOWWV5dHU0eWkxRlM4amtySVpIY2lyRWs3bWdIdzIxais4SnZtV1hraVB0dGY4QTkycS9OZ2UxdzlvUHZLMmV1clcyYTRHRlBPNzVOM2tabTdBSlVlMnZDcTh1b1hSbUc5di9BSys5Wi91ajVGR2ZFbnlxTkxzeVo5N0xXNWs4Qm11TWRmRzF1clM2dGJoWEViUzFXanhFRUtySGJ1Y2dlSjZhcDluaW5JcXZGTkZmdUNkc1Q3UWZlVldWempmdDlsNEpybVNkbThldVlKWjNYaUorR1BZRmhzQ0trY3FIVkwxNThydmNOY1BpUjFpcHpkNHBib2JMeGV4dWtXV3p1SGlodVl1cXRDMHBXUlhBb2FGU2Y0NjlFdnBMT0R4ZFVoKys5WCtuMzdYK080N0grVWVKU3RnWmJqSWZSTzFuY3lTMlRCNFoySlR1dXpLeUdJSGFTaCtHdWQ5czl4eTVzcngzaHBLWk5ibWNMSGpyS21yRkR5ci9BRTgvY3JEWXA4bGl2SWNaNWpoVXR2cTBpeWNIQzRlSXg5MVZqTW9lckZmMGdUQ3Zwb3F2dkdIN2p4MlRyWk9DbCsxNWRtK3NXWDVsWlIySGx2amtjV2R0ZkhjNWhyRTd4Wm5BeVRyYmtnQW4yTjNVRks5T1kxcTJkRzlyaHZ3TTlWdlZTazBoMzhhLzFLZmNyRHFrVnY1WmJaaTBsRzFuNU5iR0tSZ3BvUjMwNUQ1ZnJHZ012dG1DK3UySDVCR1BuWmE5NWd0TEcvNmw3YThoaVBtbmhVOXZDbTV5T0ZrWElXWnFLRWxWTEVBLzhXc2JON0FuL3dESGI2bXhnOTVkUDNJZFBIdnV4OXZQSktRNFR5S3pEeUNpMnQ0eHNwMFkxRkNIb0QxK09zYko3WHljVXlwK0J2WXZjK1BsL3VoakhOY1h3WkpKbzFuaXAvMDcxRENtd3FycVNHQlB6cnJPaTFYRmxxYk9OWTdxYVA2RmNmZTYxanlQMnk4b1hrelNSV2huWldHNDdja1VncUJ0MVRXcjdYYU9UVUE5MnJQRHV2SmZxY1VXT0hlOHhqeW9Lc0ZNbGZRQUhycnZMV2l4NXpqd3U5VzEyREgyMTcxajVmajVTVlVGd3BPeE96clhiOHRXdGxOVkRIRC9BRkNZOWt6ZUl5RWRmM3JlU0ZtSG8wVW5JRGIvQVBhYVpNbmxYY3N6N1FlTXh3NFN4eWNvQmxtUlg1TUswNURyK1d1Vzl3eXQzYVI2TjdKZ1ZNS3QzWmZuamFMYVg5akxIVnU0WlltY21wSmVNN2ZtUnJBeUp1cHI4bldqVStCWjl6R0xoazdUUEQrMkhMeGpZMDJvZjhEb095VGlEbktXMjlkZFFlMWtuYTNvWnFsQ0tVcjNCVHI2N2FnZ2haSFBrS25sbUtreW1CaGl0UXhtZFltVm8xN2pxd1JxdlQxL1JvckZkYnRGSVJqc3BlNXgvcUxMWXE4djhhY2JNelJUVzZtRVBJS0FCbE1nNjFxekFHbjg5TlNLWlphME5MTGtUcTl2OXlQTEJHeDAwTnRFRkVhUXhodTM3ZzFTVmNiVkFOQld1aTNrclp5VXJGYXFqc3U1VmYzaHRoSDVaajNETXozK0VudG5rZWc1U1dNeGxqMkFBMlY5dHRkVjdQZWNUWGd6aC9mY2UzTXJlS0hieEh4MjYvN0N3dHhOR0dhOG5lNnQwaWtra0l0SjBSVUQ5NHNTV1ljdmdPaXFLNnlPYmV1OXBkVFo5cXBkcE8zVHFIUE1NREVNM1pYbmNRem0zV01FVVVWakZDRDZFajFwdDh0Wm1USnBDTnJqMFRiZlFUTTNuN3p5SEJMZzdwTGFLYXd2MWpNU1ZTS1pTbmJKY3VhbHFpbitHdDdqVlZWdW5zY256SnM5dmRDN2hiVnJZZVAzNFFwTkJQSllUdXJFT0hBSUlORDhZdjU2MGJhcG1YU2EyVCtSajl5SU1sWi85b2VVWWlKN3ErOGF6RWtidzIwYnZOSEdDbDByRkVVMFNpcFJ0VmNhRmU2LzNKUDVoM09tMkhHNDFxMnZrOVRwZjdyWTZ5OHY4WDh1VEd0SGN3NWJFVzJhdGUweXVCY1c2dEhLcG9UUnFKYjFIWFJtQzlYR3BqNUt2VTRQKzIrU2p3bm5XTWVWcVc4MGh0bklOS2R3RkFmeUxMcTNsMDNZbWdqMnJOOXJsVXMra3g5ZERwdkU0cTJsc1lyYVZsK2hTYTl3VjBxaWc3RjJwdUlRQ2V0RlJWSHpiWExYMVRzdTIyLzAwWjNtU3FyWlVmOEE1VStUMVFHdUk3L2s4elFGN3UzZ2d1Sm9WNXV6MzJIbFdHUjlqMWV2RS9GZmxvamRySGc0K1ZpRktwMGM5YlZUbi95eHVCcHQ4ZzJOaG54bjFFWXhOeFBmWVcyZTVSYVIyWGtjSDFsb3pLQ3BhTkxsU3Y2dGhVVkZkTDdhY1hTMTBmenJwK2hnNThTcTNEalg1UmJWRlVuRXgzZVkvdlhrMTVObHM3TFpoOGhlWHlySjI1YlNiNkRJeFJScXF4Z0pBOGNxdHhMMFVFdFhXMVJyYkZkRitHWVZxdE9iYXY4QUNZUk0wVnYvQU52WmE3aTUzdG5IZFlESXgwTlpiL0JQM1ZCb2EvdlFWU3RQWFZibzF1WG5QMUNmdXlxMmZoSDBHNzdkU3dZZnlHS0ZiampISGQvUjI4MGxCQkpid2lzUWNtbTdRdkd5bXVnZVNuRCtBZmc4K3ovSWVQSzRMczM5MGVVdHZlVFJFS3FPYXMxcUJMR1l3YXFlSEVHdnJ1TlozR3lheEJvY3ZEVjBWcXZxRzdMS2pNVzhWNUpLcTVDeUlrbmhDOE83YnlFb3pxcEpxdk1tbi9EVDQ2MXBkV1lEU2lCTXlXSnQ0cGJPeXNrN05rU2J6SFRWSEVTUUVHU0RjQWxXWWNnUG5vcFBRRnV0UkErNDNnc1dReVZ6YnhwVnIrTVg5cUtVS2gvMjNTdnJ4WUEvbnFTdHRja210MVlPVjdtR2JFM3B0NTBlR1NLUmxaU0FBS0VqYjQ5TmFDY21ZMURMVThBekFpbWlkV0lLa1UzMVJtck5TYWNIVWVkeHplVStIWS95cTNJYklZNVJiWDlOeTlzZjBNZitBbW40SFdEaHVzZVY0KzF1bnhOYXMycElrVytKdWJtWllZV0JrYzBWYWdWSi9IV20zQ2xqQnR2RmIzRHZEY1hzbkNWVHlWSS9jUlRmYzlOUnc1Vlpwb296MmlyWFVXOG5mTzBrME01RkN4WU0zVUJoUWo4OWRNclNwazU2cTI2RlBacDVjZmtMZnVNc2xvekdPZGExVW94STVkUlhqWHBxak1wUVJqY01xL3pIeDFzVGxMaUZXTFdqL3UyN3NQMUlkOUNJSWFDK0trVEo0S0k4YVpER29JWG1OYXRBeHFvSUhXbE5NeCt3WXh5cWoyOHF6aFVFbEdISGtvOXUzVUVrN2RLVTB6SFM3aUZkK1o1T00zMXNaQmRSeVNPSTNuQmJqVWtCMUFLZ0g4dnkxS0NFZ1dmUDVHVWhnL0UwcHk0aXV3NmpiYlRqQTJlNXVMbHVkeEs4ci81bllzZjU2UWpWcENEV0R1S3pSeE1mMEdvK1k5UnFOdWc2Nm5VbjJjOG1pOGZ5SW1ZOGJXOGhTM3VIVUwrMDFhUlREbHQ3Q3hEVjZnbldWeXNidFQwOVViUEN6S3VTTGRMRmllZmVUZ1g5clkyczZRUTIwVWozWDFCUXhTRVJoVHhSSEpBZXRFTGZDblRXWGpydjFaMGQzYkJYYnAvUXBYN2wrU1g5ajQ2OFRmOEFUWGVXSGFsZ1ZsRkF0T1ZWSFFxZ0MxL2hyVHdZNXQ4REQ1V1pxay83Z3o5aC9INThOalovSmJocFlKSGRFNUpUanhjZTFXTlFTQ1FvS3JRbjh0UHk3YUZYQXhicnBQdUV2dkQ0ajVuOTFmTHNoWWVBNFRqaThHa0R5ZlVTSkVaaTZjZTVCeTQ4bzE0bFQ2aHYxYjZwd2NtbVBHbmQ5U3psY083eU90VjBPYWZNc0ZrL0ZyZzRiSnE2WHFIOThzQ3FtdTYwSHcrR3RYRGtya1c2dlF5TTJPMk43YmRRQkg5UUlsRWNSS1UyYjAzMWE0S1VuQXk0TzRGN2FyYlhWUkpadUExTm5FVG1wWVUzSlUvUFVMS0NTYkx5OGJ6TVdXOFVsdG9NYXR6ZTJ6WERaS1ZLRWlvRkc5NEpDeS9xNi9IanJKeTEyM21UZDQyVGRTRXBOMkR2VGhMaGJleFZlY2E5NFJTSzdrcElTa3F0eFlBQ1BadVFQenJxcTlkMnJMazlxZ2N2R2NUZXoyZWR4R0lsV3h0TG1KRkdRSjdrdHc0THBKd3JUZ1dJM0NnamI4OVF5WFNoc0dwVjduQm84WXdtUHZ2UEx2SzNNNnpTWkNIdlhKa2NtN2FPeVZJSldSZ0tjQ1NyU052N1B6MHR5clJMc2licTNhZnhvQi9KL004VmhvR3ZzVmZwTDNPWXc3UXRIY3J5VlJHRW1XRnVyYmIrMm0xUVRvaXRXM0VGZXhSSlFlYW56VDM5dm5jbTBjdVFta2tITnhVRmhVMGJpQVBjRFFIUjlOclVJRHlVdFdMTXNPM1czenZpeVhRVjVMd3lVczdtUWJDT01mdlJ0eTJxaC9QMTBJL1RhQytxM0x6Qlp0cGJtRXpSbGZwdTIxdk1ZNkxJdklFRVNCajBVZ01yQ2gzMUd5L21FWXJhK1VRV0ZoY1BkeWZSSkZKSGJYekJ6SmZSdEdxT081VGpHaTA5dEdiMnIvSFhONU1xVXQ2cndPL3BqczBscHVRYXZKOGhQR3FkNURiV3dZdGR6Um1GaHZSaEdHQUJyN2ZkVTAzNm5WVklUK1BZVjFadldGK094RXc5bmtZN2FTNGVSRmhuQzl1Y0wzaTZuYzByU2xRTmorV256WHIwN29saHcyczllakgzeDY3eWNpZHlaakJabmFNa05GM0dOU1NhazBVZkErdjVheDhzTmgxNkphUFZqQmJYZVdTRmx0NUpVWi9kQlVEazVYM0ExTktDbjgvVGZVRWdhMWFQckJEOGh1WW83SnJ6TFhFZHRiV2NZZWU4bFFKeENiayswTldoUDQvdzFQRXJXc2xYVnNWY2xjU2RuMFJSSDNBKzUzajFoRk5iNHFDTzd2NTRuRUYyQ0pWMytCQllVcnZVZGZqcnBPRjdabHMvWG9rOVRONS92M0h4WW9vOTFtdlQ0TDRsVWVNNTY2eUVWemJlUlhHUXlzVnRFWHh1TXQwTWhrdUNTUVpaZVNsSTAvVlRldncxMCtYajByclJLcjd2eVBQcWM3TmtXekphMXE5bDVrRElYUGtNZDAyT1dPU0M2WHVNOENCcExpSlRYa1hZQ28yL1VSL1QxMWZTbEhyMS9RRnZreUwwOVAxTEw4b2Y3ZCtQWVRHV2xsWmx2TmthMnVMKzV2R041UEZHQUdNVE5JZUxCbDRrS2dVb0RTZzMxblk2Y2pKbGJtTWV2bEliZTJESFZLSnZvZllUeC9DL2RETjI2V1dSeFdQdW9VSWJIM2x6SmIzTTBnWm5yYmxna1RQSUNGNEJtUHdGZEZLbDhPTi8zRmQ4bVBQbFQvWWdqbEJlNXF6YkQ1ckVUMldXd1VLcmlMQ0VKYjIwU0xDeGRaaS9SZzRkM3B1YWo0VTFuVlNwYmNucForcWVwc3YxNDlycnJWVFdPaHYraXp2a0hoK1J1c2RGeGxtdUZ4dDZaWGFGbS91Y0szQ3IyelFOR3ZhSVdwcVdQeHBxbUtZOGlucDErZ1hhMThtTGFscTlOZjhBeS9HaExzY3phdzViR1l3WHR3dHpnYks1c3V4Y1NsNUF6UnF2Tnp4REdwWjE3WUg3ZEFhYnNkUXlZOTFMV2pTelRDdU5tVk0xYXAvc1Q3anpmWkM4dE0vanNYbFpMYzRtUzlFdHEweW9seGJHTVN6QnBGREE4V0lJVmdkWnVPaWRIWlRNZlU2RE5rYXlLcmlHNStENjYrUWNHSXZMTHcydU9uN1dXeTE5SElieVFjZWNVUStwVURsekFEVkFUYWkxNmFiY2xkYmxva1UyeDJ1M3Nlci9BQkJndHkxaDV0YTVXYU9MbllRM0dQeHN2TnU0MXlMS1M3WlpBV1BJS3dBQVgwTk9oMDZUZUt5cjMvbkFMbm8vdVZkdGUzMVVzMVhFeVhNRnhjVHI5UFBMRGJYbVFpQWRrcklhc0ZaZlhtbjQ5SzZGVmR0b1hST0ViK09IUkpxSDFaWHQxVTVsRk53TGkvbWlhNmExY2lLR09RSzRCcUtjdjIvYUIwMzF0NEsraDZhSEljKy8vTkUvSXJQN2t6OWp5S0h3KzhaQmNZNkpudUpZK2ozTjB4a2V0U2R3dkNtdFhqVlRxN3J2L0E1bm4yYXVzYjZyWDVzckhJV2N0cmVGN1pHNEU4bzJGVFQ4OWFWYkpyVXlMSnBqejR6bDViMk5vcnEzS1JCUWpnZ2dCK29aYStoSTBKZWlUME5IQmszYU5hSDJjc1k1a0ViMURjVHQ2SGtBUDRhalcwYWtjdGRZRXRJWW9KeENuL01KNGxaRklxQVNOdXRkSGI5SjdBTVE5QXBGYWR4RlVSdFN1NEEySFVmejZhSHRrbjRoTU0yUlFHd2wrb0xTSkUreFdudUZhY2FqOFJxWDNOeWp1UnNvMU9yUDlPdm1MM0ZuZGVPenkya1ZyT3IzRTA4cEVVaU5GRzVqM0xLb0JQV285MWRZM3ZHSGZobHZXcTAvOWpYOXR6Yk1paGFQOURzYngvSjIyZXc4bUp5aUJnWXpaekxJL0x2UnN2Rmh2dldocHJJeDVhOGpGdHlhZjJ0ZHduazRyWWNpeVVmL0FKTHlPTy85UXYyanQvRk1nWUlHNVlYSWNwYkVGeThxTEV5N1NHZ3FhbitHbjRXZTJISzhWdXExWHcvbm9kRm5kZmMrSThyVVhwcGJ3bDkwYzM1T1hCWUdkSU1oaFZtZ2tIdHVVbmVOaXdwVUVVSTExTmQxMUtaeGQvdDRyUmFrK2N3YjdQSStFeklzdjl2bFJTQ0dYdnExR0lJQkFJNmc3NzZaMXkxMGxmUWZmeG10S3Y2bXpPNW0zekVzYzFuYndZeDE0eXhSV2E5a0pLa1lSeUNOeDNPTmFkQWRTeFVkVnE1Ni9uL0lyejVjZGt0cVZkRjlWMytaMFA4QVpUeWZHK1E0YVcweUtyOVpaeHRkUU94V2VWdHFtTUFEL3dCdFJXaEE2MStlc0wzUGpLdnJTNmVYNW0vN2R6TkZXZXZuK1ExbnpqRjR5YVRIaU9TRHVKM1lVdG1aVkFrclZhT0pGMkkvcEdzTGRvZEZpNDJYTHFvaVNMYStXNDVMdGJtYVYrL3VBMGdXUUJENmI5czZqVnBPUXEvRXpwUnRKdmxlVU9Td0VqWXV5dU1qYVg4VExKOURFNWVONHZjdXdEMTVOVG8zVFZsYXQyNngzQmF0cHc2ejJhbGVIbUpQaFdlOHNhMHRNZG5mSDhRYlNDZmlmNzJ6UTNUQnlYSTRUN2tnR25ManJZejRWdVZxV2R2Z1pISHlWaXl5VjJKYTYveWorSTc1REJZeWUxbFdURHBqWXJpakxIYjN0dFBaZ0RxVmduZU1MVS8vQUhzcHJPcnplUmdZWGJpOFhPdFd2bzAvcWl0cnpBVzFrMDEzYU0waVcwcW9IVm81WUhMVjJSNDNiZlkxSDg5ZEh4ZVUrVDZOclRkVy9rdTVnY3YyMVlVOGxMcTFheDhlcFZmMnh3UzMvd0J6NUxDYU5nc1hmZzRHdnNEdUkzTEE3N0lYNjZPeTVJNCs1ZUJrY1hDbnpOajhTMTJ2RnlIa09WekJDaUpaWWNYWnI2R1IzYTRucDA2TTdELzA2d0xWZjJrdTlwcy9ndWg2SngydjhsdDlNYVZGL3dDejFmOEFBWmNWR0xmdXp0N2lDR29PbTIrMzh0Wk5yT0RxbldkQm80ZzQ2M2NVVlJieWx1SjRpcmhrUVZQL0FCYW9iQW4rOS9GRUxHNEdXVEdtN3RFVzhrSHVrdHdUeURLYUFLclZWdmowL0RROXBIelowcnc5Q0I1ak5GWS9ieklpV0pvc2xkeXJiOWtWMmo1R2RxQSs3OU1aMGQ3WGkzY212aFhVNS8zck02WUw2NlJIemVoVVZnbHJCQmtNb0ZrRW1RK21ndEJLbkIydDBhbFZCTmZlRTVHb0hwcjBGcVR5Nm8xZUpDeFR5R3p1TGlTSklvSGVSaTdoYU9JeVZER3V4SklHczNuN3ZzWDJwdHMxdmJOcTVGSFpwYWx2WjJPeWY3ZjU1c2hLc1ZsY1dreXRLakRpR2xYdHgwYW9VRXV3OWRjUHhxWlB1MHJHdTVkVHV1Wm1wYXRuTXFITURuL3BOd3VQdy9oT1hsdEw4WDArVXlrbHhLeGtSMlVJb1ZWVUt6VkFIcVBYWG9lUzJrSG5GYXdwWGN6L0FOVXErU1RZUHh1eDhlaWp1Wjd2SU5DdHBLQVE5eXdSWWpROVFvWnpxakJWVzVlTlB6L2hQNVNYMnRISHlmOEE2ZnAvckE2L2VocHJiN1gza1Z3d2U1WTJrTXpwc0drRHJ5SStSS25RWHViVFNqL2V2NG1qN0xwblU5cTIvUTVFOFl1Zkg3cnp6QVk2SkFNdlBrTGZ1c1lBSDdhWEN4c0RLRDhVR3hHK3RmalZ0TmR2NDBNM2szcnV1MmRZZjZrN1Jzajl0WnNla2hoK3B2N1ZUSW9xeWhHTDdiamYyL0hXYnlZKzVpWC9BSmZ3WmJ4RnBrLzlIL0FVc0JoWS9IdjlPbUt4a1FWMGE0VXlPeTA1dE5rV1l0VGsxRDA5VG9yM051YXIvd0JWL0VvOXVYcmIvd0RiOURuWEpybnBmdUEwTmlPR0JUSVJOZHk4UVM3OXVoUmp5cUZyMG92WFRVajdYMUNzbGJmZXJCYTNsUWJIK0U1cTZtVmpGQmFxemlNVlBaN3lkeGdLaXBDMTFsMGo3dGZpYm1TMXZzMitCdCsybVhsdmZEY1RsTGl6RVl1MW1lTzNiWmhDdHhJSTJZNzByU29wckE5Ny93RDR2VHcxTGZhcXUzR1hiVmtCTXRESDkxN2kybWRaSm50VnNvRk5Lc0lMUVhKTkI4T1hYV2ppeC84QS9OdDlTaTkvL3dCOG91bWpYMWtKL2NqSUNUeHdRVy82TGlhMmlXbnVOT1JsSUJIcFNNNkE5blc3a0plQ1lSN2pYYmdjK0o3NWprV3lIaFdZWGlaRE5oN3VSWHJTaVNXTHR0VGF1K3FtbFRtUjRYL2lFN0o0MHJ2VTVzOGFkMWc4ZTl4QlNhQ3BYYjJpWTFCMTZMYm9jRGlmUTZVKytPT3Q4LzhBYnpJMjExQ2t2WW5ndllFZDNWVWVPNFdQa0dDazdwSVIwNkhYbnZ0bVcxT1dvZjdwUjF2T3hLMkcza0Y1cGI2UHg5TUkxdXlXMS9aTGo3Zmd5bEl5OFFRTkcxTndxRVVEVTZhSHp2WnlMV2YrNytKcFljTkw0bHRjUlgrQlh2Mll0TDMvQUxJdlByOHQzY25GZnlwSE9zVExIR3NFY1NoVnFJL2dXMnIrcnJyVjk1eWY4bEdsRTFBUGFVNlZ0VityMUM1aFBHdkd2SXZPZkxzSDVWNGpaWGxqREpKY3BrTGlQZ09kMU4zSSsyNmNHVVNxL01sV0ZENmFONUhMdmo0dU8rTzJ2UUN3OE9tVGxaS1hycDEvMEZieVA3RitGNC96NkR4dngzTFhQakJ5c01OeGFKQzVubVc0WVhJV09ObllPVWN4cWYxLzdORjhUM0RKYmpQTGRTMStZSHlmYjhWYzZ4MWNLMzVBSHkvN04vY0h4MjR0bzdtZXc4dnRMd3ZCYWk3dFVpdVZ1VVZYV09TUWtFY2xKTlZtUFRlbTJpZUg3bmk1TXFzMWFVc0Y1ZnR1VEJEbFdUQVlmejM3ZlhFQ1hXTThoOE5hVndrYzlsUDlYalhhaElvTGdtUGNBN0NYUlA4QXdaK20yMzZnN1hJd2ErcXY2QmViN3o1L3lMQjVIeDNJNVBFWm16eWR2Tll6U1hDLzJqSnJGTU9KSVp3WUdjZjhSME12YThOYnJKVlEwRWYvQUd1ZTFIanM1VEZURVluSDRUR1QyOTJicTJ0NW9wSTQ1cjIxWjRBWFZxVXVMUXpJUlVqY2dhSnpZclhhYUZ3K1ZURFcxYktWWkdyQStDeXRheStRV04xYjN0NVpPWmt0TENhTzRlUkJRZ3FxSGtHMzZGZFdibW5BRnRxNnR6cU1mM1dqa3ptUHRMNVZpWlllRTM3VWpNeXBNb0h2REloL1d0Q1J0WFU3Q3BWMmNGcS9iVXRONGxqK1VaQ0l0T3lQUmVaS2orQkd1VjV5Vzl3ZWhlMVh0YkRWTXMzRnpGSkxJY1NyUjNDRThXQkFxd0JxZitFbldQZEtOVFl5S2FXK0Jha1Vra3R2QmQyN2dXVGV5UldGQ0dCNDdFL1BXWG9xNkhOdEpOcDlUMDI4VFNxN3hOeUo1Tkd4cFVqYllmUFNwQ1kyNXBkUmF2SW5zTVpIS3N0SjdhTmZlTmlwdHJ0WTI2bWxPRG10ZFdKQnRIdXZIWnY5VVF6Q3k0eTRibWs5d1crcUtKSVEvR0Z2Y0FoV2dxdTlSOE5RcXdqZDYxcEhZQVNRV2xqYTNPWXVYakdKV1Z3dDI4bmJTM1NWbFplOTBCQUpwV3Y4em92QlQ3ajAraFBrY3A0MGs5UHgraFdQM2tld2FQeGJJMjF6RGRDMnladHpORklqODdiSVFNb0k0OVZCVmZ6MTFYczZ0V3pUN281WDN1OWNsS3RkVVdGOW0vcHNyNEZZZlZ5OWs0cVc0eHBsVm1WMU5yS3hIUUVHaU11M1hXVDdwWFp5TE5kMG1GKzI4bHZqcExVWnZLY0RldFp2ZFJTSzhDS3Zma0VmQjIyNmo4UjEycnJKZHVzbTV4YzZkMVhwSlVFT0V0N3ZPWEVPVnVXaHQxVXpOY3E2SkhibFZvVzVNS2lwVmFLU09YcHVkZERpYisyb01Ya0t2M2JOOXhkOGw4cDhZOERzc2hhejNuOTJTOG5ndnNLWFYvckIyNk8vRmZhZURPSFdzbEFSdU45YUdGWHZFTHREOERGeldyajc5NVJUbWUrNUdZOGhOMEdudWt0Ym8xa3g4TXIyMXNSMEhjN1RCbklXaWdiRDhkYU5NS3I4VE52eUxYVVRvS3R2a01waXB2cWNiZTNtTEtkZXhjU01udTJKOTdIMDFjMG4xVWcwdGRHVDdIeTI3bXVSZFhtTXRNcEpiT0hpdmtKc0xoMkJEQ3BRaXRDT3ZIUzI2UkpLdDRjK0JkdmkzK29ueHlCTCt4OGh0R3grUnZwYlc3V1Vpc2NGemFzR0JHNUpWd3FxU0QwOURYV1crRFphMTEwYStwMFZ2ZWZ2V25Jb2VuVHBLTEQ4ZDh2d09kejR6R0Z2b3JxMGp2Vi9xNHlmVDN5aUtTc0pJWVVsZm14NDdVMW5aTVY2cUxMKzMvOEFaNkczWG1ZTWxmUTU5WHppM1g1RzN5UEdTMlUwbUMzVzVTQ2ZIVnA3SG54VXYxZHBzYSs1b1c1YlYvSFduaFdzcnAxK3BqOHk5YlZTWFhWZlI2QXkreG1NYXd5Tnh4cFlRVFdXZGpkbUxOL2JjNUMyUHZGQVBJOFVkNDVEOE9PaWE5ZmovQXlMMTcvalVXZityL3Rua2xtN0VaSzNpc3ZMTFFTTjF2OEFGTWJPOFVWcit2aTNMMXA2YXNmWi9JaFZhTmZNTzRyRVlyTDJjZ3Q1MFFERnBQSEx6Q3lML2JwRlZhMXFQM0xTNHRqWDRvZEI1ZEY4L3dCZjZoMkhYNmZwL1FmODVmU1gvaE4xRGtZaWw1aW9pcUorNFpER3c5c3lTY1ZBZW42bFA0OUcxblZ3N01xam96UXRuVjhWbFplbzNlTC9BTno4aDhBeE9ZaU1hK1FZcU9lQ1lvaWhpVkxvc1RlbEhyeGZiMUI2aldrdExPdll4N1M2N3U1cGJ5bURMWVJMb2syY2hqTjJrRnd0WkxhNk5VbnQzNWV2UnZuMTlScWFXcktuWWtlUXBhWkN3OFk4Z3hudFNLUVcxd29xeFZia2NTdFBnSk9IWFRUSzFKcXZnVWI5OS90bTZzK2R4a0RKR1g3cng4YU1va0ZYWDhqMDBUaXlwT0FiTmpiMUtjOFh6U1l5ZVNDWUtzbXdCWVZvUjZnNkt0VldRSW5CMUI5cXZ1UkZhUi8yNjlwTmpieGV6TEQxSEZoUTFyK091ZDV2RGRuTlhEUnFjYk9rbW1GTXphTmljakpieGt0YnRTVzBsL3p3dnVoL0VkRDg5SFlyN3FwdnIzK0pObSsxOHB1RmkranlLbTdzbTJZRS91S1A5MXRTZEo2RUxVVE1jdmlzVmUyNHlPSGtFMGFBZCtKdHBGSFQzRC9iby9qWkdsRE1yUGpkWEpTWG1PSVlRU3J3cVJVZ0g0VjFyTjdqUG8yaEs4anRXejNpMEY1R3BOL2ovd0JpNEhWbW9lSTI2N2loMEJlcXF3OVBjZ040cFp5VzBsNWJYQ3RGV05JSjBjRldWankvVUQwSVBwcURKSUpxcHN6T1hoam1raldSYVRjbFdxS1RXcTcvQUpldW1ISzR1QmpIaldaS1JUU2treEtLZ0U5ZHowMU1yQmM1dE9RNE16RDFxTklSRllyc0ZCL1BTRVkxMGhESGhvNDVFU1ZWQW9RcElHNFlhamJvU3F0UzMvRkhsVllJMWFpdFRrZmw2OU5DQlhtV3ZGZndYQjRYeXh5WGNqeFFYbkFSeDltS0JUMlpxc09BVnVRQjNyL3R5cjBkTGVYWTZqRGxYSXhwOStqL0FKbFNlVGVQWDNsdm03c2xMbkdXQktNa1o1dUk0NUNHSkEycVdIU3ZRYUpwbVZLUjNZQms0anlabzdJNkI4VXd0K21JeGRoREE2NG01dUxmc1pTRldrZ0xMSVZRb2FIZEN6VlZpUFg0YUV5YjdWZzBjWDJzVjNidjJSWXZsYTVMd3ZJNHkzbWxMNEM4aytua2xpZDJBZFZaaXNvYXRPVE1YVmdPZ05hMDBKeXVIRlpXcFZoNWJ2Wk5uUFgrb3Z4RmM3NC9MbTQ3V1FaYkUzRXF5SGhzYk0wSUpsWmlYNUgzb0tWVUVnMTFkN1ZtVkxiWjBmNmxQdW1CM3J1anAraHpaNHk2M01VdUttQUxKV1dBK3REK29hNkhNbzFNUGlXVDlMN24xeWttSXlFT1FWU1kwUGJ1Ri96Um5ZMTBxUGNvSzgxSFZ5WEw5bDgxajdEeWUxeE9Wa1Y4WmtFV3duQmNSaVNGeVpZR1l2N1c3YmNvNkVkRzBGek1idFNWMVdvVnc4bTIvd0FSaDhqeDA5dkpOWktnZVMyRWlXdHlHQW1kSmdRb1lnME5SeE5ENmFBcFpHM2txK2d6K04zTnZtYkRHWVQ2bGJTOHNlTWNoM25LclNyU1BGRTFhTUY3Y2k3RGNIMXBxdTl0cmxyUmxicE5OSHFnUDkzdkhyT0t4OGQ4aXVwT1ZqYzVPNHNiZ3dMMktpOUhKQXBWNm9oVmFjS2RkelhWK0N6MVM2eFAwQnZTNGR1azYvTXJuS1lHREQzMCtDblh2dWthTkF5T1l3amc5eU5FV2xQV2pIMU9ycTVIWmJncTJCVWJyMUNHUjhWcy9JY0g5ZEV6cEtuYkxXdFNFakVaclB4M1BLbzM1RFVLWlhXMEN5OGRYcksvSGlLUGgyVXlHR3llVmdpdU9kcEhjTTZGMUV5dXpBMXFDQ1R5SEdvSFdnMFJ5S0t5VDd3QmNPMjIxaytnejNGckJEazdxOGdlRzRpdDZzSW5VeHhkeTdSendJV2hESTdIcDAvTFZDdjZkUzU0R3NzTFVJV2I1SlN3YVJPNnJlNjJBS1RDSktsV29pQktyOEgzNmVtc1crMXFUdU1PK3Q5cVRsOVg0QjlyN0lOQ2tQRzRVQjJXSHNGWldsamNVWXlLNUk2bjVIK0EwTlhhdGRBcms0c2o3OUExNDcvY3Njcm81Z2t1a2s0L1QzS1RXc2FxQlFnRml5TlRxVkZLL0hWT2ExTGVQNmtLWWMxVk1wL1hRc1BHM2R2ZVJpS1MvdHU2cG9sdkhLVmpCVWdNUGV4WWI3Q2c5YS9MV1JldXM2bDFwWGI4Z3ZpWjc4eE0yWXRvNGJzRldqaHRlNDRUY2hpek1UdWVvNDZiTGF2L0FQVGIrY2ZrQjFyZis1cjVBUHlYT1ltNnZ2OEFySTVMdXlqZzdiTElPU1N1KzNCS0FnSDI3Zy80RFZtR2pTbGFNTHc0YktzYWFuSXYzZHM3WlBLMVcwWnZkQ3ArbXFDSUVKTkZxQU91NTE2SjdTMjhPdmo5VHpiMyt0YThtRSszMER2aW1WeGVIOFFud3VOdlJENUc4a2Q1Rk0wcVF4aWR3eU1vZGhTcUx4cjhkL1hWdWJqMnk1VTMrMUFXSGtWeFltbCs1bHMvWS9ENDNDNUpzcElZODk1TmVsMXZJYmFlQ1ZyaUs1aUt5SUg3bFZVRTlPTlQ4dEQ4M2k1TXRkbFlWWTBKNE9SanA2clM3UHF4ZTh1K3ozbFV3Z2JKWW80KzZ0bG1nK3JXa3huaURzYmN5bEY1VlJDSTJQRTdLTmFQSHhXcE11Wi9JQno1YTNqeEtvVDdaK1RUWERSeFdibUpTeGx2MUJOcWlSaXJPMGcyQUh3Ty93QXRYWHlLaWxrTWVLMTdLcUxSd2VEeUdDeGNyWnVjK1FYZDlNL2o5cGRwTElKYlFJa1VxTkd4cWUyMFVqa3F3NkFBVTlNSGtabGxzbFgwd3QzeDdIUzhQanZDbnU5VXZicDJNdklienlBNUM1dXBJaFNPQmNlZUVxdzNNZHhFWW5TNC9VS0gzY0k1R1A4QVVhRVYxVGdwVGJIei9vSGNuTGZkTWRGdDg1OFFSa0xTMHk4OTNrSVpCZ2JYSlJ4M3VHampNMTNkTmtFQnQyalNjVW9HazVPeGNjeHhOZlN0MVc2d3YzTmRmaDhBSnhiMVR0bnBIKzdwMS9ETEZqOFZ6OXRHSU16Y3BKbHlKTWZlSkovMVYwczRDa0tIVG5VTXZGK0oyRmVvRytzaS9JbzdlbnAxWFk2M2k0TFBITjNyR3ZpTzlqRjI4UllZM2hDOXFYaXRZL3BpNUVhSkF0TzVYbFNwRks3N2JuZlFXU2JXZHBDOENWTzNZRVhNRnRtcy9qY0hHaVd0NUFKOGhMSEd3bGtWSVpGampZRnYrV1pJdUs4ZmczeTBSUk9sSGFaUlJhNnZmYSt1ckFlUXU0N1dXVzN0cm9HWmhjVzErc2pzYU03ZnRTRnpSU29SZXRUNmFtcXQ2d1cvZFZhd240cC93QVdUeFNYdVhlN2dRL1J4UU5KYjhpU3ZDeGpYdWdNMjNGQXJrVk5DVHJTeFpOdEkvR3B5L0tvc21WMlhUK1J6ZjVqa0xqTmVTWGVVWUg2bSt1R2xCR3pWYzFBMitBb05iM0hxcVVWZkE0L2szZDhqdDRoZDJXa2NKaTdiS3FxU3cxQWtNK09zNDQ4ZXR3QVRJODFTeFA2bFFVb1BscXB2VU94cEtqZmN4bGlrdStNOGc0SzlLVUg2VUcxQjhxNmNxdTI5V2J2SGZ0RmxmUHNpMFZsTkZiSkcxTy9OeUFVdFJnZmFEc1BVNnNWOWxXMzBLNjRIbHNraGdsLzA2ZWFySTMwT2FzN3VtN2NaWGk2bmIvbVJLQ2RxOWRaSzk0NC9kUWJkL1lPVFh1aWJCL3AyKzZWNURLazF2QUxKa1ltN2t1cmZzbmo2Y28yWnExNlVYUlM1ZUhiOXhQUUJ0N2ZuM2ZiYTFEdmovd0JsUHVQNGRrckMyYkhKbE1kbHBvRXVMaTFuVzVXemprSVF2TXBSWlBaWDlROWxQWFJMNUdISzRiNmFsUzRlZkRxMU02YUhaaFEyYXdYRmlGWVdmYkZ1QnNXRVFBSDhRQnJocjVJekxMMjNUOGpvcVY5T3grQk0rNi9neWZjN3cyT1BHdWtlUWhZWFZtMHE5ZmFRMFJLMUlMZjRnYTFPWmgzT3VhbXJyK2E4QWYyem1mNGVXMWNuN2JyYS93Q0QrUitkUDNLOEZ2N1hObkhaV05yZVhIczhkemJ0VGtyN2ZBMDFxOERscTlHNmtmZWVERnEzcjZxdFNuNG9TYlN3OFpMZHBjbThUSWVMSzBCREt3Tk45enJUdThuVm5PcXRPa2g2eHhQaWNRdVpieTdlNXBHNHRJNFBaSVorRlltWXNCN0NSeGFocUtnNzZwZDdxTnExL2gzQ2FZY0x0NnJhZVhYcHArWVcrM3ZsSC9hZmw4Tjdab3R0WTNoWVJSSXZkSWprOXJ4QjIzMy9BRTcxMUxQais1aWRXNTArQTNIeXFtV1V0cStzZUphdmxxMnVRekdONzF2SkRFTFJaaENnWldUNmdnSUdFVk53RjF5dEtQRnVVcHZvZWwrMzJ4NWxWMlRhMWVrL0RXQWJaMitOZGtSYnU0UnBiaFlvVjV5dFJES0VBSWVvTlJxNmxkMTBtbCtRYnlyNDZZTDJUY3JwcS9nZFcrSjJLVzJFdElvVjdUM0NCM1phSzRVa2tDblViSDBHaFdjcGUyc3Nwci9WbGdNQmp2QnhuZUhIeVhMWDFwWXJlTTdsakRDR2tvVnJ4NkxTb0ZkR2UzSzFlVFdpZWpWck5ma0E4M0x2NDE1ajBwSmZPMytwenA0UmhzclBrb29ybTRnbmlqaE1zY2FTOHoyMDl4VXB4TzI5VHJvT1hlaW8zSDVHVDdiaXZmS3F0eXZpUFBqNXY3SEZpNm5CR1B1TGxycXdoYjFDa3hrc0FBQVF5dFRSM0Z4MFdQSmsvdml1UC84QUwxUDhsK1pQa1pMckZ0aUtXdFAvQU9QOVRMN1lZOWNKNVQ5d1BLYnlyeDR5MWFTR1IvMUg2MFBMWDVuZ3AxaTgrOGNhdEYxczFYNkJuczJOWDV0c3R1bFZ1SmVIaGVPNThad2JraWMyMTFtNzhFN21TNC9iU3BQUS91UG9YTzRXUjlrbFJmeE9pNERtMkdyNjNkc3IvZ1dIWndreEVEWlFTKzN3UWdBVi9IV0N6dEx0SVpjbGFkakVGVUFWaEhER0hiWUU4bC84RHZxbksyakx4MzNaUG13TEZsamhiYTVlL21Xemp0ZitvbXVYVTBSSWw1c3grVzJxYXAyY0phbCthdFkzdm9rVVRtdktmdVI1NU5kNTIzRWNtQXVaSGZHNGVWbWk3TUJIYlZsSUJISndLdCtKMTMzRDRlUGkwVXIxUnF6eURuKzRaT1RkcXJmMjA5RjhPNEF1OHhtTE40VG1zQkxEYm9TWldIN3FWclVCZlZRcEo0aFY5ZGFhZ3lKZmNrNHJ5L0RTM2ZhZ0VkdVhvRElKbFV1QUtEbXR3eTcvQUphVVFUVjFJM1c4c2MwYkcwdVM4REFsNFYvY2lkMTNEVVZpRFE3Nm9hN3RCTy96ME5xdkVzbHRjMjkzd0Z1V1pIczVwTGVWTzRTVzRkc3JVbHZkN3E2WlZWdFdpYnUwa2s5Qmt5dVo4cG1nc1pydnliSjNWdmJVa3hiM0x4M1QyMGxWY0FCNFdMVm90UVNOTEhTdU8yNWRZZ2E3dGF1dlFkYzc5N1BNUEtNSytFOHBGamQ0OHpSUE5jMnFOYlRCa3FEVktNcEFMVklCcnR0b0xQdzNrYWJ0cFZ5YUhGNXRNRG5icTFIWHhGYng2OXRMSHlURlpackdLSllMNFhiM3hlT1gvbHltUUk2eGhaQUQxOWZ5T2pWYTJMV3ZWSnI2Z3FWY3JzcmRMRnAvZGI3bVIrYjRXUEZ5M0tRWTRYa2Nwa1NTR0RpWWkxRFdTVGtlUU5PUHAxMWlZS2NqSm5xOHJVVTFTUzhvOHpTdlhIaXcyZE90dE9wQjhUeW1XZndiRCtLeEM5dVBIckZvdXhrcDNpZUM0aytvTWhhUHRNOVFhc3dMSGJVczFMMzVLdGEzcFhTdjhTUEV0VEhoY0wxTk5UOFN1WnY3elA4QWNCNDdTM3QvN0ovZFRGZDNMSURON1FoVGdUdUQzT1EyOU5qclVySDJnYXlmM2tpM2ZOTGlMSGVIWkZtWGtIaVdHVWxRNmhacFVqTGNXQkczT3U0MWswcW5rcXZNMjhzckZaK0NJM2c1dDgxNHBnc3BheFBGalpMS2tFVFJwRWVLVHl4aHUybEZISUx5TkFQanJFOTN4UnliUDRmb0ZlMTV2LzNaTHVwRi93RHMyS2Y3dFhHWER4eDVzNDQyb2pxaWdUcEFuY0tWOTVaWVJRMC9QUm1OWC84QXJyTHRQNVNVMldOYzZqZXJoL1hzYi91Vlo1V2J4R1VZcTZXTEkyZHhGTEdaT1BBcTZQQnNXNm1rb0tuNWFEOW5hcnlWL3dDU2d2OEFkcWJzTGE3RzdKZDNIZUF5WWw1TzhJY084RTBocHllV094YU5tcVBRa0U3SHBxdk5mZnpKWCs4THc0ZHZGVTlxZndLSHhLaUt4d3J1QlVHSXFDS1Y5NTlmbHIwRm5uMWV2bWRLL2RPYTVpOEh6VWpNclJ1MXJHZ2RTcktzbDdBUFdtM3VyVTY4L3dEYjZ6ekYvd0N6T3U1algySEM3Rzd4Yk0zdDFnc1hjeFNMTlpTUUlreGw0eUtUR1dpb3Y0RlB4MDN1ZUowejI4R0VjTGJrNDlYM1FzZmJYSTJjOE9VdGJtYnN4TmYzTWdaZC9iSkk0SUNnRWtlMzAxcGU0NFVxWTdQL0FHd1VjREkzYkpXdXJWcE1NZlkyNmZjYk9RbTVsVzRreDltV201Tis0c1lTaXNyRWdlMEQwcnQrT3FjbEhiZ0orRmkybVJWNXJoYXVwOW5jYkhjL2NYd3ZKd3h3QzhnK3B0STU1K1R0d1dNR09uQmxIV1ZxY2xOQ1RxUEJ2UEd5MVU5Q0hPcFZac2QydTVyKzhrSnkzaWxwTmFDNHg5NWpydU9lV1cwSE15TE9QcDVmWUN2SDlTRmZjS1UrZXEvWmNzWlhWcnFodmM4RCsxTzdvelo5eHByOThCa2x0cllYTFd2WXVJNEplZ1cxbVZ5QlN1L2I1TnVPdXF2YjdKY3VYcExhRGVkaW5odmJyb3ZtQ1BJdkFQRy9JdkE0ODU1SGdMSTVSOE10Nlo3ZUJJNTRwa2c1Z3h5UnFHTkNCVUVtdXREL0FETStQbE9pdDZYWUNyeGNHYmpTNnJjcTlmT0RuRzg4UHM3cnlPN3VmQXM5ZTQrMW1qVzVSaXp4Z3V6OEhGQ1VKUUhvVFhiWFU1Yyt6cWpsK0p3ZnY3b3RFRTNQK0RlYjQreHVQSVV0c041RGlMUzNqdXA1R3BIZlJxWTFacXlROXB5ZDY3T2R0VCs3V1lBbml0RGZnRUxLNGluKzM5dmV6eExielIybHlDc2tmMW5CSVhMa0ZYSUw3S09wcitlcHlub1NyNmFtenczN3VYV0xzRGIyc1dKeWVOaUtvUkhMUGpabExiS29GMHJSMU5QYUErZ3MzQnBrMTdtbnh2ZDh1SFRSb3MrMSs5Zmp5MjZybThUbE1GSWVKYTZrdC9xcmJZYkh1VzVjVTFrNXZhYi9BTnJUTi9EL0FOaXhQUzlXam9MeEg3a2ZhUHkyeWEyd3ZsOWpMZFNFOExiNm9Xc3hEdHk0c2szQTlmVFdKZjI3TFJQZFZyNEFQK1p2dE5XbVdCRlpCNHU2akNTSGlVQklESWZnVVpSWDByMU9nNjR0dlg4eG5rMUVUSTJFWmZJV0U2dEF0eThpUnBVT2pMZDI3TlRwL25pNURRN1NWdGREWng1SENhMWorRFBjUmFXVnRsNCszRlZ4UUNML0FEZ3A4S0RZK3Y1NmdyUStoWm15V3RqY3NYZnVYNDdjdjRQbmJTeWl0Mm52YkMrRm5hOGlzUWFBRjNESGNEMm9DdlUxcDZhMU9KaiszbHBkNkoyN0FYSXpmY3hYWFZwTHFjR1cvd0J5SWpnNXZGakNaRWU4Z3U3T2QwV1F3UzJya2dReUtVSVJoc2FyditXdTdXQ0xxeU9OdHlIYW14bDdlRi9jeTg4RHY4cGp4UFpuQlhzcVpTTEczcmlBelBMRXBKaGs0U2U3MjA0a2NUNjZ6ZmN1R3N6VmxNOUpEK0J5ZnR5bVhWaXZ1eGgvSklMWDZpMFcwUzhWbGpTOWFTMlR1S2FzQk5IM0lTQUtIK25mK2tiYTUxKzMycktrM0s4bEtIcXBBWDNGOFUvdjJFbHpPTGtlSzBWU2pOQzBiU1cwN09wLzVvSnFsR3FyRFlEVi9GczhMMjJMTThaMTVuSG5sZmdIa21PeU55OGtzMDAvTUNlUzU1UEszKzhTM1g1YTZxbVdyUnl1YmozcTMzRi82RE53Y29JRmpuSkZlUkpqTmV2UTBxZHRXeW1ETldQTGUybWdxY25ITUoyTlVNaUVSajVDbFZwODlKdndHWG1iWkpyR05LeXFwVVY1T2FMUUhvQjh4cG9IbEVXU1lUcDJyVW9MZDFvVEtpbW40RXJVNmVJR2VwcHM0cm13aDQyMDkxR3hJS1NXc29VSzQ5U214NmZQVHR5TXRCd3huM0grNHVMbHQ0N08vYkx3MnJKSmJpNUFZeHVxOFZKTmYxQlNVcWY2ZHVtb2ZicDhDMzd1UmQ1TEN3ZjN2eEtXeHgzbDJKdUxDMmt4dC9ocmw3VTk0R1BJQUFFaGowaWNCMHBxdTJOeW1uM0xWbVVRMTJHcnhIeXpBNXJNNFhNcms3ZStKWnJITld3WlZmNmZKMndndVhFY2dGVVNWTzZXL3dCK3VvWlcxVnJvVzQ3SjNUSlgyMmNZRzZ1N0cvY0ttS3VKTFc3bFpTemZUSS8wc2hCTlJRMjl5c2dwL3dEZTYrbXFza1dYeEw4YjI2ZUg0L1F1ZkdZK1dTeXkyTnVpMGtMeHl3cncvYnBJcm1DclVvYThlTEtLRUVrVXBvTzNaaGlVdGl0OXRwR3hyWnJDelhNME0ySW5Gelp1OUNqcmN3RzNWWlZVbW9hVHRPV3ArcjNmSFJWMzBjZFFGZWx0UHN6ZjVmYW0yZTY4cHhFU3pJUzM5MHg5T0puQVZTd1E3Z1N4aHlWK0sxSFVEVThlcTFJWkZyS05IakYvYlpUeGZLWVZXazc5cTd1a2RQM0JGTWhkWDIycURUcC9VTlFzbTJLamdmNDdYSGVZZUpyM1llNXRFSjJwVjFFOGU1OWRnNFA0YWltcGp3Sk9XY1FmZFh4Q2Z3YnlxV0lJUmJ1N2NEeDJvS24xL0hXbml0dVJuWmE3YkVudy93QW9FRXNRWWdHb0EyMDJUSHVSQ3JPb3JMTFdubXZpRVRSMEdjd3dKVWJBeTJ4RldBK0pYOVdzRk40YzhmMjMvVTFzWHJwNW9XSkcyMjMxcUlZOHNiMjR4OTJsekN3V01rSmNCaHlCaUo5d3ArR2l1TXF2SWxibzlDRnNmM1BTUi91ZmdIc21XNVQ5MjNtUXlSeWdBQWdpditHajhWK3RYMVdoaVpNTHBZcU9UQVo3RVNTZjNMRzNVR055VVN1c2trVHFOelJKQWFVb1NhZm5xek54NzdkMGFFTU9XanRDZW9yV3pUM04xbGJ5ZWJsY3kzQitvUFRrNDM1R2xPdGRBaGh0S3czTGZ1M0Vkc2swYnhGcG1QSHVicUtrQTlhMTB3aXZiL0JtMWJpV0xydnhmOUlOUFVkZHRTa3JCVWxsdzJGQUJ2eU9uRVFYVGoxSVB3STMwaEhrYXE3cXJIaUNhY2owRmRJUTE0RzA3SGNpcVc3aEJxUlFBci80NnJ5ZENkT3BaK0Fkb0Y1QUJoc2FIZlEwaEkrNUc2c01aQkZrYnFlV0NlU1BzMWdDczNDUkNRV0xiS3FNUlZqMDFYa3B2UVJneld4T1VUL3MxNVBaMmVReU9BenNhSWtkR3RibFFDR2lNZ1pKTjkrSUM4alRxUWV1czNsNFhwWkc1N2Z5MG02MkxwKzJFTnY0bDUzbC9HYnU2RVZobHdNaGhMVU8zWWt1b2l3dUFnWURkazRzb3JUMm5VZVBtVnFwUHNQN2hnZGJiNnJTeS8xR2I3cFl1WHlLMXZZWVdNTUZ0Q2pPV0hKSGNFaFhBRmFNaE8xTjZhTXltZmdVcUgzRWZGMm1QOGo4WWxUSk9Ibmpra3RMNnlsRE5ITzlPenpvSFByMFB4MXplUld3NUpSdVk3ZmR4dy9tY08rZCtOMzMyMTg5dk1ZOUNMT2Z1VzhpMUtTVzdub0NhVjI5cCtkZGRuZ3lyUGlWamorUmlmSHpSOHdwbExhMXZyUkxpRDNRWEtCZ2ZrMyswYUhxM1Z3YU9TdGNsTnk3Z2JDM3N0akpHenNSY1lxVlJJZDZtMlpodUtiMUhVYUxzcFh4TWpXcmp3T2tQTFUraThmbDhseTE1REptNlEyZHZFSkFmcUxhU0FHTzl0bEFEU1I4T01nclVnazE2YXhWajlVTG9kRGl6TFpOaEF6cXdlTjJ4YU83WWVVb3kzelpGeUZsWnBnc2tpT0FOd3djTVdyK3JvS2I2dVhyY1I2U042cWlibjFNWmNmTmNlZjRmeW13eUoraXQ3R3dpOGh4Y04rR1dWcDhjQXJ0RTBZSzNGQXpveWpmZXJiNmZaOXRwL0lDVnBtUGlCcnRMak0yMXZlM0tOYnozc3lwYXJKUndndFY0OG1ZQ29jRnVoSXBzZDlVUDBhTHNiTkg5elY5WC9EK0kvOEFoOGNkOWlHd3lTd1EzS2syc1QzS05XS1NFQm1CNWtxdGFjVi8zaUJYUVYzRGtQcW0xSGdVdmtzTStJejk3RGJJc0J5RWNGOVlwQ1FrY2JYSU1aaUtOVWhRNGFNbjBOTmE5YnE5VjVHRmt4UEhrZm5xdng4VFZaZWJ6WXVBUnR6akRNNXVRc1MreVhnVjRrKzJwTk5oMVdwMVZmamJ5L0h6cTAxYTFIeXd5YWYyNk9DNGFidlNneVNjajNENkNMM2JualFCYWZIZmZYUDVNWHE2SGM0czcyTFVQMnQyMTlLRWh0bW1WQVN4N2FxckZ2YWZldEFPSkhWZ2V2VFZEeDZhc2Y4QXludTBXa2ZBYWJXeEVNc2F6M2tDV1FibExEYlNMTVdiaXhLcXluMUE1RS96MW5XV2owbjhncTNJM0x3Zm1Qa3VlSDBWcGp4WlIzUlplRFhyd0lKSXdBQWYyaFUxSXF2SWsvam9hMUxXbGRBR3VIMU8weDVTSlAzRThqOFo4RXhNbWZXMXZXdDRuU3phSzNDU0NRdXBwekRNQng1TFJuNVUzRzNLbWp1RnhYeWJyR29Xa3l3Zm1jNjNFeC9jdXQzdzdmeU9jYzU5OTgva1ZTSEMyRUdMalJERjMyTFR6RWJnVTVVVmFBN0NoL0U2N0xEN05pbzVzM1k0L1A4QTlqNUYxRkVxZm14SlZjOTVIZU5jU3RMZVhjeEhPUSt0QlFWTzNRYTI2MXJSUXRFYzNlOXNsdDFuTFl6MlhoRitrdHBEUEh3TnpJRTdoRlF1MVNmeUFycG5ja3FteURIM3FUTTFvNVhzbjl1UmZZZmtSVG9kUmttV2Y0bjk4ZnVqNGlzZHNjai9BSE93am9xMmVYakY3RHhIOU5YOTZqL2hjYVh3RTZwOVM0ZkN2OVNYMnlmSVNTK1orSUhEWHR6SDJydWZIS3QzajNKTzdQYnVBNHFOalF2dDZhVnBhZ2FsRlcwamZtL0JQdDM5MTdlSysrejNsT09peU1VNXZwTUk1QWhubWVQdG5uR1F0ekV3VUJVSUJWZmdCck50eEtwdHJ1YW1QbTNVSnVVYzdlYWZiL0krTitVcFllY1k2NHhwdmEyaHU0RmpDdXJndTBxczdjSEMwQ2xnMzhLYXJTdlNyanFneTE2WmJwcnZvTEdUeEdTd0Z6YlM5NFhtT2xkYm14eWtGdzZOSGIzbk15QUlxcndxM2NERWpydjZqVEs2dW4yY2RJOENOc2RzZGwzVTZPZFlMVDhQZk1SM21ZeHVVNGxZcnZ2NCtKdTZyTmFOYnVrVXdOU1pGUENQM0UrN2RqdnRyRDVTcEZiVjhOZmlkYjdjN3ZlbjBuVDRkdmlQVnJKYldOdkhOSkJLSTdaWGpIS1AzUnM3QXF4NEUxQ0lLb1Q3cVU5ZEE1SytycjFOQk9GSGdML2ltUExlUXllU3Bkc0lKWlpiYU9LWll4S2xuYjdsUWFzU0NUeW9OeFdwNmFMeVdTcHRhN2ZtQzBydXM4bmpvdmtJWGxVbC9MbUxtRkpZc2RaM3NiVDJzNVRpV1Myckh5WitnUEtPZ0k5UGxUUm1CTGFtOVdnTG1YdExTYXFyYWc2N3Zud2ZoV1VuNU8wZHpIYjRhMHVaU1N2ZHVlVXR3c2JWcFFCRFUvMVYwWnMzWFM4NU1TK1I0c1RmbEgxS0d0YmQ3M3lNTUZxdHVlUitBYjgvaHJibEtoeXNOM0d5NXcweW1PNm1Xa1ZPZkp2UVZwL002R3JkUFJkUTYySnhMR2JJNG01eGpRVzNzN2J4a1J4c1FGNUtQZDY5YS9QVmRNaXRJWGx4T3FYZ2E0TEc3bnVZVWloNWR5UHZ4VllLQWkraDlCME8yck55S0xVY3J3WmUvaG1QUGluaHRwY1RJQmZYeWxrMjRzRk5XWnFiSCtvRDh0WmZ1ZkkyVlZLLzNIUyt5Y0g3bHQxdWxkUXZZM1prUUJUVW1udFB6RlA1YTR6Skx0QjNXU3FMYmdFbHJpQkJBdkthQWUybzlWVVYvaWY1YTZxdEZYRWw0SEU1TDdzcmZpZldNaGFacitXZ2lsaDdYYlhvcERCYWZnYWJhaGtTVlcvRWR5L1NobmlNUXNTa2V6UmpraE5LVU81cnJQdFJPa0lFYzc1SjJJeXJZdDBFNS82RzZQTGt2OUxIWUdudytPbndaSFQwK1BRb3o0ZnVkT3FLQS8xSytCUzM5K3ZtL2o5bUxuRHp4RmNuYzIxSkZTNmdkbzVDOUNhZEtFOUtnMTMwL0Z1c0dTZWxNbXE4SjcvbWJIRXYva2NiN0ZuL0FNbU4rbFBxNnZXRjhQQTRZeW5qRnd1UnVyaTd1WXJGSkoyQ1BNL0ZUeU8xRFQ0YTdmSG1XMVJxY0Ztd090M3UwMU5zUGpkd2t5QjhsYnVpN0xKSE9IcjhLMDB2dlZoNkNlTnA5UTFrc1pqOFJCSEJGZWYzTExyUzRZUnVEREE4Yk9yeEVBSG1XQVJ3NnRTbXFWZmMra0w5UzYyTlVTY3kvRHcvMUw5KzJWMVllVzRKTHVibERrYlNHS0Z5aWtobzAyUm01aGlTU2VSb2ZYWE4rNjQzamU5ZEgrcDJQcy9QdHMrMzA4Qncvd0N6MHRZN1NTMXVWbk51NnlwQ1FvbGJoMHFGMzZtcDFqVjVWbGVZN0hRWk0zM2NibzNDNi9SbHZZOS9JYnUzaVcxZTFoN2NjU3lsU1RNbTN1OXJDZ05ONmROUE43T2F0UVk5bGpyKzVQOEFnVU4vcTd6Tnl0bDRwNDNOd3ZaRGMzRjQ2bjlzaFVSRVE3RWVySFd6N1BWMjVON1AreXFYMWY4QVF4ZmRHcThiMHI5OWwrVXNwTERXa01jRjFkWE9GdjdkbFR0OTJDUThXNTdFcUFBU3REVTBiWFI1SmJTbGRURjQ2cWs3YmJkT3c2M1N4Mk9NeGxqR1p1S1FpUlJPM0oxUnlXVmVtM1VuV2xaYk1GRnBObmE3L3dEMlYrU0o4bTBxdFUzRlYzN1RxSDdmSDk3d3lhS0lpR1h5M0tXR05jalptdDdLTXRPZmp1cXNwL0hYTlpXdnZxcjZZNXYvQUMvTTF1Ri84RjNYUjVOdVA2dlg4akxIV3R4TjU3NURrcDZmU3hRVzFsWkZUc0k0NnNSK1BKZFoyYXkveDE0dXpiT3o0bUZyblc4S1VyVkZoNGkyN3loVHNINEN2cHhEY2ovdDFuSkkxK1JlSDlRMzVMTW90WWs0QjRaNVkxckllQ3FxcXpGanQwNmFFeUxVenVNdlZQaEp6bC9xRDg2c1lMZUR3SENFL1ZYWlNiTk9HNUJReHJEQXRDU0svcmYvQU5PdWg5ajRVdjcxdWkvYjhmRTViL3NudVZxVi93QWVyMXQxOHErRCtKQXl1ZnVjZGJ5WWl3TUtRU0pGYlJ2SFdzSVJBalVBSkFiWW5wMTMxMVZxN2pnMWRyUkF4Zk1zampMSTkrUTMwYUFMQXR5ZWZRN1ZyMTIycjEwbjVEK2JHQlljRm1raHVNdGlZWXA1MEVqOW1NZGdNUUNlSXJXbnBwSk5keDAwMTBJemVCZU9YYkI4Yk9MYWJjOElYYUtRVTZnZ1UweXMrNCt5dmlhdisxL0pzWWV4anMyMDFxZ1BhanZZa25RQkRzRlp4eUEvQnRQSXRqblJtRXVROCtzMFR2NDNHWDlwMXFxUEEvRTlWRGd2US96MHRCTjNOZDc1cGR4Ujk2LzhidW80elVCSkVGMWJpaG9lRWdLdHQrR2xBbmQ5MFI0UFA4SjJXaFYydHBSVmxqZG1qQUo2a0NRQ3RkS0Jsa2diOFZuNUxaRmU0bWZneFZsdlNxWEVhQnQrUU1aNDBGZDk5S0Nhc2d0SG5URmRMZDJONTJiVXIrKzF2S2JiMW9XVmVRbzlkMkExVmJGV3oxUVZUazNwKzE2SHRoNUdNVmw0TCtXYTV2bmp1R3UvcGpNVmpuSkh1cUdRZzcwYmxXdnpPcE9pMndpUDNYdTN2cVArZSs2bUx5R0F2YlJiT1cxdjVDa1lXNUk3ZkV1cGM4MVZ1aWcvMEhmUUZlSTFkT2REVXQ3Z3JZMm8xWTNlRGVaWTZYRFl5Q2U0czRwNGJjVzA4TWIreEZqWjZjU3lSZ2dxZlFEOE5ZbnVmRnpQSzcwckthTkQyL0xqZUZWYml5RnV6VEFUZmVHZkxwQXd5VVVGd3NNMzdra0JwYlFyTSswWlQ5QzBIdnIxMjFkUlpLKzN0UFQrVWtiYkh6YXBhdVB6R0Q3a0s5MTQ0LzhBYUxoSURGY3dTTElBRkRHUU5IVGlOK3Jod1A4QWQwQjdUWmY1QzA4UXozQ3RsZ2M2TWozMWxkUitCY0xtZEx1NGh3ckxjM05hTklSWXR5TzU5dzVWMUhOcnk1WCsvd0RpRThleVhFaC83Q2c4REdMcng3RzMzTGoyMktjWDZGZWJjU0RydVdjRFRxbjVuVWZtOW5aWkR3RHlDRE5BbTNsc0xudU1BQnZIRldNNzFBbzZxUnJ6dkR2cHlVMTEzblo1bysyMTIyZ1h3bFVzdnQ3aVlNT3l0YTR4Skk3bFY0T2Ura3JCbHFvVmExUFduVFJYdTlYL0FKRDNkTklKZTFiSGpTK1FrZmJmRzVQRitTZVVwZTNqTmp4TkZIYlF3Y0M4Y1Vzc3MvN2lnR3BJZFYzUDhOSGMvTHY0dU54K0VVOExEczVlVlN2OVRmZVhHUlQ3MjJkdmpZZVdOek51TGdYUUlCRUVWbkxFOGROL2Vza1lQNWpWbUc2dHdiTHVwS010TDA1dFcrNXQrNDEvWitQNUxBNVV5Q0pMYWE1bGRwU0ZMdW9nY0lhMHF4RmFBZW1oL1pVcmZjWGtFZTc1R2xSK1llODFlSC90aklwQXhFenRDclJna29wZThoV29KUFVVRzN6MEI3WW81YVhoS0R1Zkw0N2ZhRExJM2xyay9HWGNxSGU4eDh5M0VYOUpQWmJrN2JiMGRkTEpUN1hNaGY3aVhIczh2RW4vQU1TZjQ0WWIzdzdGeXhWRVZyYVJ3UGJxM3NIYWxDeWNVcDdSdzNJMWQ3aFRaeUcvbVZlMlpFOFNYeFJ6bmY0MmZGZVQ0K2lnd1RXMGlEbWtjYWpzek5WYVJvbzJLK3UrK3VtNURuQ21ZWEFXM2szcXVtcE94RnNjUmhmSU1IQk5hMnRya1lMcWtkeXMwMHNycHp0MlpaSTFWVkE0cXFxM0krdGFhbnJaVnNBWG9xV3ZVVi9FWm5tOGZnaGNqaDMyaktydWFUcUY5ZGh2MTBXbEVnZGJSQU84VHd2ajJWbXM4Rm1zRkpmUVptZG9aTHFCekFZbmh1Q3hrTEp1Q3F5ajAzL0xVSGQxclorQmFzTmJaS3ByU3pHbnlmN1FZWHd5K2lYQytVWkhEeFpDS1Q2WDZxUVRLbHdra0lRQlFFN2dJa0lLOWZXdXF1Tnkza1RsZEMvbWNCWWJKSi91OFNMNUg5bmZ1Sml4WU5mSEFlVXg1U05qWlNtTTI5MjB5Y2FSdTdySHdadVd6YzZiZFJwY2JuNHM3c3F6NmVwUnlmYjh1Qnc5ZFFVTHY3cS9hNjY3TStQOHI4SWRWZVZmcExoN214WllhRitLemM0M0NnZ2tLeDIxY2xnenJUYllvM1pzZldVTXVFLzFRZWNzOFp1OHhodkl1REkvREtXell5N1BiQkNqdXdWUS9xSTNHczdON054N3VVb2ZrRjRQYzh0Tk5HV0hoLzhBVXBqb3pITG52RmIvQUJoNDhXdmNhWXN0YTEyM3BHVllBajVheWMzL0FGOXY5bGpXcjd6VnFMMVpiZmhuM3crMC9uTk1MZWVRWXlDNWtSalpwZVBKWnpwY01nUTl3M0pVQU1BQnhvMytHck1IRXkwU3BscnBPajhINGxlWGtZdGJZcmZGZE5QZ2ZuZjVEWTJXTThqdmJDNVpZSjdPK21pUnAwTVplT09WbERMSkgrMnlrQUVOMGF0ZGRVckhOdUpHdnlxeWc4cDhZd0VrYlNTWGtjUWc1UnFTcGVGaW42aUtVNGtIcnAyNFEzN21NLzJ0K3l2M0p6bDViMitJOGpuczhjckIzQURTVzZlb1BDVW1NbmJweDFqY3JtNHFPSFdXYTNHNGVTeTNidHFSMk9zY2ZoZU1nOFZ6T1FreXN1U3RpalhVeVJSdkpPa1BDVXJIR2lxcSswVVhmajg2NjVuTmUyUzIrdFlSMEhGeHFFcDFSUkhtMmVzSjVaN05MTVhVc01jZGo5WGNWN3hpajNWMWRTQVdGZU85ZHRiZkhkbFJTRGNsSjJiWFlydTY4ZXg4NGxFU0hnZUpqTGlqZzllTzJ4cHVORS9jc2dSNEtXa0h2NGxRSzRCZGFNSTRsWThRRk5XNDAyMlBYVXY4b2krRHBJcVpQeGUxbm1ra3VJMlp5ZUViQThXUUNwUHNVY2FHdlhyb3VtWFF6NzhWOVFIZFlTaWlPMnVJekwvVWswYkthRGZaaFVWMjFkdUJuallSdE1YNC9pMGp1c25MUGR5VVhuRGJKeFVWK081SjAyNXNhRXVwRHlYa2tGN2NGTWJERFoyTkNGUmFkMDBwMTRqWW5TVlJuZVhvS3Q3ZUJKV2FLU2twTlNBM0p1V3Jhb29zeUZkWFVrc3FUcGJyYVNvZDJoQlVsaWR5VFhVMGhOalQ0NTVCNTQyUVRIK0xTMzkvZlhpdEg5QndOd1pZM1VvNEtnRThTcElKK0hycXQxcjFaYlMxNWhIYXYyY3lYa01LWTZIejU0djduZWdESTJDU0hoSWx4R0RGT0pJdGxmaWloZ0Qrb2I2eWNxckxqb2pheHV5UzM5U0xjZlZlSS9kdjZXUlFtTnlLeVkrVlN3b1F3N3RzV08vS2pLbkhVNnJkaks4c1Z5VDJEbVMvNVdac2JjRk9QYXlNVWFkR1YyNHlMdjhBQWNXK1h5MVpUWFVwdVZWNDU1SERaZWM1SzFTNWVLZTNLcTFvYUtrdHZNT1VUeHFUVHFSdDA1Q25xTlgyckNUQnEybGxyZmJ6eWExeDNsRW1PYVoyczhrcGlqY3FLZjhBVUlKNFNSOEMzSWZ5MFBaSmFsOHlBdjhBVXA0TW1iOFlUeUsxaUVrbG15eWxVRzVWUU9ZSkgrNlRxN0RhR1U1YVNqakc0aXVQSDhxOXFXSWpxSGlZZEdqYmRUbzZybFNCTlF5MWZBZlByakdYVVVxVEVTeDdBMTJLK29PZ2VWZ1YwWDRzcm9YTmpKTGJPbzl4ajJVdVR2YTFBY2NxbjIvRUNtZ2I4bFlvVjAvaWFtS2p5TDA5VEs0aEVKTWNpbFc5VllVUDg5RjB5S3ltcmtqRFRER2ZqbjhsOEJpN0s5Mi94eE1Mb09yQ1BiLzhnMTFwWmNpV1JYLzNyOCs0UHpNVGZxWGZVVE1SbU05NXhoSHh1VThrRmpoclFyWVQ0eUNJQzRtamlVVU0wejgyTlFLN1UwUms5d3lxcW91aGlZUGJzVzk1STlSU1ZxSVJjWE1jY25PM3VKak5GSTI3QmR4dlFpcDIwS0dFWm9EUEJrSTFoZVNNMjdFa0NpcktRUXRUMHFhN2FjWXIyNmx6RWNQMDhraFZZeHg3WlVjaHhHMituSWdSKyt4RFRsaVczRmZocHhqVVVQcDAwaEdVVUplUUlBV0o2QlJVMTBoRHBnTzg2eG1jVWNHaC9BYkE2cHlFNjY2RmpZZUNhTzRoUXI3U0RMRlNwRGNmVDh6dG9PejFERlNCclNlSzd2Qks1NTJFY0QydHhiRURpUmRVRGY4QTJScTFQUVRRazVLNHluZ1dXbHM1OFRKZlc5eEdJWU1yTElRcGlNaXl3UEcxQ1F5Y1ZSNmRSVWJWcnBYeDcxMUh4WlhqdG9wT2xVelo4eThTc3M5akZXTE00S1NLOHRWWnVaU2EySVpGTkJVTElQYWZ6MXpycThPWHlPMnBISndSMGY4QUVzYTF6Mk15MXQvY0lBOCtFejF0M1prTW5KWVpuVXJMQURXdk9ObElZZW10VGRQUTUxVWFjQ2RsbzdIeGZ5aTJ1TWFlNzQzbisxYXRHekl5eHowSGFsUjNQc1YyOXJFTjhPbXMvbFkxbHJwMVFWZ3ZiRmFiZEgxSzEvMVgvYnU0eW5qc1BtbGpqbHRyangxVmh5SlJlSGN0N2h6NzFBVUJncm1wWUU5VHBlMGNtTGJMZjNkQ3YzWEFyMDMxNnI5RG16dys5K3F4czJQZjNTV3Z2U3ZYdE4xNi9BNjM4OVljbVh3YjdrNkVHOXVaTFRJTGVRanRML3lMbW9xaGpZK3Z4cHEzSHFvQnVRdFpMRDhieWVKangzMGQrTG0rOGl3ckdmRVN5U2QyMGF3Q2dHSmxrSjRtRjk0K1B0NHNlbEFkQzVxdnQwWmR4YktZZmJvTkhoZmgyUjh4em1QOGl2bWh4MkVVbTRueVY1RkZjUnhyRiswMDA2T0hYanlaVmpSa28rL29DZFVibFJPdmNMeTJlUnF3eWVaK1JlTFRZdkhlTitNUlROYVltVzR0c2xGUDI0NTJTWk9EbFY5OUc3aTl6a0FPWFUvQVRwVnczNGc5ckxSSVJyMzdneDNOc01mSllsOHBqb095WElJS1RCZUJLOFQrb3NONmRTYTAxUStPMDVuUm1yVGwxZFlTMVNEWGlXZHY1NTd5S0RFc3IzdHRNN1NUTVhhUjBpOTNhcngzVWhXNWJ0dDdhYXF5WWFxSFBSaE9QazNzNGRld0srNUVkbGR4V0dUdG9HbGx4NkphWlc2RXFwMzRKSEVnbVplUEpIU1E4SlBhZW9OZDlXOFZPdWpCZWM5ejNKZEZEWlgzbFZ2Rk5oNHIyMHQ0WTdrbHBydHJhY1NxNXFhbDBZQjFiOGV1dERFNHQxTWpQclNVdmpBNjJFZHdzY2lKeU1jZTFkazlmOHBQcVRybTcyVFozMlBIYXFmV0J2eDErNnZ4a2xhUU02bXZKZzFPSEUwUElmSDEwQmMwcVl0MGFqTGI1ZVdMRkpORk8wTmlaQUlZNktVSUZReEZhTVdKQURGU1FUOE5VV3JXWWZVU3JicWxvTUdPeXFQYnlyRUhnTWlWV1lTYnFBRHVVYlkxcDAzR2g3VmdJclhkcUNzN2RXMG1PL3RVOGEzRnRkZ1d2MDhxOXpsRzRMT1hxQ2FldStsanJaV1ZxNk5haGF4WThpYXlLYXM1dS83U3NENVJrN0xIUi84QVFXdDIwTUNrczVDaW0xV3FUdnIwVEJrdGJGVzF1clI0dnpjVk1lZTlhZnRUY0Z5K0llSVF3MmtzcGpDU0FBUmlsTnlhVTAxckExVHpLd1JwZVQyNk1hMjF2SVdOVFFTWEpFSzArSjQ4dE05RVdyeFo1NDc0NnMxbVpFdGd5VHNhTWQ5bDJHLzRhaGUwZFdXMHBhd1R2dkJWV0pYRUxMek93UHorR2xUTElRc0xGYkxlR2UwT0VLdWFnK2gyNmF1VnlxK05vVEx2Q1pISHlpNHMzZEpveldPVkNVZFNQOHBHNE9weVVNWUlmdmw5eXNmaXBQSGZKWm8vTFBHWG9IeEhra1g5d2c5dlFwSXhFcU1QUmtsQkdrMG1OTFJIdXZQdkUvSVloRGpZcmp4Mjh1WS9wcjZ4dUpEZlduYkJWeDJKV3BJS0dOUXFPS2ovQURuUXQrTnQxV29iajVtNksyK0JZMkF2NVBJYnpEWEwzRUMzUXhxd1pTNHNxb3hYR1BLVlYrWk5IZEJHU3luY1ZxTllHZXFvcmZHVlBtZFo3ZmxkbXRlM1ZlUXplUVp4TVpaVDVLeVJmcXJ5WEgyOE5va3pGeVptTWNjekNoUHRxdENhOHZ3R2c4ZUozc2srbXY4QW9hK2JOOW1rcGE2THI0bm5rdVdieEtYSHd3VC9BRnQ2OGIyOHlIM1NTU1hnZFJJMnhLa0VNcTBPMWQ5V1lxcklucG9WNXJMQ2xyTG1QcjNFck9yZjVJVzE3SkNMd1IyS3pkbG5xREpFN3ZJdnROR1lJaThsUG9wYlJtSlZySzZhbWR6TFd0RGFuUVJmdURkR2J4dkhZd1R0UFp4R1RJVlkxQ3lUam9LVkI0aFQ3dld1dExCV0x0OTRnNXJuWlpvcXB5cGtVZkU3U09LeG56bDJlMURMTHdEYjdsUnZ2K09qTXRwaXFNN0JYKzU5QjB3elcyU3Y3UzBrRWs5dkpJbkZsWG1GUmZjQVQ4T3Z3MzBKWk5hbXBTeXRwMVE4ZVlXdUZieTBZeVZaRERiUUpOV0JVTGQ3ZmtxVlBSZG1vZmg4TkNZWFpWZHZNTzVOYWIxVjlJa0I0akFaT1R5Q0MydFlXUkwyOFJZbkpEOEl3eThsZXZ5YjNGVFd1anNlUlBTUUMrRzA2ZEpMbDgxbVgrNm15aVlHS3lqU0JWQjZHbFcvbWRjdHlyL2N5dC9JOUk5dnhiT09uNG1yR3lnZHBnb1BDakZ2V3ErbXNtN2l4bzJob3VXQjJFQURPVmFWS2svTGl0ZGRSUzNwWGljSmxyRm44VEszVHROTkVmZkRJUlRmZFFGMjRyMTZpdW8yeHltaGJvU2ZkQm15bGJoM0Q3Z0I3bytsVkdoNjR2UnVaRElsTUVMSnRGWldNK1dadi91ZFp3U3lTaHErMFJLMG14R3dwVFdWbngrbVYwL2lFNGZWWlU3dHIrUlRQK25uN2gydWVteTMyeDhza0V1SjhtTTh1T0RzUUJkeVZhV0d0UlR1RDNyL0FMeS83MnVrejhPdVhoN1A3c2FsZWE2Ly93QXIvSXplWnlMVTVmMzZhUmJUeWpSZmtjNi9lTHdiTllTUzh4RjNaU1EzU1RFSXNpTXZLTkhwelFrZTRmTWFsN1Z5MWtxcGVxV3ZqSmI3N3hhMlgzY1VPbDlWSDZmRmVCVWxyZzdwSmUzOVpGRkluNm9tbFFNTittNTF2Mnlyd09QV045bU1XRzhhbXVwR2U0eXR2YVc4WEpudVpKVktnOFdLS0tFbXJsZUEycHlJcm9mSmxoZEFuSGlkbkVwZWJIdjdNK1pwNGw1L1l5SXBPR25rS25uN3BleEtRR1UwSVVOL1RYMDAyYkdzdUoxZmRSL0lsZ3l2SGROZGp1WHYySGZWYmRsblBJQXVHRkUzSUg2UjBvZHRjSG9yUWR0VldkWkNsdGYyeFp1MUVWalB2bDVqaXZJYjBKMzIwUlhJdkRRR3ZpdDNaeVgvQUtrc2RMNW45d3JhT0pnc0dKeHZjazdiQ3E5MlIyWWtWSm9WVmZUV3Y3UmxWRmt1L3dDNjBmUkFQdVBGZVd1T2k3Ym0vd0FsL0FyWHhUR0pGa29ZWVpybWFOWXlGQ1MvdFZmMmdFRmRoVTc2Nk82ZVJRa3BlaGdZVnR1b2JnWnMzY0diSlRMdHhocEFsT25HSWNmOW10SG1SOTExWFNrVi93RHgwL1VqbHZ1czJPK0RXM21IaXRoSW9MWTJ4dk11NEc0TTE3TjJJeWZtRVVuWEhacFZzOTE0MXA5T3Y1blVlMTR0MThHTitOci9BRTBSdDhkWHVXOTVlN3NaN2x5VFQ0SGIvSFdWbXQ2YXJ5Tys0MUVzbVIrTC9Rc1hEUkZXQ0lBRDdFWWVtNDVFNm90TWFBL0lmZGdIN29lUlcvaVdKVy9hbHhjRGxEWjJiVUFubW5WWTQ0Z1Avd0FvL0N1bGc0N3paVlJmTitDOFFISnpLY1hCZkxmdDBYaSt4dzdsWWZJTWo1Wkozbk56bnJxOFltVmZXNE1uV2hyUUFqK0ExNkhqcFdsRld1aVI1Rm16WHpaTFh2cmF6MUxWeTNoR044VWo1SmRTWFdVaHRsbHpOd1dEUmZWVDFNY2FDbitYM3VTZlVhSCs4MjJvMDdCSDJLMVNmY1FjaGVnTFVOeWpqRE80NmoyaW9GTkVvRXMvQTMyZjNLdlFFUzZTQ1ZWQUFESzBSMjlmYWFmeTBvRW1NZG45eU1YSUszVnJLSHJYdVF5cklBUFdnUEUxUDQ2aWtUV1FMNDN6VHhqNmd2SmtIdEN6ZTFaNG5DS2FldkN1eE9uSnE5WkQ5dG44ZkRETGUyR2Vqdm03WjRXMExLd3FOdmNDM0lBZWxCcU1FM2ZUcUNZUEtjbGlZTGk0bHY1N2lwNW1MbVZqcVU0bjJFYitnSDRhZUNxZkVNWXUxVHlyQ1FaTE1ZbUF6VEdUaThFSVV2R1dQRXVCdHlvUDFVR202Q1VOYWtTWDdjWVZwaDlEenh0MUlyRUxGSTF1L3RJclVnZ2V1bmttcTFaTG0rMy9BSmhHRitselAxNjllMWZwSGRoUWVoTG4zai82dEtTdDFCMXpnZnVCWWJ6MlZzNHQyRHlTVzdORVNFcldxekNXTWZHdE5PUEZrUllQS3NsaitFMXpaM1VWcEtoSVo3ZnZ4TWovQU5TdmJ1Vm9UMElpMHd6cys1bk41dGdyNkJySzhVdEZNQnpheG5NRTBaREJ0aEtMVmlhL0N1bmdtOGlhMUc3RytZNDJPMjdkcGs3aTBLTWhVM2F6eHlLRkJEQVB4ZEtFSC9QK2VvdFQxTEtaWTd3d3JMNXhmWkdJV1MzMFdUdEM2dXNZbjdncXRRQ3hSdVEySjlkVVY0K090dHlxa3dxM012YXUxMmJRY1h6dG9jQWNIYzJLbU5yWnNkM0VaeklzY2l0SFhrN0V0eEJydU5BNXZicVh5YjA0Y2gvSDl6dmp4L2JpVkVmVXI3SDNGbmpJWmZHRjcxeGI0N3RBWkNLUGVReXIzQVRFYUZTcFBIMStPdGN4Y2VqZzZJbis0bmgrZDhZeWR0ZFhrY2h1TEdlT1d5bFY3ZWFYbEF3S1JpUUFNekhZQlNUWDAxeG1UMi9QVFB2UzduV0xsWWJZNG5zUlB0Z2NmUDRtdGhqNHBJdnBtbVYzbER4OHBwbkV6TlNRTHNlZEFlUHBxMzNqRFo1VmJ5Ulo3VGtyOXFGMnNDL0dMVElZNzdoK1F5MzExOVZaVFF5UDlKTWVLaDdoNEpXYmtLcVdRTVZGRDAxYmxlN2cxaGRHUXgxVmVjMG4yTnZrTi9sTWQ5eFBHbHRvQmQyOXdmcDNuaVpsU05HdVpFdURJbzJGRTdSRmZqcUhCcFI4ZkluMUZ6cldXZkcxMC9FbnYzT1hHTmdvbXkwTVQyMXJmVzhrRE16MWpZcExXcFRpYU1vWmQ5Qyt6V2Yzb1hnRmU3SmZZbCtJWHpkdFo1M3hIS0xaTWJhMnlGbDlmSGRyVWtNWWhjeHZ2dlZYQ25RdU4ydzhwTHVyQk9Wck54NWZlcEM4UXcxckg0VlpRUGNPYmg3YWUwbG5rcXpMSk8wb2NzcDVFQUYvajg5WCs1TjE1ZTUrVEtQYlh1NG14ZWErWmw5clpNcGIrRFpYKytSaU84anYzZ2lpUVZDUnBEQ2tucWVyS3hxZFgrODJxN1Z0WHVnWDJpbHEyZFgwVEtlOGp5TWQzNUZIaU8yelhPSnVjakhkRmxvdjcwa3BRQW5ydHhiODlidG51NDlYNUl6dU1uWG1XVDZ5eG84UHZzVUxxZXd1M2lTZVdhNWRGbUtnOXRraWthdkxvS3ZwWFRXR3JYWXB1aytUZFB1Vlg0MUVJSU1uWWY4QStIZUV4c3BCVW1HUmtOS2RkdVBUV2xYVkdWQ1VvbGVIeXcybVVlM2xVcFBhWmdTUnFqc3E4WjQzYmNBZ0hkQnRvZmJ1YlhpZ3o3aVZVNDFUTGw4M3NSbGNSYTNiSWtweDl6YXp4enpJWkNqU1ZqSUFERHFXVS9sckw0N2k3cjRtN3prcllsZnJEUVQ4NHc4T2U4QnRyNDk3dTRPNWduL1lrRVpNRDNCaGxVazdjV0VpSDhRTlpudDd0WGtXcjJzZ2ozZXFkYTI4MC95UkwrOUZ6a1RpN1creDkyTGE3eGVSVzRScGxKQWl1bE1CWmVQTGRXS2tiR29ycWoyVy93QnZQa28vN3AvSW85d3dPMkd1U3ZSZGZtUXZ2N2hmRnNqanNQNUJaK08yV1djWGIyZVRNRnVrTTgwRjdIKzJKWGlVT3lkeFZIS3RWSkhTdWovYWVYZTFyMHRiNFNaM080ZTFWdHQwblVyYjdpL1pIN1krRzUyeGh0WThuamNQazc2U3duanRMbDVlQllXMGtRZ2FVU0VPQTB2NnExQTFvOEhtNU10YnpEZGVnTnpPRGp4S2pVcFdXdnhBWG5QK255LzhjOG1zL0dzWjVQSGtMUEpqall5K1F4cXdpbVNSRTRPVVdRa1AzVUNzQU4vVFYzQzl3Ky9SMnRYYnQrWU55ZmIzaXRWSnp1SzM4b3dHZThFdnNwZzg5YUtKTU0xc2w3L1pidzNOb0JkSnlVdEhjQ2FNRWZwWlNpOFRzYWExS3RXVW96cjFkSEQ3RUx4ek1RWlNkemJTek5EYXV0eHdlR0szNHNCeEtoWWlWYW82N0Q4TkpxVVBUckorakgyenhWcGcvRHNkY1czQ1B2TXJQSUdBcWt5aHhUWTdrZkQwMXlQdU5OdE42NitKMEhIczdUVUgvZE9LK05yL0FIUVc4VHgyTG9NZ0N2S1ZMYTVaVk0wVEt3b1VkVnI4bTNGTkNZYTIxbHk0TlBEWlYycnMyVmxkL2JPSHlLMWJMeFhDeDIxdThzYm9wRGMxWnVjZm9Cc0NBZHRGL2VkVklVOEszUStwWHZrZmlGL2lKNXhiUExMSVZqa1ZTUUFVN29pNVZBTkI3cUE2S3BsclpBMmJDNjlPcHBoU0c4czdDZTd0NXNYR3NEenk1R0lHYUpHZVJsL2NXbFFqc3JWWWZnZlRUMlNqVFZndnEzYStsR1dVOExpdHJpT1g2aUdidnVlRTBTc1lwdUNDVWdFVjRrTHY4eHFoWlgwOEF4OGVxVTd0V0FKUEUwbldTU0ZJcE9MZ1FTRGNTQmw1QUFkZVZQbG9oNWJlSUhYRWhWejNpNE1kWStEbmxYc25ZcXdQdVIxNmdqUkdITSs0SG40NjdGZngrTVFKbGJtMnY3R3NZQVlSRXlSbFFSWGtDVHZUV2c4amlVWkgyUFUwMGFiM3hhRkkyT09ZeE1vUENPUUVoaUQ4YWJmbWRMN3ZpUmVMd0p2aDNnOWhtcnRGejJRN1VLdlQ2V0loV1pRZHlYSUlVZjhBcEoxTjVJNkVzZUhjOVRwSC90YkhlQ3hZUCt3MlF4WnYxU1I1SVhqbTcxck43Vm1kaTRsY0ZoU3JFVW9hQ201QmVUZW5KclZ4MXh0UUVjakxsY0w1SGdzdkVVTWQxeHQ1QkhMM1Y1eE9YVGd4SHQyT3g5eEI2NmdvZFg1RE9WZnlZWis5VWNSZnh6eXV3Wm1tY1J6cTFhQ0thb0lxUlRsdjdWNWV1bndQcU55MW9uNERBaXg1aGY3bmJUU2ZXRzNNVXNaQUhLMXZJNjAySW95RnEvZ3BHcFYwQm5ycWN6ZmUrd3ZQSHZKc1Y1TllxdmQ3SnM3aUwwa01GRzR1QlQ5UWMvdytPanNYcXJEQU1xaHlnMTRkNUxlVFNZZkpXQ3luQnlrMjFwSks3ZDIxdVlmM1RiTzVQdlJUeWFGdi9UcXJKV09wWmp1ZFFZbTZpOG44VXVjYmtEWHVvb2FSbC9iTHlWRWlqOEdyVWZQUWFlMXdHUFZIRlgzZjhWa3hqV04wa2RXdHBac2JPOUNLbUtyUm44MTFvWVhxMTh3RE5YdVZ2YVhza0RVVU1IR3poSy9udm9ocVFZZXZIUE1MKzNpckVqTGFxT0JjTVF3cnRVSHJ5QjMyMEpreEtkZFMrbDdMVkZsZVBmZU8zbWpTMXpIQzhqRGNYVnFMY0JhajlISWlwLzhBVitXczNKd25YV25wZmwwTkhGeTAzNnRTeS9IL0FEYnhpL2xtdFBISG1JbmFON3UxbDNNZkVjU3dxQWFFR21yTWVUTzhhcGwyNlBxaTdKZWxsRmVpOGV1cFVFK1VsOEw4NXpXTW0vOEE2WGtZSjJ0bU5WMzRQSkVSK0RCazFwTDFWVE1tMDFzMFY5aWk0eGNFNjd0eVpsTmZSaVFmNGF1WlVqVjVBbDBNVkxkSWtuZlVxcU1qRktOdDhLQTBBMGtKaWZlWnU0bEZaN2RSS1J4WmlTV1kvRTZrUUJNMXc4MU9RVmZrTklSb1lualRTRWJMZTN1cEhXYUFiSWYxSFlhUWg4d2taTGNTTnlwTlB5OWRENVM3R3g3c1daYmFEMnMzQnVVWlVtb3IxMitlMmhXb2NoY3lvREdLYnUyOGwxSUFCTk9lVkJUanhQRk9uUTBGZFRXaEZESG1zU25rUGpzOXZjRG5kWTBtNHRRUGRWV29XU2cvaHAwNUV0SEpEKzJmbDQ4ZHpFRnV6R08wdUc3ZHhBOVNlVkNxT09sS1YzMW1jakR1VTkwZEh3K1VzZG83UHFYVGlWdGZHUE1JYlM5dklyYkQ1L3UzbHVFRkxkYjJVQ0NaVzZBQjBQSVZQVWFvNHVSdFEvd2d2bjQwdGFnejdnd1dEWm1TeWhhR1BHU3JOYnFsQ2l5S2lEZzRQeDdsRkZCNmZMUkRlc0l6SHJTZkVjdkdwWXZ1SDRrcHpVUWRMYTBiR1oyd2NFdTNKZTJHQUpJUEpCVTdkYTY1N2tWdGh5YmwwbVVIOGZLclUyUHdnNEI4Z3d0ejlzdnVEZllXNDVOYldWdzBjY2hGTzladWZZLzVyVDg5ZHRpeUxrWVZaZC8xT1Z5VXR4YzhQdCtnWXorTnRwTGRwa0llRzRCTWZ6SHhHcU1WM01lQnA4bkhWcmN1akZHMXZKNFpFaXFQcmJNa3h1eDlza1pIRXFRZW9aZmFkSFBWR0QwY0hUMzI3KzVTUXhSaVRFeTMzakdieHJRWnVlV05Ka2l1QUhSSlJFQlFxalIvdVZwUTFwdXcxbFh3dytxbFBRMDZacFhUNGtmelRIMkZoQkRrcnFLRzhMVzZ6UjVPd2QrRXNWdWlLa3k5MEhkMExlMW4vSGNIVjFXVk5TOVNwY2hrSnBiaVc0YXdaN2pJdXZZYVpGVG5DaUtFYXFWOTNxS0hiMXJwUXA2OUFxcmRhOU5XVGZIc3BrN09YNkl5T2tqaDB0cEdZVmhtZXZ0UUNqRGM3alZXUko2aG1DMWxwNC9xV2Zrc2JoTW5oNUJ5U0R5REtOYzI4VmdoZVF4cWVKS01hSDIxRHJ2MUZQZ05aOU1yVDZhSTFMNHF0TmQ3ZmlDbzdpR2Z4djZuQVg4RVplM2NrOGlDR2liMmtjeFd2K1grZXRMZHU5U01WVWRKcS93aDhoVkxhTXJMVkZnNUxKTzRWcWJVQUhGbTZWMzF5OE4vTTlOeXV0YTlQMjlXVG84bGJXcXJMQVZsbDVKSEp4WmFyR2VRSkFCUHk2alZleHZSaE5IUkpOUXlaUGUyOEVWc3Q0MFVQYVR1VzlDQ3FxeHJRY3RpYTAxRlZiNkNXMVY5VFNaQWZ5U0NQOXZ2N3RTVlFvS0FwUnVURC9MVWpiVTFnYjFHZkpyV3pTZ0YzM2trdmJiZ1ZDaWtMR3BkaDNQZDhQaDhSNjZLeGNkSm1mbjV0bFJwZE80SCszY1A5emx1cnlXcGVXN2xjdnZ1UVIvczExMGJhcEhrR1I3cjJmbXkvd0RIV3R0SFlOS0NBV0hNY2hROFI4dlNnK09xcEhTS3Z2TGdYOTljbUw5VjdkQ0ZHLzhBMmE5dFA0c3phc2FjZkFrbEtMeThNd01ObzBGbzF1REhISHdxMnpiQ3A2cnRYUVZza00wOFZFMTRGblRmYStXL3hCdlkwRWthRGtRd0cyM1N1cFV3NlNGTGtWVnRwU3ZrdUIraW1NRktFbHRoUWtFYm5yUWROVFRHejBVU2hRZngrU1JUSWtIY2lKcHpwUTBOT214OVQ4TldTWTFscVZUNTViV3k1TCt6V2tkWjBOTG1tM3Y2OGZ5RzUxYlRwTEs0bHdBYmZ3dkJpWmJtVTNtUml0NHBKcjViWlZpaDVrQXhMSEpYbDFZY3l3K0dxcmNpM1RSQlZPTFdaYmJoYXdXUDRMa01UalpZWE5qSzlsanlxWDJRaFl2TmJtNnQ0b3pKSkdLZ1FIbng1TlUrM2ZicGs4ckhheWV1cjdmanVkSDdmbnBqc2xHaTcrRC9BSkROZVpEQjVMeWF3dWhNWklSSkRjbTVZU0oySjdSbWc0U1F4amlReGtXU2hOVStRT2hLVnRYRzUwTlhMa3BiTFZweWxyOEd0TlE5bUN0MTViZmlTMldYRTI4WVY0enVyM0pEeVZydFIxV3ArWm9LNkZ4NlU3eUgzZjhBeWE5RXZ6QWNCRm40NzlSWjI1a3ZEQVFMTjl5anpPc0lYbWF0eGVzaXIvVnZvdjhBZGVETnRGY1RmZndFbnpIeEtQeURBelhHSGxtbXljY1NDRHVSOXRaNDRWNHNoUUQ5cVJRdXlldjU2ME1lYlpiMWRHYzd5T0xYTFJ1dlZmbUl1UnQ3akYrUDQ3R3dMeWpqVGxPU0JSWnBRR0lJNjlQam8xV1ZydG1YYXRxNDBnbDRQSG1HdTVMMnk3LzB0a2dhOGxnREh0cXgrVkJ2U20rbXliVXRTM2o3NTA3ZFJqTjcvd0J5ZVJ4WE9PcE5jeVJySEZCY0x3TXJxZVJkVlN0VUEySWJxT3VxRlRaVi9FSmVUN3QwL0l0Znh1eVkrZlBrWEltc01CaldtRXBiMk5KT0Y0emhmOHprc0tqUU5zdXpEZTNjMk1HRjVlUldyNkkwM2Q1SmUzMHQzTWF0STFXK2V1ZVhROUJjS3FTRE9KbGJ0OEJzR0E1anJYZlFlWFJqdGFhbGxZbk50ZVBiMlZ6SDcyWGlraTFPd0cxZjRhMGNISWQyaytwenZKNGlTZGt4aDRkdEdtNWUxYURsU3ByMEZOYXJ0Q2xtUXF6b2JiRzlEM0YxSHlQN1RCRFd0UGNEWFZTeXBwcnpKWHd0SlB4Rlg3eTVoc1A5cjgzSEF4N3VSQ1dFTk5pRE80RGdVLzNBMmdsRnJVcjV6OUM3aTFuSTdmN2F0L2xIOFRsREFZSEsycndaR0M1ZXludFpGbnQ1VS81cVN4RU9yaWgySUlHdDFjdlprVFhValQydmZqOVRoSFQzMzZ4dHI1VjRKaU01Y3huL0FMeHM0NEZ2bUtzbjdVa1JlUUl0U29VeWIvSFhQUExqdzgxN0pTdFp6L0Q2YWtQYmNONzRyNGJmdGEzTC93QmwvTkg1K2VZWWU5R2J1SjFpS1d3Q1VtYjJyOE56MDY2N3pEZGJUaWVYaXRYSTlJQk1HTXVHRkZ1b2xGYTh1NENQNUhWMjllREJWUjltTThjQ1l1R015WDBkMWZxZThpdzFZUUZHWU9qVkFCTHJ4WlNwTzN6MFBhMHZSUVhxclMxWjJuOW4vdUI0NzVwNGxqN085dFRjNTJ5Q1c4c3hvcklqRWhHNThnZUEvUlRjN2E1ZjNYanF1UldhMHRwOHpyZmE4OTcwZGEyL2FwanlMQmJLWTNEc2NYZnJkdE1TOGtiUU15d3hwV3NZcTFDM3oyUDRVMXp6dlNpZGJUSnRMRmZJOTFZanpPU3ZQdko3SmZ1WjVKOWJqR3ZPek5CYXBkUXV5ekVRUW9qS042clZxNjY3MnpqMmZFbzZ1SmwvVm5PZTRjcXRPUTFhc3drdXZ6L2lIdkQ1N09TOWx5bjB6UVk2eWdkWXl3UXFqTEdkcEVJWmpSMkFCOWV1dHZpWVg5MnFzNTEzUDRWMUJLNTY2MnFvVlZwOFJXWWtobmJjbXJIOGV1cjNadHlZOEZvWTZGclRJWnE2a0lZMkdMc2JOV0ZBS3BBWkNCVDRtaDF5V2F5K3gvN1hzL3pPODltcFBLWGhUSFJmL2xxVGZGYmNwaHJGSmdmM09jajErQlppT241YXo4MGJvT3d3SjFvMzMxSDdETUlUY1R0NytOQW9IcjBGQnFodHdCOGxUQ09kL3ZiZVpxVDdyWWlETnZIL0FHSEhXNHZyS09GandUMnNXYVVrVTVsMW9QVGpTbXVtOW1yWDdWbXYzVEQvQUtIbi93RDJLMTFrcFYvczFhK1BkdjhBZ0lQZ3RyOVg1UkZmeGxaYjJhWXJDd1lFQmo3bWF0VHJmdHBVNWJHcHVHdnVsa3JDT2RmSGNTb0YxRDJueUZ4V3E5eElnbkJhZXBPN0g0L2pvZkRXZlV3cmtQYjZlNVZXUkNXMWpKM0R4a2xCU0lBMFlzYWRRZlRSUUNLamUxL2RScWRhZE5JUjZ4anBWQVFmeDBoR1VSbmtORlpxRHFhazBycENIN3duSElJSmI1eDd5ZUlhbFNWWDNFVjlCVUN2eDB6SkltWnE4NXhYQkxIdDFMUFRvS2IwNjZaRXJPUWZpZnVsNURqWTQ0WXIyc0VTOEVobmpWMUNmQ29BTk5QQkZXWTg0ajc3M2tRSXlPUHRiNm80MVJ6Q2Q2ZFZZTUQwMDIwbXNqSnRyOTNmRGJ3dC9kclc1dDVIL1gyMFY0K201NUszS3RlbTJtZ2ZldTRUdVBKTWRua2l4bUF1bkdIbGhsK3JrTHlPWlVBQkVmR1dnUUEwREVmUFNFMm4wSWtQbUdaeGN0ajRwZ0dqdTdDNW00MnNkOUVKeENnSXFVM0ZCVUZ1Sjl1bmdaeDJIZWVPeHZtWVpIRVdreUhlUUt1NVA5VEFjR0hyMC9ocUpZbElGdVB0NzRkZEk5emFNdU91U0ZMR0NacmNyeTZEK2thVWlXTk1XcnI3YjM3U045SGtHbFVjdmJkSkZjTW9YL2VQdUIvUFV0dzFzVUVHMnRQSzdLN2JENDNLd1hOeW5GZnBvYjE0WDVIcDdKKzdHVDhhYVJXMDEzUHNoY2ViK1BaQ1ZzcGEzMXBlekxIOVV0M2FyTWpxbzlyODdZclhib2VHbG9PblpIcDg4aXVKbGl5VUN5Z1VyUER4amJrQjFFYzNhYlNnbThyNk1LWTN5ZXlzWjF1YmJJWFdQV242NlBBUnk2SG1vb1IvNnRNNko5VkpLdVoxL2E0R2F4OHN5RVdVUGtPSXlGdGM1SndVdUpwVmpta2tSaHdOV0c5U29VZGZUVk4rUFMxTmthQldQazNyZjdpZnFDdDU5d3MxZlgyTXZyeUdPQjhmSVNCWmdlOW1lTnp6RWdrcFVMdzlwNmFId2NMSGlWbFgrNEo1UHVHVEs2dTM5b3grUitmZVA1L0EzYUd4bmp1YmxvMmp0WkZqYUk4SmxkaVg1VnFxcnRWZFpuRzlzdmh6S3llaHJjbjNXbWZqdWpUbGpsaGZJY1BuUEdEanJ5ZTJqbGtzMnRtc1JNa1JTSm91MUlvNThhbmo3a29QUWF5K1Z4Y2xlUTdWVGVzcG1oeGMrSytDcXRaTFNIOHVocCsyVStQdGZDM1MxdUd1cHJlL21udVhjMVBjbVJKQUsxcHVDdXBlOVkzOTJ0bjRJaDdNazYycXRkV2FmQm92STQ1L0o4ZmN6UUczUzRCdHUyQlZ1Wm41U09GM3F5c241NnU5eGUvRGpzbHFOd0Y5dmtaSzI3Q0I1eExERjUxOUV0azZYaHYwa2UvQ3FJekhKYkllTEVDcDVra0NwNnJyUjQzL0FQQ0x5QXNyam4rRS93QWdmNHpGaWJYeW01a3U1NEJuTDZPR0N6amxCa1YrY1lHeUNtOVl1dklhSm81d3VlaUJPVlhieVUxMWNDNHR2TGp2UHMvamJoVVNPYVJwdU1hOEUvZFZaaHhHOUJ2OGRHNFduVk5HWmxUVjdKa1c3RjFCbWNoY1kyRlpyMnpqc01qSENDeDdpeENXT1FiQTcwWW44dEw5dDBMOTFISGFDNmIyNXZJZnQxYjN1UVYzdWt0Ykc0dkZDTlZVaWVOcGlGb0RzQVNSVDAxa1VjY2o1blFaWHU0aWZrSGNEbkJsdnN6bnJ0bzJqWllGY3JLT0xHSkpvL2N3UHlocm9YWlhGemswUnpXZVRpVmI4UDBCL2tPWWp6ZmgwZVJTWlpHK2g3TXJnaGgzTENic3NhanJ2SHkwSThmMnVlbDR1ZnFhbUczM1BiYmVTTUw2NE9TOEh5aVRubmFHMUJlSjkxVzV0SkZxUi82a1A4ZEttRjRlZkM2Ti9xUG10WE43ZXI5MHYwTm4zSTgyOFZtOGJ4Mkx1OHRBdWZ5djl1dThkWnc4SmJ5Syt0SlFnRElVZnRxRU1nNU5UNWFMNGZFeVk4OXRQVHFZdkw1R0crQ3FuMUo2SW8zN2wvZExPL2R2eXY4QXRWeGlvY1pCaXpkTGJSUXU4MTZzL0hnSlo1d3BDQXNpY1ZWUU9WUFhXM3hPRlhqcHc1M0dGeWVaYk5GWWhWRjY1KzJ2azNpR0lzazhrdUVzYkh5MkJybVcwdDJlZWRWdHlremZVT1JUbnhQSmdDYWF2eGNtbVJ2Yi9hVlplUGt4SmJsKzVTTFVXTWk4ZThreUdNaUJXM0JCUmExOWpxRy9QVjZjb0hUZy9SWDdJNVJMMzdRNG5NdFNRVzhLd05XaFBldEhhM0ZTZW15aldKN2pTTVZuL3RjbXZ4bnV5S3ZpR3ZOWjNUeGZPWE00K29qL0FMWGRGN2VGZUR6SzhaOXZJZEtEZXRQVFdKdzFmYk5vVGJOWkpkRXUvd0JDc1BGc3RlM21LdExuRzNVQ08wY00xemJzVkhKV2hDRnd0ZVI5eFRvT21xcXJhM1Z2dWJtWnFLdnhNcHhIbGNQZFhjUUhjV0tXeW1na0hOVEtZMWxBTkNQYUpmMGRhRFZqc2swSkt6bGRYMUU3R1dtVnMwYTJ2MDdWcGJCWVdpV3NrSmhsY3ZUOU5CeFlFOUs3NkpkaytoVXNibVdvUGN2aHJYeC9ENUNTemxGM2NXdkI3VVNvWndVbkt4dkhFb1BST0x0VDRWUFE2bFcyNXFUUHRSMFRnUU1yWlhSVkxtMGxWYmkwN2FTdkVPSXFrZEZaV0ZLdDhQaU5GMWE3Z2xzYlQwWlkvaHZoN1oveHpNNUc0eDZ6WldFckVZV0hOak82SzBqb2VXNnR6Qi9MUTd0Nm9uUW5aU3ZNcXI3aldkeGg4OVpORkVCQmtMU0M1TnRJakxTYUFtRndSMW9lSTFwOFpLMUk4REw1VnJWdW40b1cwdDhaZWJYU1NXcmYxZlNoWkZydjdpSktFajVBNnV0UjlpaFpFK3FQb3ZGOGZQSkhEYjVXQTNMOXhDcC9aNWJFZys0VUZkVTdycnRvRVZyanQwdHFQdUh5RmpqTVBpOE5uNDJPZjdrZjlzeW9tM2l0V1prbUJBWGl5Z212QitXeHF1NTFXNzZ0eG9FN0lTVXpZTDVLOGd5Mkx1YksxaFAxT0lxTWJPV1FmdnJLQXBVcXdCUmlRRnJ1Vk5kUXJhSDVNbmFydFY2YW9OUzUvd0Q3cyszVmxaNUd6UDFGbGZKM0haUnhOdk9HVG1DS1U3YkRmWTdnSDQ2c1MyVzBaVzdmY3g2OVNaNE5jeHl3eFdBbGQrdzF6WjNNMGloQzZRa3RFU0J0dFZXK2RUVFZsMEEwRWo3eFltMnZSajgxZHJITmF3M2x0YzNNZXhWWWJnbUdTdnlBZmwrV3JzYmNORk9WS1V3cjVSNFZZWUt4czhLc0t4VzkxYXQzRXR6MnFUUU1Iam5TbEtPQTNVZjVkRjMxeHF3UFJMYzBOUDJ6a3lodFpjSGZTOHN2YkdNUE8zLzRQY3JNZ210YmxhQ2xYSEpYSG8xUjhOWnVUOTNrdzJreHFBL3VQNHBaNTN4bkt6d0lIdUpGYTdtdFNhbFpZRjUxL0V4ODBOUDhvK09wMWNNWnFVYzAvYTdHcW5rOHRwZXBHTWJEM0lKaXdxd2RpUWoxK0ZSb2prMzlDanFVY2VrM2FaWm5uR0dzUEhUaTdTL3h3bHdsL0ZLb2VDTldJbVE4MlBiV2hKbzFlU2I2Rm8zWlRWNmhPVGF0SDBLc244QW12ckgrNCtKWFA5dzdKSnVtbVpGTkdyd01ZQjVWMklLc0s2SlhKaHhmUUVmSGJVMTFKbjI2dmZKUEYvSjhjMlZ0NXJheXlxUGFyTGNxZHlmMGZNVWRRS0hUWjlsNnVPcUpjZmRXNm5veDMrOHVPZ3VzRGFlUnhFdEpCeWhtWUNsUTlTSy9EZW1vY1hKTGd1NWVPRkpXK09rVVk2MmpPNnFpMVVFZFg2L3kxb0dkMkEyZXVHc29JN3FEdVNTZHp0eXBVOENxZ21qRHBwRENyZDVTYTVaaUlvNEZOUndRZFBsVTEwNHhFNjZRakZocENKMkxNc2MzQWc5bVQ5UjlBUjBPa0lkOFBWYmlObDNIcUtmSGJRMlhxVzBjTWY4QUgwVzJaSXpTWGFLTU4vdmRQNGJuUWxtR2htMmlqZ2lNWVVjWlFzVGV0R0JVQmlPbGZUODlOVnowRkE3NGJqRmR4aU4xVVhjRWtVaXMzRGt6VkE2QW5ZZGFlbXJTRmhKOGk4YlRDNU5Wb2ZvaUNMVzRtQkZaQVQzRUpORHVSeVd2eDFYZGQwSGNlNnN0dHUzUXNIeHkvSGsyQ0dOdDVIbDhpeDVWc2NYcFNHNWhOZUlKUFJoeFgrZXNqS3Z0Mm5zZFJ4ckxMajIvN1NWZTVLNXptSVdiUHdLWUlUSkRFd0Erb1Njc3plM29PdGFnVjQxK1dpSzJub1ptU20xd3dsNFY1Qkg0dDVqM2JtNDd1T3lRTmxrZ1dxc2tvQkVFa1pydnlGRDZVUElhQzVHUGZqbUpkZFNLYldUWFNSTy8xaS9iWko4WFovY0RIeHFzK09LMitTUlBXMHVYSWlhbEJ2Ry90UDhBeFYxYjdOeVlzOGR2N3RVRGU2NHQrTlpPOWRHY3hZakl5M21NRm94NVBiMVZhMXJ4UFQrR3VoeVVTdEpsOGZLN1k5cjdEYjR6NGRaWkNLN215MFRDL3VJekhiTXJBR0FlMDgyVWpydlhyWDAxRzEybG9WT2t2VWwrSForZnd2S254RzlMR3l6RXZablJnMFQyenpLSTVBcGJpQ2s0NGxsUHFxVjByMDNxZkFoUzJ4eDRsekpnTS9ONGhjWEYwMEgwdmo4YndMYmxhdDlKY1ZjRWxVYjI3RWhTUndQeU9oVmVyZnhDV21pdnZHOGFqTGIyc3M2aGxTR2FWR1FxQjNTQ2tWZVZQY282OWE5T2xORFpyd2J2RnB1cWw4RER5N0QyMWt6eHdsSTd3bVNPTno3cENLMTVWQXBzZmIxNURycHNXVGQ4Q3pOaDJ2VHFDOGY1TGRjckthTjQ0YjZFRUYyTEtWbGpSbExFay9xS25yWDRhc3RqV29OVE8zSGlaK2JGTTdGd3h6bS9qc1AyNExuaU9YdFFlMWlGV29ZQ2dxU2RxNmJFOXZYU1NYSVc5UXRkcElBU1M2djFSblY0dUloWXN3Q2dBRnFna2JsZmhUZldXdWlrNlczcXM5dlg2ZmtiN1MzcVh0MDQ4QURLR0xWL2JWZVlEVnJTbndKNmFxdStqRCtMVzFaVC9VenlzL2V4MWhrNTdncmRtSXJISHVPNTcyV29XbTJsanI2blZMUWJKbGUxWGIxYS9HZ3BGNVlPTU1xR1IrWGNhZXBCQ0tDZUpOS2IvUFdoQ2VxTXBYdFgwdjZrUEtaVnNkYnlTS2VhdWo4SXlCU3JpbTVwdlN0ZHRFWU1POWdITjVmMktPSEthZjVqUjlxeGtHdElMT3hoTTBrN3l5QUt0V1BGaHZ0dlFVMXJaT3B3OVM2Ym1USjRueGE4enVWaE1MckV5V2tiZ29USTU0cjdUVDFiYlZDMWNGdllUZnQ1Wi84QWNIbUVLc2hGclpnM01zVkNSeTZLZDl0MmF1cjd1RVRxam8zSHA5SVc0Uk9XRzQ1Y3FjZXBJL0xwb0t5TkREZExxT1VIM0Nuc2NRMlBMamc2c1FLN2UzcUQ4TldmY2NRRXZEVzF0d2hYVmljdGRtWmw1bENXa1liVkJPNVU5U1B3MUFobnlxSVFLODd2TVA4QWI3eHQ4cE15L3dCeXVDME9QV2dZbWJjbHg4bEJxd1B5K09wVjlUZ3k3VzFPWDdLMkUxMGN4a0c1Zld5VFF5STMvTmhXYU1sSmpXblVucnFXVy84QWFnampZOVZaL0FzWEZYbmpzT1N3YmZTSlpZQ0x4cTloYUM0NG9sOWtnamNtVWpuUjVtU014YjFCbzFOcWF6Y3FkcXVINnBYeVJwNHZUR25waCtVbGJadTR4ME1zV1V0TGw0TFBKUXJickJHemMzbGtpN2JJek1TV1VTQmxmbCtyZWxCVFJOVmJWUnFpcTlxcUxUbzlJTEMrMzhhcGFaYUVNRnh0cXk1RXpKQ08rMHZjU1BoSVNUc1RFRmFob0JyUDVYVlQxNkc5N2UwMWJ3NmtTZk10bHBMNnp1YlZoZXltWjdVVzVhNGFSTHVQZ3hSMzRuOXR2WlQvQUNuK0xWcHRocC9oRnQ4Mi9jcktQQ05abitSTmFTVDJZOHNKbHRVZVlUTVZqcGRSb3NLbEEyNUVYdUlwV3JlbW95dFdVdzdOVW1ZQnJYcTRXNldQRzNVMGQ4QzF4ZDNFb0R4VHlmb1dxQ25FZ2xpQjE0L0RWNjlTMVduWUR1bFZwVmJWdTdCWGtmank1UHh1WHlqRFdFME50Q1k0c3JDWStQY2FyQXpRdC9VRVljVDdSeUZHSFE2SnBiYmJhMzhQNm1YbHJLM0pPTzRJOGRndDdqRFNXTnZKTmJDNmREa3dYU0dFd00vN2ZObTM0ajIxcDFCK1dyc2phYWJJWWtuUnBUNS9BZUk3UnNOa3NhY2ZESGMyN3JMTGIzRm9WY0NSZ2ljVUswcXFnMVUrclZHaFhhVTVEYlk5cnJCWVBqeTNkcDRoZVBlTVhlNnVWc1lDNmxKUmJXZFNWYmx2K3B6ckw5eHNxMHFsMXNkSjdGaWRyTnZzQ2ZwdTZ4TVlxeElKQTlLbnBySTNRZGhzVW0yMnorSWg4bVBpRFRjYzAxdEhkUVI3VWw1MVpvMTllWVVCK1BxRHQwMVl1SGUrSjVWcWs0TXpKenNWYzZ3dHhacVN4dkZibTNodXZxWlQrMnFNTit0ZWdwcWppVzIzbDlDbm0wczZ3aGt0c3ZIZm9sbGJpckIzZVN2b0k2a0Qvd0JWTkhMUDl4YlVabCtPOGIzTVg4ajVNMk5udVozRXdRelJ4RnhienlSY2lSdHlqUmdXcTRYOGRDMis1ZjhBYkdyNlNYTlVxa3JUMEZEN3RlVll2S1k3RVk2UzQ3TVVUdGRYUGRqbWpBOW9DY3VTQ2xlUnBvcmpZc2xyeTEwVWRpcWw4ZUd0blp4dWpxbjBURmpETjQzSmRXTnJQa2JhS09TZUVUbWFSWWdzWElGaVMvR2dLZzduV2pqeFhyZE5xWUh5ODNFOE5rcktXaTc3TzJueXR4azdPL3E1dTRIbGRIM293WUVVL0FHbjRhNUpWdFozbjkzVWxhMWNWYVdwMFRqNUhILzNhOGNleXVzdGIya1BLTithVzYraGIxMTJudFBKMzQxUFZHWDcvd0FOL3dEeVZXbDFQOHpuNlhHejIwdmF1SkVnbUcvRnlRYUhvZGhycDFaUG9lZk9ycm93bFkyMFNBeVQ1TkJ4VXNpSVN4WmdwS3JYMDVVcFhVbjhKSkpQeExuL0FOUFhtVnI0NzUzWlcxMHpmMnJJU0xFRi9VZjNQYkdlSXBWZzFBUFFiblFYTXdyTGphalhzYVhDNUR4M1VQcm8vbWRTK1IzUDEyWitvU1Bnc2p4dzh1aWtnOGEwK1lwcnkyNzNaRzJlbThlcnBpaEhJbHpEYlovem5PNVNUaXNOMWtMcTRFc2QwcTFqRXJjZVZUVUVqcHRyMHpqTjQrUFJlUzdIbS9NcFhKeTd0ZEovUWU4SGpKY1Y0bk9icmtseGxKUUVIS3RValBKK1JIenByVHhYakhhM2pGZi9BTzUvd0tuUjB4cWY3bitTUExMR0xlWGx2YUwrcWVSSWgvNnlCb1RMZlpSMmZaTmxOS2JtcStMU0dXeXljVjM0bDVSNUZGc01oZlNSUURvdmFoWllJd3Y0QlRybStSUjFyaXA1Uy9ucWQ3N0xaZmN6NUYwVDJyNUtCMXhjSFp0TWJGTHRKOU5GM0FOeFUwLzhOWldXTjdPcXhOL2IxR2VGeENMYUJTVk14THNSdnVBU0IvRTZvdSt3SlpUTDhDblBQYjdHK2JlVDN2aVZ0YkxKRnpnVEo1RWtGWWJlMlVsdC9rQWZYcTJ1aDlyeDJyWDdqZW5aZUp5WHYxc2IyNFVwdkhxZmhPb3NlWHhlSS9idmkzam1OVzJ2WkxkT3o3bmNoNTFxekVNUlJ2dzZmbHJYdzN5WkcwK2tuTTVxWStQVmJlc0ZNUzNNa2p0UFBLWGtZbDVaRzNZay9IV2lsQ2hHUGF6czVZQ3ZvTG0rdXVVNUFRaWtJclFBZi9QVGtDQk5qcEluQ3VDQ1JVSHFQNGpTSElraWNXWmVvSDVhUWdyWlFJSUJHQVRjeTBDcVA5NnRUL0RTRVBRdWt0TVZiWWV6ZnRMQ3JMZHpwczByTy9PbTlkbDZWMUFsT2d1WjYrdDdhd2V6RWhrbW4vU28yS2oxTGZMNGFraGhPMDR4NkJVMCtPblNFRjhiank3cVhGZVcxUFFjdHQ5TzRFVzNBa2VEdFVqUmhDRWlNREFzS24vTXZINEd1cXl3U2ZKc3RKYTNNRThSS1NrZnQ4R0tGVlg0TU5UcXBJdG1Oajl4YzlaTU96a2JsQU9nZGhLS0g1UHFieGkzTVpvL3ZmNUFrWFp1RXRyMk1VSHVpTUxtbnBWVHg5ZlVhWllXeVN5TU9XUDNOdWZKTFJyTzB4WDBjb1BGcmhYREtXbEhHbEtMV3ZVMEdvV3B0RnVrZzVnMjJNeDBzc2I4cGxIR0NRKzFpelVVZkhicWRSRXl6ZkdidXhiRDJkdEhtYlc5bGlSVWxkcmhaSm1ZN3Qrb2swcjAyMUZsbFdvQ2QvQjQ5Y3hzdDVnNVpvZWhjckZKV3ZRaXU5UG5wRTI1WXFYWGdQZ0Z3N3pocE1TOFk1UHg1UkFjYTEvU2FmQ2xOUEpYWlZub0tzSGpPR3ZESXR0bTdteVV5OGJhZkp3d1RRU3IxTGNtSWtXblhyV21ua3JnbXgrSStmVzBLeVlpNGd6Rm5LQzF2ZDI4OGlxdzMyQ3pDUmVvK0dsSllxMjZvaXo1SHpURlFkdkw0ZTZTTkFGNXJFSlUrZnVqYmIvNmRPTXIyUHJienZHQXFsMHBna2tJU1JaQzBYNmVoTE9xVUdtZ2Y3ckdUR2VUM01JNVlITHl3U011OFVVeFlVSFJ2MnpUOGpxdStPdC8zS1Mrbkp2UnpWdEJIQ2VmK1lZUy91TXIyNGIyL3UxN2QxTE9yTUpGTHExU0ZaQUNTQWR0OVVaZUxqeVUyUkNRVmc1dVNsL3VUTm1lNWp6eTR6K1RsdThqYmZUR1I3YWFhRzMvQUhJZzlvT0swNXR5V3RLOWROajR5cGpkRjNKMzVqdG5XUzNZd3RNdmo3ZnlOczFDc0YyS1JOQVpUMm1Sa2RqK3BodHMzcHFOT08xUjFmY255T1lzbVJYcXVoRThsZTd5UG5Wdm5MS0poWTNjTVNTVFFjblNPVkR3SUxjZGpTbXA4V2pwVGF5amwzVnNrcDlRem1MQ1I4OG90ZUs1REpZeTRodHBIRkZFaSs4QWdmOEFGUTZmTjFUOHhZckoxYTd3V1o0WWNoa2ZBR3ViK0tLNXZudDcyT0szaHAyK0RoakZIOE9oQzc2enVUV00wOWpYNGQyK00xMUNuMmN2cmZPWVRKMkY1WU1tTm5qZXllMWtGVExidkY3elNnb1c3ekRRWFA4QVJucmFwZnhadnhXbjJiRnJ4YVBCNXp3aTN4Rm96R0cyTTJNdTZHaEF2a053R0JPOVFKZC9nUm9iM090c2ZJcmtYZURUOW5heThhK0hzVmI1ZGtQSWZIL0NNYkJoc2pMYzkrNnVFekNSUW1hV1I3aHc4ZGZjZUNPUFU5ZlRYUlZ3MGVUZlphd21qa3I4bk5URDl1ajlNdVRIdy83WVpYenZ5THlQTTNkNnRoa3NkakJtckN6aWpYdVh0eEgwaU1oWThVVWhWYWxUVSttaWN1YlpIbUFZOFR2Wnk0YUxHOFV2TGJLZlpmelM1dHNVTEsrRjlOYzNrc1VhbWU0Vld0cnhPNHdISnVLamhUK0dzams1SFhtNDlkSU5YQmhWdUxmVFZNMCtVWFVPZCsyUGlQa0pRdkZZWlA2THZ1Q2U3Rkl6MlpjRWpia3NhZmpxZkdTcHlyMDhZWXVUWjM0OUxQdHAvSW9qekdPS1B5T3h2b2FORmQycGpaaHVPZHRJeU4vTFczVXdHdFRzVC9SL2xJOHQ5dnZJUEZiaGdUWVh4ZEZCclNPN2pCSDRlK050QjhyRXIwdFh4UWZndnNzbXV6TFh5aW02eHQvYXdxOXUvWWt0eElTRHhaME1ldzNIVSt1dVB3Y2l0L1N0SFU2VlVucTVrNXY4QnVibit6RzR5MXVrVVdLUkk3YU9IbUhaYmNNWlNRYUNwUEdvcHRTdFJxM2twSytuYzNjRS9ibDlsMC9tRXNwNVpjK0NaMld5dVh0TWpoN3RvTHJuSkt6TjJsVHRLOFRjQ0ZQczRPckE4WEJHcnZzN2tnUDc2MTdOUFdkQTFqYjIwdk16Y1J3R2E2czViZTNXNWhkSzl1WjVPU01xalliYlZVMDlRZFJhY0tVVzF0TTZoRExZMjl5SGlOL080Wm50aytnTVJBWncvSjVWTEEwMk5RdGQ2blN3dVdwN0ZISVNWbkMvY2lxOFpkMnNYYWVTWm9GbGRMaVZGaU04U01pcFVyMndTdnNZMEgrNGRHUFVDMnhEa3ZYd2JDM2x0OXZzZERqNzQyZVZ5a2ozUDE1V1NTVm80cUVsUURVN0t2NmpUai9EVUtxVzJ3WEpiV0NuL3dEVWVpdzIrUHpOM0RKam50Ym93U1g4NnNsdGNyY0xRdEdXclFLOGFnaXZxRDZuV2p3WmFhQWVkRUorQlVXT3RwN3lacE9TejI3S3ZBeE43QU90VFN2SS9BZE5ITXpJR3ZFK0wyTXk5bWFNbVdTZ1FLUzhzaE93QUFHNStXcWI1VlhxWFV4dXpoRjgrQWY2ZHNWa0h0OGo1VkZKRmFWVjF4cUhpekFkQkt5L3BIKzZ1L3oxbTE1ZHN0b290UEVMdGlXSmF2VXFYeUh0K09aeTc4YWR1emY0eTVHTnE4WlVTeFdrM09ObTJwdkNRR05kK3VsbHh0TitCczRNeXZWS2RWQTJlSnoyV1lneXVBeWlNc2NGMElJZ2tnSFlXNklZU01Bd0ppSklxRFVEOGRUcm9rMndmS2s3TlZRTThhanVyRzk4a3dUTVRrN0s3RHdFa3NaTzIvQjZBMERLVkFOTkh2VkptTDBiUnM4eXhkcmYrSzM5aTZqbktseGJqbCtwVW1ERlZwVTBDc1NScFUwYUlYVTFadGI2bnpqN2FlS2Vad0tKYjJ6dFZ0Y3p3SEtSSnJUbGJ6c3c2a0FyeU90R3JxNk9yZW9KRDNLeUllSG15RjdEY1dWdE0xdmRYTnBKajdLZEdDR040R0wyN2srbkVuYldadFRlb2JMalFsUjVxYUN5dDh0a0loRmR5S3NtUXRqL0FFdlVwY0pUL0pVc3crSzZlTmRCSjZhbEoyK0Rnd1AzUG54VjBDbVB5TWJHRGFoZGxhc1pVbi9Nb1UvbnFPZWRtblluaFhyK0phZjNwOE91czc5cmIrRXdLYnZBSkZsOGZjd0UrNkdQMlNEZmNIaXgyR3FlSGxTdEhpUzVXTjJxOU9oRCt5TnJoY3ppc0JsakhIeHpOdkppTW9pSUZJdjdNY2tjMEc1SUhYcnZxWExvMG1SNGwxS1k2K1MvYmV4bW1Od0dyRWpBU2NUVW9hMVNWbzlxRlQxSTlOWk8rMU5EYVdPdHl0YnZEcmMrTDVHMXlpZ2ZVU1MyZ2dJSUt5d25lU25wK29iYTBNZG9hYU03SlZXVHF5aFVNdGxKTGF5Q2hpSmpLMHBRclVhM2xycVlMVU9DQm41YjZDSzBXUnBaSUR5N2xtM0VKSHNDR1gxOTJrTXhQdXJ0WjJLSkFJaXAzSFUxMDR4b0d3M08ra0krTlRUcWZocENEK0lnZG9LU0xRb2FBSC9ML3dEUFRQd0hRMjRlRmk2QlJWZ2VYWGFpOVJvTzdsaE5GQTNSWExXOXpCVGVGcW9Sc1NINjFQeUZQNTZwaE5GN3VwR3ExN2R4REpHYTFJQlVucFVhUzBKdGFBZnpMeUcvd21EK290WDdPVWFaSVZrcFUxUWlRc3RlbFFCWDhkWFk2eXdhN2hUM0xCc014WWZjanh2R1pTU1ZtU1VHRElSSlF0YjNVUUtxNmcwL1M1clg0ZmpwclZpVVNwazFURXl4eW1YOEI4cTdWL0diUytSdUZ5OFpySE1zbENrZzNGUWV0UjZIUW1YRXIxZzJlTnlkdGswV2xoNy9BQkUzbDl6SW9rbk41QTg4bG9Rb0RYTnhDVWZ0dnkvWHg5dzIxbjBlMWVwR3h5cXE3bFBzUnIrM3NZTE83RjlXYklUV0NXNW9UenM1aXdNREZqN1M0WmR5dnRBTk5qV3JwdXIwQTdWVjFIY3NqR0szblBpRWZobmsxcWwzYnk0anNYdDEzZzV1SVpCeGlsVmdDUVZJQkhMY0VkSzZ4czJUN1dYN2xld2NzSC9GdHQvZG9jYytFZmEzeURHK1NOYVMyNlhHUmE3dThiYVc4cEMyNWtzYXZLWlhhaThqR09VU0xVdDExMmw4MWNsZFBJNDM3TnNWM1Bad2RDK0dlRTIrT3RMWE5aV1MydXpkeE1GdHJOaUxhbmNWWm8zYXBYdUJsV3Y5SStlaHNsbXRDNnRaaHJxSlArb3Y3ZlcrVXNKdk5NYVNNallNaTVTTWNnelc3L29ma1JRdEZzYWpxcCtXcDhmSkRncXpWVFVpL3dEYmI3bFpuSVkyYTJQYXZjNExkOGRrSXAzZDViNkoxQ0lyaHVRb1ZGRmJhaDZuYlVyNGxWNmRCWXNqZWhydFdVWE9QZTRxa3NpeFc4VnVsSlVZVy9zOTNMcVJRMUhXaDIxblpVOVRwK05aS3RXK3JnMGVVTmtiazNkcktXN3NiUE5CSXpWWnlQMXAyd0txYURmZW41NldDSVVGdkxUZG1teEVzSjdZWHZjdm5VMmprQ1pwRmFpc2c5ckduU3ZUUnRrNDBNZWpXN1Y2RDF4V1d5aXVyMkxsWk5OSENJSVVLeThYb1JMei9xcW9JRlBYUTIzNmhUczRoOUNGWjQ4UVdGd2tjdmRqTG4zSDlXOWFPeDZLYWlsUFVEV1plODJUT3R4WU51TnBQOGVmZ2FBbHhiTkZNcXVJNUF2Y2lLa2JIMmdFcTM2UzJ4MjIwN2hxQ0ZkMUdyZG4yL0xzRWMzakdtL3QxeGI4a1lRMWFnZGtMRTFNWTVDdXdJcHZxdkhraVV3ck5nZG5XMVpUL0dndkpaTkk4emwwamlVaWtJUDdoQXB5b0tuWUVqcjAwWHZpUEV6ZnQvdWN3dkFSL01icERrUmFvMVZGSGtBMzNwUWEyZUZTS3l6amZlTXM1ZHFHekQvY1R6UHcvd0Fhc0lzTmgxeGRwSXJxbWVrdDNrK3BxNUpDdTRNV3hOS0NwMFU2MXRacWRmQXh2VWxNQVM5OHo4azhqdVJjWjdLWEdRbEFvaHVKQ3lxUGdxL3BINURVM1JMb1BXMGhiQytSWlhFekM0eHQ1TGF6VTRtU0Z5aEkrQm9keHFMVWx5TGE4ZSsrM2xObUZpeUFoeVNVQ0V5cndrcDhPVWZHdnpxRHF0NGt5eXRvSHZEL0FIbndWN2RzbWJSc2Vxbjlrb0RNaTFTZ0xFQUViL0FhcWVKOWk3N3BiWGpQa1hpR1JzM3kxdGxyU2UzdDQybHVTc2lneEQ5YjFRN3FvQjJxTlUycTBWV3ZKek41djVlbjNNOHN1Y2xkTXllS1l5a2RyQWhvN1FCNkNsZjZuL1dmNGF0cy90MTAvY3llTEdydVgwWFVrM0V1QnluMXVGeGVPNzF6UEZGYlkyK2xsV09hSC9wNUdtQXFRR2pXUUFNVHZ4OWE5Y3hLNml6Zm0wYmJWTFRXcThrd1Y1bGlMZnhueU5QRlo0WHZMVzB4ME54YTNNajh1TjlFV2ZseEpWUkg3anpHMjI0MVBEa2VTcnV0TmZ5SVo2cWwxamFsYlorWUV1SW9iL1BtN1c1Z3VyNjd5RXBPTWloRWNJdkhhU05SR0VBaVZDM1BoeU85VkIxWXJOVjZScDE4aWgwcnU2cnIwOHczNGVSaS9IOHJhTElzazF4S3I4NGJwWllTWkM1YUpXNDBERlpHNUs5TjZrRFEzSjlWbC9JMlBiZlRqc3Y0aFdYS1h1Rnh0cExaUThsdG10L3FJUXBrTFJxc3RIYVkrNU8yVFZ2aitBMVRXaXUzUGNLejUzaXJYYjI3ZjFCRU5tTHFHQ2Y2bDN5TUNQTmJ4UkhsRXR1Wk9RcUYzY3NFcityY2ZqcTV0VlVSb0FZNjcvVk1OTDhqR2FlVnJwR1l0S2t4bnVURUt4eWdRb1FwSEZTUnVLOFNLZkxUMXFvancwSVpMT1o4ZFF6SDVnY1Jhb2h1NWJxM2l0bnQ1N0s4VXlRczF4R0NxbU5RdEFhRnVRNk1lbStuMlRwSGNveVdTVXpQeEVpK3ptTmp5TnpKZVE5dTFSWUJCallLUEtxUlJrb3hiaUJUZnJ2dHRveFkyK24xQWxscldaK0VkeHF0QlBQY1J5WE5zOXpkMjlrWkpiWkdLaFdjQnl6Z01wQlZXQ0tPUS9TTlV0S2ZLUWhOeHJxNExmYXdmRVlMRTRXZXNrOWphb3R3OVNTWlg5ejduYzduMTMxem5QdnV6UHdSMzN0R0o0OEtucURiT0ZqZW9JRHdVbW9xZHFWcC9Qcm9CdUViYmEybk1IbGZrcTVmemZLWjIzbDdiL1ZzMWxjUmtvNkxia0pFeXNOd1FGQkd1NjRlSDdlQ3RYNGFuamZ1WEorN3lyWFhaNmZJdnp3RDdqUitYV1BiZDBqOGl0dUl2NEVvcXpSbnJjUnI4RDBjRDlMSDRFYTVqM0hnUEZiZlg5ci9BQ082OW85eXJ5cUtsbi95Vi9OZVA4eTNzZmVMaXNQUGZRZSs4bXFJd2FIZ0dJUlQvSFdmanM2VWxkV0hacWZjeUtyNkl4eVR6QmxTUGVlTGxLYTdLWGpYNWZHVmtPcVhiVzF2QmZxVnJxbDQvajlCRXVJWTd5OXRMV1IxTWQzZHJSSFlHc1VCYVU3SHFEMjFHdExpcll2L0FGWDZsM0xhZEZWLzNXaitMQ05wYXdaR1hKUFBFbHhaM0R6d3ZDNEJSb0lsRnRRZzlRUXIvd0FkRlZsd3ZCVDgyQlhWZHJiWDdyUjhsL1VZdnRSa1piVzZ5WGpPU25hVEpZV3hlVER0SS9ja3U4U3o5dTNrTEVBdExEUVF5LzhBb2IrclVlYmdUcmJPdXJVVy93RGJ4K1ppYjNTTURXbTcwL0R1dmsveUJIM0k4SFcrOFVWNVVIOXg0TmNFN2N1VDBZTDhhMEdzZmpaTGNmSlU2TDdsZVFyNDMwN2ZJNGg4eDhkdTQ3eVcrZGdMYU5BQ09yaWhOZHRlaVlNcWRkRHpIbmNhMUx0OWhVaGlzQzY5MjVkVVA2aXFiaitlalRNREZyZVdkcmRKL2JXZXNKVW1TUnQzYm8zR2xLQTlSNjZTSjFhVE8xZkNQTUkvSlBCYkhPdVQ5Vmk0cGt2bWFoRmJPQnBReEFGQlZBTnZRVXJyejMzZmhiT1JLV2wvMVBTZlpPVjkzREQ2MWEraHp0Z3NETGR6UTNsazltc2wvS3NWb0plNnMwa214YWdBcFNwM2FtdXgzdFJUVnRIRzNwOXpKYTZhaTFuRWxrNXk0aWhOcGlMWmxkTVpGMnBwSXlUSEpjTXhhUmtxQWFWMjBka1d4S25oMStMNi9Ub1F6WFZucDBTZ0krRTMrTXM3NjRueXlvTGNSS291SlA4QTJDN2hlNE90S1ZvVDhOWkhNcTdLdFU0VGV2bnAwTHVLbDZyZDBwWDFYOERPNHNFeFhnR0l3MW1BWTd5OXFBUFZKSm5rcVB4NURXWHlMN3MrdlpIYmV6NG5UaHRyclovcXl4NDR3SkFVRlVqQ0xVK2hBQnAvSFdQWmF0blR0d29JUG5Ya3orTVlWY2xiSjNNbkwvMCtMZ0Iza3VwUndVVUhvdjYveTBzR0I1OHFyOWZnWm5JNU5PTml0ZTJzZHZGOWtWL2liU3k4TXdOeStSazdsM0xidGQ1TzVGSFBlblljVUJQVUFtcCtXdXZhN1Y2STg0cmtiYnlYNjIxWlFYbHZrOG5rMlZudjVEVUhnc1FBL3BVQmFtcFBXbWo4V1BZWXVmSzhscEExdGRza3kzQVZaZURnbUpoVldwOFFQVFZ6S0F6ZFR3WkFOSjIxamNnOFkrT3dQd0IyL0xVYTEyb2MwVFFySENBQWpyU2pjZ0R2NjByNmFrT0tQYVdXNGNHaGpWaVNQUTA2QWZscERCZXdpN2JDNGJaLzZRUFRTSFFRa3VWUmR2MTlGL0g1L25wb0hCMHVMUzY1U3R5WXNSeWtjRDlSNmdVL2xweG9CbDNoMmlSNWxLckdwT3hxRFFldS93QWRJUkdzb2dzZ2xkVHhBMitaUC9ocEREYjQ0a1FtRjFjeEZvMDJpak95bGp2VnZscG1PZzNlWDZWbHZMMzNNU1NDYWtuNUFEYzZpT0l1WHlNdVNuVml2YnQ0dG9FTzVBSkJxVDZucG91dE5wRmtTRzFNcFlzYU4vU1BqcTVWSVdjRTZPell5Q0pVTlQxcjFOZWcxTFJMVWV1cUxQeCtPczhKaGJmdS90M2QwQk1TbzVOeFFsZUcyNHIxMW5XczdNdWdXL0o3dVpyQjUrUEdyaU9QYW9Vbi93QWhxZU9zc2l4TlhKWENVTkZaaDhRSy93QVJxOTBxUkN1UDhzOGpzU0pzZmYzVnFEdFNLWitOUGhTdEthWDJVMFB1SExEK1RlVjV1M0s1ZThOeGJxUXFCNDBYM01mNm5VQTZHdWtub1Nsc3p6dDQ2Mkp0eXdDZTRuNEFzZDZma05SR1k3ZVBmY2Z3K3lzYlcyZUM3c3BJSTBpV1JGNXJSUUttc2I5U2QvMDZUcXl4WDBnYWJMejd4UEtNWTA4bldGVFdxWEVjUWF1NS93RGNRYms2aVB1OEdCZkliakd5WE1GbGR0YVpMSFNwSThqUVJnVHQ2UmU4TVl3U1JRN2JEZW1uSWlyZFduaThVZ1RKNGFMazFQcDdqSHRMREpSMm9vcVR1Mys4ZXZ3MDVGcEdCOGR1WUdZNHpKWHRxbFNGU1YrNkFvTlJVT0NEMDlOS1NhWHhNS2VVV2hKV2Ezdk9SclZ1NUM5Ui93QUxFRC82ZElocVp3NW5PdEdZWk1MTmN0Q0MzY3RVUzQyRksxNGlNa2ZPbWtQTE50dDVsaklXVlppYmFZTUdsUTl5M2ZrRHVEM0ZDL3owaWF5TVkvOEF1T3p5UnRieXp1V2lsaERqdmtvNjhDdEtGMDVEMHAxMUZxZW82eU9aSldJODV2TUZiSlpZQzRoNEZ5ODZodTRHY2V4ZG01R25GUnF1K0t0K29UaDVEcHBYUVA4QWlYM1p1ZkZyMlNTWEhtNWpuVlkyakVuYkViRGZrajhmVTByeTBOeWVIWE1sMmdPNC9PZUdkSlREUGgvM0o4V2pYS0pLaHNyTElYQnlObWtVQkxKTTdNV1Ixb3A0aE9JQkZUN2VsTkNjM2cyeTFydGV0UXoyNzNHdUMxbTE2YmVCaDRoYmVGeVhlYXhqWFBZdHIyWVhOamRTU0FJQkM3ckZIKzRSVDJ2MFBwcXprVXliS3ZxMHRTSEd5NGxlNjZKOUpOSDIrdGIvQUJIM0hlQTVCSjVKYkcveE5sTTdjaEdxeWNnL0FEM0JncTdnOWRYNTMveEptZGpwR1pvMytFWlR5ZnhUTFp6QVhsckU5bmJWaXVMWHVpU0tWbWRrTEVzZWpMdzZiME9oT1ZSWDJYUWR3NzdkOUdUUENidXc4dCt5dmxYaG4wUU4zaWtuT09qY0JFZDUxa1lIOUpvMFUwWjR0NmswcnBaNktuSXBmdXdmRloydzJvOVlLbDh2d2VCZjdhWUx5WERPL3dEY2NabFRqc2lPUU1YQzhoTnpId0ZCdi9tMXAxdmI3cnEra1NqTXRWS2lzdXM2bG8vNlNQTEZ3SG0yVXNMaU9SN1RMV1N0KzBPUVdTMWxEQmlOdGdydldtb2N2S3NWTno2RnZHbzhqZFVkVVh0OWoydnJxSkRKR1pKT0pqbGprUlpGb0dxck1PQjIzcUcxNS95Y1RyZDJvOVA1blM0bTRTOENsY0ZCSGpQSjh6aXZJTHMzbUgvdkU1anRvWitTdmIzVWJzREdBUlFnMUxLS2JqZXAxcFpiUld2ZFFhbUgva3JaMTB2UDRrQytiWUxFL3dCMVpqanBZclc1TXNhR1ZnYVI4NnB5Tkc0dFJnMWVOSzlkRVk4dmgwSjJwYTFFM3JaOVgySW1NeXFZMkhNUEdXT1N0YmEzaFNaVlVHT0pQM0NEVXJ4WFp0cSttM3BxN1pMWGdCUEswbSs2SFY4MWMrU21mSFEyeTJkcmRwQmNSM0JGWkoyTWFxaGIzZjB5UnlMVlFLQmhYcnFqSkZFbWl5bVBlM3VaWFNXRjliNUs0c1JZR3d1WGlrdFRZU0dSK1RRZ21PV0p4VUVzcFpHcHRvaVUxTWtFb2Y0L0k2S21tVHhqRWVMWXFHMkp5WXRHVzFFVElrdktYakh3aGVVY09ZNThnR0ZLTHZxekRWYlZabVBsdHV2WkZOZmQyOHhQM0kreXZsZGhaZlZTWkxFd05jeVFYTVhBd1hkckpGY09DeW5pUXl4dndaUUFlbXhJR3IrS25qeXBUbytoSGxmOG1KdExwSDVINStZN01aYkR5OTdHWGsxcEo4WVhLVkh6QTJQNTYzMmt6bTAvQTc4LzBaUjJmbVBoOTM1TG1LMzNrZU92NUxLUzdsSUxoQ2lTSlJRS0RacWE1M240MjhxcjJnM2VKbGpGL3dDVW5ZR050ekdyRXNXQkpORFFjVjlGRkI2YUk0MkdDbkxhVG1YNzZlT1lPMCs0R1h1OGhhck1tZHdUWGFqaUM2WGxpVmpFcUY2RGtFWGxUMUFPcnNxaG91d2Fwd1ZqNDBJRThtZ1NXeC90NXVZWGl1a2lidkkxR05PSlFWQ24ydDdpZC9XbXFiSk9yREUyckp4QWJ6TU9TLzdxV1V0SXF1ZXhlUzhlTFJHYU5ZKzRXQXB2eFZ2UTcrdXJzY091Z0R5S3RYTmx6bFBxNHMzakx0MEdUc1Q5WWtLMFV5V2FnSGxUcVRSalUvNWhxY0EwaDN4N0U0R1A3VlN6WU9XQ0FYdHhOQmxzY2JqOUdSbVJrVjBVbmtyWFBGWDdmVGtlUzdFZ0Y4YklwaTMxQnMxWVhwRkR4NWJtQ0h0WkFzbDRzMFQ4R1NoU1ZCeGtUZjhBVHlYaXcrZWg4aVNzMFgwbHBFTHlmeWFERTVtYkhacGYyYisza250cFY5eUxKYWtMZVFIYjFnWVNyOHdmanBLc3FVSjJod0xYM1F3cVpyN2U0bnluRjFYSytQUEhDMDZOUjNnNThGWWtiKzA4VCtlbzBlc01sZGFTdW84K0YvY3FUTFlWckhQeEhKWTNJV05IZ0FDelJSdWUxT0F4QUJBSmFxbjhkQXZEdHRLQzFubXNQdUtYMnV4OC9pV0s4bzhkeGt6WGNKdm9NbjQrSm96RGNSWFZxM0lvNDVGUUpJbHFwNWVoMGJsdXJKTUN4VWRXNE9tTFMyVzZzUmRXWU1WeE9uMUhDUW5pQkxRdUtINGJnK211ZnZYV0gxT2h4MjFUSy84QU9jU2xuWVpPYjZZcGNGUmRGQ3BweWRncmswNmdrVjYvUFJISGwxaGxPYnJLT1JmUDhhMWo1QjMwRllja29taklJQzl4cUJodjBwcm9PTmZkV1BBNS9sVTIzbnhLNHljdDVZM2R5c01kWUNRQlJ1NGdJRzVGQ1J1ZEZBWUlhVnBYN2pBY2oxb0tkTklSNGVXMU5JUjdIRzhqZnQrNWwwaERsaWxMQ1BhaE94QTZWcHFuSmFCME5lTWlwd1dnVmtQd3AxNm12ejBHMmFHTk9BWDVKa1dYSVc4Vm94RFdOVElDMnpTeUdyQWtlZ1dpNkt4VTlPdmNHeTIxandMRDhZeWtlUXM0WjRXRWlPbzZIYmJZZy9NZE5DMlVPQWpIYVVOY1BpUGpubVV0dmpzNzNsQkIraXVZbm9WWnR4eVhvYS9wMzFkaGVwVGtXbW9yWVdHVDdNZmMrZnhPN20rcThXemdWck9XV25FdWZhQ2ZRRW1xTitXaU10SDgwVTBjTWFmdXQ0ekxjWG1GdnJkKzVZM01Fa0ZyTzFLc1l6M0ZqSkhVZ0dncjhOQTN0M05majBseEpCKzM5L0xlU3kydDBHWEwyWURXTDBCWmdqVlZxN2RDS0VmaU5BWjZheXVodGNYS3JKMXY4aXo4MWk3ZTVObmtybTRodGJQUEdic3pNU3BESkd4S0FDdlZ1UTRONmdiOWRET3JWZE94Ymh0WDdrUFI5UGlMV004dnluaTJEdkxTMkhLN3RnaVFScEpXUUpJQ0pKRkpHNEI5M0gwMzFWZmoweVdVaGQ4OXExYVM2ZmlTSkFsbjR6ak1aZjRITHZrY2xsTGhibkpZeEhrK21tRVViUElad3JCMGwzQzFQd3FEdm8ybVJ6cW8ybUF1TTIrdlVzM3hmeVR4N09ZWEs1ZjZwZVRJRnlWaFJWNVBSdTZpUUxSbUxKdnpXb2s1SFZ5dlA3dW9QazQ3bzN0NkhxWW1meUR4NmEwdEszR0xnRFFMaXNnaVJ6ZlRjU2UxTDZ0eDZCeFUraHIxRXQ2VEJIV05EakxJaVg3YS9jR1NaVW1qeGdmakxGV3NqV0UxUDBrMHF5RFlmTWEwVi95VmdEZm90Slk5NWdEa2g5Zmo3Nks0anNEYmxMVjVBeVRTM2NabUJXWkdOSzFXaE5RcE5DZXVnYWQwMGJHWE1rcTdkVi9FaWpKRzd2dXpmeHl3WkNhbklTZnVPdHhDQ0dpb2ZhM09vSkxWMkdxWGpkZW5RMGFjaFpJM2RSY3ZzQkNqVHRQd2duU1hoZTJ5TVZBVjYxSTNLN1YxYlc3S2JZazUvTVp2Q0xpT0RGWGR0Y2haSjhYT2crb2N0S0doQkxqMmhpUGNyaGh0MUd4NjZvenIxSjltVHdOSk5QcXYwR0N4d3l3V3pSWEVxUGJ0SFJnRVpRNmtrKzRNZXAyb2E5TmMxZk51Y3JxZW5WNDFhVmhxVS94cVl5NC9IeXFsakE2b2tjaG1na2pOVzVpdkVqY0ExcDYvTFRySlpPV1BmSGpkVWxvMXFpWkxZWEYzWS8yekhUVzBWd2ltYWtuSWlSK0pMQXF1NjlLVkhJL0xUVnZWV20wd0xPNzdHcXdtaXU4L2xMYXd4Y2xuQWdqdkpDWHZwVnIyR1BvVUxJamlvNmh2WDAxdFlNYnZkT2RPeHgvTjVLeDRtb2l6MWZnVS9ESGRaakxCTGVDUzZudUpOb1lGTHlNSzdoUW9KNmZMWFQ2VXJyb2tqemh0NUwrYkw2dGZKM3R2dGd2aWkzOXZaZzIwa2wwalZFVWl6MzhZQ2pseG84Q0dTb1plbFI3dWk4NWJCdTVYM0liaDZmVCtKMEt5S3ZHVkcxMC9qL0FTZkpuOEJrT1IvczdPK1NqdklrdDF0WTZRRzFpWGhMSzBvYmgrNDN1U2taK1o5TmJHRlp0TjNTREl6UERydDhRU3NjWkNpMElkbkJhT01PanljUjhlUC9nTkZQUW9Ua2xXMTVjaEdFTVh0VVVkZ3BKRzNxZlRwcHBKaERHMm1ZeWZOckMybG1XSkdtbGRSN1ZqVDlURW1nb05OYkpXdlZsbE1kNy9BTFZJNTIvMjJ1Umo3SEszMmN0SWJmSXViZDQ0V1pwSUpIaGttVkppNFJRV1ZEc3BiUVZ1YXR6cWsyMStOQXV2Q3MwbTJrckJiSFdscGk3ZUxFRUM2eEw1RzJ0Ym0xZVhhWnB5RVpta1ZSdFFuaFFjaHZvUytSM2M5NEQ4ZU5VcnQ2cVViNXBjQlo1Nkt6c3JkeUN3V0paRmJ0bUdORW1TNllsQ2FVWVZBOU5tMVZYZnNsdjhlQVJhdVA3cXFsNWVYeEFVOTRmSmZKYnBHbWx6T1Z2cFpZcmFlVXd4eEd0dng0cy90NGxXVU02N0xzS2ZPeXRYVEgwMnIrcFRlOWI1WEwzUHAyanAwQlVtTmE0dmx5SWFPRzh1VWU1anNHNENON2wza0xLeEI0QVNvZVhJQUQ5SUhTdXIxZlNBUzJOelB6anovcUhQRThlOXhnTHd6SjNMU2FZR0tFbnRwR0MvY2tZQW96VklqSlB0clQxMEp5SDYxQnVjS24vQTVYWDhlQWV6a1M0ekJXOXBhTzBUVHQ5VmUrMnJ4bWR6R3FyU2xWQU5EdFQxcDAxVmpidGNzNUcybU5lZW9TdTRiREZZSEg1SEZYRWE1U1dSSUp5a1pvemR3Y1FTb1pWb1N2QUFmejMxVTV0ZHA5QzMwVXhLeWZxRlo3bG5SYmk2Q2YzSzRtRnZiWEM4M1Z5NS9jTzRxZUNnQUJUMTBTcWRsMEFNbVR1K3I3aS9iM1NaKzh5Q3d4aGJPS09kd1pUeFl4aEFJeXpDcFlnamI1NkxkZGlYaVo5Y24zYlBUVFVuSVhoc3pjNHUyK2tGaVVzTDJTNGdGeks4VEdxeUtHQTVNQ1FvVURZZW0ybXJxNGI2Ni9NamVGWDBxSTBmZjVsaGVPcEw1TGw4UEJaVHpXZVdqZnVaQzZrQWtNbG5icnlaWGo1SitwbklKS25pL3dBcWFxL2E3TjYxQzhXTjVMMVZkTFQxK0JZVjlrUHJKN21jVTNrUEhmZmlOZ05jcmUyOXQrWjZUanhiS3BDNTV0Zmp4bndieUR5TkNGZTJ0NUk3YXY4QTkvbkhhaHA2L3JkVHE3aTR2dVphMThYK21wbmU2Y3Y3UEh1KzZyK1p5RFpXTTNialFra2dBRmo2blhkMmFQSXNlTzFpeS90aDQ5ZTNYbE9QdkZ2WkxGTGFWWE54R0tsZ1AxSnVEczYxVnZTbWdlVmxxc2JYV1RvL2ErQmt0bVRxMm83bzZvUm9wTTFiWTlHSFlXZTF0VEVoQkZVVXpTZktnSnBya3E0NXRIYVR2N05yRzd4cnEvNEU3UENhMFhKWE1CSmtoWklVTGRlNU5XYzFwOHpDTlZYd3RVVlgvZGI4a1plUEluYWY5dFN2SW1hRy9ta1V4M09Ud0dOZVl6U0RoYmg1RDZLS25rUkQvT3V3b05hTllkSldsYjJnamt1NjVFck5PMk9yZmttTU9JamUwdFdzcENEUEhhcWtoTzFaU3RTZnprNWFuZ1c1M2ZpNFh5SytYWjByaVhndHorWjdJbDFDTGZMWUlvL2xPRmxhZXdpTGdKSVlsN1Z4YVNrSFpKazVJZmczRnVvMW80MGwrN3BaYS9EK2hrOHhmZHI2WCsxOWZQOEFyMFpaQzVIRGVZZU0ydWF4am1XeXlNWGRqNWlrcU1LckpISXY5THh1Q2pqMEkxZzh6ai9iZTE2dGQvSUo0SEpkb3N2bjVISjMzbzhMU0czbHVMVVZodmVhRXhVWUxMR2FNRDhDQ054clY5cnoyMFZoZTljZXVTcnZUNW5NTi9hSllYa3RxemQwUjBISWUzcUFkZFhWenFlZDJyRGdrMjE1YlJnTEJhRHZ0c0pTeFlnYmZwL0VWQnJxWTA2RnZmYVB5Nit4VXVSd2tibU9QTTJjbHRFWEZRalNiQThhRW1vTEtGRktraXVzN244ZFpjZXZaejlEWTlxNXI0K1ZQeCtubFB3Wlo4VC9BRVZ2OWRKYmZUNUZvemI0cTBDSUJGRHVwbUpqQUZXcjdUVTEzcnFyZ0xZM2VaZmI0LzA3R256c2lWRldJZjhBRHgrWUdGcExYM0ExUFVuNDZMa3hZQ0dNeDVtdTB0dUlkWmc4Y2tiR2drUXFlU0UrbFFLYUY1TmtzVm0rd1Z4RS92VlM3dUJvdkxaVGQrSFlvSVZXR0R1dkVlcTlwRkh1L0RqckF5dWIzWjZQeEtxbUxIWHByMEhteFFOSHhiWXZKVW4vQUhSckxjbXJrZW9nZmNITVg1djRiSzNlQ1c5c1lybVcwaFZHQ3BNeUJPNC9jZHFtSUgwMnFkYi9BTFpqckR2QndQdm1TNnNxTjZkUkE4bDhWOG04ajhJdE12RmUyMXBqNWYyclMxbC8vQzd1T01nRzRWUTFSRzdnOFMzNmdQZ2RhbjM2MXk3WWwvcDhUbTdZcjN3N3BoZnFVOUg0Ym1JN3hFbFV6UmttaGlVbW9GSzc5S2ZoclFXWk16SGlzZ3JjWWw4YmV5NDhjVmtqOVFWYW5RMEpHMVFOSlhUVWpPclRoa3UzeGQ5Y1dNOXhGQjlSYjI3ZStaS2t4RUd0R0hVVkhycHJYU2FYaVRyUnRTaVBmMnBXRmxDaFVhRTE5dFNkcTFQclVhVmJTMlJnUysycHVHSnFvaVVLVDBKWWRUcXdpRVlDOHJld0hpUDFVK0IwaEV0TGVRQU5KVjQwMzdiamFuK09rU0M5dFkzTTl2Sk5ad1JyQnNyVnFTV3BVYmFZVUN6bUl5dHdJYnRoR29xV2pIdTVPQUtVL0hUak1pMnR0OVFlY3ZzUmV0QVJUMUdrTU1FRlFCSEFPU3JUa1QwSDRuVE1sQnRlMU1oSmtSWmR4d1Z4c0I2OUR0WFRTS0FIa29JVWtTb1BJNzBYb0tVMkg0YTBNUzlKRTBSMnpTaG5GS0NwRzI5QjBvTlhrYlBhTUdEaCtra1M2dUY1RUQyOGhVY3ZuWDRhRXo1RTFDTEVnNWVaSU9UUGNNMHM3YkJGSHA2QWZBRFF0S096aER0d0ptVXZMbklUSHVzR1JEV09KSzhWSCswNlB4NGxVaE1nK1MyVndPQ1VhbFNRT3Y0YXNkU0MwNmtpQlZMcWdVR3Z0QUlJRmZqUWFlMEpNc2FIM0h3d1d0aEFxb1huTUZKVmJZcktIWWhsWUU5UlFFRWZIV1MzTEpvQmVYWEtwWm1CNVYrc2xwV0lmcTRIcVRUb05xYjZ1eFZuVWhZUmtrbVRaSEtVOWFrVTBWQkVtd0xMTVRSdTRHTkMxTjY2aGRLSUVpenZHY09iS3pRVGZ0ZTd1TXlnMVpxRFkwMjJIUWFDYkxFUXZMZklHeDF4YlhrS2hwSXBWYU9OOTBJakcxUUNOU3JWMll6WjVaZmRZdkpXK3NGa3FhVmljcTNUY2dNRC9qcVR4TWtzbllZckx6ekE1YVNPMXRMU1ZiMlpnaUpMR0dUZjFMSTJxM1dCYmt3amNTQ0dLZStlVlVkRnBZcEdTRlFzd1Vzb0JvS2dHcDlkUkVhYkMrbXo4SXViMVk1eUhhS0txam53WGFySGNtcHIxMDRqQys4UXhkMnBhSzBFZHdhMEVSNE5UNWtVT25rZDFVU0RycnhyNk5sTFpDYUNiang0eXFMdG1YcUFGS3QwK2ROS1JtanhzSm5JVUVtTHlkdGRvdjhBN1o3dG5jRDVGR3FwSTlhRFNrU2xkRFZKZCtUV1h1dXJGcFc2OGxDT1BoMVRnZjVhUkxmWWd5ZVNxaFVYTWZaTmFzQnlqM0h4N2lxUDRIVGpPOGt5THkrUlNKTFMrbGlaUDBGZVFPL29HVWtVL1BUTkprM2srb1h4dm11VmduNzhWM0RjUE5HWVpoSVNRVkxLMVRRaXBxaTdrVjIxWGJHbW9aS3VacHlNUGozM0RuOFd5Y3Q1QmJMSmJYWVkzRnBBd01mN3I4MzlRMUNTMjFmWFVMNFZaSmVCYmk1RzF0dnVRRThseEYxNE41UjRwZFNmVHo1SHRaREdSQldDTmZXOXlIQWVnb1AyaVVETWFlbW50Ujc2Mlh3RnZUeHRmTkU3N01abC9IZnVENDFmM0RjTE9XVjdTN0trRmVGekcwVlRRbW03QTZHOXh4ZmM0OWtMZzIyNVVkeHBrMGtzN1hKMnR4OVN5c2JXZVdBQ1FqdEVoR0FQeTZhNGZJbFhiZldUcXEwbHVyanhLaHpua3EySGtXU3VjajlMZGY4QWJvRThUU012SjVUSnpXT2NEMmdjRFVsVDFZRFdzNmI2MVVkUjhiZEZaenAwK29KODB5TWx4aVpyeExTNG1zN3lPQ2VCVHhwQkVRb1ptN2RTSTI5d0JZZmp0dnA4R09xZlZTRVp1UlpVMnc0OFJYczRNYm5GK2x0Mmpta3VvWXJlUkx3aVJtNUtaSUVrUE5BU2hqMzM2RUhSY1dyMUJjbDZYVUx3Ry9KNUtQd21HTEwyTWNGOWtZVnRwTTlhSnlBbnQ0MlVmOVBFMndjS0dBNHQ4TnREMXhmZVRUNmR2Nmx0OHYycGE3clgrZ1lTRHlEeXZPdzRqRFIybmlsdmtMQmN2aUxxRXBsc2c4Y3M0UXF4SkVFREtlTE1PTXY2dXVyNjRxVXFuKzZYSGdsL0V6M3ljdVJ0VHRoVDVzQ2VXZUtlSDV1Ynd2TFpOSnIzSlR0YlIrUTVPOXZKNUwxYnE3aWxnWGpNSDVRaUs1aEFDeEtxcjZEUnYzYjEzVlhib1p0TVZiSk5pMzR2YVptRzhiRjJua1Y1WldYa2R4ZTR6TFJYeXg1V0I3dU5wV3RDeG5BbDdib3FCbkVnNi94bTdWVDNRdElKS2xta2svRmFsSStjZmEyL3R2SDJuZXhzNUx6czNrcVRXenRCSkdjVzRXNGplS1ZXNU1CeUlwSjBCMXExdEpqM3BHaFlIK2g3N2k0SHduSWVYWUR5dklManNiZEpiWHNGek1raHQwbHQyYUtYdU9pc3NZNHlKN25vdTNYUXZKeE96cTBYWU1pcW1tZm9WNC9tc0RucmI2cng3SjJtVnRqdVpyR2VLNVQrTVROVFVxVmduWnlWdjk4dkhiak00cUs0c3BVaXVZMG1DbDRSTFVvdGZZNVpTajBMS0RXaHFRZENjdDdhejVtbndWdXR0T1o4TkJjbTBrbmlnanVaYkNjdzNWNENJSkdNWEVSeGhXS2tFeG83YlYzMk5TSzZIcGRCdDZOMThJSEh5YVNkcEI1Q1pJbCtzaUtSU09DWFJ3Z2RDN2JncWFFa0RWbUo5Z2ZrcFFtRDdlQ09mTFdlWmFpUlpPeitubGFuNnQyREszcjFKMzZqUkVtYTZsRGVmaTV4Rnk4VnBkUERienREYlgxc0NBczBWbk4zUGJUOU1zZE9jYmpkZDZkZEZZMXBBRGJSNkY0ZVlYTnZhK1h6aEhEL0FGTnBhenpzZ1pWa0x4aWpDdGFtZ1E4dm5xaStOMVNiN2hkTEswaWw1WkhHNjQzS2tSM0VjTWl1NWJlcGZsRE1wcUtVZEdGYWpmVThLbTBFY3VpbndKRmhMaVVqei9oTjQ1aWdtdDBkSWlOdXhkUnFFZFNDZGxZYi9ocWpKVjExTDhkcTJVTXJ2d2ZMeTJsN2tNVVFYT01mdlMyOURWb1hZSk9BdnI3MTVkZWhKMUt5MFRLNnVMUVd6ajN0c25rWGp4NnlES1JvVEM2MVF2YnNGZUlsdXV4cUsrbFNEc2REUzExTGtsMVhVYmNQNW5mWXFPMVV6aTR1N3FSNFk4ZmRIMkNhbnVqNUJTVi9UVUg1K3VoOG1MY3dtdVhicjFCK2M4N3hHWGx4TTBvdUxGTG1Wc1JtYktlakt2MVNudGxKVU82eHV2VHJSdW1sVEM2Tms3NWxkTFFwcjdtK0xPY0JONjNtQ2xacFcvVVJHcmNTUjFKVXFRMjJpK1BmYmtqc3dUazAzWTU4RG1lUmJ1MWFVMjdpU0tWaVNWRlJTdlVWMXJtTVFESTdPZTVzVDEycFRTRWVrZkUvN2RJUVF4bHU3U0xPdE8wS2hoNmthUWh2eGNUcWdsVmYydVE1UDhLanBvVzcxY2x0VjNIRmJDK2prZ2dzWTFreU05WTRJZ3lwVitxaXJrRDU3NkhVTjZoVjI2MVVkV0pmbDJNelBqMXFXek5wSkJjWEROR2pPVllGeHUyNmx0eDZqUjliVmVpQTdLeTFaTCsxbVVraG11TVpNM3RjZlV4K3BYb0dvUG4rclZPZXVrazhUMTFMdGd5RTFuMlpZOTFjY2wycDI1UnZVVTlDTnhvVk1MMGdZL3VqNHhhL2N6N2J0NURZUlNmM3ZFeHkzRnVJcWR4WjRGRFN4a2RhT2lsbHAvVUJyWW9ua3g3bDJNKzBLMEN6NEo1YS9tWGdGeERNZ3VjeFlkdHhHZjFDNWcvclVBOUpJeVcyOVFkWmVhbXBvOFRMdHNtUk1wQkZoc3JhZVE0NWhMYXpzRFdOeDdRS0dTTGZhb05UK0dnYXZjblY2Ry9hcXExZW84WW42WEszVmxESzZTNC9NbDRZcmFTNEVDeDNCak1pdUhsMjVCMERyUWprVFExMUhINE1yNURhU3N1blloWlBEQzh0Y2haWkMxYUR5R01ORThRWUtrZTFRd0JveEV0ZTRLYmROUWRYUjlkQy9GZjd0WENFYkc0MzZuRjJtVnN5d3ZMWUpCTEZFeFJxZzBxZDloc1IwcDhkV08zcWg5QnFWbW01ZFViTE82dUJjUGs4UEdJY3JiMWtsaERGV0pQUThSVnZZMjZrZitXb0pxdlhvU2ZyV2kxTHQ4UThxc3ZMRmE1dGJ4aDVYWldjYlpheGtWaEpjeXFLR1JPSkZXVUUvSS9pZFJkbXUzd016SmdkWmpYOVJkKzgzMjJzZkwvRTB5Tm5CMjh4OU1aTVpMS2VNa2x6SEp4bGliMFBLaCtBcVFkR1liT3NQc3pPeVVsUVU5OW1mSW9NaGlidndTK2RyUEtZOFNYVnJkeHF6M0UyUGpKZTRnTUo5cnkyN0R1SVAxY09ZQjlxalJHZFE5eFhpc29kR2FmUHJ4TG5FTGs3U1NXNXU0TGhJSkhpdDFqNEx4UGFabm9SeXFEV3ExNmcrbWxSYXd5NTVIVk9CUkdZOG44enZJYkNaZTFoNGxVNUZvS0ZYWUFjeUhaVW9TT2tkYWFmN1ZhSnZ1UmZKdmZUdDNEK1Z6bU44Zmp0UEN2RjcrTzhqdjVrRi9sa2s3UUlQRUNJcXlFK3orbG0yRzUrZXFxWTNaNzdMb0U1K1JXaTJVY3ozL2dXSGdybVdlMDdCY1NpaGRYZmdXQ2c3QWNqVVUySVB6MXhPZXNPVDJyQTVycjA3RXhMYVp1NHRza2JYU2hxUnBVVkM4cVY5UDhBWnF0V1duZ1BiUmZvQVZFNHVtaXZIN2Q0ekVRT0NrY0o2ZjhBTWVSVHhCWUhSOVV1M1F4ODJXNlVmM2R2NnQrWlQvM09udnNmbnJqQ3ozOXZlOW84cEpyT1R2UkZtRlQ3eXFWTmY5MGE2bjIrbEhUY2sxOGREekgzbmtaYlpYVzcrU05YMnd3M2xXU3lsNWt2RHJnMk43aUlSUGNaVVU3bHRFN2NlY1lvVHpyMEtrRWFJNXViRlNrWk5WYlNQRXorRnhzdWF6KzMxcXBIWHhiN1p4K1UrUTRyL3VDN3U3Nnh5bVJTMWE4WXFMaDBpTmJ3T2drWmcwSTRobUxGUVdvQ2RCWk9iOXVyMnBLRlA4dnFIWStDc210bTI1LzFPeFAvQU1XWGkwbUlpOFN3K1B4bU93NEtTejIxdkVqU3Rid0hsRTBqRnF5TXpxcGFScTlEdFUxMXdOUGM4MXNyeVdiY2ZSUCtSdnZqWXEwMkt1bndPU2Z1UDRyNDlaK1RaQk1GWklMREgzSXVMeTR0Mm1hTzVZeWhiamcwak0zRU13VWJnZW8yMTMzRTVON1VUdjNXaThQQXdNL0ZwL1l1blUyV3VDeE5oRjlGWTNVOXhlWHp2SzFzN1F4UWRqdG1XSXBOeU81S2xXcXUzU20rbSs5YStyVUpGNzRxeHFLdVcvcEFXbXlzdHpqWU9jdmVaZ3R2ZHh5eUNLV09hTlkwanBTbnNvOUZKMkZEcWpiRm1HNzVvbDhuMkNIa1hpdDM0ajQvaTd2SVBiWE9ZdkhlL1dGcG5tV09LQlNGM2lKajlUeFlkVHRVaW1xOFBKKzdrdFZUQzBJWmNIMnNhcy8zZFNINDI4V1h3Y0dleWVPdUxxd3d1UkYxbTFzYW8wc01TRXhNV1VOU2pCdWJFZnBQWFYyWmJMN1UwdHloU1U0N2I2YjJwMnVXYUpCakliUEozbHZKY1M1T09OSk1hSUdDUW1VeHlFcnpiOXdLQU9iSG9kdlU2UzNOcGR1NVpaMVc2eTZ4cDhTQUxhOXhzQS90MTlKQlpaR1NMTEtsbkQrL3ltVmtrbGpka05CR3dNYjhDYUQzRWJhdWxQcXVtaFJ0dFhvLzNhaEh4OWJleXNZaUZ0TEhFeUdXMW10c2t2QmJtWkpPTVU5dE02dnpsUVNJM0ZLVW9SVGZWR1J0dDlaanQyOG12QXV4eFZKYUpUMy9BRm54R2l5eE11SThWaG1tVloxeVBac1loempIYVlpUnJqdUQra3NpSGNFa0d1aEhaWHY4RGFkSFRFdlBUK1lDaXVMV2E3a0Z4SDlPMWpjODVZcXlGSkdpWUJVRGprT1B0QlUwMkdpTlVrK3NvQ1ZxMnREMGhncTh1anp1SjhWUEkzT1ZEY1F3aFMzRkhFaGpGU2R1RkNlUDZhZW0rcktyUkt4RExicmFqK1g4RE81eVl2TFcvdjRaVERlMml4UzI5a29wR2tiQTFwWCtyYzFVQ3Z6MkdtVlloUHYzSU8rNnRyTFJyb2dmYUppYlhGeHBJaU5meXM2M3RzenVnVmk0S1UvM1ZvQWFzT3VycmJuYlRvQzErMnFhOVgxR1MxdTRSZnZtTGwzV3drWkd0a2hRUEh5WXFqRTdBRktyMGY0Yi9PbGROcTZsOW5OdDcvYVBuaVBaYUJzNWowU0xIMjFpbUt0V1FpVHV2M2U5SXdZZWdDcUQ4em9UazNkYVErclowSHMrQlh5cTZXbFZBeTRzUVhWbzBnWmEwTE9BVDdUMDZmUFdMZWlYVTZ6SzNXeFdQK29XL2VEeHZ4L3hlTi9mbExzM2x5UGpiMkNWcWZrWGtTbjRhMS9hY2M1TFhmOEFhdnpaeFA4QTJUTk5LNDEvZGFma2lvOEZoSnNoUEZFb0FTUmdHSjlCV2xmeDF1NWN1MHcrSnhsWnBIU1Bnbmk4V0RnaVNUaWhvN25rUXpzN2hZNHhVZkU4OXRjMXlNcnZKM25IeExGVGJVbTRlNHViWE5OUFBLcGt0M2FZa2xWLzVwNGduNTBBR2hzYTZOR3B5TFkzWFk5TkJobHljZVd4Rm5jS3haOGpjelhqTTJ5OXRTWFNwK1N4UWcvam96a1ZoK2RhL216bThOVjE3V3QrU0JNUGF2c1pLRmNTTG1zb0xaSFFocTI5bXdqWVZIcHd0NVQvQU9yVlZVNmJVLzdhdTN6Wkc5bGZkWlA5OWxVMVQzblp2cFoxSmtReWdOeDl4UGIvQUZLS2RhT3BHaU9OUjF4cWVyMUJlZGtWOGpqb3RQb1JzQmVUNGZ4R1R5RE5TdExlUlF6enZNcWxuS1N5VWpMcWFWWWN4eStXM3ByVXlWVzVLdmVFWVdMSmF0SHU2UzJNSGplWVh4Yk5wRmV2R1BIUExuUmhLQ1JEYVp4bzltV3Y2WXJ0RTRua2YrYUYvd0E1MEh6TWYzS1dxbDY2VHQrSGRmeUxNRnRsMWsvdHRFL0hzLzVsRytNK1RKNU5sODk0MWxuL0FPbnpWNWMzZUxhU25HSzZkeXhWYWY4QTM1VkNqL2UvSFYxc0RXQ3JyKzZxWDlRdXZJcXVWZWw5YVdjZlRSTXBMN2hlUERGWGNzb2dLVDl3SzRvZXZUY2Zsclc0bWJmVmFuT2U1OFQ3T1JpaGFYTjlBdytuUVZPMWVBcnZ0MXB0bzR4MHhoeGsxL2EzY1Z6Y3NCT1hNbjZxc1QxTmFmR3VtWTBuU2VIdXJiS1l1enZiZmlZMmpVY0ZwN1NteEZCMEZkTGxZUHRXVWZ0c3BYOHZpalF4NUhkYTlVRlRhMnNpMXB4YlFaYVRjUFoyalg4U3VDUVE5S2VqY0RRL3gwRnpHMWljZVg2aDNCcTNucWw0ayt6UTN2bHQxYzBwRFlXU1FyMUhHUzRQY0lINWE1K3ppcmZpejBqSE8rcS8yMVgxWXkzZDFIaHNQYzVhUUJoYVJ0SXFNUXZjazM0TFU5T1RjVi9QUTd4dXpWVjNMTStWVlRiNkpDVllmYnkrOGwrNUhqM2lWMEM4Y0ZwSG1mTlpXb3RZNVpHbWExREFWSWtZOXI4T1d1anc1YVljZDdkcWFMNG84NDVydHlNbFc5SGJWLzhBcVB2bXZpL2orWnRiN0pYc0VFTWRtSUxQRlcxdVIyd0k2aDBSSXhVUnF2Rkk5enVLZE5aSEh6V3E5eWN1NzFEYytKV3FxV1dsVm9VcmMrTzR1MXZZSVZUdHh6TmRneUk2RGhCQkZ6NUtXSFd1eFkvbHJicmxkMW9ZbDhLcDFCRTMyd1c3eGk1YTB2VlNzUGZtaGRnL0RtZlp5WWJsajhhVUdyTFo5dG9ncVdDdGxNNml6TGhickRLOXN6OEZ5WU1NaGlQTXVVUFQ1ZmpxeFpGYjVGZjI0K1pNZzhldkx0SkdpeDhza2FEaTh0UGFVSXBUMDYxMm9kUXRtcW4xTEs0TFc2TG9LdHg0bGoyZWNQRTl2S3RlWWRtallIcFRpMWE2SVdWd0N2REROOWo0M2IyaWd5eFNyRVBlOHdGZll2WDRibjQ2ZDVtUldGaFMzeG1KTm5jWEtwZHgzQVZoYkNTTXRISlVFRUlVVmlTQWFrR20yb3ZOYWV4YjlsYloxTnVIaHhjOXBIYjNWNExDWkJXUXlsRVdnb0tnN2trK29OTlR0bGZaU1UxcExoNkZmK1VZOVRtSGV3U1c0dFVMQlg0c2ExSXJVVTlldWlhdHRhbFZscWFMQzF1YnlVd0pFWWhHQnlaZ1JTdlRZajExSVliTGZIL1R4L1RpRlRLcDNJWWtjZ090RHFKSkc4V1RDTitKS0ExTEZoVU1mblhZNzZRNG41K0NXSzlnV2xLcXhVcUtjZ2FiL0xSZUMwSmtHakd5c2d0SGtjVU5DRjNCSUc5RHFXWExwQzZqUU1sbmoyblVGajJZeHVwSU5DUGxvSW1TSk1Zem1SbHE3S0tnb3BDQ240N2FtcnRkQm5VUzd1TjBtbFVLQWpTSGZvMURRNjFVcEtuV1hxYTJqYVVLRkZaQ1RRYjEvSFNlaUhTaGhuRlkxWXFTU0V0T1FLb3ZvYTEzL3dETFdkbXk3dEYwTENYbE1oZVdsb3pXL3dDMEYvcVlWb04rbE5MRmpyWjZzVWlYY0UzRXZONHkwamU2V1JxaXZYYzduUisxZEVRazhTRHVCQ0ZveFA2ZXFrZkE3YmFmUmFzY1pQSDhTanNyeUxWQXcyT3c1ZFQ2YXpzdVRjU1NIUEtaZUtDR1NlNm5GdkZJcTl4VW9vZmlOcUtQV285QnZxbEtlaEpzckRQNVNMS1BIRmJ4TWtNSElxN21ydHlwMUEyR2pjZEhYcVZOeVFMU0ZuWWl2Q2xLMTlmdzFMSTJxOUJJZS9FY1RDTFo3eWRnd1Z4R3hIL3Rxd0o3aEZSVVYyMjBEWnl5YVFYek43MjdSNHcvY0Z1aHF5bXFCUlUrM1lFalRJZHNyQ0sreVRTaWFCMlJpNUs4U1VGZmhVRWFJZU5iZEN1US9qL0kvS3d5ckJsSmp5OW83amR6K1REZlZMUzdFa3l5N1NkN2lDSXUzSHN4MWtkMUN1empkanhGUUtuVVNZdVhYbVdPeG5rRFNYMEJuWll1Q2NDb28waHF6RUhZbjAwOENtR0dyZjdpZUhYakxGUEpMYmdFSDNJVDBGZXExMDBEYnBKelNXV1VuSDlzYU5iVnVCRjFLT2JNRDhPUU5OdjkzVERndzJHUHlsMVBhSEdXcDdBN2ozS1JyRE43bUlYM0pTdFFLblRpVWR6Nlh3VEhUeHFZWjU0cEsrd1Y3aVZIL0ZXbW5rVUlGWDNpMld4cG9tV2lqV3RCM0MwWjMrSUJZZjhBMmRLU01FVzV4SGwxcW9uYTBXOGhYZnYyekpOVUgxSEhpZlg0YWNiVWhKblpjYWdqeVZwY3hLRzJLZXdxYWlyVWtTbjg5S0pIM3dkYzNQazl4ay90bGhzMWFaaVRIV0dTdXJhemt0RmxZcTF5Nmw1SGFvTFFvQ0txRCtvTjdkdGN0bDQ4V3RvZGx4ZVJXeXJQWHhORFhQMTE5YlJISHhTdzVCcGFTTEd6Qm5pTHh5bTVBTy9GWFdRS1ZyWHBYVldLc0tlNi9HZ1huczdYaGREQnZJTEMwOGR1TWRrcFdOMUJhckJaWFFpN01jb1ZsS3BFRTNCTVlZaFIxK1dyRmhidk5SdnYxV1BiZnQrYUV2RTViR2pPMldGeUZnajQyRjFhOGx0OW5FaWhpWTA1YkhnVzNaeHlvS1YwYmVyMnQ5ekp4Mlc1THNYQy9nZDRHc1pidVdLYXhhU1NTV1Jsak1qSTRDQmhMdlJKRUJWMHAxRlR2UTZCVnpTMkp2ckpKeDloZStLZmRUdys1RngvOXdMMUpiZTBxb3AyTHEzRHFHS0VBY1hoalduNEhSVnF6amYxK2hsWGNXL0lYOHhKZHZCNWZjd1JFZjIzTHkzRUNxd05POEJrYmNoZ042VEdxL0luVitqc3ZOQTlXMVJyd1o1TGo1THRNbDVOaVdRbVBIV1hsRnJJN2NKQzF1M2JtVlNDUVF5UlJxVjYrNGFldGVuelExcjZ2NU5BM3ltK0UrWWx3ZHg5T21Fa3lIOXdpYVFjNW5oemNYMDF3c2JyVWNSM1puYW8vcCtPdFBqYTQ1N2dYSXJGbXloZjlQdDkvd0J2L2VxMndHUmZzMlhrY1YxNDNraDZVdlVleU5mbUpnamZscWVWYWZBRXgvdU8xYjN4bngvT1l0dkpMdkRRSjVMY1lLREtOZVdvYXp2ZjdsNHhjOW5KUXJjV3hqbEhkVDJzQTJvSXRoRzd6dkU1M0g0eklRWVR6TElTWWRiNndLMm1aV0xOMnk0bkt4S3NNcXRNRXVmYk9lQlAxQjl1cXMxVmFyVFVoSEhkbGRRNEtOWHlYeXJ4MnhsbXlHSHRzcGFSdzNzanZZVHNoUTJzdkNkMmd1YVZrSWRXb2s1OXZwck9wU2xucEsrSnIyeTVxTDFKUDRlUnRuODc4V3ZjSGRZSzl2Ym5GM2pkcmhKbGJkclNONWVDc3lDUWd4Y3FOeXFHb1I4anF4WWJLMDlWNUZkK1RpdFRicW41a1dDNmpFY2s3WHlDRzlFY3RneXlySkMxNGdDeXFDUGFzajhlYVVJRGRPdXJySUJySFppbjkxZkhyak9ZaUtTeEErcm1sUzR0QS9HTmhNNTRNalY5ZVkvVWR0OVg0YkFlYXVvZnhPV3lPYysyL2pYa0dUVXhaanh5YVR4dk5xNHBLdjByVmo3cWtWQkNjUlQ1YXZ5Sk9rZURJWXJOVzhpZjlQSmY0SEkycWxERXFTTktLKzhvMVVMQ214NG5pZEIwdEZrd3k2bXJRbVgwR1d5V1k4WHp1S1lSeTNWcmM0ck1PYWNRTGRlNXlvU0tsV0QwR3JieFp0UDRsRlcxREVuT1g5M1llV3JtRVdJeFh3ZXJLQ0kzRWhDU0t4SkZDc2kvSDU2cnFwVUU3NldrZC9HL0toRTl1c2NRTWtVaHQ3b1NQU1VSeTdCeVFhTVU1QUVENGFvdlNkQ3ltU1MxUDdhZnBManlTMW1VNGd6S3QyVmNpYUs0VlJSaUtFY1R0djhBK09oMDlIVnJVS2hmdTdDYmVXR095VjlmWWRMeVdPMHZCRGxMVzRWMWRZbmxrQmtDTDBOR0ZTSy9IcFhWam10WktkTjBFejd4WS9KK09lTlhFRnBkUnpsN2R1WEtOcVNqaUtyVUdvSld1NXFOVjRJZDFJVHlOTWJnNC9ieHp5Q1N6VEkydGpkUFlYRFVna2pqZDQzWnVRb3BVR3Y2Vy9ocmVaejhNOHRQRC9JcnJ2bGJGNC9wbVZaKzhSR1VMZEFWYWg5UGhwcEhoa20yOFN1SllqTEpjSXBHNWpVRm1vT3BxYURTa1VHNnlzUlpNQUhxajFxalU1aW55R28yWWhodDFNVU1NYU1VRXNnTk9teWpjZXZ4ME5iVmhHSjloeWpzRGV5MnFRS2tjaktKWUxrODZzd0E0azlhTUtVMkdoNWdNdFNlblVzenpQeG14KzRQMmJrdjBNYTUzQ0I3bWFUaXRUZFcxUk9HS2ordEtzZnkxUEZmYmI0bFZxcTFXdTZPZk1kaERZK01XL2wrTWJsZll1NktaRlVhcE1ibmp2NlVwdG81dlhhd0pkSkx0d1V0cGxzZGJTd3kvdHpSaVdFMUFKMnFwUFNsRHRyTzZPQXF0cXVCMysyL2wrSDhmeTh1TzhqeUZuWjRmS29ZcnI2cWVKRWh1SXhWV05XRkExQ3AvTFIzSHU2UFdTbTlVeWhzbmY4QWovMjgrNmVYYnhuTHdaRHcyN1l6eDNlTGY2aUtKV3E2S09QckU1NEgvZE9wNUtxeWhFVmJhNVEzK08rUVlYekcxeXd3b2FES1dNWmxrc25pNExMYmh1UnB5Mk1zZFN5a2U0cnNkWnVYQzExTmJqY3JzQ2JYeUMyaWpmRVpHWXRZenlLN282dWV5WWpXTmtIb1ZKOUR2cXQ0M01ycWFDelYvYmJvK3hZUGwva1E4cHNjSG04WmR0QjVmTEFscG1BMGl5SkxCRUFJM1lVV2ltbFZhbzlwT21jUkRLOE5MVnM5ckFHR3Q1V2U4ckE5dmU0MmFWTCt3VnE5cHBHSlpnU2ZkSHYrcjRFYUh5UHQyOFRSd1ZsdnMxMVJxdUlSWlphRzRzM0J1cDFWZTBXNHlWaUhQdWNqeG95QUZlTkFHWGJVcG1zZGhyVTJYVFdyL0d2eU1udDVYbWc4cnc1YUxLeGtDOVdGeEU4cEJxem9PUUh6QU5UcUt2cHRKWk1hZnIrcGJuaTMzRnhIbFFqc0wyZHY3bGl2ZkdTaXdvNnl5QUJHSkNrMVk4Q1BuWDEwdHJTa3pNK09yZWh6UDkzTUxlK0EvY1QvQUxrOGVta3RibWVmKzdZcTQ5cGs1TTVjTXk3aWpBOFdVaWpEMDNPdGJGWlhyRE1UTlhiYVRQTTVTNHZ2SDN6WGkwNngrTWVURVcxM0RldjIxeE9hVlROTmJ4TXBQQkdJYVdEWUFwN2RpTkpLSEQ2cjgwTTdPSlhSaVBKZjVESDJVTnBiejltWkpKSjJLTit5b0lDMVN2OEFVMjU2ZmhxMkUyVmFwQ3psTW5KTS9ZV1h2TEZXTlo2RWNrMnAxOTN4NjZzclVnMlhUNHJraDNKb0ZZeWllTnV5ak5WUzRHeEt0N0tIL2RyK1d1UTVXTFNUMkgyN2tPN2RVM3IwMTdyOHZvV25GUGNRVzMxTi9aeVFMSzVXMnU0V0N2RThhMDRNQ3JWWDRHbjRiNnhZOERieTJTalVXY2xseGRxV2pyTktVTUtTSTVrNUJkbVZONmlvM0xub0JvN0hpanIwQU11VGNtcXFaL0VmMUtROHR4bDNsdktwY2ZqWW5rWlZJV09oSldPRmFzU2Fra0FldXVzNG1SVXc3ckhsdnVlQzErVTZWTDgrenZpYmVHZUt5Mzl5ckRKMzkyMEYrbEE4VHdSZXdJdXdKNmxqWGIrZXVVOTU1YXpaRWwrMWFuWit4ZTMvQUdNVDNSdXQrVWRCdCt4bUN1WXZ1dm5WeStRdDU1c1hqWXY3TGF4K3psYVhyQTk1bENJbk5lRkhXaFlNKzUyMVp5czlQOFdycW5GbjZuNEdMYkhrcHlMMXU5YXJSZVQvQUNMSjg1KzRsajRyWmVRWEVZWmM1am9JdURLQXJGYnZsSERLNDQwTldEdUZVbHVLVnByT3g4SDdxcXV6ZjlZSkxQdFRWdTM0azVydzNrVTFobXJqeDdLM2ozM2pPUnRJYnBaNzJIdlhrcTNrRVVZU1BpWkdSU2FuMjBJNDh2dzZPK0pXeHExVkZrKzNSUUM3OW1SMXM1cTBtcDZ3MFJidTN4VTFsWTNWcmNRd3hXZ3VJYk80YzkrUm51WkMwY01vYjlTUmdsVmszRzJwVnZaV2FhNnhQeTcvQURMWGpwYkhXMDlKaC9Ic2ZaNjdraW1OcktoTURZK0x2aTdFY2pNWUVZaGo3eC9TVFNsYWJmRFQ0dGRlODloWjdiWEQ2YmU1a21jdXZJTVpaV1BrQWFlNXQ0WXJHMW1hSUw5UGJ3bDV5SysxR2pvQXRmbHRxVG9zZDI2Zkg0OWlsUDdtTkszWHAwNmQvb051QXNycnhmQ1hLWjZQNnByb2ZUNDFyWlMxSUwyNTdGKzNLQmxTWndqZ3hySTQ2Y2hvYkxldWE2Mi9QOWFsMk9sdVBUMWZoUHFRWjJ3dGppcm16eU50OUxjWStYSDJFdHRlUUxGTmJ3VHl5TTA3S3BJNHlEZ2FDdTlmZ05XVlZyV1VQck9xZmgySnZKUlU2ZElUbnN2SDRNZzVYR3pYMW5FOFY0OXJEWVhzZHpqSGloTUttemcvNmVhNGprVkNhRXVva1VVVUU5T1dyOGVqYTY2YS93QWdUTTVTY3hEVWR0RUIzak9aeStNdFZlNXlzRnRjVGl5TnRHc0NXOXhkS2tqMUJmaXZKbFZhaXZ5RmFhc25aVnZTc2xlT24zTWxVNXREN2RpMVBKTWRGRmEyK09qdVd1clY3d21TT0dnZUdDNWg1OG1XZ3F5a2I5Szh6dnZySngybG5TNXFQYWxNNi9RcXVLRjdpeTdsaGVsYjJreWlCNURHdmR1Q2lCUzBsS3lkdDYxSFdsTnV1dG1GMGFPVXRrYWMxZmorZWhNejJZOGVuc3ZHOG5qUEY0TUpGajRBYnE1U1FUVDM3MGpEOTdqMVpuVmg3dWdOTk1xdWJLWm44aWRXb1Y5c0w4d1hmV056QTF2bERKM3BtaEltYmlBWUhtNU5GVWs3MVgyZzEycHBxTlEwVzVhMlRWcDdmU2VoblpRejVYSWZUVzhhWEViTkhJN1MxSm1lNFh0OEtiY1JzMzRWMDdlMVN5TmFQSmVGcXY1akRjd0xhK01HMXNvbGxuN3BqdTRTWk9La3pDSGlqRnFra2xpMjlOL1FVMVJPN0ltWDJyOXZFMHRTelZ4QjhTd2R0ZzRaVFBCRzhzZ21rQVhsM1NDZUlWajdRZHE2enVYZDN1bXp1Zll1TXNlS1BPU0haMzgxamRPbFFZR2pDOVR0dlUrbjQ2QzhqcEwwVi9pVnI1KzMvZlAzRHV1MldGamdMUzNzSS9oM3BTYmlaZnhQSlIrV3QzaEw3V0RkL3VjL0xvankzM1d2M2ViYW5iR28rYjFZMCtPWUtCTGxMV0cwWVNxRUlsS2JSY1JVODZDbncvSFZGcnV6Y21uZ3gvYnJLTElpaVNHTTNERGpKSCsyZzZBc2xVNWRTQlNyVTFrWlh0Y0k2VGl0MnFwV3JPYi9BTDFaZTFoOG5Mc0oydDQ0ZXlrbHN3VWhsZXZJMU8vNDY2VDIzRkdQNG5uL0FQMkxrNytSM2lxZ1JzYjl3bnM0cDRreTJXaUxwKzFTWGtBOWQ5aSt3SUcrdE8zSG5zam02Y20xVkNiK29VdC91YTZ3UndyZlhIMUVmSWdTUXJRc1JSVFVHZ0pyUW40SFVIZzE2RHJrdUlsamw5c1B1SGR5WGMyRnlVcUpjWEhOOGNYcUkxbWZZTHhHd1VrKzZsUGo2blZXVEJ2cks3QkhHNWJwWjFiMFphZVl5K2V0b0xiR3pYRnF5WDk5WjJFYkNDVDN1U0pwVWtCa1ljT0pBK0orWFhWR0t0WGI1Tmh1VzEwdTJyUytwczgzeTk3TDR6bGNQa0lyS1NPNGh1SUVpakU0ckRHeGhXUUZxZ01yeGdoYTdiSFZIMi9VbXBEYlpOdEhWeDhCYyt6UGlJbHl1Qm12b1VrdUkrZHhMS0JYa0lGWmxPL1NwQ2s2czVPVFcwZUEzQnhQWlYyWGMxZmVMeGdmM0s2bmpRQkhKSmFuVW4vejBCd3NtM1NUWTl6d2ZjcjAxT1ZNcGk1OFhkR0M2WUs3VlljYWtVcnJxS1dWa2VlNUtPamhteXhuc29EeWtsbGtsT3lyU2lnL0U3NmtWbDVmYWJ5QVRGc0RLOUZsQmx0UTIzdkhWZnowV3FQTmd0VmRjYzJYbW5HNzZkU3pGZmJaZURMVGFGeCtHc1kwb0NPQ0xXOXpOY3N3Q1JXOGhJSS9WV2dvTlpmdVd1Tkx4c3Z5MU52MmFtN2tyeVRmNUJMeDQ4M3lFNVFDYWViazU2MUNnS3UvNERXSmtiY0hvZEV0WDNOM2tiMk9TeW1GOFFuWkdTYVVaRzloY2xTMEZvYXFxa1ZvUzlYQlBvaDBad0tlcDM3Vi9VNWozdlBHTlVYVy93Q2hiR0FhUnJieVR5cTl4N1cxM2ZYRFcxczRpcGROamJOQ2xxMGlHaHFXbGtsb2FlMWg4TkJjcHBZMVJQV3pidDhUSngxbko4RWt2Z0psejlGZnRiQzVSYmlGbUY1ZExKS3FGMmo1SkdGUkdhdER5TEJRQityNGJGNGx0VGYwR3pYVnJKZEN0L0pXdDdueWc0MktLMUVFR0x1SnZyY2loYTFWTGlXSlM2b1FBd0NDaWZGdlRXdHgxNkcvTXh1UzN2UzdDcmxManhPTjU0N0NkeGNSNDFzaGNOWXRjUld5dUtBSUU0aFN2RlQrc1ViYlJLcllFbEVXREIydGkrTHY4aGRTM04xSkJMTGFZeHdzWmdCaWFUdU9SU3BSVFduekdvV2ZWSkU2d29iR0hQWHVOeWZpbVB0WnJtZU9HQzRLdWtUbVNTOFAvTGppQUhGcXN4Nkg0VlBUV2ZTbHE1Vy93alh0a3JiQ3F0OS9xSldTdzhxV3R6ZlQ1QlA3aGFGWURCSVF6eElLMFdTUUFCbnFlUDhBQWFPcmZXSU0yMWRKblV6eDExYll5M0Z5NlNGM1J1Y2JiaEhaZ2FFZjd4RzMvanBycmU5bzlHcUtXRGJKc3l1V3VjWmpvNUxPMzVSelNvZi9BR0hmM0RjVUs5YWoxMzFPMjFWbDZsVlZaMmhkRFJlV2J6M1gxazl5ODh2Q1ZVTWtRSzBGQVN3cldwOUNOVHJiVG9SdFgxVDRHdjZKNEwvdTVDSTI4Tnc3QkhRRlF6S29KSEZpRHVOK3VyZnVPSVRLOW5xbDlDVGQ0VjdlNnRtc2JodTVPaXM4MHNhckdDU0FBS3NRU2FqYlU2WnBUa2pmRHFvSU1rMS9jM3oyVWNVZDNlcktJbE1LS29Zbm9RVklHOU5XMWRWV1FkMWN3U3NqSmNMSVV1OGZQWVJRMWtDUHlZZ2JpaEpIU3VucFpQdkpLMVd1cWdBNVBBUVpXWmJpM243YktRRVVxR1NoNjFJSW9ScTJZS21qWmpmRFNHbW0rcWp1VEFBL1pEY1R4K0pWaUsvaHBwSktqZlFOSkRDSUk1WlpLdEZLcU90VlplTEVkS2ZEU0ZCbmVXcnJPM0FLc0RFb3ZVcFExRmErblRUREZaWk8zS1pXNFFHcUVxQ1Q2R2cxbzRzaTJFQWpaV3dsVGhhcWVJcVhuYmNENGdhRnZsdFlTUXlZeTJ0STR4d0RmVUtLckl4cnlYMUZPbnoxU1RCMmZ0VXVjWk9zbjdYQWNsb0RYa3AycWZucTNDNHNobUl5S0hDUm9HWmlLRHJVL0Q1NjFPblY2RmFRVnM4YUVWUktlVktmdHBUa2ZYYzArT2dzdWFyVUpFb0dZUlBCYkJuS0lTS2lOYVYrRlQrR2cyeVFnM3R6TkxmU3RKSVpGRHRHSE8vdEI2ZkxXald0WVRnZ1FldzdQeWpQcHlKK08veDFaSytvMEJtd3hnbGtTU1FjVjJveEpKTzNYODlCWHYySGdPVDVySFlpRmJkYXlYQ0FmdG9BVzNGYW4wR3FWVnZvU2tYc2ptY2xtQ3NjaGFDMTY5cGR1WDQrcDFmanhlT2cwa016TGJ0eFZLc0JSV3BSUi80bjAxSy9TRW9HR1B4cUdNVGZWM2daMTRrRlNmZDd1bkU3N3IrR2hXT2czbVBJN2UxZ0NQTWtUTUtVVUh2T0I4UU52NWFZZHNyTzl1UDdqa1pKeTNGWlcyTGYwcjBGZFNJazd4N0ZQZjNhaWxWMzQwNmxsRlFCK09rSXM2TEl3NGl3SWprTEZ3Q0lhMWZtQVZvUWQ5aCtXb2t5dU10NURrUDdsTzhFalJNR0FMSXhWdGhTbFFSMDA4RUNYaXZOL0xsbFdHRElNeTFCcEtxeUFEYjFJSjBvSGxqNG1aZVgvcXJsRURydksvSDN1M1VtaHJTcDAwRHlRTWI1VkY0OUpjM1Y5YTNiV2wyUjJabzFic0JWSjVFRTBCcWR0ajZhY1hRSmY5NytLWk9ONHBMb29ISElSU1JsWExEb3U5UWEvanBKQ2szWUw3aVpIeDdJdmQ0dXl0WmJWMDRTVzJRak56Q3pBSGd3ajVLb2RLK3grcSttb1pNVmJxR2l6SG50amMxWmNYaDNtR2Y4c3c4WGtXVnZMU3h3Z3VMakZ6Ujl0bzZSM052Mm1rNTFyUXNPTzUvVlQxMWlac05jZHRsVjVuU2NYUGZMWGZrZmtOK09ud1dUeFAwY3NWdGRTeEphMk5xa2t5Unl5OXlXVzFRdWt0TjJRTThiRTFqY3JXbGQ2YXBwL010eVdWdFBMdWFQdDlqcmFPU3lrbnhOd01qTWJxNXdrc2NGUHJPeTdReVJ0S1Y0TS91YXRUdFExMjMxUE03VzZFTUd4ZnVHRnZNMVR5bkQrRitQdWx4akowYU9WVWdMTkhkdy93RFVrb0RTcWtGa1lMNmI5ZFUyeHQwM1BxRUxNbGVGMEdyeXUyZTg4WFR5eTF0cEVuOFdnYk5XanpNeXR5dExpR2FTRmtZVlU4VlliYlUrZWlPTnF0cjc2QUhNaVcwSjl2bTQ3ek9pTlcrcHM4NVlXOGh0b2dyQnBNVmNjYVZZRWU2R2VwUFgyNnN0WFJOZjJnOVg2bjVnVHhQTXk0Vzd3MkV4YVFOVyt1OEJmeFNobVNTMnVIRUtsMUxlb2hnMjIzMzFmcW0vcVZ0YUw1ay9BUERleUxnTWtZWWJySjRXL3dESDVycWZpbmF1TVV6SWpobnJRMFNVMUhYUnVEU3pRSm1jcEhKdms4bHpnL3VOQm43SmcweTM4R1RpWlcvcnZGVzViM2RQWk1yZ25STmxJR3RHZm8zaHNwWVRUeFpPMllOam9zeGFaUHFHVVlyek8xN1VnTlA2UmRzeFA0YW9ycWdtMmpNN2ZCeVpMQ3I0ek0zNzh0aGxmRUpabVkxVyt3N21mR3lFTnR2RXBrL1BTYVFsWm5ML0FKaGtKcmZJdm5iRzUvNmU1ZXp5TStPZG1pWnhrWWpZM2thc2l0VGdhY3ZhYTZ5NlkwbnRmYlQrS043Tmw5RzVkNGYxMFlxV2QvbjdoOG5HK1FNRjFpREk2dzJ5aEM0eFFWSmF1NFk4bnRtSUJBV3RLZW1qa2xwNW1TMjNLZjRnSzRueFh4dXhqeXVLaHRvMmh5UzNGcjlUSHRNOXhiTUxxM241ZFFXaGs1YkgrbmJVSFp1SkVzZFYwRjdPWm5NMmxoYllqTlFyUGk0VVVRNUMzQkRMOVE1TVV6am9WYysyWGZxQTN4MUtzZGlpNmNhbG5RNUo4OVlacTFzTWVJci9BQzBOdmYzMlBCby8xRnR4UVhDbHYxcVZIQnY2bEk0c1Q3UzF0YnBweVYycTB6eng5N1Y0b3JXNEI1cXJ4dktBZmN4TkY1VTNwN1YwR0dKNmk3YjJGell6NWExUnFXMXhjZHlIaFdzVTEzR1k5dXUyNEkrTy93QU5FNDdwdE5sRFNod1ZuNWE0K25hMjNXODV5VG9wQkE0UzhSSnhyc2FTVTFGMWF0NUQ3azZ3YXNYZHhYMlVXK1RuR2JsQlBPcU53ZjZtMklaK0pJb0c5cDB1bGRTaExVY3JiN3UyY09keXVBdDY0TEY1Unc1aXYrVTl0SzVvVlptSEpvbXJ0VlNWUHdHcWJZRzByZFFxdklXNXJzd3RsY3Q5SGo1cmEzc08vTFpYNjN0bVY0cTZKY1JLczBLcVJSbzZxckx2K0dvSmF5WFB4Z3NuTTQ2UHpid1cybnVQL3dBSVcyRXNoVDMxbHRhZ29BZUlyd3IxTzJnMDlsZzJOOVNqL3RlVml4bVk4ZnZIY1A0N2tKSWw3U0xKSWJhOTVNdXpNQUFIak8vcHkxdXB5a3pCaUcwRFBNa2h3Zms0dVlESXRqbkxYdDNKa1pYUGVVZ1Y5cWdEY0tmajEzMG1wK1F6MEVpZExheHlzVmhmTlNLNko0Z2I4UlhxZlVWTzJyRVFOZC9pbnRMaVYwV3BXcmlvNVVXbFJ2OEFocUZ0VUlLNDJ6dDcwUlJ5YlNUS1Vpa3JRQ1FnZHY1Ym5yb0hWRitPeVEvZUZ5TGZJbHMwYS9WUW5tbnhWcTBZTURUWU5RMCtlcWJxSEpvVWVnOS9ibnlPRHhIUFhJeXpoUEhjekJJOXpKS1FZb2J1RU1XNjlBNmppZFNTblFGczl0bXlnTUxuWXM3NU5sSUlybzRueC95QzZtaG1XQkVaU2hhc1ZSSUNBQ0I2Q28xbzJVS1lsb0RUMUNYak9Oc284amUrS2VSdk1iaXhsS1djUW1saWlhSVZacUpHVkc0OXcwck9WS0hyQTAydUc4ZHgyWm1zSThUYUxGa29rdnNUY05Dc3NzWWpQQ2FMbEp5Sm9RSEh5T3E2M2RxazBsSVQ4aXViZkorVTNWbFBDTEt6ek5zOHFwRWlMRU1oMmxpdTJpV25FQ1FJc3ZEcHlycXQvdCtESnF5VDZkUlArMzB0cjRQNVRmWTJVZlV4VG5zeWw2bzNhZjhBUkxHNFVoV0FORHRxV1QxVlRJVWFyYVJtekdKc2J4WjBaZ01rVkJnUTd5UEpDS0VBbWlrUFN0UitJMEJWdXZVNksyekpWUHVFZkFaUEc0NWxqdUo0amVYU0V5V1V0VlFHTmdRZ0o2RWJpbkxwcU9WV2EvaVdZTFkxYWU3N0V6eVRJSkpLdDliMjhpMzF0RzhHUnRrYWtrK1BEVkFicHk0VlZvM0h3SU5kVTQ2YVIyL2lFNXNxM2JsK0VCOFhsSmJtSzRzZzhFY2tCRXRsY0xJbzVyVWNhTng5Rk80TEQ1NzZsZXNhalk4N3NvMFhnUmJlZnMzZHZESTRXNldRWE1Fd2NNK3lsM3JHRjkzTDlQdU8ycE5FTi9aK0lxK1VRTSthTjdES2JlNTVzeFVsKzRFWTBDK2dJVW1oMFJqZWdGeVBWZWU1TXZML0FEMzNBeGk0SE4vU1E1RENXcnZhM0FSNDU1WW9pVCtvRnc1UU5UanRzUHgxWlcxYWFyb3dLOUhkUmJSb3BxNXVibTNtdXJQdXREWnRLUHFMZUp5MFRTUjFBZmpVQWtWTkRyUVNUTW0yamczWlZXaXNyS2EydTRwMHZJaThxeEZ1N0d5bmlZNVFRS0hhdXhOUnFOZW83ZWdKanRwbVV5QkN5THUzNGZIVTJ5TUZ1WXU4YTBuZVhtR1pwR1pBTjJWaUs4dVE0Z1ZKTzFkOWMxa29tajA3ajViVXU5ZTgvUHhuUWE3bkwzZHBZZHBROFU0WUJWanFLUlVxU3pNU0JVa2dtbndHcyt1Sk8wOWphelpiVnJyMVg2ZkVqK1BaU3doTjlkWFVjcGxXb0xPU1RSaUMxVVVWT3gzcHRUMDFabngyY0pGSEU1RktxMXJKeXZIK1FQOEFHNUxKL3VSUGZRbEJOWnFrTmhDR1lPMTFldXNLbFIvVUlneGRoWCtXanNsTGY0MjN4Ni9CYW5LckpqZlBkMzByMCtML0FKSFMyRXhxV1VkdkRERVkwU09ZeXhyR3hyTkRJZ200aHFrMUQveE5kY1prczd6Wm5YN2xqOUMrUDQrWjdnUEY3QzJ6Vjdub0xpNHNJcnNMY0xlaVJvNVVpTXJFVXJ4N1lZOGcxRjNYWTFycTdOeTdLcXBwQzBqOGRUUHlZS09YMXRiOGFHWG5pVCtYZUkrVVJKYXh2Y0xhUEpERXdjdTBNUkRPN2VvOWpIZ3c2ZW1xdmJhMnJuclp0d1VlNFlsVGp0THVWVmdQdExaU2VMWVhJK1BaeTJ2UEtyckdSMytKbWNOSmJXOHJYS3hNSmd2SXZTTXNGV1JhRGVxMDEwdkk1enBrYXZXS1REODlPeHorRGlySlJmYmZxUzBmNDYrR29vK1QyOXpsY0Y0MWk4YjR6YmVPNUc1aHVXUW94UkxscktSbG1sa0JVSkg3bzJBV3A2ZmhvM0UxWEphenZ1cnA4cDZGRjYzdmpyU3RWVnQvcDFDMTk0L2tJTUZqa3pKdDNudUpydEVuN2pTU3h1eVFSS0hqakJJWnFjbEoyQXFUV3VoOGVhdHJ2Yk1hZnhOTE5nc3FWVjRuL1FEV21PeGxrWWpsN3U0aXM3YVNhTzZzNDFhUXp6UURpQWlBcnhVamtXYmtUdFNtK2liNWJXL2FrMkJWd3FrTzdhUzZoeTdhenVjUFkzUGpsOUpjV09YanU4ZkZZNU5wQWZxY2NZcDVTR3I3WW5DZHRQYlVWcDZFNnJ4N2xkcTYvYkQwOEgvRWxtdFM5VThiYmxOYStLL2dmWXBUNVZQZVhNVWtGdG1Mcm5XZklLNVQvcE9KZU5sSkFDQkg1b3oxNjBBQnBxVi8rTkx1dkx6SVkxOTN3VDgvMENlTldYTlgxeGovQURDM21qbnRyaW1PS2hZa1FjblFSMjhNZkVnY25WNTFMR242alRVYnRVck5PL1grcGZqcThsblhKMmVuOVA0aTMvYzE4ZThwczcyL3YzRnRpakpZdXNJQ3l3b29NbzVJZzR5TTNQOEFWeUpCRmRGUjl6RzBsKzdVRHJiN0daV2IwV2cwK2ErVzR1QzMvdkdPWXFiNTRwTHNNVXFJRVdJZTBPU1hXZ0tuYXBHNEh4Rnc4ZHUwTmREVzVQTXJTbStqNnNSN0h5WHgrNnltYlhKWFVOalozRWNjTWNFcUl0WkpDWGxkS3EzQThBcW81RmR2bnJVcmlzcXBScWN0bXoxdGV6VDBadmdrOGJCR0t4a3NWMWpWUlltdnBMaUdlcnE1bFZsS0dPaFVua1ZLMFBwK25VTDFzM0w2aEhIelZxdHZXckR5M2RsQVpjakRNc2tITmlJMlRncXl4S0JDS0d1NTVjUGNCOGFhRmF0MGFOVldvNWRiZmpzUTdmSDVTeE10bFoyaGFXV2NDT2haWlBwbEllUXNoSVpTdkduS3V3cnBPMWJhdGtLVXZTVWxxMytYY05lS1k3S1hubEF2ckUvMjBUM1ZxYk9DUmxlUmtWNG1SblJTck1oQloyUHFQaHFhMjdZZXBWR1MyWFRTV1dGNWRPeHZmbzQ0akpNbk1HbjlSYm93OU54VGJXRlp6YlU5WTRHTlZwUGJRWGJKeEgzTHk3MldJMWREdFJVRlcvTGJTNjZlSm9aTDFyVnZzbEltZmJtM256RnZKbTVSeG16ZDVjMzhpTlVjaEkvN2FqYm9GQXByZDVFVWlpNlZTUjVCeExQTmEyVjliMmJMMnhGb0xTMGt1V1BLVlkzUEZEN1NWSk5DZjlwMWtXc2pmeDFpRVFMeC9wOFVyeXNlOGtRYVE5UDNXWG1meDl6YURWWnViK0syekhMMDBPWC9BTGp4dGR6eVhKOXpCdUpIeDIzNi9QWFY4ZFJWSTh0OXdzOGwyeW9idTJGcklIMjRzT1NvZmo4UHcxcVV2S01HeWdpODJKTmQ2bXAxYkpFTzQrK0t2RkxieUZiNjNvOGNoMk5WUHlPaDdKMWM5aCtwMFo0ZDUxRG5zZGo1WkE4MlV4TFhON0xIVWtTU3JFc2FCai9tOXgzL0FNcTErT2c4bVBYZFh1b05mQm0zTGJicW5KcnllUnZyNmU3aG50N2dYTEpiV2NsdFdOa0U4WXE3TFJ5ZDNEZi9BQWRNcXBMNWx1UzltNWE3UVcvOXY3ckhZMVh2alpYc1VGbmpXSWMyNEo0QmxWbkNxN0U3S2FVRlRyRjVTY055dFhCMFBEeUpxdFVub2UrWjQrMjhudzlobHNTUmVXTjgwVThWekhVcThFZ0pEYmlvK1lQVG9kOUExVnNWOXR1cHZZOGxNMkhkWFU1Vys1L2ljTU1UWk9CRE5Nb1VSdEVhcndMMDZEclE2NlBoWjIvU3ppZmRPS2t0NjFLdXRZN3lPVGxIQ3ZJSGZrQWFIOEs2MXptUmt3dVJ2c2ZmUlhuS2wwamR4ZUo2VVB3SHkxYmh5dkZkWFhiOGZtS0RxbkIzc09aeE5sazBOVXVJMWR0dWowbzQvSTZxOXh3Vnc1N0tuN0g2cS84QXJiVmZUcDhqVHczM1VudUhaT3d1SnZXSDdYRlVCZFZyK283ajhTQnJsL2NMYVVYamIrQjAvc2FuUForRlgvQTNlTnNpMlFsQTRDUTl3czVxUDFFMXI2VUFGZFpXVTduRXZUNUN6NGhQL3dCNDVQeUhPRy9TMGh6RjViNDFaVlpPVnJoYlkwYzcxOTgyeTBHL3VycmJwaisxaXFuL0FPei9BSkhubk56dlBudFpkRjZhL3dBV1hONUg1TGtQL3dBWDBOeDQ3YnpHYVdaNExONDQzdUptRWQwYmVKYUJ3eDVHUDlWZjBqZldOYkh1ejFWdFA3bjh5K3Jxc2JhMVMwSzcvdmZtOXpiUlMzSGpsaENBcWg0azcwSm8zNlZlTlpYQVhjL3BwOHVtdGY3V05McVpmM2NqbVZxTFA5cDhueWVVeldkeWdpK3F1MCtraHg4VE5HWW9WbE03cEdYU2xXZmx4L1VmOE5FSjBwVktvUGF0cjJkckFETGp5RE01UzN4WDBMV3ZqN3kyelg4TUx3dFdLMm9ySW9SL2NDeUtvREx5L0RSS3RXSkIzUzB4SFU4dnBjb2ZKcnJ5aklXRTdXYWxyZUJaSTZQREJJdE5sR3cyTkt0WDhOUXJhdTJKMVpPOUxOejJSaFR5R1Y4YmxKOFpiWTdEWTJjUzJrdDI2d05JVlppN3JHeDVFdHk2bitHMnFtNmF3NWNGdFZlRktoRUU0cTdHUG5lM3QzdWpmWFlrbHUwQ3oyNGpYZGR3UnlKYm9vMGxkS0Urd25pczVhMWsxV0dLeTE3TkxscjVVeDJNc1Q5TmEyaktxZDJTUmd6ODFhcHBWZGdkeHFOcnBhTFZzblNsbTV0b2wyTnVLdWJDMnU4aWpvMXlKcDBIMS9KcGtlVlFLVlk3KzNvT21vWksyZFZBK085VTJaeVBaV25lbHVaVEc4clNUV3R0VDl3OFNFQWFOV3J4SzEyMDlKblJFcnVxMVlzeHgzV1V0SGVPS2U0dmEvOEEzUDVFdEhDNGtCWTE2YmdEbDg5dEYyYXErMGR3T3FkazlKZllLWlRCM24xVmplenNJbzVBZ2FLUldNUWxDMDRBMXBVbjhOUnBtV3FSWms0OXRHK2dHbmp1OGRrcmtvOE1ZbWlWZTI5UUc0bm1qTVFEeHAxMWNtckpGRjhicmJzR3JWc3ZsMlNXL2hwMlkrSDFBOTZ5RWtIWW12cWRQdXJSUWh0dHI5UWRkNE43VEpHQkllNWE5dXNvZ1BjSmszYWdGZlFldlRTcmxjQ3RoU1pBUzZTN1hzWE51TGFYc09ZNURHVkpBRlVyMDVmRFY4dEtaa3FUbHcxQkt2OEFHd1dsclpYV1M3TW4xc2FTd0pHVEhJcTdBeHNLVUZQanBxNU56aEN0aTJwTnNqaTNWWVZpaVdRdklTSVEzSUJnUVBhb0JJcUsrbXB1ME1pcXl0T3BxZkdHZ3Q1Ykppemd5VWVNZTVSVWtoanZzUGhYVHF5OFNMeHRkVWJqai83ZFlRM1JDTmF6K3hGWlNGNUd0T0xEb2ZYU1ZrM0hjVHBDVDhUZFpYa2FRWEUxblpkeTBoNGk0a2VYa3E4dmFLYkxzZE9SU2toWk9DTytzN3dMR3k5eFFqdU9McXA5RCtxdjh0U1RoeU1Lc1BqdDNCTFFTeEJSUWQwMURrZkt2VHJxNjJWMlVNaEF3MldPV0Znc1FEa2dxWDJQSW41Nm9KcEVsTFEvVHpTRkEwc2JHbzZuaUJwbUlySzl0bE9SdUNGNGtTRmg4TitsZEhVeVZWVVZrK3dzTzRSSkRIeXAwa05lSTlQejBOYTl1ZzZRd1JZeUpJdWNuTjJPM0psSVgwclFqVlpJU00zR0lNbE1pbm9WTy9xU0sxMFhqdHByb1Facmlnbm1YWWttcEorQjlLRTZWc2thSVFTdGNaRnM3Z01WQUlBSkNBN2I3N25RN3MyUEJHeXVZdllYTmxCU0ZZeHV5N01hL0ErbW5WWkdrQ3Vzc3BNanNXYWxXWnExK2ZYVE1STXRiQ1lrOXNlZ1BjSUJYZmVsVC9zMHdnekhkWS9FeDhaWk9VbzNXSkJYZW55LzI2WWNoWkh5Ni92SSt4YjB0NHVqRWJ1MzRuMC9MU2dZQUFOSy9xV1k5ZmlUcHhEWDR6WUdDVjdpYUJwWXlwVW12RGkxUVF5a2crdWtJbjUzS1F4Z3E4NkNZL3JqaS9XYWROaHNQNWFRZ05tUE8vS2MzaTdYQlhlUWtUQVdTTEhhNHFFbU8xUUo2OEYyWWs3a3RVMTFGVVNjazNkdlJnL0d4T3F5WE1VWWtFWlVOSVJ5NGN2V24rM1ZpS3c3ZmZXMmlRMmp3dXR4Y2hlMHJqM09ISUNrZkk2YVVPNnZvZEwrSWVQVytDc0l2SHJTVEgzdHlsb3IzUDFQS2UybjVBdGNWbzZyVUs3OGVMVjVVb2E2d3NsOXozUHhPbHhVZEs3VU9VYTJPVmVTTzk0VFR2REpZMlYzTFdZeXBIREV5N1JyWGxGdzRyUTEvbWRDM3JaUnFIWXIwMWxFUmJ2TjRqeGE1ajhnOGpsUGo5bGJyYWVNWFdOaVNKRnVydHlYN3FmdG1ra1N1ek1UeW9DdGQ2YUlUVHRvdmlBMlVMVmdmN2YrU1plMHlHRXVWRU4vL2FaSm50NUc0U1Q4YUJwZ3JGaXcyVWhXL0VWcHRwOGlqVXR4UGNvNjZGMjRhNmt5ZjI0OHlrdThneGVCcnEzamptcVYrbXVJMGFyVi93QTRKRGRhR3Y0NmpWLzhrZy9JWHBTT2RyRHlES1FZbkczV01ScEx2RTNVY0RYVlZRTGN6LzhBVE9BVDFISmxZa2JWR2o5aWxwZ0c5d283R09jdlhzSHpObmYzNlJ6dEhhNVNOMlYyYWU2Z2tXTmxWcThrZCsydkUvanRUVDFVdzBLOXVxWWN1ZkpWeHVhRWlyM2JhMm5zc3lKWndyY0k3b3JiM094SDdnREs1MjY4cTZzeHRxR3lySjNSVjMzN3g2MnZrdHliYU9TQmdibEZqa1hneGlMaThpWUJTd0NzSnBGU2hPeS9MUjFrQkhVZjJZdkQ1cDlzUEUzU2N3M1dSdzJUOFNsZUlnSDZ6Rm42NndMRTEzNGlVL2pxaXEvWDlTOTIwK1JaRW1RU2MzdWVqY3RIYzIrSDgzaVhabUR4QmJYSUFBN0Q5cEZEQ25WdEsxWjBIcmNwRDdzV2xyaFBJTW5pNGJZekQrNlh0cFpzNG9zVm5tSVV1NGVMSzlUeGYyb3BGQlE5ZEE1S3hhZkhVMHNWNW9sNGFmVXFhMHk5dTNrMGVZdWxrRFg2eHlYOXUzSGwzMVZyVzROU2FlNE01L0xVNG1zZUFMdWkwK0p1eGVXTUhDR0ZUUDhBUTlzek0xVloydzdtRjlqMFo3Ui9kK0dyR3UvaVEzNndXRGNZS3h2Y1JOQXlySkR5S0lkdUppWUU5cy9JZy96MjBPdEFpM1RRcktCN2pFUldXQ3lrNWt2TFl2OEFRM3l5djNJeUR5UmVYNmo2SzQ2RWRkVzJYOXk2QWxiTG94OThkdVV1VkZ4ZGNyTzVZaWRVVW5ZbGpVQWpyc2Q2NnFTa3Z2cFVqZVNqSllqSzJGekh5V1poSmJNS0RpN29XbXQrWEUwcXJBVWJVc2NTVWFHLy9VWjVCNFA1TEY0WExoWllqZmZTelcxOUJhMjd4d1JSMzBhUEVSSlFLekJ1YW5pZEU0MDFNbFZpaHZGYmFmNmk1dzkwengzVUorcHRuOWFqWnZ5TkJxT1pRcFExYXpvUWM2MG1QenRqZk80ZFlwdnA3a3NBVXBJYUtTQ0tlMG5WbVA4QWIwSU1iN2ZNeFcyTWZDWkYrY2xrN3hSOVFlMlJ5UXEzVGV2OHREWmFOV2xCTmNyaUM4ZnNWNUNjdGlzaDQ2MHBrYXdhS2FDRW1ydkZLREd4QUpyeHAxUHgwQm5wdGNtbHhjazBnUXZKc1EzMnQrNDk5bExURlBkK01aMjFNRnhiUnl4aVdLNnQ1bGxqZFJNWHJ1cTBEQTFVbldoaHlwMWh2b0FjakcxZVkwWXVlVjVtNjgrdFljVW1LWEYyZGhMM1V1cFptbGxWcGp3Q2tJa1VhcXhQUlUxWTh5cXl2N1ZuNUM3NUI0eExJd3ViMVZseWNNZGFJR0JEUnR3WlFUc1JXamFsV3lYZlJsVHJvQm9idTRhNitodllTTHFCREgzUVcvZDNxdFFmZ050UnRaYXgzSWpGak1mSmtMcVBHb2lxZTJhLzAwQys0MC9BN2FGYlFWalNlaVdveFl5YnQzQ1plSkdqdlpXN2QyS2JtVlBheGJjaFdZQlcvRWFoWlNvWVZUcHFDL3VQbW10UEVidU5tSDErYm5TS0NJRGlVQXFaR3BUcFFiSC9BSHRFWWF6YWZBRjVHaFVkdWh0clpJNDM3ZHhHUklsT29ralBRZE5IZ2FIQ1c0eTk5YVJmY3lVQnByV2VPMnVJUlJWRU1ZQ0xTbTVicnlKMUhTWUplWTdaZVY3ckVXV1l4WkV0M2pRTWpacC9TOEkvNXNZb1A2b3lmekdxSzFoNjl5YmM2a3pPUnhaekJSMzJGay8rNk51WThuaW1MVVdUaU9YYi93RFVwS25VY2FpMFFTYmxDM2xwYmU0Rmhub1l6MjVGSDFMb051ekx2VTA5VWZZMStlclltVVJtTlJ4c2NnOXhqMXVKa1M3dU1jRVE4aXZLTUxRSnpCSUpwdXRRTnFhenIwZzF1UG1UVVBzTHVUdzBWcmZ4NXpGWGl0Rk1STXFwV25jWW1vSFgxcHA2MmxReTYxRlcyNVBxV0g0ckJZNVVHNW1sbzhrQVdGM0FFYk1qY2pHU2EwYXRhZkd1aHNrOUVqUTQ2clp1elpXM2tXSHkzaXpOZTJibHJJdHpnVTBabU5LUEd5bmYyL21OWDFkYmVsOVFTNnZqVHN1azZCZTFraXlHTnRyK0NPRHZ4bFhtWUx3a1IraUpUcUUvemZEcjAxVy9UWXMzYnFhZFFwSjQ3ZTNVV1J5VHl4Mjk3WnAybnVicHdZbTM1eUpGK29PVFZkOXY1NmkybEhnWGJMV2JmZ28vMEt3OGx6WDl1UTJOcUN0d0trU0VnRkl6VVVGYXRRVjY3Y3RHWTZibkxNbms1ZGkyb3JMTVhGdmRYSUZwR3NjYUFCdUZhRnZVNzZQcW1rWTkybTlESkhqN0Nrb1dlbmJkRXBVc1AwdHVEK0JwcVJBbFdWNzJvMmhCV1B2K3g0aVQ3eDhEVHAvSFVMVmtsVndOVUdRWXlyT2tuMUhjSU0zTWxRYWZFMVBwMTFqMng2UjBPNXg1NWFzbnVucklkT1d1bzRMaFdFWmlNWUpaVklKV3V5aytoTlBUUWl4SnRRYTl1WmRWdHVpSS9MK0FQZ3U0cldSN3kydm9ua2hoWjVvdy93QzZ6bXZ0QWFwSEVVM3Jvalk3UW5YdVpmMzY0NXRTNmxMWHgrR3Y0N0dIZ0Z0bThqZkdld0R0WndPMHQxY0IrRGNwYXBWalVWSkFORnJ2K0dpZVU2VXByNEhPY1IzdGJjdWllcitKMFBhK1NkdkhqSFdPY2lNK1FqdDRZNy92aTN1bnQ1Sk94Y05iOGg3cmdMRzFBbE9sZXROY2ovamJjanU2dmFwY1JLbnF2a2R2L2svZXhWeHluWnRMckRqK1paWGpFa0dkdkdzaHlLVEdDTzE1c0dZcGJVTENoNmdtVWlwMWtYeHU3VzN1L3dCVFE1UC9BQXFmQmFtZHljeGo0OHphUUMyZk9CcnZHeHZiTVVnV09HUmhFRVBJc3JPdEtoanMvTDAwZEZlUG1pVzY2ZlV5S08vTDQrNkllb2cybU12WVpEaGNmZGRqNmFkV1FvaTIwWVNTMFo3aEtMeW80V09xTzFDZHE3YUt5WmE1SDl5eW5UK09uK2hianE4TmZ0cHhMU2JYbi9FK3krUnd2bE1UWXJNV2dGNml5M05tRHhFcnJHT0Vrck9LbFpEV3Z4cDFxUm9XbjNNVVhvOU9qOERXdng4ZHYrTzY2NnJ4K0tFckxYdmhNTjladGp2SElyVEQyOXFNWGU1T1M0ZDJndjJ0KzZYbFFNOGtySVFWalpXRlNQaHRyb01OTTFrOTE5VzVTanQvQTQzUGJIamJTcTlQVE05QVA0cDVGTUpadkVjdFpwZTIrWlJWak14S3lkMTVpeGxqWXNTak9wVGtPVlBhQnZYUk9Yakp0WHE0ZFgrRURZdVM5YVhVcG8wZVZXVTNqSGtNM2prOTQxekhEazViekV2aVhia0VrclZZb2ZjQ3pNeW5sV29LblZ1RzI5Ymt1ME9Takw2WVRmVnlvL2tUWUpiSEhZdWF5ekZnMlV5QXU2RytqY3h5V2lQYmR6dTg2aFM3dHhjZnFGQWR4WFVIVnUwMWNLUHJxV3BwVml5M2EvVFFuMjl6Rm0zczVKa2VXOXhjYzFuRGV4eUhqUENVTXl2TEd4SGFjMEhJN2xxRWZoWGFycks3VzFqOGRRekRldDdUM3JwK1BBQnlwZzdTNkdjaHNiZjZGU2tseVZhanp6ekl5TXFSU3lMUVJoU2ZaMWJpQ1RYUk5kelVTQTVkdWxrdmo4UmR5L2p1S254ZDNhUGZPSXNaY1BKSk96QkxrU3pMMzFaNHhWS3gwQ1VydnZ1S0RSVkx0V21PcU03TFJPa1QwWW9TZVN6NFdXUzN4VTdTNDZXRVJYY1phUkVuYXJGWGJveWxlUXAvRHBvdFUzS1daOTd3NFFWc0xTTERXUDhBZmNMZVcxNWlMMTViZkk0UXQyYmhyZXlpaWVlUTl5Umlqc1haVUkvVnZ4K0dtdHJveVZOTlVPK0N1N0xNd1Rabnh5VnBIdXlKNzIwbGRKWllpcFlkb3hIaHlxUGNLTnlBNmFDeVZhMHQyRDhPU1BWVjZrL2prWWIrM3pUMjhzODRuZ25SWW1aU283YXZMR3JWVWtFTWR2Z1BVRFZDMnh0Um92N2plOXpPZy84QTI2aml5V1piSjI4RDIzOXBzSkM3M1NKSjdybDFqNHFVa0JSdTJDQVBTdStxYnJaUnV4cWNKL2R6MTJyb3U1SnpWeTMxY2s2c1N6UDdIcHZRbWxQOE5ZaVo2bHg2TGJCcmpodHBsdVJjVWVLUk8yWWp2ek1nNDBOZlExT3JVNFkyYlZiWDMwSzd2Y0Q1VGc4b3MvaUtmVWVNeFNxajJhU04zN0dOeDIrNEIxS0JLMG9DVi9ucll4NWFaS3hmOTM2bm1mUDl0NVBEeXppVzdIUFQvYVdTOGRuak1lcjJWMjNmdWUyclN3T1VqWHVWNUgzVkpMRGMvUDhBSFdaWjZ1VG9lUHRzNngzZ0Ruekcya052Z2xadVVheVN4M0w3ajJsalFtcEZCMXFkWFk4RGZxSy9jK1ZYRzlpN2xSZVlYRUZ3UjlJeVhiM0xOOUlJbURpVC9NMVZxT0svMU5yYXhwL0E4KzVGMDIydFo2RmRYT05FRVpqbEhQbVBlVDZtdnA4aDZhSmR0VE1lT09vdVQyejJ6OFNOaitodmlORjFzbURXVUdLdThmRmhzNm1vT3B0RWRCbThjenQzanIxTCt5NURiamRJcDZvMVFmNVZwL0RWTDJyUmpxelRrdkRINXV5eUYzYlpTeS9jZ0ZicG9vd0RKeWpIT2xEOFg1VTBEa1RVbTVqeUs3VEx3c3J3MkdJdlE0UEpvN1d5RDFIdDdVZkpnZU5SWDk0VjF6V2R0NUtVOGJOblpZTVZhMHRkUDl0Zno2aTU0MTVMYmVJWG1Rd2VSbDQrUDVKYmkveGJNZlpiWDBjYlRUUVZQUlo2R1NNZWoxWCtvYTArVGgrNWpsZnVyK2Evb1luRjVQMk0wVDZiZmsvNmxRL2IrSzQ4bHg5NWo4b3NrTWNUbTV0cDNGZithYXRIU3RhY2p5SDU2TXZoMVRYd0FNUEwwdFcvUnR0RWxQc1Y0eEl6UEpsTG96eU1YY2lPTUNyR3BwdjAxb3JNbDJNaDhlWE1oREUvWnJ4akZYWDFWMU5Ma1VVZnR4UzBqV3Z4UEExUDRhbC9rSlZhVmRmRi93QWhWNDhQVmp2ajdLd3hjVFFZNjNXMWdKNUdPT29XdnlCSnBxakptdmRLcmVpNkJOYVZyMEpPVHVYZ3dicWdOYmlkVnIxcUVYcFQ4VzFnY3hUbHF2QlA4LzhBUTZuMlZiYTN0OEYvRi93SVBtZVhHTThNbnQ3YjJYbVI0MkZzcVZERHZMKzR3SFgyeEJtL2hvYmk0dnVaVXV5MStoMDN1bktYSDR6ZmQ2TDRzWi9IZkY4TDNNUGpjWmNHUEZUV2s4dDlCRU9Ja3h3VkF2SGMwSmxJWWtzR0trMTBkeWN1MVdkdTM2OWpoT1BUZFpLdmY4TWZzSkttVjhXYTVpeUJ0Y0xKZS9RWTc2RlQvd0JQajdLMkVDeEkzVlpYZVIzTHFHNjFHZ2JKcDFzMU5uTGY4UGtnaHdrMHVpai9BRk5QbGVHdmx0SFN4aU50Tkhickxad0JIS05MZEE4RFBNU1QzQkdUeUFISW1uUUxvaWxtcmErSUxacnBVcnBJRnRoWmlQaTl6d2xhNnVYY2wyamhVbDVDUlFneWNhSW9OUUdGQ0s2TDZ0K0JUdGlBRlBlTk9KbVFYSVZYN3NzY1o0ckVyTUZVdktRUW85U0R1QWE5ZFdLdWhSWnowQStlaGtudG50TFd0THk0c2tVOTBrQjdpWlNEeDM2QmYxTjBIeDFPdjdsNUQzVDJ2NUJUeUc4dXJPTzN2cG9FeTMxVVNXMktXM0tsU0l1VkhBYjlTbmx5UFFuNGFDeDNyYXpTN2RRakxqdldpYlV6MEZPU1R5T0dHOHlXUWhuU1dhY0NON3dNdklnZ0Z4R0kxUlZSUnhVQS9DbEJvM2RUUklDZGNtckI4T2FueVdXQ3g5eTV5bDVPTGo2TlVNak5OSjdGS3FteUduNmp0UVU2blUzalNXZzFidHZYcU1rWGoxM1pSellxZkxXNHVWazd0NnFLWmxpaWxrRGxTQldqZzFwdm9aMmx6dDBDVlJMVGRxUlBLUEpNWmpMeTF0RXRSSktCeGg3cWQxdWdLN21nb2ExcUs2V0xDN0p1U1dmUHRoUjBJemVSWFBGOGpNSW9iUEh6UVNKRkduYmRnejhLTUJzT1Fhb0h3MVlzS1duV1NwWjIxUGdaZVFaa1hjSDlvalpwc2hjU3h4MnRxaTBmOWZkTXhKUDlLMFhiOGRReDRZdHU4Qy9MeU4xZG5jRVozeGVmSTNrbDNGTkZDenlLTGhBVk1JZGhYY2prU1NCOEJUVitQS2trZ2JMaGJlZ1NzY1hOanhaeDNWMUJQalRSMWRIYXNoSUtrbW82VlA4QWhxTnJxM1p5UFdqckNsUVpOZ2JPUzdqdUlMZzI5aHdjU3FGTHNyMElCVnExSC9qcExLNDE2a3ZzcVpuUUNYdVNGdkhZUnpUQnRwbGxMa0UvdHNSeVFFSHJUZlJDcTNJTmEwYUFuSVhzV1dhQUZIN2lSRXM4SkRVVStyRDFwL3U2dXFuVkZOb3NiNHJPZkh3d1QydDBmb2hKM0VsQzhBSkFwVkN1OVJRRTZaNUU5R3RTU282cWV3UWt5Y3J3T2NlZ211SmxEVzl4STNFeEVibGdyVjZrZW14MVNxNjY5Qzk1SlVScURJcnk1dExKOERkd21kcHFUTDIyM0JCclhqMCtQVDAxYyt1NUE2bExheU5qSkpMY1hib0ZmR21TTW1HYzBMTVAwajJrVjY2c3M5RlBValZOVEhRMXlMSEswa3Fxb3VHcXppT1EwQ29SVThHb1FSOE5Ua2k2eTVHSzl5bUprYUpyVzNMQWhXbVNsRHlOUlFENURmbHZxdWlzcGt0dXF2c0M3aExWUkZMTkNZM2xrNE1TNnNuRWpjKzBxUlQxcUthdFRVd1V1c0kyWCtPYUsyR1F0VjdFREFCb1NXTHFUc1RUcDAweXVtNEZiSEdxSW45aVdXZEplMms3R2pTUnp4aWxSOFNQVGZTZDB1cEg3VmpZTEF5eXkyNGdTTjRVN3JwVUlnWGFqQ2xkaU5MY29rZjdUTVlhUTJrbmZ0Wlpvd3ZKSm9YUmxGVDg5L3lwcVVrTnJpUkx5V0JGemR5M2NMY1ZtQVpJM1VzS2RBS2o4TlNrcmFOdHBoaEVuT1ZnWFhxckRpQitXbEkwQkczdER6S2UxR2REOGxKSHArWTBwSEUzT1k1aGtwZ1ZJUlFBSEFKRlJ0U3VuR0pPS3dNdHduMUFpUGJGRmVSdjBqNTA2blNGQVl1c1RMYTJoZVE5eUlFSUo0eWVJYjBCVWdFVjBoUVY5SXA3cnIxSVlqK2VrTWI0ckNhV2hJNHFhZFJ2L0RTRUVrU3p4SkU3d0c1Y2JxSDJVSDBPa0kwWDNrT1N2dllaT3pCMEVVWHRBSHdyMTBoQXNCbklDZ3N4OUJ1U2RJUWR3bmh1ZnoxeEhiV0ZuTEpMSXl4cEdpTThoWnpSUUVVRTFKMkdtYlM2a2xWdm9pK3Z0bi9wcnpHY3lFVnZKbUxEQzVEaUpHUzhuVnJ2K3IyTEdsVVIvYWRuZmtPcEdnOG5KcXRFcERNZkd0TXRsOCtQL2FuN2RmYkRJMmQ3NVRpbzc2K3lKbXNrem1Ybml1WkV5RWNaTFFVWmUyakVVS1ZYM3JXamVtaEhrdmZUcEhaQmlwU2o4WDRzMitIWS93QWp0c0d1S3V3WnNlOGJTNDJlUkV1WW9xZ2xHV1dObUtLQ0tGQ20yNEh4MW01OXFzMnREb2VOa2V4S3dnWldmeW1HNldQRDRCYlpzWUl2cUpjZXFTUkpMYkVzczZvaDVEa3JkUGh1ZEUwcW11c3lDV3Q2bkZZajZFMjN1TEMveFYwMDFyY202dWp5WHNLekxCRzI0azdhcVVrVUVCV0JYM3FRMVFkVnphdHRDMTBwYXM5eGw4UngwRXQ2K1VoaW0vdTZMRzhEdzI0U1NWUVRVVVVJbk5lUEZrSUJJb2QrdXFyM2N3K2dxNHF2b3ZPU3c4bDQxWitPZmJqeWlWSlVSY3RDYmk1dEl0bzQyazR0YmhTWFk3QWo4YWdFYUl4V2J1bVorWmFmTTVldmJacnliSlFZZU9VVEh1WGlCa1V2KzdHTGppZTJPTWFwS3J1cmZnT05kYWtwUkpsN1czQ0ExN0pEanBJY2ZsYjIxaGp2WTduNmhiMllCUXN5cElPNkRWeTNORFQzYkdsQU5PbjRTTnRYUnRFdTV1NWM3SmpjZmJYanpmUzJ3eGJTclBHOGN0bys4WlEwWmxWeXZGbzJCb1NQWGJUcTBMVWkxdTdpOTVhM2tkL2F5cG1zZGRRM3RnSXJXMWtaQ3d1SGhkMGFqRWtxRkVrbEtmcStBMFQ5eFdnSGVOcnNXNy9wVThxU3c4TDhtdzEvZExCZitLWmZIZVFXVnM3Y0MwU1M5bTdFYW5jMWg1MUFHbDMrS0V1bndaMExQSmIrUCtSV2RpMTJzOW5hNW5JK00zTm5JNnRBbUs4blJMcTFsUEVja2pTWmtoK0RIYnJUVDJla2lUMU9mdnVKNUljeGYyS1R6MnNXY1hITllTVEt6S2o1RHhpNVpZK1lZbmVaUS9ibS9TM1NuSldHcUwxMCtZUmp1K3pLcjhodklGdmt1NGw3Uk56M0hLOG1CZ3ZZZzlSeEZEUU01MjBzZFI4bGt0Zk1KUTVDTy9rbXVMK2RWRjZrR1JhWmFJQzFQbzdzS2R0MlJsYjh0UzJ0RlR0SlpmaDg4bDNpa3RHZGF3UnRhM0RVMk1sbzVqRFU5ZVNCVHQ4ZENXV29UamMxUlhuM1hDNFpyTEp0RVh4czA0aHZXMkx4c3c5am8zV280bXUrK3I4TGxOQSthc09TYmgvSW9JdnA4YmZ5SmNZdVNNejIrYVFOMnlHOXFxeEoyYXV4L0xTVkloaksra0RIbXBXdWZHcjVnUjlWaVpJNTRmY1N6QzJLdUN4TmYxRFliN2pTMk5QUjZNWkEvd0MyMmJ4bUU4MHVYOG1raVBqVnROYTNkbWJoVEl0dEZLcnp4TnhIVlZjTW9IVUZ0UHE2YUVIMUs2ODNqc3NiNTNlNXJ4eVo1UEhFdkpIc2JrbzBKYTF1bUxMN0hvYUNwRytwUFdzZVJKdDlSVzhpZ04rdHdnYms4MVZMQVVJZmJqdDZhV0psTEdESVV5dmhlTXpVY0FpdTdVQ0c5N2FiOXlCakcvTTdtb085UG5xcE5ySTBhRnFxMkJXUzFSTCszdWZtOFc4aHNzNWpMMUxXYTcvNk82Z2tVc3BKSVlWLzNHb0FUMTArZE95YWFLT1BiYmVaR3J6cTluOGc4Z09YN0RjRzkzSjJkNHdxMEJSUXgyM0crZ2NVcGFtbm1hYlVFZXp5K1BsanVzVzhLdzNkMUJJSTFSVlZSUEVSS3RhSHFDZ3B0cXphVU5wcURYZVhNTnpqNUppanNpbExrblk3c3ZwUTFCcFRSR045Tk5BQ3lLdnVMbnVUelhqTVEvSXR2dWZqb2hWa3FrY2NIZHl0RGFaeXlZbWVFcTBtM3VaU2FIYitSMEJkUTRaZFhSU1BHVHhnbnZZNWJWU0xDOGliWUdnNWxlWTZiamNIZjBPcTA5QW1sM09wU3VXeUQrVitRWFZ5WkNjWmlWZUxIcngvNWdVL3VOdHRVOWRhZUt1MnZ4Qk1sM2UwZ1M1N2J5ZG1FaDJKREpRY1R5SHo5UlFhdUtCeCsyV1Z0SThqY2VOWk1COFJtbzJpUE0rMVM0NGxoWG9SUUg4dFFzaWRYNGgzeEZybkRYRjU0dms5NThQY1BHbGR5MXV4cC9Ldjg5UXYwa25VMllHVnNWZTNlQ2ZsMmJPWDZqRk5VZ20xbVl0eDYvMEdvMzBvbUdKZUJsYUpCRGxjbDQxS0EwRndyWDFvdlZERlBVVHhxUi9sYmY4QVBUYmsxSXZJRFdsL2NXcnlXTi9ScDdCeEdrZ3I3NHpUZ1grVEEwcjhkVlpLejA3bDJGdzU4QmdzbzRLbHJadS9ET2dkSTJMckdHTy91SHJ4clJxZW0vcG9SK1pxMGpxTkhpV1l0L0hjZ3VNelM4Yk82QW10cmlNbG9XZWxDeS9xTmQ2YjBQeDFYWjJhbEJlTjFUaDZUOUExNWJEaXNuSVlTaHVyT1lFTGNRTXdrQ3NRUVVxdERMSFd0QlN1cUt0cHlFNU5yMFdzbFNQRGZlTVh6d1A3cmRISU55eWdMTkFUN0hRTlhlbiswYU1sWFJtV1ZzVEdQTmVmUVk3eHVLR08yaXlma015Q08wbm1ZeXJIR29xdmFpb0ZRUmtBbC8xT3dBMUNtSnUzL2lQazVTcldZbTNZcExPWlJtaE1jcnRQa2Jwak5jM1VqY3BaSFk3czUzUFVhMHFWK2hoWHMzMTZnQzJ0NUpaQWkrNHRxNXVDa2NMSERXQ1dxOXh3THYzRnc5RlJPSUozYXZVLzAwNjZIZHJTVFNJMHZoT1NXeW15ZG5heVhGa3ljNDVVOTlSV2xBUjZnOVIxMU5aRk1NbDl0eEtHbkI0WVhNMFBPMkVrREZ1TURvUWtyRDlKNWdiQUQzTlhXSG15N1U5ZFR2dUp4MWFKcnA0UjErZjZoKzFzcnU0dVV4OEt4TGJPSzFpTFZDeCs0Y1RTamUycHAwMEc3SkxjK3ByMHhXcy90cExhL2lDUFAwbXg4Q1dkaXRtaEZLeDI4SVdTYU5DSE5XcWErNDBvT3ROdEhjQ0x1WFAxT2E5OS93Q0wwVjJyNExVbmZiZUJML0hYTU52RXEzVnpJMXpJOUt5UklvREp4akREOWJtaW4wRmZocWZNOUxUZlJHVndZc283c2JQS0dlTy94cTI4RWNFSGpkeEhOZlNmOHgvcTdoSDR2SndabGZnaUdtNDNwU3BPZ3VQcld6Zjk2aGZBT3krbTlXdjdHdnFYUDlxY3ZCSmNSNWJHekdhNng5dmJxM2ZWdVFNdEdjeXhuaVR6Q0VxNDlOMUcyL1BjbWVQZlZhTi9pUGdkUmx5MTVtR0t2V05mR2Y2K0lXeW1WVVhpWW0zVHR4M1N6WGdkMVlFczVkdVJKclhreFkrdTUrV3M1V3ZhYldjaHZGNDFhVVVmMjZHbkUrTC9BUDNIeU9jbXVaWXNobGdqWTVYUFpsSWpqZm5DNmc4VzVqa0tHdnQwYmt6cXFWRWxwMUFjdFZiSUt1UXNMU3g4dStyUUV4R3lXQ1ZRU1ZFc3JLek1wTy9RbXRmbnBWeXpoaCtKdVlNYnZiZDRLQ3RmdURscDhibjRwYkN3U3d5R0x1Uk91UmRWa3R2cEpDcmlReGlxbGk3TXJNd3FhME91aTl2eGI4ZXJsV1hUdWNQN3JsMlo1U2gxZlh0SGpBTGZ5VjdtNXh2UERyRFozeVc3UGRMRzhqUlhsdVl6R3NmSGlZNHlZSG9xbWhyOHRHMXc3RTR0MC9UK1puMzVDeVhVMTBzdnpRd1pySC9YWlF5NC9JeGp5RE5QYm9Kc0tGVzF0cG1kbGVObko1UkkxUXpzdlg4OVU0cnBKeXZUWHg3L0FNeTdOam1IVjZ2L0FHOXY1RFA5ZGk4dDVKQmtjdkM4ZmpHRHVMZnhoc2picHhqbU1ETlp3R2UySXFvSTl4ZjNINTBGTlUyVjlyVlkzWFc2R1N4YkU5MWw2YXVQNGRBWGIzdmk5aGNUc2lYTUdHdnpmMk9IU08zUDB4bWdmc1c1a3VEUjNMRWd1UWE5T1JJSjFaR1hhdWpzb2IvaVZwMFV4cFZ6SHk2YTlRVGxKVnZaNHByKzFpRjllV3ZhbnRZWldWcmVPMVpaQUZLOWVha2hUVW40OUcwUlRTWTZUOVNPYTI2SldyWDZDZm5zbzJJRjlCbExGN0pMK1Y1SkhLdjlRSU9RWkFwQTRjZUtjQ1VKcXRhNkx4MTNRMDVneTh0dHNwcnFWWEhtMnZycVo3aFYvZGRwU0FhamNraFRYYW5wclRWWVVJeWJPWEpKdHJpZkV5Tzl0eTdNcUxCY1JEWXNqRVNPdGFIMjdlbTYrbW9XVXVCVnM2anhhWXEreVV0djVINDlOR0wvQUNMUnczY1ROUkRQa0duUGJkbWtLdHdnVDNPRldnSXFBZDlVMnNsNldFVnEyNVJZYVRQZjQzR1hDUlRLSXJlS1I0Z2lvUTl4Q1FBT0lxeEFQenFOWlRXMnpPbXJrM1ZycDBRNGVOWW0xd1BpbVh5Y01paHN2Y3JheEZCd2pNZHVBWkdRY2ovVjdUNmJiYUY1dVNVcW5SZjlkNDNyZHpOSFc2N2tEMGlqa1BjaW42bENSdjhBaUNUWFdja3V4M20yMVBVdFNOa1poYTNQMFNFdVk0MWxmaU9UQmxHei9NRTZzcWs5UWUrUnZSbXpENU9iSDIwdHp6TDN2ZFhpNnZWbVd2dTJwUmVJMUtDdDJkazA5U1htTHJIM0dHbmtzNnhYVTBuSzRoL1ZHcnJ1V1NsS1YrQTIwME5zQ3JocmpzN0xveXU1TENTUmIrV05Dc0pnbGpQRTc4bmo5eEhyU3BHdFBIb2psL2NmVlpxT3pGT0xHWTdBWXQ3NktIak1rZk9lU3BaajZjS3QwcjhCbzYrUzEzSGljcC9qVnhVZHU2RjI1aXQ3bU16UVVhSnhWR1BvZlVINEVhdWN5Q05LeUZtK3NpNm1FZ2tMU2hGVHYrV3JhMmRXQjJyMkpHTCsyZm5tYXQxdWNSZ0xxK3RaSzl1YUZRUVFEU3U1cjErT3JMY25IUnhacE1mSHdjK1JUU3JhOGlOZWVKK1llTlRnNVhDWGRrV1JuS3l4RlFZbFpWWmo2QlFXVWN1bFRwMWtwa1dqVEs4bkh5NC8zVmFMUiswMkE4cXM4M0Mxemo1TFBFM2JpeWE3dXgyVERJV1dabENzUXg1S2xOaHRXdWhjK1NxbzAzcjFOSGhjWE52VmxWdzlDOE12ZVEyR050NHJjTEhhM3Q1TmNjRkpOUVpHQ3RVMTZxRTFnWWs3WjlmN2FuYjhoTEh4Tk5IZXdnK1NYNjMvQUlsSzk2aFdmTEZvTGFPV2l5Ui91c3lzdEJTcUJReS80NjM2VmhwSTRmSmVVNUpYMjNEWFdNdVZsVUprb0pGaXZGQW9DUXRVZGY4QWRjYmo4OVNza3VoREcrejZvYlpiYTRoZmRhcWZVYWdXR2w1R0RGVDZhUTVpSlJ0VTZReG5tSlIvYjhaQUNDSlhrWnh1Q0tzQU54MS9UckI1R3VlM2trdjRuWmV6MWpBdi9Lei9BQ2hDMUhOZFpyeldDQzI3c3krT3dzUjIrSVY3eTRBN3ZMbHQ3SW1SUGtTZEc4UEdxWTNaL3dCMzZBSHZuSmVUTXNTZWxQMVkvd0RoMXRIRGVTZVBqSXdSNCt3V21UdnI0bU9jMkVaVmtqaktWQU1qZ3F6Z25pbEtWYWxLZVRGcVMxUDh6TTQxN1V2by93RFFic2o5d2NUOXZjVDR4amJ1M21TNWxqVzV2RXQ0QklZbzdsbGZ0ZnVrRUVSaGFBRUg5SUpwdHFuSFcyVzhka3Z6TGN6Vkt1M2l3RmxQdW40L20zK3JhV2VOSjNJdXhlVzhzY1VZa0hGcEFJa2tYaUVYaVdaaDZBTFNwTjllTzZvQys4bXhSdVBKL0hab3hCWTVtek1qU1NURzZhNlZPRGc4Z0lveFVoYUVMV254Nm5WOWNkbHEweUR5VjZKZ3ZGUEdiQ2FlWEtMTGNzUUlyS0dXT1hrQzQyVWNrb0FxR3RWOTFldE5XMjY2SXJxOUhxYTg4WXNhbUdrbWpsRUVsNjhza0t5Y3JpYjZlMmxKNlVvT1pLUjhSUWRmaHBVaHQvQWZKcFZmRW0zbC93Q1VlVDVuQlcwVmhkNHJ4SEVTMjgwVjFmdzAvd0NYdWVKa1JDNU5GMlVVcFhyb1NtTEhpZHJyVzF2QUkrNWx5S3RPbGErSUw4ejhuZkc1RzRzVG1GYWVaL1pIQXJRVW1jc1hkdThLQ29KQUo2OWRXNGE3MXFpR2U3cmJSazNHM01tRjhXelBsbVFLaTR1cnVHeHhyRll5eEZBWEt2N2VXeW5rdzJPb09MWkswcVNUdFhIYTdGQ2VkSnNPOHRvTHMzWGtONllyTEd4VEtJcEkxY01pbGY4QW1FZkZxMDFvUFRUd0FOWHIzYkdQTGVHMlZqTmlZOHhXK2tkbVI0NEp3eks0SGNrUkJ4TExIRVNBZVIzSi9IUWl5ek8wTWVKSnBXQmRsZ3ZHTHU5bm5qeDB0eE5ISlN6Z2x1SkRBMGdMQVVYajZVRldQeEExWnZzcTlTdDB4dHZRRjJlU1dTL3UzRm0wY1VDUlJYRnoyT01uY1lsV2pVZ21pbHVQNldxUnRxM2I2VnIxSzFkcDlPZ1pndVJFazZDSkk1bVBjSTNWTmp2N0t0UnVIV3U5ZW8xWGFwYlhJUkxnMkN6cEMvYk1PVEtTUlFRdXNrc016S09SQ3FTVkIveDFDTGZRZVY4bURjOVBiVzQvYzdyMnlnZ0pLd2o3aW9OandqQzdraXA1RS9IVitLc2xXYTBFTzF5ZUp5TnRKSTlyRkREYklCRXJNUlFzck5VbnFQMDdVMVphbGwwZXBXc2xiZFVmZjl2M1MzdlBIcEVZTHFGWkxYbXhYaWtwcHlITGNFK2dQeDBsbFVhOWhmYTEwN2htL3dBTGVpempObThGNUNRSXdGZFNJM0E0eVVyVGNBYXBWMU91aGZiSGJiMllOaHdXUmlsdGhIYU9CSElpU3lMVXFVTFVKNUhZaWg5TlhQTFY5eWhZN2VCb3l6WXVLOWxoeU1za2NyQlN4NThTa2RTVFRwVVUrRytuVGNTaFdoUDFHcTF3YTMwek5ISUlXL2JtakRBTTFDdEEwaS8wMTJPbmVTRnFPc1c1NkF1VERYMXBPYmU2dEdsa0JQR2RDZUo5YXMyNjEzcnE5WlUxS0tIamFjTkVpK0dUalMyN3NUQVJCeEhJb0JMcUZBNHQ4dHE3Nmc5ckp0V1I1TGFFVzBVNExkd09xOWswSkpjN05YNS83ZE1uNGp4b1NCMzRJa2U0dUU0VG5lM0xIbFhvQlJ2bnZwVEl6Y0hrYzk1MlM4bHc2M01zakIxVmp5N1lHNGNlbENCMDBvcTJKTjl3YzF5Nnl5UlQ4WlMxRmVZc3hYZ1QwcUtialZ0V21RYklVNWRoR3JUSHRjVHhjRGpYZ2Y1R25YVnNBN1doS3NMQ1dTSnFGbzJQSm9XRy9FZ2dnRWRDQ1BUVUhkRmxhYUc5MnU3SzVTNXZZSTU0a1V4a1FMeDdpTDFJREFpdnpwcUQ4SkpiV25MTm95R05oalNkckZPNFYvYUUwYW1OalhseUk5VDZmbnFxTGVKWXRzZERHNmd0YjY0NVlpSGphUEFzazZ4S1FFZXJCZ1ZCSUJyVDVhc3BlRjZpdTlKYzFKUGozanVSeU5xYnVLNmh0RmFReDI1a1IyWjJpQU95cnNRUWZVZkxWZVRsVm80TE1QRXRrVTlBYmYzR1N0UmQ0dStDcExISTBVc25IWXNQaFQ4aVBscTJsNnYxTHVENU1kcU5wOWhNWHh1QjVheHV4a0ozNDBZRWsxNm1oMWM3SkZTcTMwSjBOaGIyVWlkMk40K085V1VsanQwSjMwdHlmUVRyRGhtalBZNks2Z2MyTEJwQ1ArWCtsdmp0WDAwMWJhYWpRRHZHUEJNdjVKY1NSUVJjVmkvNWhkZ2lpdnozSi9JSFN2a3JYcVdZOFZydUVXdmgvdFppY05HdDFlRTNjNHEzYlNzYTBIVWh2MUdoK1kwRGJsTnVGb2F0ZUFsWGM5UytmQmNYWTJWb0NzSXQzVjRMYVd3dGlZcHpPaXRPenFoVUl6UnRFcC9kWnE4cURRZHJPMHVTOXBWYVVERm1KY1A0cDUzYVptRGpld3h3UE5jRnU0MGQ5STN0VTlzRUF0R3JxdFBhZmo3dFVWeU8xU3o3YXJiVjlpd2ZxSlBJbHlIajloajRwTE9XQVhER2FSKzdiWDlzcU5BaXJNQ1ZFZzV4ODFxUjA5ZFJ4dFMybjFKWkZEU2E2Q1A1cDkyTHFHd3NiMzdlV3ozRjNnMVNESmVQQm9pZ1c0WGVDVktyeFNJUmJ5b1Y0ayt1cnNlSlcweWZVV1M5cTFuSHJCWkhnZHJjbisyNUlXTnJaM2wzWVIzT2N0aEFaU0g0c1JicGNOUmVhR1NxTXk5TmpxbXRsRGpvaFprMjAyb2IrZ0Z5UGlzV1dFK0V2NWIyMnVYN2tWaGxoY3hScXNZWVN4cnk3SjQwNDlzZFY0dXkvd0NXbE5jOVpVcFFYdkRiWk5XNThCbHN2Q01WSFpKTENsMWJxZ0RSUkNSblpIVGZuR2FHblFNdW9XeGE3a1hMbFBiczBGVHpQQ1hWdGc3MkdDNG5WV3RwSXNhc3lSMDd5YzBSdmJ4UmxERUduRU54b2E3VTBaaC9jcDZBV1o2T0RpYnpmQi9jSTVHNXNNbG5YTVNGb1hhekNyRTNiMm9UQ1J5QU8yNU90cFdxdXhoVzN2dVZ4ZCtDWnZuVlpJcFhKUEptWXE1UHhQS3YrT3JmdW9wKzJ3Zi9BTnUrUldVMG5aZ2N2Q2FPMEwvRVY5Q0NmeTFMY21RaG9ueCtmK2VZeVNLS1RLM1ZiZGVFVUY1KytpcU5nQXM0Y0NnMkJHbSszWHdKL2N0NGhmR2ZkL3lPeHY1TDdoQ2trME10dGNDMzVXd2tpblRoSXI5czdoaDFIVFMySkxRWDNIM0RsbjkzclpiRnJhNytwRjJKWWJtS2NSUUZETGJCaEZ5QzhTVjk1NWRlVkZMVjB6VnBKYnF3R2NmNXQ0ZmtvSU1VUkd0aVovckwyM25jb1oyZWlQQis0R0JGQzdLUzlhdDExRzZ0R2hPbHE5d1hlbkhUVHlXeHZuc0k3ZUVtMWFPVVRSc0N4YTNqazRuWmdLcFgrblNwSTJSb2twbHBqaXJXM2xuaVc1N3NxSThzWWtWN2FkVEZLelVyeFBJRTBJMk8rK3JHaUR1NExMK3kyVGE2dXNwanBVV0JWWmJoVWdMTkdRNmlOeU9YUWxsVm1Ib1RvYk5YVk1Jd1dtVUZQdVZoVnl2ajJWc0dBSGFpYTVpSU8vS0JoSlhwdHNHOWRWNG5GaWViV3BXMzJ5d1dVeFY3TERtZWY5b3ZMYjZtTzFrQWVKNHBGREdXdGZhZUIvUFYrUnl0T3dQalcxNmxoMkZvTVpmeTJsOU55c0hSN2Z2U0hkWWo3ZUxtdEdYaS90UHBxQ3lwcnpGRU1VcDRJNU1yak1iUElESGNSWEhqbDA3Ymd5eE96MmJramY4QVVvb1Q2SFU2VHFSRnJNdVpjSDlNNHFVQWpRazd4OEdZOGQ5OW1KRkRxT05QY3l5OGJWQXN3WGtra1hOd1NHWGlhOUFWb1A1YXR0Uk1IRGxsNXJaWWkzWENISExKWVhzUk9STWJGWlpMbHFvMGc1RmwzVGp0eEcrcW5pYjFucDBES2NoVlVSbytvczk0d0FpUGczRWg0Wk92NlRzZldtaU9xMUErNWI4VjJ1Vnc5bkpidnlqdW9oTS9Hb293UHVYYllnTlhXUGUyeTBHM2pxOGxVMTNQc1Q0eGpCZjJsME83Y1hqT0pDM1Bpc0pYcWFBRW5wME9tV1p2cjBHZkhpSUlHU3RYc2Nya3NKT2hpaGtvOXRJTjFjT1dlTUNsYVUzRk5GNGJKL01CejFoaWRlZUVadklDNWx4QWpsdG91TFhFTE9JNWtFbjZhcWZRa0hmUlZzdGE2TUYydG1QZ3VSdWJISjN2aStRUXd5MnhZeHh0K29rMDVEYmJZMFlmTFZXYW05YmtQVjlobzgvOHJmQmVMdGhMUmg5ZmtlTUZxeWtoa2ozTWtnT3hGUDBqOGRWNE1kcGxrNzJTV2dnMkR4MjJJdFk3ZE9NdHJVeUd1NVJ0bU5QVWJqUnpLZXdCbnFBSm85MlZ0OXFVSjM2YVlyaUFuakgvQU9ndVRGd2p5RnBJbVF0bUJxU0JSV1VuK0cya1dMb0g4OTVLTWhrN0R5ZTJSMXRvbGdneUVzWm8wa3FEM1ZGQnNFOXJFOVNOdE1QMEdQSzNNTm45QjVHS2R1MFlKY2xUVU5iVDdiL0dob3cwa1RmaVIvSTdaWUlyYkkySklObXh1TFdTTTE1UnZYbkZYNE1wUDVqVk0rcUgzRTU2bW5OWTRTMk52NWJqdjNMYVMyaUdWdDkvYWhhaGxVa21vVnFjdHR0SktGdGZ5SnhDM0lPZUczaXFra01TTExDc3F1VmxKUEVPT0xrOGY2ZCt2WFFlYnpORGp2d0NQa25qMGtRRnpqV0VDSS9jbUJja0pKMVZ1UHcyNmhScW5IZnN3L0xoc2x1RC9pMTlIblZzSWU3MkxtRndibFhJN2d1WVJVZG8vcFZIcFdoQS9scXU5WVpiaXR1U2tGZmMvTStNWTZ4VzFNVnZkZVFMSVlraEVoV3NKSlpqUHhvUU54eHA2OUR2cXpEUnQ2ZnRLK1ZtcFZhNjJLQXkyY25ndUhrWGd1UWtwUVJqMlJMdUFxZzFwUWRCclVyVDZIT1d5T1JjaWlrbms1TVN6dWQyUHFUcTV1RVVqOTQ3NDNQTGFyUGFRdE5kVkNtTlZMR2piZnowTGEydmtYS3BiSGduMnV2TDNMeVA1SGJmU1lxQ05UT3R5RlIySkFkVUhYWWcwSjlOVjVNeVM5SmRqeE52VUFmYzM3bDJabW04UyszMGFSMmtNamlhOWpYaXNTZENFYXBCQkEzYy9scFlzVGZxc1R5NUZYMDFCR0F6UGwwT05teTBTMk0xallMOVBmUXVHaWRVWUxRdUsxWDBqV3RPVmZYV2RuNHVGdFZiYWI2SFE4WDNubFkvVWxWcXVqUklsOHZ6bUp1emVOaTdlR0MxQ0Q2aTJra1ZPTXFxeGpBS2NXYmZjRWZIVmY4QWcwc28zUDVoeS83QmxwYWZ0MVVlRGY4QW9JbWJ6NzViTlhGL2JCMDJqUklaeU9YSktLMU9JVWZxWm1YYW8xcTRNQ3g0MVZuTGN6bHZrWlhmOGhxeEUxLzQ5bFliL0VCYlc4UkZXZXlnWUNTNDQ4V2NxMjFYQU5hVjZiYjc2R3VxNUt0VzFYajRGbFc4ZGs2OVYySFR3dkkzZDFrTHpLbStOcExicjljWGUzK3Z0NVBxSEplR1ZGRmQwNDBmbDdhRTdqYlFIS3hwVlZZbWRPc2ZNMU1HVjYybU8vU1ZyMkxLK3g0TVY5NUZuMVNHd2p5c2l5TmJKTDlSR0N6eUlsVkFBVlF4SVFqOVFyckQ5M1UwcFNXOXZrYW50dEozMmlOemtQbkpXa0hrc3VNdjcrU1RJTFlvWTdhSWo2aVJaRkJwSHlZS1dKSS9MMTNPZ0s0bThjMVdrOWY1blMxdlhidFVidXNmeElENVBPTGQ0NmJLVzhhUVltR2RiQ3pNb1ZJSWxRb3NnSUpEeW1xOXh2eVdncm91MUtLalNlcmovVDRBdUxHN1paYTFaQXVNdlBuNDdlL3VUSEhjR0tLM3Urd2F3bTRpWGpJMFpIOUorWjBMZkVzYmRWMGIwazMrRlZxbXJsejI2ZklGK2YzZU55bmgrRXVibXhtL3U5bUJCZHg4bGpTSXozTDJjY2dZUkZubFZsNThDMnlnZE5iL0FBcVdwZHBOYmY1S1R6NzNTeXZaMmFoejlOWU04ajRuNWI0dGxVeEdQSkdMa3Q3R1lYTU1TOXE3YTBNaW1KZVpWQVZEOHl6bnA4YWN0TjkvRmw5VDZ5MUhoUGY4aHNlTEpodEM3UnJIWHJvSU0wZWR3VnZGazdZUlJya0x5U2VHR3pwTkduWkJwellFZ2NtdHkzRGNNT3ZYV3BWMXRwL3RYY3pyNzZhcis5OWliZ1JrN3UydTdXMFM4dUsyazJWeGhSd0VOMURIMkxuNmwzQ3J5VkNyRkFwcFgvTnBYMnBycDFoL0RzUnhxOXF1SjZTdmo1bWNNbHg1QmpjSmdWN3VKdFpZdm9MT2E0dHpLanlTVmpsNTBIR1AzclZnT25VOWRKMTJOMjZpVnZ1VnJYcDI2QSsyRjR0cGF3aVJidUcyN3FURGlZNW9uWXZDeU82S0hHelVhUW4yN2VtK3JYRDFLSmFTOGhDOHV5aU5qN2lSWlhsbW5qK21keUE2b3pFRThtWWx1WlZmNmR0R1lLT2RRRGtaRjJFN3h1eGp1WDdjM3RodTVrdDFtY1VUWThtRlR0V25wb3hzQVNIakc0TzZ4Y1p5YnhOUGpaSUU3ajByTmJmM1NSNG9uQ2lwa3BGR3owRzQ2OU5RZXVnOEdUWFZ4bUwyL3dBdGhqYlE4NVo3bjZmdXZ4a1c0YjZLRllvMVVLSkVRbDZxZDFyWHBxdUlXcGRWdHZRdFB4ekg0TzB4ZDg4Z2t1TWhERXN1SXVCSTBRaFFyMldJSHVxU1dWa0ZLZW1zbks3dHFPbmMzK09xTHZMalFzWEtZY1l5encvajhkV3Q0SWVYYjJMUnRjdTB3NUVFZ21oM1ByOEFOWk9lKzdKOGowZjJhbjJjSHhZRXM4ZXlYTVRzNEZ1aEFrVlNXUW1oNGdFNzcxMzFVNzFnMnZWT25ZK3pkdFBGS0wyMGtJTUh1dUdCQllCYXJzZXRLRTErWTFMRzEzS2J5K2owQThzRWkyS3RZS0RJdE8vQ3RlSmlrcUN3UHJ5cnZxOVBXR0QzVm85UFh3OGdmSTF6SGJUcTY5cElVUmxOU1ZJOWEwMnB1ZlhVMnRRZTJScXIwNkdpeHRta003RmlJN3UzSmpoTmFnajNBamtSdWFEYlJ0Vm9jWHlzcWQ1OFN2ZnVKZGZRWWFLME1uS2U0bFVTZ0NoTzNOcW4xOU5HWUt6WXdlYzRwSGQ5Ukp4Ti9ORTNzaUxvZmJKSHVkaHRYOHRFdEdYU3o2b1o0Y1o5ZmRRd3hyVHZGUjBvZHpwVlpkZXN0SFE5dmxzZDRmZ2lYUmdzTUNRV3RyRVFKYm1ma29qamlYcVhaMjQ3ZkVrOU5ZUEl4UFBrMDhmb2Qzd2VSWGg4ZWJmVHhLbnlIM0x5K016OTMvY2JKWnN0Szl0UGtHTFJ1b1dBQ1JMUVJ0VUxIRTIzdFB1UHVPNTFxVXdWMnJhOUYrSk9Zdjdwa3g1TGJxcWJOTno0ZjdTVGJmZHlkWmt2SllER2dubnZTdlpFZ2FhNjVBa3QzYSt3TnhYVVA4UlJCWmYzcTdlNXBkWi9Id1BzeDl6c1huN3pHWVdMOWlIRzJxcVRSb25hV0pCWGszSmg3bEhvZFdZZUp0ZHJkMkQ4cjNWNXFWeDlrUUx5VzRtbnNzTzF4T1k3YUsyL3FMSUpIWW1RMUpKQkVmdzlORzBYVm1Ua2ZSRmkvYmJIaVhHVGVRQXR5a0pRY25KQmhra0pqRk9ob0YyK0g1NldTdnAwSlluTEcyNE1yTlZhY1JvZVFvZ3ZicXhKYnFldjU2UWlKTGJEK2c5T3VuRUR2TUw1Y0pEYjNjem5qWVdJbTdURHE1SEpSVC9pWUFhNTlWKzVsc2wzdEIySEd2OEFZNDFMTjZKTzM1aXo0amZyanNianhhdk1jcGZUelQ1QzRLZ1JrN05QS1phVkNobjdmRmYxY1RUV3pldjl2Wkk1TlpXL1U5WFp5V3Zqc2JEZDVxTzA4ZnVDc0VzOEQzN3lRZ1BkNUZtNHJDZ2tVQUt2YlJ2MDBDTFUxMzFuS3piaDlPMzh3NUtxcks2dnIvSXZ0L0ZzZmJZbUhIVFEyVTk1WnJKSU1uZlJvekdXUm1aMkRPajhReEk2MStRMW1QTEY0cjJMVkwxZmNTL01QRnJXNzhidmx5VDI2Um9nRStSdEUramQ1SUVhVXhROFFDMFNsU3p1NFZmYjY2dnJtYzdsNHdRZEt2UTVtd1BuR0p4ZUV4dU95VjFiQzdlMlcrbmVlemltbVFrdVlvKzR5TlV5VVdnUHRVR3ByMDF1M3h0dHRHUFRLa29aSHV2S1B0akdMLzhBdlZoYTVLOGlhSUpkVzhVYUpUa3hrYU43Y1Ftb1ZsQTIzb2E2U3BrY1JvTzc0OVpVazZERDVMR1lKZkxQSHZFN3pFWDk5TTR3VjlNc3Q5Y1EyYkNvbVMzbWR1TEVibVVxUW8vU0NlaTNMZHRibnhIVlh0M0pSNEVGZkpCYW04bnZjcUh1cks0aFMydThpOGt0N2V6RmQzWDZnS0k0U3hibTZJemUxUUI2NnQycHdrdFAwS0ZacldROWhmdWhaNTNKU1FTTGJSUUxiME5yYnd5WFYxM0k1VkxUa3lvM3U0N0JWQTIvam9MTHg5cWxkUS9CeWR6aXc4NWp6SEE1UEdUU1lXOHh1VE5sSEhIUGo1dTBlNjVEZ0JWNDBEQW9PVkJ1VzlOWStPdVN0L1hWNm14a3RqdFJxbGs0RVBIM0dQdFBLN3U2OGRzY1JidloyaXkzY3pUY2V4UGRraU9JencxUlpUU250NmY0Yk1OMDFucVl6dFZYN1NnVmQzbDNjV3NkdmF3U1dHYzV1SllyYWN6STZ5anVkdzNRWnFLUVNKYW5sVUFFVk9wS3FyYWV4VzdPNmp1TUdDcy9GWjQ1c1BkWDZYRnBiV0xYYlhqM1JTWVNFTzBpaU5WRzRZZEtualViMTBIbHlYWHFxdThCMkxIUittejdTQy9HY3RoY21rTHBDOHRqYzNqdkxDelJtWjdjb3NjUlpaR1ZqUnFjdUEyNjZMdGpmZnJBSFhLbDBXa2t2SllYRVdrYytVaW11RnY3aUtlT1dCSnJoQ1pFZFVxbEdidWdnK2g2alZlNnllM3NXS3RIcWc1NHZoOFBCNDU5ZE92Wm10WmJabXRiZU5USnh1RkFDbDZBdFZpUGRYMDIwUG52WldDY05LT21xNkN2NWQ0dk9ZMGplQ015M3QwYlZtWWxDTHNxSFY0NlZvckFFSDU5ZDlFNE0ydW5ZbzVHSFFXVzhKbnhOMjJNeTJMdmJhMm5Fa2tWeEE4THl5S1NBbkxuSndBMlplWHdPajNtbFNucVo2d3RkU1dMTzluYkhDYU53MGtVTU1SdCtNZzVGZ0N6OXVwcHdHeE9xMWVxa3NkVzRQYm8zZUh0SisvZC9TWEgxekhHckdoVmFXL0ZWRHFGcHhJWmpVN0hUNldmeUUzYWlmeE1wWUx1L3dBUGNYRnRrWmt0YlpYWWR4d3RUQk94SlFLS2N1UHArQTAybGJSQS9xdFdaSU5sazdlNW1naHljWnV6TE94ZHAxVU1za29ySHhTbXlnVUorZnBxZDZ4cXRDR084dEo2aEdESFhWemxDYlJKaE5QUkxqOXAxQ3FFOXc1YktPbngxWFc2VmRTMTQyN2FCbkp4Wm5IMm1ManRoOVRZeXE2NU9XM3BLMFJWanhEQUVxSEswQkJGUG5xdXUxekpiZDNxa2w4eU9GaGZETXoySTdVRFBCZFNPRlE4cENDQ2gzcityM2ZBNmY4QXUwWXphMjlBZGRZQ0dFbVF3RTVLVUVXQVZ2YXBDOHZhV05PVlBrUDU2dVRmVHNVeFZycHFEcDhhY2hkV0FoUnB0eWt5b3ZKMWNiRXM2MXJ1YTExTlpHazBRZEphZ1A1RERXTnJNa2tpeXBNV2FPTm0rRkJVMEIzM0ZORDF0WmhOcTFxUkxMeEdDOW5aMm1MWE1BSEtBVVJFVXJ5NSszWTdIWTZWc3JYYlFnc1ZmRUN6K0xKYmlXYVNseFpMSS9ZbERld1NNTm1ZRFkxUHFOWHJLM29WMnhKS1RkSFkyMGlFQ1NPT2IraGVXOVFxbmY4QXkvS3VtbGtVcE1yN0ZYa21IampqamVSKzcyNHBwV1NObGpHM0toTlNwclVEODlNcnJjVGVOeHFEcmpCdlBKRERid3VseHpNYmxpc2NSV0JlUkJxVytINGFXOUlyKzN1aEl3eG1CbWRycU15eVcwOFo1ZHVFbFY0TTN0SlB3MzIxSzErZzlhZFExNDdudjdiS2NUYzJ6M0tXWmxaV2lqN3ZNYjhhS1JVZitPaGMySGQ2azlRdkJtYVd5SlBzUmpjSGQ0bVc0eTd5UzVpYVZqZHdPd1NXSXlFbFdBWUE3KzNvZE5lMWxaS3ZSRXNlT2xxdDI2c0VaL0EyOGRxTHF3VTFVS3JUS2FlNG5mbFdtcnNXUjI2Z21iQ3FyMGdTOXgwbGhiTGV5RVhFTEE5MG4zRG51S2ltOVIxMFFuNEE3cXVwSXQ4UGMyTTJOdWJ5MkFqbUtsWmVZb1ZrRzNYcDExRjVFNUoxeFEwMml3dkdzRGJXOS9MTEVvaTdqQVBMSFVVNWtVNC9PbWdzdVZzMHNHRk93WXpUcFpUS1BxWmtrdG9yaVMxc2xTUHRUU3JSdVRzYUgyZjVhME9xc2JtZk1LejQ5c09Yb1RiZTV1Y2ZpN0hKWTJkMXViaVJrZEpFYWVNWENoalhpU0RSK1ZPUU5WOURxMnFUbE1IdW1vWkliT1pISTVUR1NTM01WMjJPdkpGdm5NQWloTHh4cEtZT05hMUpVKzdrUTM0R21tZUt0YXNiN3RyV1RrdFRMZWZ6S3F4Mmxra0dWdWJKNzZ4dUFqQ0FwREdqeXh6cEg3ZjZheDBxR2FuejFuNHNTUytEQ2NsbW1sM2FsRkwzVjlodkt2Sjd4VXhKTjVrWTdtTzh0clZsUXJJa2thOTlGbVZYNXNBenRHTjIzMitPczN0clBnQjQvWGFQRXNEd3lESVl4N3lmQkxkM0Z4amdiZXhzSlpKSEFramVpdlB6SzhHQkFtUk4xTkI4YUVDOTlkZTVwMXd5b2pvQzV2dnprdkcvTmJtejgxZFd5MXNxMjh0ckpGRDJiYU5sRG8wYmNxbDJETXptbENTUGhxMy9BQk4xRTY5QVI4bFk3dXR0R1d4NGw5Ky9IY3JZeFc5d2VkNDc4M1dSd3FFTzNHa1QxQUxBQ29EMG9QVTAzcGVLMU5IMEpWMjNlakN1USs0V0F6ZHZhVDJyeVdzbHRQTE5hcE9vYU5oYlZYdHV3cUFKbFBzNjlmbHF4ZnVhN0RYeCttZTVYZmsvaG5qL0FKUExOa1BIRVdrcUc1bWhRSDl0NU4yRlFLR3A5M0lkZjQ2T3hXVFVHWGxyRGtxZSsrM2J6Q1NjUk9HVUZYQkc2OGZYZjAxS3oyNkVLcVJIeVBqYjJNeFczNVNrQWhveFNoSTNyVVYyUFRVRm5Vd0Uvd0NIWm9WTXpnNytjU1hLV3FkeUtOakV1eEZhZEtIZWxkWFZ6SjZTVTI0bHFwdU9oWFp6VmxNQUx2SEl6ZEM2R2gvZ1IvdDBZNlBzek8zcnVqRzNUeGljdjlSTGMyekduQ2loMEh4clNwMHZVdk1iMG01c0hpNWdUWVppRm0vcFNZR01uOHpUUzNOZGg5cWZjaVhXSHlXUGZrdEpGQTVkNkIrUzArTlJxYWNxU0RVQmJFNHZ6TEpCSXJLR1F4MTlqU2dEZVRhZ0xlNDFyMEdtZGt1cEt0SGJvWDk5c3NGNVpnczNhWGVidTdNd3poNDVZSVlYRW9MUlZWUTlFWHJHdm9kOURYdXJkQW5IUzFiRmorUWdXc2tjNEJsdEpxVlY2dCszTnNlb1B4ME91b1RaU29JZmhIaDl6blBHVGQyRitxWlhCdzNtRE5yUEQzWVpQcCtZaExua3BIS0NaRi9ubzJ2WDRnYlVyNEdHTWppeTJMUzN1aEdMa3FiV1paUitwbEd3L00vSFExVjZuNGwxa29ueEtwOG14dVV4OXBjeTJzNU0xdGNSWFZ0TC93QzdISkV4QURINHJ4OXA5ZEUxdExoOVFWb3h5TXEzYXRrSXBWbHQ4aWkzdk5mU1J2OEFtS1FSMVdSVFhWVzVieXlHcTZkeEFNa2tFdDNHZzR3aVV2R1FDQjd2aFg0L0RSSlF3WmxsK29zMXZWcURDL0dVVXAxK0czcU5PaGpHeXVJK3dEVGxIK2h0NmxTZlU2Y1JZdmdPUmFGSmNKUGNGYldSWGt0V1VFc0dHN0lvOVEzV21zN2xZazR0QnBjUFB0ZXh2UXN2SFpMSDRPeTcyUXRaRW5ia3lRRlU3anF0VkozTzN6cm9EN1ZtdzYzSXFxaVZtdkxzYjVMbUxjMnVQbnNaWVJ4YVdjcVVka2JsSHg0OWFWUHI2Nk54OGUxVjFNM1BuVitpQ0hqbVFpeFhrRVY3ZVVOcGVzTGErYzBFU0xKc2hwOG5wMTFkZEsxZmdEcHc1QW4zbjhabjhmeldNOHdzejI0NTJOdGVTSW9QR1JTUUNWcVJ1dTM1YWx4N2FiV1JzdTVYVjNjNVBNWkU1ZklSc1k0a1cydEZsb09LTHNDYWVybXBPaVVrdWhDWk1iVUZTbEc1d3M3SVkyTkF3cHV0Qjh0S1JFckx5VzVZTXpnM0VLQ0tTSkZvenc3RlpQbUtNTkloWktSZE1nU1VkdW5GMTRzb0ZRVjZFYWNVai80REhhNUZjajRka1lnQms0SGt4VWtsQ3l5amNVUHpJMy9QVVdUVE5uamwyRnRaOEJrQVhsdENiU2VPVVZMd01hTFd2U202Nlprayt3YThjamFYSDNHTnVHRWx4aW5OczZQN1MxdVR5aVkxclgyK3VoOHNMVW11a0F2SDNENCtYSitNWHJFcEdROWkxS0swRHR5NEUwM0hWZFRiM0pXUXEyaVVZV0ludytVTnBISUVraUd5N2Z1UXlubEdUMDlDVU5CMUdxN3JjcExzZG5SbG8yVjFZNXJGdERjczBWd29FY3JnYmZzN0k3RTA1VUFvYVYxbTJxNldOM0RrcmtyRFlqejVXNzhmeWQzYTRKR3VzckxEMnBZVWpadTFRa2liMnFSN1FLalJGY2U1YTlBTExuV08yblVxSFBaNUpyaVlSUnRMZXN4N3VRdUs5eHo4ZUo2RWRLL3kxbzBwQ01qSmVYNHZ4QTF2YlN6dUdZRm1rTzVPNUpQcWRXdHdVamhqUEhtRkVkRDM5bVduVTEyQUE5ZERQSW15U1IwajlzUEViSHhmRVQrWStRemRscklPczBMTVl1d0l5R2JrWDI1TlFVTlB3NjZDeVdkbkNEOGVKclVxdjd1ZmVTVHppNXViRHhzZjIzeGlGaXMxK3c0eXpBaW5hVUwvQUU5U3E5VDFKMFZpd2JkYkZlWE5LMjFLWGVScmhEYjJrWmhzZ2F0WDNPNS96U01PcCtYUWFOQXl6Y2JhVzk3aWIvRll1QzVna1o0N3VlMk1rWTdrc0tzeU5LeDJaYU94VWVqZngxazNzNjJUdEhnYWxLSnBwVCtQRWtlYTN1Y1M2eHR0YllvMkZ4aGxGL1Bqd2drdDR5dkJ6TEovbVhnRlptS2hmZFFkZFY4V2xJYmRwVnRQNkZ2THZmU3NRNjZpcmFjSHgyV3pHVC9leVdUazVXVElPVE5Pejl5WGtUVUJTRCtPakgrNnRWMFhVRG8vVGF6NnZwOFEvd0NONC82aTF2Y2pGT1d2bWxFVXBBRWdacmhlYWlqaWxBUnNCdlU2cHpYaHBkaTNGVnViQlB4aTZGaGU1eTNhVHNaZEZpdkxLZUJBaXdPNnVaNGxFckFvQ04xNG1vME55Rk5hdEtWMGY4R0g4U3MydFZ2WHIvTkY2L2FhT0dIR1grVXljc0RXQmd0K2JnaDJTNTd2ZGVJaWhEZjVoUTFGZGN0N2phZEtyV2RQZ2RweGNkdHRVb2NydDJZdTJPYnpROHN5ZmtUM0JmQTJyOTIzeFpDeGw0T1haRENVbHdHVUZ1UDRiMEhRdW1DcnhLcVhxN3Z6K0JITnlNdUt6M05iT2xheC9Fc2pKV0ZybGNMQmQ0eGhkMkYvQ3BpbVdvNVF6RlhMUmtWSVBIcjgvbnJNYmRiN1gxUWJpeTc2VFZsZjVYTTRyeHlLN0VzVFJXMFM5ekd4Umd2ei9VcXBVZ0FGbUZkem95bkh2bGFhNjl3ei9PeDRNYm5TRnA1L2hpWFkzK1Z5RmprWmNrMlJ1SVBJNFMrUXQ3WW5rdHpiU3dsWnJkTjFRajJvVFRkQWZscm9WanJXRW85SFQ0ZVo1NW55MnlXZG5QcjZyelhTQWw1TGxzcm5MekkydHpGZFJXMkZzSW9NYzZUTUVFYlhDbG1rNUZpV2xQc1duNmR0VVlzVmNjT1Y2bnFXWHZlODZOYlZwOVFuNDlnYnJCNC9MWHZuZVNoeC9kaVlSeTkrR1p5MGl5Q1VyQ0tQekNJQXFMU3Z4NmFyejVkN29zU25YWDRCUEVyc3JrZVp3NDArTEJHYWt6bU5HTnhXR2xsdmJpR3hDUGYyOHA3Y2QzSlJ4RWhOUlNzaWR6cFJ1cDVhSXhLdDNhejAxL0g5QVhMZTFLVnJUckhVMVl2SzNzYzEza0ljNFd5RXFuNm5Fd0pjZCtTUzRhVVhFc0NxRFJTWEZhSDNCQ2RYMnFuQzI2ZUlKVzdsdmRyNEcyOXpVcjVLK3V4azdacjZRUzJrOEJCaFdmdW9wdVk1MWJhTnVTbC9YM2luVFRxbWlVT0NMdkxibEZMK2FYakxCOU1JaEZiU3pTVHdzdlZsYzhRMUNCUUVLU0svSFdwaFdrbU5tY3NZL0I4ZGJUWTZQQ1hGdXY4QWRaYlJ6Wldsd0ZKbnVjeE5IYXdQR1A2Z2lNei9BQ3BxVnVza0toM3lnM1hqY005dmo1L3FjQkxjWE11T01oTWwzRWxtV3hWcXhZa21TT3ZjWkZBcVBucVA3dmorR1RqYitQa0xuajJIdm9iOFhHUGtqbXNnOGtwaWpYakhMSGFEdGh4dVdWaVpOcWRkUXlYVWFrc1ZIT2hadmptQlM5ekdNeDR0b2t4ZVl1NExkcnNLNVpEUlhNUWtmanY3ZVZQbVFOQlh5ZC9BMU1HT2JwZU1GcjV1L2JJNWU3dXhVUkIvMjFBQUFvZUFJcDhocm1MNnZjZXljZkVzZU5JZ0twaFJTdENlWEovbU56K1g4TlRpUWp1ZldjWGVwSXA3ZHVlUktFMVBLb0pxUlhyOE5POUN2VkF2SzJiVExPTVhLc1c0amtEQWhRcGFqS0dyMDVIbFQwR3I2MmpxRDVaZFdxOVJkeWhodFJGaTV1NUhKYnJ4TW5FcUN1NVZoL21BRGRORVVUYmt4K1ZrVkZzYzZFRVRISVhkekZqUGNMRlc1THVwY2NndnAxRk92ejBjbENrNHJONnNqalZsUy9jRGxkWm0zczNiMjI2Rm5VYi9BTGtoL3dEQlJvM0JvcE1mbU9iS3ZnYThiWUZZZGtDa2lsQ042RWpldWxaNmthVmhEcGdueG1IbnNiM0t5ZHUya2w0Um1oY0FnRTFJSFJSU3BQcHByUzA0Nmw2MjFhZHVnL1JUVytTZHZMcmlNZjIvSExKRDQyc3k4V2VXVWNacnNnaW9xQUVpK1h1OWRaNzlDMnJxK3Y4QUk2Rkw3clYzK3lpOVBtL0U1eDh6VjcvTlhWMDUvZWtKUEluNGExOFQycEk1RGsrdTdmY1ZhTUR3YW9ZR20vcG93QTZFcTFNa0xwTEczQ1JTQ2pqY2hoNjZrTVc1Z3NxTXZaL1VVWDY2MlNlVzlMYmdrUWlKUFhmYnArZXFZaGwxYlNYWjQrUmlQQnJHMm9GZDVsUUFkU3R2RUYveGZWbDlNRm40MnF2cExMOFZZc3ZnZW5LQ201L2hyTURqVzk4cmdyV2xmWFR5TWExbGRtRWNZTHlNUUVVYmtzZGdCcE95V29vRmI3cTVDMXllZnRNQ1N5UnlqNmk2VWJ1TGUwVDJ4cjh5dy9scks5dW85YnZ0UDUvME9nOTN5TEhpcGg3d3ArQy9xSFBHc2MxemNZLys0MjVzbWxRL3JaVWtXQ3RQY0hxaWtxenNEOFI4YTBQeVByRE1HdWhaMzJ3Uzd6ZjNFd3R0SEpJME9Fc212c3ZaM0s4bzdhV1ZYN1lSalNybU40RDYwOTI1cm9hMEt0cjlpOVBXdFRvWmdoSmN4UGRBOEFRa2ZNRGp1RFQ0MXJ4clRmNGE1NmxFN01NdFovQXJyN2pzdHI0ajVKbFlGTnJMWTR5N2IvcldrbGtCYTFrSEhrWEFrQWJlckVMV2dXdTUwUlNpZDAwNVRhSU83VkdtbzZuS2QrQU1TdUd2cldKN0QvcGJHTHV3MmpwRXFXeGRwT0NoNXVRRVR5TXhGU0QvQU1PdW1TVDlYY3hIWnIwOWdaOXZyYnd2Tlo0NUNmRkJNZmliSCs1VzlsRE84c01ydEtSYnhsQ2pQVml2SmdXK1dtenUxYXVIcXllRGJhMnFEZmtCdWI0NVhJbkpTWHBtaW1FdjFMTkJCWUlKQzg0dDVIUEtRa050RkVLa1Y5cEcrbzBVSktQNmozY3pBQ3VQTEpzYmhySm9iU3pXM3NacEpJcER4RXJTSXFNdzRTMDRCRjVNUXFnQXN0YW5iVnJ4emFTdXVWcFFPTmpOZll6RDIxeEpOZEVORWt0eEwzbGpNb3VwWkdQdjRqaUZWbGFSbS9wL2tIYXlkb2dMVmJLc3BtR0d1OEJMS1BKZkk3VEgzdG5oSTd1SzJOM0pEZXh1NnNDc2pROXRSSkkreUtxbmlCN3RQZFA5dFpsa2FQOEF1dERnMTNjbU95UGllUnU4eFp4MmFNYmJLMmRuYlc4TnRDN0h1S2tjUFpXakxVTFdvTy9MVHFhMlNUOGgzRnFOc0RZKzg4UHcrWDhabThTZTRmSlhqbytjeDg2bjZlS2FaUXZGWFlVWUNqVUFKcDZuYW1wMis0OTIrSVhSbGF0anJ0ZEpsOVN3c25uTVI1Qm5NK3VJeWl5U3k0SzNsZ3Q0KzBaTE82aG5kbmhJcCtza0JhZGFOck5yVzJPaWxmM2ZWTTFGYXVXN1U2N1FMNWRqOGNMREczUGtqMlVlYnliUlR5R1pWTlVabzQwaGlDbFc1Z2xuWmdOdlhST0oyVm1xekNCOGxhN1Z1alVpM1ZwNHphWXE3dTQyaXM4Y3R2TGFwYzNNNWU0ZFlwR0xKQXFNU2p6SGp3WGtOdlRycTJMekhVcWRxSmFhRTNBZUVadzRxQ1Z2SmhqMmdXM2RNZExiZHdKd0NUUkh1ODBMRWxsb0dHM1RWT2JMVk9Oc2x1TEUzV1U0Q2wvNDVHbmtjTjE1RGZITVhNelRMWk5hS0xhR0tXQUtHaGlRdFJISEl1enRVN0hWZU95MnRWVUZtU3ZxVzV5WVcySnhxdGRYdHBIS2tZUDA2MmM5eDlVWlJVRldVOXB5U0NnOXF2dDhOVCs1YUlaU3NkVTVCbmplSzhrdnZJNXBMTm9idkpZbCtNdFNHdG80WmxKaFZFQ0J0aWVUKzRVMzFQTmx4MHA2dEJZc09TOTJxNmt2elB4L3lSN1NNWkJMZTJ4Y1REaHU3RUtoNXQyZ1ZGQXc2QW4xK09xOEhKeFdjVmVwZHlPTmxxcHN0Q1JMNFo0NWpMSEN5NXFJdkRNNStwaWVTUlFxemJCaUM2OHFsdHpUYXVwZmRzN09DS3gwVlZJTXNJc1ZZUkprcmV4L3R2Y2FTWmNjdHVKUUlrTWF4dXJjQy83bk9sWElyMXJUVnVyY055Vi90MVNndzh4ZSt2MVNiQ1k2K3Q3ZU1scjU3c29RNWZnVlNLS0oycXEwZHFtbTJsaVNxOVhJczEzYm9vSTNoOXROY1RmVEk4czJPczdkeGZOYzI3dzI2a09KWFZnZVFOV0ZOeWErZzFibmRZMEtlT3JiaDA4dHdOOWs4UEJsc2dJSWtsdUxlMk9KU09OaXRwTDdsZVoxNUNsRkxMVHBzTkIwc3FYMmgxazhsZDNZWGJMeGF5RUYxY1dhaUN5YVNTQXlRcXdkM1VlMVNhbFN0U0FEL0g0YU9odnVBN3FweEJBd054QmJKaWJISGdKSzdLWnBtUThKQklTMUEwYTA1bGp4cVFPbW0yN3RXT3Nqb3RDYmtjUTJUbC82ZHpmbUZ2OEE4R2hhSklVbTVVQkRPMUtWQitaTzQyMUJYMjZFOXU5eWpkRjRxUDdYTTk4Rml5VXpSck5hVzhoSTNxRlY2TnVEeHExVFRWZS93SjdZWHFDc0dEc3NtTFN5alVQZHNYRDQva085R3FvQlV4MTNxMUtOODl0VzEwMUtyS1drYXJQQTRYQ3o1REVac0RIeVFRL1VRWFRnTEpJM1EyOUtHck9QMDE2NzAwTGt0YVUxcnFFMFZZZllnU1llR2V4dURMYjl0QTQ3RUV4UkpVRElhdU42bGV0QlN1cjZXaXhYYWpkWlpwdy9pdHpmenJlckhMSkZiTTZSVEtBaVN5VUpRcUNLRlZHMys4VCtHbzVjdllXTEMrckIwT0J6TjM5WGRXODhWblBNRGJ5VGRubEY3R3FlSExZRThxcVA1YVNzbkhjaTF0bFRETWNWZ2IrM3VwYjVMeDN5Y0VqUXpMTkdqSXZJbGpWRkNBTHRYNDZWMjc2TVZJcDZreWZrWlI1R2xzMXppNHJUS013UnNoQTNhU1pERzN0M3BRMDlHR2hsUzJOdFRLOEE1MnJsU2xRd0pmZU93MmcrbXRidHJtMXVKbFdXMWNndURVQU1HWGVtOUdGS2V1cFlzOXJ2VlJBdVJ4YVkxTmJicDZvaFduZ1ZwbDh6ZVkyOVY0SGdoN3NDeGJFZ3ZUb1FRS2o4TkVaT1M2VlRRRGg0MWIyYVlTZjdVNWVhMWl0cmZMeVNXVnZLWkxPSzRpRGNPSnFvcUNEVDVkTlVmNXRVM0sxQzF3RzBrcmFCV0xCZVEyTnFzVTBGdE9zYzBaYVpPNXk0Y2dLallqMXB2cUR6VWV1b1Jod1pGWlYwNmdueW15dUxqTzR1QzJFcUQ2Z1F6cWdWaXZkWGxTakVlcWdpdXBjZXkyMmtzNTAxdld2MUhGOFhkM25pVFkyNjRXbDdZWExHTUszRWlHVGs2VmNDaElEZFB4K1dwMXlKTURkSFpha3p4ckQ0dTloT0NuZi9BTzdjWGNuTTBKWnp5dDY5c2NPUlV2Nk5SUUtIZXZUVWNsN0xVbGp4MWVoYlhqdmtRd2VKbVM0eDdYR1FqdGZxWW9JbzQxN2lQVXRGc1IwS3QxcHJOVkhhd2JtU1ZTbzdQeFBGK2IrVDVPT2VFWTdMV0VGeFBkUVJFOXVRS0t3U0pLQ3JqaFdNMTRWWTFEYmExN1dkS3gxUmsxcnVjOUdndmhmTVBKdnQ0c0wrUTRoYmF6dmJXU1MzeUMzSXU0YnR1U21OelFyUkkwb250WGtQWHEyaDc0MWsvYXc2bVpyUzYwOGZNNSsvMUhlU1NaUHlmRytYZjIwR0RLV3ZZbXVKQnhFczF1RmJZcHQ3VWtUcnZyWjRTMjQ5dmdZWHVLWDNGQzBncFdQeVI0NWU0aXlRZy9xN1VoSCtGQm81cE16Rlpyb3c3WmZjYk4yY1lqdE1uY1JvcEZJeVR1QWFnTlE3MDFVOEZMUG9Ycms1Szl5NmZzejl3czU1Wm5KTUpKazVyVGphdk9iNkFGZUJnRlVWa1VBYmxxRmlRYWFDejQxaVVvUDQrVDc3MjJSYkdSanpHYW14ZHZjTTFySmRJNVlCdjNKUnlGQ3pLeEhRQ2xkOUNaOGtLVWFYQXdicnROR3FEdzYzdDRXYU9OdVlJRFJzT0pCMzJGZXZUV1U4cmIxT214OGRSb0NibnhXMmVIdU90R2VwWDJVTmEwTmE2dHBjRXZSVEJYdmszMnk4YStua2tURlJKY0lyU1BJaW1NSHQ3aysybGRnYTYwY0hJdnVodlF4K2J3Y2V4dXFobGNXM2gvZ2VaWUN6dVhqWmhVQzNsRWhyL3dBSkx0L0xXemUyMDVldFZidU1lTC8wMFpieVZsVHgyK05IRlZrdTQrTWUvU3BBREQvNmRDMjVkVTRDcThTekZySGZiUHlMQlhkeERrbzQyZ1pTakZHNVVrUnYwa0VEZlRaT1JSb3N4OFM2Y3NhOFZpOGxqSURjd0VySmJzcks0M1pHSTlyY2R4dDEwUDhBZXEyWC93Q1BhSEhZZHNWNURHMWpmV0RYckhKNHNwY1FDVms1dE9oRXIxMkFDUDFGRDFOS2F1YWxKd0R1OGVrZmNybThKZTQ1ZTFkQ2ZpZ0xkbFhtNHFSeUhKb3d3WFkwM3BwOWplaEcxNndSdnR2bjhoanZKczVpN095N2k1eTBUSVcwZHhNc0M5K3gvWW1ZRWQwN28wZFFCWDI2SXJXSUtHeVBrRnlPRjg2YTF1YmRJSUw5bXU0VmdacExjbVNNdnhETXFuWmc0clQ1YWJMUlMyUFM5a2hHODVzN3UweThVbVBVeXhUVDF1SW5xUzlyZERtYS9OSFdxblNxNVNJT1pFVEhScWZxNElpRDJwSEVzZTZsVDFyVGNFYmFhN2h6SFlTaUlCTnhCd3ZJV2R5YlZ5VWxCcnhYMVZ2blFuVmljNndSZ3l5ZU01V3JPaThyU1lGVWtqOTBkUldxdDhDRDBycHE1RTNIY2UxV3ZnS21PdDFTU2RLaXNRSWxpcU9Rb2ZhMUQxNjZ1S3d6aXJ5YUdUa0pESFBCVUkwWjRTQSt0UHlPbWEwSERVY3Qra3JmUXl0S2hCWjF1WlhrQklIVU9TekFrZE9PcWJxcTFnY1Vibk01cWE1YWEwbmdTN1JrYUMyUldhWnlDZGgzcXVDdnc5ZFNXTlZHbGxxeFhNT1d4VnUzQnJWcjZPczhMQURnOVBldENLN01LalRKRmhZMXRZVy8zSisybDFqcFFxNVNPTnJTOHJUbDlaYis2Q1VqNHV0Ti93QWRETk9scExsNnF3YzN4elN4MnBzN3dHR1dKMnRieFQxSEVVNVUrTzM4dEhTQ2tLTzNlSzVhMk1oV1dOcW82RHF5N3FhVitZL0k2UTBRYlZqZTl0RnVPNEZ2TForeklXMkJWNmxLajhlU2Z3MGhBMlNJL3dET1ZRcEpxeHJUY2JiL0FDcnBTUmFrTld1Um1qZ3RjbmowN09Sd3NxeVZVa2w0bWF0VDZuZXFuVEQ2RFI1TGVXaHpsbDVUaHlrNlpHQVMzMW9qcUhSbUh2REJpS0hrT1FycGlTTTduTld1T3lzR1VnV1pVdUl6QmZJMFpqTEtQZEd3RDBxUjAvRFVMVlZsQlozTkdWeXRua2IyeHlWcmJYWmp0NnJMeUFqTHg5UUFJKzRRSzlDVHFPT20xUVBacHVVZ041TGtvc2xkeHp0Q1lwNGhRQldNY1lGSzBBWmkzNW1tcDBUU0kyNm1PTTgxdk1NV203d2tjTEZickNlYm9MZEg1c3Fra0JUWG9WSFd2eDFHK0pXSlk4cm81Um96bmxlVHY4MWNadkRYRStQam1WbzBhM2N3eTlrcnc0dndZVjIyT25waVZhd3haY2p2YVJaK203a29FZ1oyYzd6SDFyMTY5ZFd0d1VqZjR0aDdlNHZueDdBeXl2R1pvRVVBdHhVYjlDZW5YUXVTN2lVVzFySmRtSjhid3ZoVnZMNVQ1YzVpczdDSlpJd1NLQ1oxOWdGZDNja1U0RDg5Q3UyNXhVS3BqMjZzcDd6anpxNjh2dUxtNG1lNHhuaDAwd2x0OFp6QnVMdVJBRURzQlFWb092NlY5TkdZOGUzNGxHVE03ZkFSbzQ3ck9YS3d3eGlHMWgyZ3QwL1NpLzdTZlZ2WFYraVdvUDFHU3k4ZFdGbzQ3Nlg2Sm5vMXNyZ05LN0NsQjJ3YSs0L0xWVnNpN2FrMGhyOGRhL3QxWHZCWjdkdWQzZkMxRVl1WGlST0VLVVBLckVyK25qeXFRQlNwMW01ZHZ3L1EwOFRjZnI0K1FEOHNrOHRzN3k5eEhrVm95WE1oZ3U1SmJsdVYxRkdpVjdDQWZvVGRlU1UyNDZ1dy9hYVZxUHkwNlNWWi91S3pWbDVnV2FlNUNXSWx0MWd1N29TU0dSS2h1Y3FoSTZna0JRbzRuYjQ2SVNVdlhSRkRiVVNoeXlGcGtQSC9BQjJ4eUYzRndoa3RwTGhZV1U4ZzBMQ0MzTHVuRUV5Rm5aT0pJL2hvQ3RxNU1qcXV6L1hWaGRxMngwVGZkZjBRSHhFMGxsYnZZVy9LNXkweVJ5WEZ1QU80OGpMeFNOR2VwYWhJclQ0VU9wNVZ1Y3ZSZGdyalA3YTIxMXMrcS9nWHg0UGdmSnNaNDhMSEtxc0Z2a0ZwWldrZnVvOGtkSGxsRzlDRjZhNWptNWNWN3pYVjFPNTlzeFhwWDFxRjRBSzllOXZ2UE1GNGpCRVV4OENOOWJIRXpyRW9MY0hXWXcxYjNvQW9WajdPUVliNjJPQlNxd1d5ZFhZNXYzN2s3K1NzYTZVUTVlSjUvd0FYOFA4QUhiN3h4Yitjd1JaYVdUREM4NVJzbHE4amMxUmo3RzRoR2NVUHVCMkhVYXp2Y09Ma3ZkWGorM3NFKzBjcWxVNk45KzRtK1I1REdlUkh4L0I0WXRjWXRMZ1MzSVZRSGVKcGF4L3FOYXVlWkh5MWZ4c2RzYnRhL1dJRGVWa3BreDFwWFZUUDhqZkprNXJDR05iU1dOSURGTkE1VWR1c0ptVlVCVGtlcktTVCtINGF1cXA2OVRNc210ZFB4MEFWeGhUZDV0Skpyc3lZcTRtNHFFRHJJSnF0UEl3amNnU0ZlUGNSZWhyVFJOYnhTRXRZQXI0ditTRzlQd3lUY0xINUpaMmZsT2J1RVd3U0x0eHZhQ0ZieU0yMHNzYnlTeGtjWW5rWUxScWU3M0RhbWxUL0FJMjZwYS9scitwVGx0OTMxdDZmbnA1ZEVUdkhCbWNyWVJMRFBIZXRCWnQzWmtVd3ZiMmR5YXppUWJyTkt6dEh2eTl1Mm81SFdzdDZFc1R2YUkxMC9JMzJHWXlualY3bEk4cGpJa3VNU2o0aS92WWlJMHVVVklYa2pSaXk4QWtEU2NPM3V4WXRTbzFMWXIxVFQ2NmpMSTYyYWE2YU1FK1YrTVhXTXdDWjd4ektSMzlwZTNMd2pHUEdqVElnWitQR1EwSXFpTDd2V3VyOFYwN0t0bERRSm1xNnFhNnA5aWx2SlV2TS93Q1IyZUp0WUUrc3VIanQ3ZTBoSjRCM0lqVlJ5NkN1dGZIWGFqSHZiYzVMY3RwY1hsTEs0V1MzYTB5ZUplNnlVMFVUR0c1dGhpYlNQSFdDd1RMdVE5eTdQV01rR20rcTNLNkV1cUUzeTlydkhULzJxOG5XOXQ4Y3dnUytqQmpKVEhvVklkVk93Nzh6ZThIY2l1Mm9wK0JPeTdNYy90aDRuZk5kWmE1OFFsU2ZNNDYwV2l5VXVMTzU1b3JTUmNXTzVrWml2c0lPM1hyb1hQazBXN29GNE1ibDdPcGRQaitRa2N6NEtXQ3lWc0ZZeVpaYmUzanBKQmR0SWJlUG5JeHIzRjVGcUdwQTQxMzFrOGlWamRsOERwUGFzZGNuSXJXM3hCRnV6SjNvbFppbk5WWGVwQUhydnJLYlo2ckhRTjJEeENCbmtBWm8xWmdnRlQ3VHhBRkJwS1d1b0xkT1lQQlpXeldFTnNvS3RVZHhXL1UxZHlwb1IwQjA4NmlkbTdNWG1zM3gxekpaMi83Vm5LbFJJVjUxSlA2V3FhZzdWMFhLc2szMUFYUjB0RmRFeE16VTFrdHdsd1JMTDJwVVZpYWxTa1o5NUE5S0QwNmFMeEptQno4bFZWdFM5UTFqc0RKanhrY3NzaXJIZXRTM0VZMlMzUFVqYy9xSkIvTFY3dHBCeXJjdDJLUW50Lzd0NVRleW9PVVpuTWFmQ2lIaVA4TmFOWHRvaklkZCtSc2JKY1c5bll4UEkzSGxVZ05UYWcySStPaEs1RTdCN3hPdFpZeCtJV05tSVpjdGVLc2tNRVRKYks2cWF1NTl4bzIzUURjNmpsdTRnTDRlT3J0TFVoWHltL0NZbU9NUDdUeVpsRFZWU2FIWWtDdGZqcWpIV2JHcnpNbTNFVU5ub21ubEtLd003bmx5RkdDeCtySDhmNmRhOWREaXNtdnhGM01ZYVd5RUJZQlpaWWxtNGYxQkgvVHkrWkh1L0RWMUwrSlJhZ0poZDBQeTZFSFY2Qnhyd2QvTFlYYVRSdUNLZ1NwWDJ5TFVFcWRKaVIwL0ZjeFpMeHJCeVFWNHRCSk82ZkI1WldxRFhmWUFhZmxlbkZSZUxzLzBTL2lhR0RWdCtCQjdEQTdxZFppQ3piRkJLNUN4b1NUMG9OSmlCZmtYbGR2NC9KWjRUR1RwL3dCeFhrMGFYVjBTQ0xTTm5BS1Ivd0Q1eGwzTGYwaldkWld6dHovOGRmOEErWi95TktpcmcyeTE5eTBmL3BYbi93Q1g2ZkVVYk84dXN6bGNsNU5GRkhMSkxjUVEyeGxWV0tXU09XQlhsMExnRno4cSttak1kUHQwVlFQbDhoOGpOYko4bDhQNmpyakloazR4ZnpQTGN4WER4S2J1NEpqNHhTU29nUmZSdU1UblpWb09YWFZjUm9RV3FrdDc3UjVZNGJ5YnlpNWh0KzZodFl2cUxxN21NbDNjMzl6SlMzZ2RpQ0ZZbHFOUTdJcTArUStSMmVLTzdMSzFXL1FmTXpjZmNYS3BKWTRYUFJ3MnpMSElaNHJKSGxjSU82cXJYaFJXSVhrNUlvcEc1OVE4TzJrcG90eTFseWlzUFBzZDkyNy9BQk43aE1oNWJqOGpoWnJZeTNVVm5pNG8zU0VxcU5CQXdscTVjTXdCUDZ2Y1FlbWk2TEVuS3JxdWdOWlpHbjZpaDd6QjNYa0dhbnlzM2tWOWE1V1Jtc2xaY1BLSllvRUF0aWlMSEp4U2c5cHFPWjM2NjBWazJyb3ZxQlBIdWZWL1FKNHp4ZTJ3NXY1ZkhmSm83L3lzTXNGMUhlV043WnhSd0xGL3lRSWtrNCswRTdpbXE3WkhhSldueFJaWEVxekQxODBCTUg0UDVOZVptUzd5TWxsTGk3ZVdSWG1zbmU2YUZaaTFVaVZsakhJTEd5SXo3RGNnK21yTDhpcVVLWks2Y2UxclNNTi9aK0JMQmk3NjU1dkxkM2NReU5oY3ljUThTeUFkc2R1RkNVRmF5SGx2eG9lV3FhWHUyd2k5S0pCbko1ekIrVCtSOEh5MEZ2WXpRenpRMjFwSEM4S3JBakRnenNPVlNGNGdqaUY1RDExWHNkS3ZUVWx2cmEwU0VNNUxhNWs0L3dBZDhmU3lzZkhFaUVzaVhOdWw3UGRPR1lFS2txaEFhRGl2TmdlUkc1NmFIeDZOMmVyQ2J4Q3FvZ2dYdHI0amVRcjQxaDFtd29sdFZ1cnlLeGtTR0Y1SkdSVmdrZVNpSnMyM3VYcVQ4OVRxNzYyZXNlSlhsVlAyclExWUh4RHg3QTV1OHlWN2NKa3IyM2pTV3p0S2xJbHVwb21abFp1Y3ZKbzFYaFhvdGR1dXJiWmI1S3d0UDVGTmNWTWJsdVQ2MnZNemVXbDZqK01XUzQyYTI1U1hHTUlnbVdPUmozUDNoMjJKb2dyOEttdXB2RFZLWkdXZXpmUWMvSHJmN2VlRDNWbmpiNjNqc1d1WTRseUdYdm0vNUFtdHcvQXpTa2tNU2VLZ2VtL1Ntc3ZQWFBrclowY3gwUm80cllzY1N1dmZ3QXQxYjNHYXQ3VHg3RXRqTHc0ZDdpK2d5OGJTUzJnaTk2ODFWUVZrY0FndDdxY2g4OUcwdTZyZFpOZVhtQ1pLcXo5TFQ4ekdiSCtRbnhKV3gza0ZyZnREZEdHZTlMU2MyaEN4cUlsWUt3VHQ4Vjl4REhsNmpycDNEdkxyQXliMndyYWl0NWJGNUprTHJFSllZR1NMRWNaTzFHWlliaUpuS3BIM2lxSHVPekdwYnVLSzExZmkycFBYVXF5dXphaEduRVlmN2czTjlGaDdhZUtUNkdibXRrMG4wOTFNMDZzV01UdHhIQmxPdzZiYmFsWjQwdHhHdGNqY0lzUHhjM24yL2p1c3BrVVRJM0Y3UEZCY1k3SC9BTGtpZ0JqUXlsaXZObTkyM1JmeDFtOG5FdVJYYjBORGpaYmNlMDlXRlBJL0w1L05iTnNUaGNiY2Mwdkk3dTV2V1I0MWl0NEg3amNta1JWMzNYMkVuM2IwR2crSndGeDc3M2J0OVF6a2MxNXE3S3J3STEvZVkveURCUlhGNUtUbThmZUdlS3ptRW5XdE9RcXFxQUYyQ0xYM2U3NTYwazJuQ1hWQUVKMWw5VEtRWXp5WEh5MitVbUZvN1Nvd056VHNvMXNoVGl5eDFZRUZFL1hRSDBPK3JhelhwcURXZTU2amo0MTJmSjhKQjVYZHhQYlpDZTJsRUdIakNxa2tiUWd5RmU1MVlMN2kzOU5SdHJJejVuaXRzU2syTVZWa1c1Nk9CVThPeS9qdUd0b01EbUhra2phMk1oY1JudHZQTXFpUnVaWUQ5dm0zSGxUMDQ3alJ2Snhac2ltbWdMZ3o0c2JpMHRreTR3RjNpTFM1d050UGUzTUs1Sm1hd1dTR0VSckVuZWpaWEtHUTBvdnNSdUpPOU5MRlZYaTlvVGdyeVdkSnJWdHBzenRVVTJ1THgyT2x2Ulo1YWN5VHh5eEpGelNDTXRJL2NFWVBiSlhpN244ZEZYZHFyV0NxaXBkd2s1UGNYSFlQZVhkcmpZWGprblV5S3o4RnRvMmpZRUVWNGx3OWVmV2lyODlFS3Vpa0dkcHM0R0NFbE05YzRzdmJUcWJSNTJpUXFlRXNYSk5tN1NVVWc3SC9BSFRvTEpSVnNtdEEzRmtkazA5U2wvS2Z1Qmc0UEpyZkM0MUxtSUMxbWt5VnhpSXplUnd5d3VRWVJHMFRHV2xWRXBVcUZQcnRyUXhZVzF1Y0dmbXpLWVFROGQrNm4ycXY1cnJJWlRNM2xybTJSSCtxN0UwQ0p4cXFSUWxGWVIwb1N6L0UrdnBYbHdaZXRTN0R5TVBTMC9FYnNSOXh2dG9NUExjZVA1bkhTWGFQY0M1Z3ZMa2QyVHQwS3l2SmRFT3krM2JpUDAvcDBIYmg1TE9iSUxyenFWVVVhZ2E3SStOMzFsWlBIa0xTNGh5U1JKYjNDVFJuc0daYXRGRlJ2ZVN5cW9COXhIOG9MSGRUby81alBMVnVaV3Bqay9IL0FDVHh2RlpVV2tzRjRQOEFxYmpHV2trTEdKREg3Z0dkV1Z3Z0srZ0JycFZTdGZWYUVuWnFrSnl6TEg0akpyYlhOMWRZTDZqRlpNV3Q3YlFXOHFscldXSlFuYzRTQUdoNVZLVjlPcDFIN2xhdjRFbmpkalRpY1BjWTNPWktISjRtNkYxZVJTVHFrWGF1SkdVOFc1c0M2THlmMTRIMjEyMHp5THJJbGphVWR5SEY0cGxzN2IyMGFXSXh0M2F5R1oybDR5U3pPS2hGTVNzM0JTTjJabTllZzFLK1pURmRTTk1MUzNXY0FQSVlHVzhzR3lwaXRMT1V5S3JYQjVBU3RFL0hoemFnSUxxbzllaEZkUlYzTUYxbFZwV1lKdHNqRmlQS3JYS2VTUVNXQWUya3NNclBFRExDem9VRVRJVi9Dai9EVDVjYnZqYVhXUnNHUlV5Ym4wZ3NiSDV2eG5KMnFOQmw4ZlNSMmo0cGNSUnRRcld2RTBQNWY3ZFpOOE9SUG9iRmMyT3k2b0taRHhYRTVEeCs5anM3eUtTUklUTXJSeXF6dThCN29BQU5TQ1Y2Z2FHcGt2VzBORXEyb3JLQ2s3YTEvdUtYVTE1enQ1cGNuQ2xyTUdGSVpZaWo5MlJtOUdRdUtWOTJ0ekJwcDVBL3VtdHBqdVdCNUZqeGE1SzhmRUlra09RaFNYNmNPMGg1cldDWThuL1N3YWpKdDAxREZiY3BmWUhzbzA4U040U0wrMWwrbWtzNHJTNjd4dDViaDBFVWtjTEllTElhZjFmekpycDd0ZUpPbFduRUJhUzZzOEhtTFdhMWtjeDN2L1MzVVpLeUtpeWxtOWpKdWFQWDRmaHBxeTAvRWJKcEdvU09KaXdYbXR0NVZZdDJJRWoramxpbTNhZTF1RUpWT0pYb0dEZnIrTlB3c1ZyT3Z3S0xZNnpJb2VhOFpjZGpNZkhaVHc0cXprUkx1WG1XakVWekc2R01FZ3BUbXhvOVBhVFFkZFR3dVpmY2pkUTFQUXBUN3k0cDgxOXVZTDZ6Vm5URTVDMldKeWdSQkJMQWJka1VxeEZWWll5MVFEdnJTNGQvVTB6UDl4cE5WWmZBNTBPR3lJb2V3MUQ2aWgvdzFwN2w0bUhCTXdXT1Z2SU1mYTNxcWJhU2FNUzhoeVV4czRVN0g4ZEs4cXJnbFNOeWsvVG43S2ZiYkNlSWVHMzgwRmpGRmMzTWF0SUVpVVB4WDNCYTcxLzhkYzY1dTNadm9icVZhd3FvQStmWXVXUHlMRDVLM0FTS2VEdUpCVVJoVmpiZml3SkhMNWFwdTkyUG9hdkFUV1hRa2xyS1VnTXdXUjZ0eEc0RkFPVkFha25ldjU2emJhOWpwYXQxbURWTmE0Rkdqamp1STVDeGNwQXpKUml4bzRVVnFhYmRPbXJIb2lxcWw2aS9rc1JJNjNDdWk4MEhGQTVDcUZZa2NkaHNkWDRyT2RRYlBSYXhxbWNWMjJMdHZFUHV6QmJYWkF4VnJsaEU3Vi8vQUVhWnlBZnlRNjZwK3ZIcDNSNTFHekxEN00vU1R4VEEyOWdzQmppb3UxQUJzYURydHJKcGo4VFd2bGtwejdsK0tXMXI1VG1NZndXSVN6Q2VPUWVxVC91SnQ4dVpHMm16VjJ1UXJqK3VvanlXZGhaeVRZOUppSlU3WDFGQXpIcFZPVk9vT3FMSjlRcWtOd21LZWQ4ZHgwWGtrT2FnaVdTUEpRVktGUklzZHhabFZjaFNCK3BHREQ4RHJSNDJSdkcxNEdMek1TcmxueExGZ2xoeStDeFdFUnVTWFZKTHN3a0lERlpidUJ4NkF1STFQNDZ2VTBVc0QwYmdFM2x6SDQzNVo0L25sSWh0TE8vUlorTk9Jc3NqL3dCTktQaFFjK1gvQUtkUGpzNFkrU0NMOThyTDYzTjJhWXpOM01XWHN1VU54YTJ6c3NTTFgyc0dRcVZjbGp0eTMwWmF5YVRCcXA5Q0JMWlF5ZU9ZWHM1SkpMbXhpaWd5SzNkd3FYS2dPR0xFeXNDMnhib1Q4TkRwUXk1ekh3S3l5R1B5Y0htRnhGaCtNMk11a2ttTXFubWhFUUlxcFVtdFFPbGRXU1ZScVFoZERJWHQzalZYaFBiVkxwU3F5Uk1BeU9wSHhIWFN0b0pHeExoNWZHN2o5OHJORzFXdDZnSGtITlcrTzQyMUNGdjZmTXNUOUQxK1FtTGFTZlZyZWR3d0FxVmNrVjVWRlBqNjZ0S0F4ZDNLeHJGSXFvSGtVSThoSU5XcnN5MTZmanBoeWN0N0piVy83S2lLNnR3endUSTFVb1Y2VTZFNkd5VmFma3g1Tmt2bGNreVdOeGw3YUdlSWl2ZDdhOStOMGFuSlhvTnFIVExIWk5wTW03TFJqRGdzblo1UVhWdGJ5aVdlSm1taVdTaXVVQkFORDZnMUduVGEwNlNQTTZzYmZBTTlMZ2ZOWWtmZkU1bEJiM2taR3lQL0FPMjUrYUVnZmdkSzBPa3NWZW9zZmVMeDFmR2ZOcHJxMmo0V0djQW5qSm9GU2V0Ry9EM2IvbnFXRzZhanVQbHJESzR5Y2JtTkwxZ1k1MFlRWENLU3JxKy9CalQwSTJyb2hGVFJvK3FsbW1FVXE4WTVBWWJoK2lrU1VKWWZnUUcwNUZNOG10cmg2V0REbk5FeGpVQTFJQk82ay9MVENabTk5RGhZb0JIeHVIWWhwVllBaVNoM0pERDlIK1VldjZ0TjFFb1EwMlhtM2o2MjZQWTQ5WXIyb2JoYzNESXFPT2hIWUVQTDg5VXV0bSt1Z1FzbFV1bXBCdWM1a081SkxCOU5abDZmL2d0dEZ5UC9BTzhkV2Y4QVBscWUxTFFnN3NGWGQ1ZlhQdXZiaWE0Skd3bGtaaHQ2Ym1tcDFTWFFnMjJCcmlYZ2VLVVdtMjIrMm5SRWhjU3pEa2FBL3dCWFduOE5PTWJrV2RWN0FZSjNQMFNOMG9SL3Q5TklSQ211bU1hd3ROSS9iSkFVdDdRT3RSK09rSVlQQWN6UGdjL0ZsNEpZN2RMZmVhU1plNGVCUHVDTDZ1UnNOVTVWTllMTWJoeU1YbmYzQnY4QXllOVM1ekNqNmExci9aOEdQMFJCdWt0eDZrK3ZFN241RFVjV0xhdk1uZkpQd0UwVzEza3B6ZDN6bVNTU2dVZ3IrU2dEb0I4QnE2U25xT1dQeEYvOUdpNDZ5dVhXNjdVVWJpRXh5RitYdVZPaDkxZmIxMVZleVhWbGlSMGg5dXZzaGpZbmk4aTh4dDRUY3hGWkxQRW9US0k2ZTRHNGtKOXgrS0RiNDE2YXpNbWVlZ2JpdzYrcEZDWXZ4anl6QVNXbmxYamVPeTJDamhLVDJtVkZ2TGVRS3l0VU1aWUZaTmlQMHVOU3RucGVhV2RiZG82ZnFUcmlkWWFtdm1ZWnJ5MjU4a3owR1d5VnRZUVplNGFTQysvdHFsbHVaSkZJdUxseUhkQXpmcWZpUHdHb1llS3NWSFdyZTNxcDdlWHdMY21kdXlzNG5wcCtvRXd0bTJaTjNrYmg0amNXek9yeHlSTVdLTW14aFZUeVloVjNISFpOK21qTXR0aVNYZjhBR29IU3U5dCtBdzVYeXZHWDFxNXNtdVpMYUQ2VlpJNStJak1GdWdMU0tBcUlXQmpWVkFRYkhyb1RIaXRYckV1ZjlBM0pscmI5c3hXQXA5cE1Eai9KQmN6d1VseVRCdTdkVHFsWTdxNGZ0eFJxV3FLTUMzKzkrR2h2Y016eE5KOVA0ZHpZOW80OU10TDM2Mi9pKzMwTG12OEFLM3VQdFlMMi90SkliWW95TEhBU2c1c09CUTFiWUg5STQrZy9MWE52R3Nsb1QxWjJtSElzZUZ0clJHNjZ3Vjk5cWJiemJ5M3lHemp1N085eHkyT1B5Uys4WFU4ZzVSbVNQbDdIUnVNWFBpQS9CYWJuWFJZY3F5MXBTdWpUNmVCNXp5cTJyZTk3OSs1VGVjbXNiL3cwaFlLNWlHMVMzZTdWV2FWczBralBJNmtHdFFBRURBVXBzSzZJdGEzMzB1M2gvd0NJUml4VVhEZHY3bjAvOWtFdnRtTEhOM0dGeW1SdVVoV2FLUVpDZGlJMGpsc1VjZHNBVTRVQldnOWVWZEM4eFBIdVMrWHpOSGhaVm0yV3Qxalg1QnJ5VER3WTY4c2hDNWx0WnhHakp4QysyM29LRGV1K3hKTkRxbkJrM0p6MUo1NktyU1hjd3NNTE5sSjhkajB1VXRMM1BYbDVEbE1oTFVRMmRnbHNwVmdzbEk2dTVvQ0c1Ykt2WFJWc2lyVnRyb3ZxNU1xOWJQSkgrNmRmRFFSNFdaUEY3UVhZdW83U2VkN2U1TmtWVnJtU0JpNUhHUUJDSTR4N3FOWGs0MGM0ZC9PSk01YmxTSDBtUG9QMkFuaThZd2x2NXhZV2x2ZVp1MHYya3RNUEhXUkpMS0VSSktwWUFtb0FEMUpOUGQrT2dNaSs1YjdiZWpXck5QSEZNZjNWMW5vTkhrTi9sRE5KYytSeldwd3YwclpDTzJzbUV3K3V5VUFpNHM1RzZjYWhBL1RvRDhLK0xpcXF1SmxhYWxQSnlXbFBUWCtKVDJTYk00dm5IRGxVdUkvZExIR0NKSTRJSFVlenRsaVZjc092THByVnhxdG10RE55TzFFOVJJOEdueVgvQUhsUDVWWTJ5WDBuamtjbVJlTjI0QnUzU0tQaUNHcTNjZFNxK3AyMXBXaUlNNUZvWHFZREsyVnVYbWtoZkZtM3gwVnp4N2QvYlJZU3llOHZXS1B1alMzY3dRcTYwTk5EdHRmajVGdllyZHJ1TTVPTzN6clFoNGVFZHpNeWg0MkNscm1Tb05Tck03Qlc5RHZxWGJRU2E3bDJmYnk3dWZIdkY0YlhDM0Z2YXpaZ0F5Y0ZSaWswekZqN1NXVmlFWXB4NDhxSHBVQTZ5czczWDlYWTJlUFNLSjE2c2RNRGlYdzNoNHZuUGV5T1JJdDN1eXBqTHdRTVpIWUt4Sm84aEZUUVY0Nyttc3ptWDBoZERzdit2Y1ZLMjk2dUNOWUJvWkpwcFc5amdBOFFTTmdhVVd2WHJvTnFVa2p0NGM2OVF5a0tudENOd2tORWtsa2I5S29SeUEvUFVmSkZlNUtaRWp4cjdxZU4rU1hsMWo1cDJzYitHV1lXOGM1OWx3Z1lnR054c1dJL282L2pyUXljRzlLeWpudUo3OXhzMTNqL0FHT1kxN3g0ZnlHakx6UXRCQ3hLcE5BaG1UbjdRU3dXZ2F2cnVOVXFkM2tiVjNWcHZ1VkRuYmkzeDlZaktlRnpKOVBHaTFvaWozTTNYcHQvNDYxTVZXOVR6LzNMSlhIYUcrNUp3dm5WbGliQ2EyTjBIdFZFalJxM05nc29CNG9EU2dKUHBxeTJHek1pbkl4MWMrQXNlSHlZcnV2YzNWM0NzNFBPVG1mNm5OVFg4YTZ1enEwSkpGUEZ0VGRObU52azh1TnZiaTB4dVB2SVo3cUJDenhRc0dJQk5XcU5qMXBvZkduV1cwSDh1K08wS3IxR01RakdZQzF0VmhRTmNVMllrTlVpcE8zVHBxbTlwZW9Wdzhka25DRlh5Ui9xYkUyN3R5UVJkdGdQY1I4aWRXWVY2aXJuMzNKVksrTnZaUlpLS3dFWVd4aGllOHlEQmp2REh2WGtkd1RRSXRmanJTbHRTem5MMVZYQ0lGeGF0bThpdDFLZjI3Z2cxRzRDallML0FPa1VHbnFRYWt1ZnhYRStNNHJ4eVcveW1OdFo0YmJnUXNsdkhKSzdFMDRKeVVrc3hOQm9XOXIyc29aczRNZU91R2JKTWJiRHd6eFJHZ3lOOWk3STVNb0puZU9GRmdReUJlS0tnRk9LQ2dWaUsxcVR1ZFNlZXljU1FyeGFXMWd0SEN0WVRXNGt1TFdKbWtjMVlxRCsybEVGQlRZQURSUEx0dHJYV2R0RitmcS9pVXFzM2FTNnVDbzdQN2g1RFBlZTR6eGlDd3Mwc2Nqa1RiUnppT2p4d2prMUNpTXBKNGplckRyckszUC9BQjNrYmhxdTZBM05XdUxrZmFWVTF1MnkrdW5VYnZ1QmVYYytGbXdQaTdwajdoMjRUM2NLaFdrNCszZ0dKWmxCSjVNUlUrbXVTNDNOdGE2dGxiZGZBN2JIN1FyNDNzaXRtdE5Db1BIZnRWTForQ2VSZWMrUUJyakxxSmJMRDJ3cXl4elBJSVRKL3ZPM0lnZkRyMTEwT2IzUlh6NDhPUHBicjhEbDYrMWY0MWNsODJ0MHJRdkR6SXVQaHRqQ21OU2J2TVY3MXk2Y1NHTVFNWGJqb0tiR3Z1cnNLNzAxczMxY25ONDlFTTBVc3p2UGFZcVJJTWJJa2w1T3EvdVRNWnBRSFNOaHVIbExDSlF3b29HM1RRdEg0L0FLdXAwWHhIbjdkV2N1VnpPTXltVHVESFpXRnhlWkdmRnhMSXhrT1BpTVJkL2RWKzN5cEMxS2ttb0ZLYWhlS2ZGL3hKcHR3dkJsM1hjN1pLU3ludVpwN0t5U0dlNHZJSW80b3VUU0lrY0NTcXlzQVFHOXFFVllpaDZEUStQRzZ0enFLOWs0Z1R2SXIxalpYOS9ESjMydkpBc2RvSTRWdkJFNlVqaHRrUDhBeTBBajVOTFFzZU5haEJxNVVpRVFlVFFXc2RZVzJRTnViVVdkeGxEZXZQTmJYRjRZa2d0cUc0ck15Z1BJbzRBL3BDN0w2blZscWEvSWpYSnBJQ21naGVQSlRXREtrMTFidzJsdmN4S0M4U3JOS1pIVUFCZ0pWQWJpVHVvMzB6U1NKUzJ6WDl1NWJXNlhQTk5iT2JMNjBXa01FN3QzeUF0UzBsT1RHc2daNkRjOHRVNWxLUmJnYVRmZ1dmam84V1lqZXkyeGdrZVQ5U2tEdVBDdjdwS1VhTUFrY2FzUDAxcHZyUGFzdEpESjdrREtZRENTRzhONWpMSjdlQ3FzelJvZVRMc0Y1RlY1S09KQkFwdlhWYXZkSlEyV2JLdDZvVmJyd254VE1OTFpuSG0ydFl5cUpERk5KWnFUSFR0dXdSeFFPMWFLRjl2cVRveFpiMXJNeXdhMk9sOUkwTXZIL0d2RWpuNWNITkJML2FYczR5NFdlYTR1R25sbGVuR2RpVFJWamFwclN0QnRwOG1YSTZOOXlxdU9xc2wyR1BHL2FueHlPVjU4TENsbkpNUzAwUzNKcTF3QWZkVG1lWm9EVUVVcWRELzVWOW5xZW9ROEZLMmhJMHQ5b29MNjQ3c21UdXJlT0dJVXQzYUZRVUI1VVlMQ0FQMWIrN2xTbWsrZFpMb21OL2lVbnF5UG1mQnNwa0xXTmJpOHQyeHNxTEZOWlhFQmxUa0dCNXU1WldhdkdnT3dBOU5SeDh1SExYemt1dHhVMUNmeUljSGhXVHh5elRXVjFGMnBGbGdpQmpUdHFzc2dkeElWa1V2WGlBUFNoMkdyWHpWT3FCMXcvQmdPNSszUG1tWWxrdFlzeEJiV2NWR2d0WGpaUjdXTXBaNmJsbXFRUlhSUzl5b2wwS2JlMzNlc2tHYnhEelRBVFdkMWdYL3VWc2JXVzJtc3BGRVpUazVkcElnYWU1ZjBLSDlQanFkT1ZqdG85Q051TGVzUnFFSnJITjVISlF6MkdIdjdPNWltdExXV2E1WGhGRFoyOGJkeDRtUTBidWNpb0hCZC9UMTFGWktWV3JRdnQzdDJhYU50OUxuWmJtK2VLMGxzTU1hU0pTcVhzNjJxS3FKN28yQ2N5Z3FOaXcyRzJpSzVjYldyS1hpeUo5RDZ6eU1pNENHZkxaSCt6SW9XUnNSY1Jva1RjSmk2L3VCZmU1b3RRYUFVL2pVb2QvVERMb3NsNnBRRXlReXVYeUVHRGp6RnJkV3pNQk5QWVJ4eHcyZGk0WWxwWlBkem1jbmt3M0MwNmIwMWROVXBqWCtKUk43V2lkQnVzdkZQQTdLRzJzSFpybTN0Z0ZOMUhmS0pBcjBZR1FxVko1SDNiOVBYZlZMdmtlcTYvQXVWY2N3MW9hOHg0NzRUZ25GN2U0OFhHUGl1RFp6dkxHSGpWV2pMbVJHWnYzQW5FVksvRGFvMDFGa2FTYmlSN1hvbTRxSFI0NzRiYVpDOW5tanRSYVJZKzFudDdoSkx1MWltZTRaeHhNZHRJeDRVV2hBVHFOOVBsKzdTRlZ0dVNGSGpzNXN0Q2RKWStNWXZBSE5ZcVEyTDJFbkNSTFNlNm9rbkJHWlpsdVdMbE50dzFQYlRwb2E2eXErMjNjSW84ZTJWMk42ZVA1YTZodC9LTHE4VzN5cld2N0VPT0VzNGhXZCtiek84NWRwWkpQOEFMdFFDbnoxUm01U1QyZnFYNE9QUHFYZm9SYlh4M05adURJVzdacTB5ZHpKY0NPK2t0WW50N2hFSVVvaU9XTEJXUnZjMUR0N1IwMGRYa3VKalFFZkdUY1RxYXB4SDR0bXJoczRyTFkzRUtXbU9XelI1M0Njano3cFg5d3VXcnk5TnFhcnRtKzkwMGduOXRZWm5Vb0h6UE80T3c4N3c5OUhlU1krNE1kMTlUTE5iTmJ1a2J2SFFNQWFBTnhadmwvVlU2MThWYlBHKzVrNW5WWFI3ajhWYXlYR1o4ZnNmTHNRTWZrTVpiVFNNczhTeFNMRkxJREFwRHF2TUE5RDZIVnR0eVNlM1VoWGEyMDNvYnJid2krejJJeUdHRnZocjYzeDk5TE1yUkNJT3p5Y3FlNk1WS0FzQ0IwclQ0YWx2YWN4MUs5cTI5VDI2KzNsczFwZ010ZmVGMjZXd2F3QWV3WjdkTGxKbmhrcS9hS2U5bGJoeXJVVlBydnBxNVc3TlNQYkV0cVp1azhPdWNYNVJjWFV0dDVIakxiL3Iwc29iUElUcUxkRVNOMWpSbkxzVlE4dVlKOTFSOE5RKzlWMWZRbXNObFpkVFZqTHo3aVlHeDVXSGxua01mYmF5K3JpdVlFdW9ZWUpMZmd6S0dWaXBWaVFnRzFCOGQ5TzNqY05wRHF1Uk5wTms2eCs0UDNSeGlXRVVIbEZua0paQkJMZFQ1Zkh1ckpOM0ZoYVBtRDcxRVlxeDIyOUs3NmpiSGlzNGRSVnk1YWRHR0kvdWI1M2tmT2NHdHpQanJYRVdFOTVaM04zZ2pOREpkSkVzY3psaEs1SVZGSjRMUmpzUnhwVFVQOGZIdGNUSkt2SXU3SlBvTytSemtjdU5oZXh1WkZobG1jM3NWekZGZEt3RXpNN1VOS2xhOGkwYkw2aWcwRXNMckxORDdpdkM3QkRMZUpySTlyZHczUWxXeERTcGFReFBEYWlacWZ1bFhMR25wczFLZW1zdDgxVHROU3ZFbGJrSk9TdVBHUG8yaHZZaEZjckpOOVpEZng4WlY0Z012RjFIRWcxb0NwSnAwMXFZNGY4QVF5N1dzcFQ3REw0VjQ1NDlrUHQvanBibkdSWFYxSERMQTdHTmVieUpJdzVjZ09YdFFLRHkvd0EzUTZ4dVhtdlRLNGZjMmVEaXJlaVZoWHVzWmIydGxucGI4c2s4cXdRUXFCeUJNZ2VqOEZJTkJRTWY5blhSSEd0TjFBYjdva3NTUSszMXkzL2FHQ2xpaWdtbmpXR2FhV0ppaFAxQ2JSbXErcEpJM29hZkhUcFJkb3kxWjdWT3NDRGJabStnek41bGJBM2wxUGFzWlZ0bzBXVlNxaGFNdFJRQWtGQUJYMCtPaUhSV1VNajkxMXMyMVBrTUdPczdYTVpOY3FpMU51NjNra1JDeU9xU016amRnQ2FubHR0VHBxQ2Jxb0p0SnVVTjNrSGxWbGtNVWxwRE1ZcmVKVmFab0FMaTRCamNDTklneFdqQWs4aUs3YW5ST0NtK1JJbjVuSFdXYThERm5GQzBjbVJFS3pJU1luUm82c1FvZHlCRTQ0cWFjaFQ0YUV4V1ZHMit4T3lkbjhTbi9MTVhieitFNTNEUUtzZDdCRWJxZTFibXpoRllUd2dQdWtqRlZCMjNvTmFlQ3lWMDVCdWF0MkpwZGlpclBHUVhDVkFHNDJGT3ROYWh6aWlCUzhneG94dDlITEhzWUorUEllaXlDcS9sb3VqbEZUUDFJKzFXWHQ4Lzl0c1JtSTJka3lObkRKSUZJSkVqSUE0QTZDakJ0WXV5RlplWnVUTU1yajdnMWd4TFc4bmN1bnhHUkRRTFQzL1RTQmp3SHJzb0orT2dtbTVxYVhHc3EzcS9NV3JEeUdWN0w2bExHU05ZdUFka0g3aFJpQWdvNFB3NjZ6NGpRNnJkVitNQ3RIYjJza2YxenUwZDVhWE13dFpGQUVqcUhxQ1JRMHA4T2cxWmF6N0YrT2xHbDRreVBKVDNNSWd1K01WOUdBbmRmY1NpUWt4dXdvSzByeEhUVmJjUXl4NHVxWnpiOTU4WTBYa2paRGlGYTZocVN1MUpvRHYxNmZwT3VxNE9UZGpqd1BNL2Q4SDJzNzh6OUJmc3Bub1BMdnQzNDVucXE4OTFaUkNjamVrMEM5cVQvd0MwaDFiV2tOb0RkcFVpSi9xTnRZTWJlWTNNTzdSQzh0M3N4S3BBSmt0eVpGSHVCMzR1eEgvRG9iazR1ak5EaVo0VFJ6a3VkbnU1N09aeDJubHR1M0xKMGQycVNqMDM1QUdtNTFRNkxhMEVWczVUSk9TdHN6ZllobXZMZHpKYlhNZHdaaWFVaWRERTYxSFJDalYwL0djV2p4SytYanM2Ym1HL0FXU1MxTjBxaXFjcmEzai9BRXNwUm1lY0FBbnE3SURyUXRXZEhxWktjc2dmY05NNi93QlBEWlEyNjRtVnUxZHlUKzZSSGRxb08yYURoWCtxdlgwcHF1dFZWNms4amJYa0xEZUhaMjRsQ1pUSXpscGFNVVFsVXI2RWNlTlR2NjZJbVNtSEpMeVgyeXhGaGl6YzNVSnVReWxSTk9XTEZuSEZUVmFBZTQ3RTZxdEsxa3NVUHFWNWhQRmhZK1NZdURHNU83c0xHOE1ieUNPVXJVU0FlMm8rWnBxK1NoSXp5S3k0VHlpS1YxNDdQYXlNdEtGVk5BZHV0VlBYVWJKV1VDN2duTlFyYVpLZU5GYWs0N3NCSjRzR0pvMzhkS2psQ2FobW14aEJkclRJUXZkS3NMekxGWGk0YUpTd0NFZjFGYTAwOW0waElocWJESndTdmk3YTVvU3FyM3dBaTFyMGFwMzlkTW0xbytvbWwyUFlyaTRXUDZPNUNLMGRGMnFDV0d4NlZHcGpIMTdtaGIya0MzZHYzNDRuYU5pT3ZCaHRYOFJxbjdYcW1TeDVKckJ1eE9Ud3FaRzJ2c2RJeXZGN1piZDZ4c1k2VWZjYkdvSjFCL2NYVWQ3WDA2ajcvY2gvY3JuSFkweEF3TUJMa1phc0JKS2haVVVMVGNDbFcrZlRUNUU5cmtaT0hvT1hrOW5kL2NmN2VTMzk1UEcrZDhmWmd4Q3BHak1nQkhIK284MG9SVnYxYW9vMVZwOW1FUTcxMTZvb3k3dVVlMlNXUlF2MXNIWXVuNnNrc2JVQksvaUExZEhnY2d3aVVXNnpTSDlvU0lrNjFKWlNha01LOVFhSDg5SVlLTjJ4anBzaGRTbExnaFk1WXd0WGtVQWlxMHBUbW9BWmo2VjBoeFZ1NzAzY25jdVZCY2JGbFdtM29QeUd3MG9JbWtJcnFXWGNWNmV1bkVUYkRNM2VQYWxCTkdCUlkzL29wdUN2L25wRHlFYmZKMkdRTHgzYi9TdWQxRGttTW41RURyK1dtZ2RIMGpZeU0wV1pKRDBJWDNIK0FycHRSTWdTY0paRlJTd3JzR2NDSlJYNGxxYWtNZUd3aWJsVzh0NkwxQ0Y1VC84QVpXbjg5TWhFbXc4Zng5d0pKWkxpVjQ0aHlrUEZJVVZhMHFXZG1OUC9BRTZoZThmRW5Xa2syM3QydVlaWnZIY1BKZUxqZ3BteWdEdUl3NTRxNVJWVWJrVUJJNjZoTWZ1Y1NTaHZvcGc4Z3gxeEJJSnBJd2szTG5KTTBQUGRxbWc3dFNTTldTbVFnTldDWHR4TmIyMk5uQnVtOXpTcEtVaWlqQnBXUXhpUGlOcTFHbzJhUzFKcE51RVhkOXJwTEh3RzhrdC9JSWZyY2plRTNGcGx5eGxuQi9TOFNsMklXbXhvRHVEMTFsWjhtN1ZkRWFXSEJhdGtuM0xiVHk5WTFLMjFsTEhGM0FRWmVQY1pIMmtQRUduc0pVMHIwMW52S3V4c1c0ZHNkZHpmVTVGaSsrUG5XR2l0Y2Y0OUt1SXZyUWxHeVZzR1c3WWhxQldibHdaVkh0Q3NoSFhXbC84QVY0Yk4ydHI1ZGpHdDdsbDJmYlVMOVJzVnZGUHVWbDJndjdMKzAvY3Y2UXpRNVB2TC9iNzI5dG9sREc3WDJjV2xHN01OK1kzclVqUXJlVGkwbFBkam5wM1NmaDhQMENWanhaN2JVdHVTUEhSdEZlM0hrOXZjMkVXUDdNSDE4Y2wyYjYrZU5USy9lQUREdUFBMENydDhkOTlhU3d2ZE02YVFaMzNWdGp2cU1PRCszRjU1SEppbGU1aHRZL0pMRTNsc1Zacm94dzI1Q0ZHV1AzaG1ZcjdWQk9oTXZNcmozYVQ5dDY5dW9aaDRWcnF1c2ZjV255TEk4RXdVSGl1THh1UFJZcEhrdi9xTGk2VjJpam00U0MzRlNmOEE3MjcwSTJKQTZkZFkzSXpQTmUxdkJSK1BpZGx4dUdzSEh4MFRsMmU1d05BczA4Zzg5eG5qalh0dERMaTR6ZVFTTEl6Tk5QYXhWS2NIcXJsbkpjN2ZvVGJWUEZXMmxza045aVh1ZVJxdGNic2szci9RYzgvTlorUVdXWDhaelUwc1dFVlI5Rkl3YnUyZVJRdEtzZ0xyUmxBWG1GWWxkNmZwSW9iVGRqU3V1djZvNVBMR1Z1aTZQOVNzWWZHTVhZV01kNW0zYjlpekNmU1JqOXhMaWFRVzFzd0hJZ3UvYm1tb2QveTBQOSsxN1BiM2ZYOWZvZEk4TmFVclczOXRlbm4vQUZLcG1XWHhEeVlOQkdWd3VXbnFrYm5ra09RUS9INGNqK2UydDFSbXgvOEFsWDlEbVoreG1qKzJ6L011TE1RcEkySmd1cFJQSkZieWxya056WjV5VTVMVVZBQzh2WFdSaWV0bzZHOWxqUmRmTVJQSnM3ZVkrVzNTM2FkN3FHWkhOb0kxYUZJaEFpMjgxS01HZGp5WkE2OVNHMXBZY2Fmd01Ia1pHckd2eUtaTVVMWEdacXlOdXNrczBseTVEcExKZUpiaUxzaFZXa1lvekdpcnNXQk8ycDQxdWJkZng1bGVScFFyZmhqdjRabnNKOXZzMWVXN3l5cGpac2ZOYjQrTmdabGh2WmFTMTQ4VnFKQ29Ya1BhS2I2Qno0N1o2VEdzL2tnekRrV0cwZG9GYTF5K1JoczRjYmJ4VFk2OVZwcmNjbGprZ3VTcmlWNDNrSU5HQnFFY0tUN2lBd0ZkR3VxMWZVRWx1RkdvbGVkR0REU1hrZG9qMlhDcVhFSEZSM0xxcGFWalVjcWNpcXFEbzdqZXBTelA1YVZiUWdaOXQ4dkw0dVljbGZZNlM1OGZ5ZDFidmVHSmVVelJZdVVYTEJRZGlqT0ZEYittaXI2NmR3TmFESmxyckQ1NnpiTVc4L0xLTkRIOVplV3JVYVc2dlpac2hmR1ZTQnpFY1lFUURhcVhwTE5JRnZGWDF6ZnlSUTNscExGTEpJTFdXOFVTckV6NUdidk9rZ3BRRm8vVG9hVjByVmp2K0VTcmFlMzRaZFdjeCtWOGR3TmprSXJlTExlUDVCa2lobGlqU0NXM21xYUtoQ25tbFYzNVViOE91c3FyVjdPWEROV2JVU2hTaXpQSTRUWVBqOFZDQlN5dFk0SFFNYUx5OXppcCtlc0xrYTMxUFUvYThlM0NoWWpqdU9UVEtBU3JIbUJUWXNLQURmNTZUc2t2STNOeTdtSG0yWS83YzhVeTBrRGczZHZZdEh4RGYrNUtCR3BBNjBEUFRST0N1KzlWNW1IN2x5UHM4ZTkrOE9Qbm9paWZ0NTl1Qm14SGY1QWxNZERKRWkxUEh1ek80VlFOK2c2bjhOYjNJejdGQzZubC90dkJXYkpYZDBrdTN5MjV0WWtTd2dvNlJrUkZtM2VNR2gySkozSUlOZmpyRXg2Mms5TjVOcTBwdEVESnhHTkxQSXpsVWt4NnlURks3bGlhME5mOTBmejBmajhQRTRubjJic3JQKzBBWmhwTGEzeFZ2SXlyQzhadUpsVmVzc3RhbjhhdWRFNCt0bVovSmEyVVM3cVg4UTM0bVlMbTNpdDRsN2I1VElJQyt4Wm8wYnVGYWZEakVQWFVNdXR2Z2l6ajQyOGNyKzYwQS83Z29tYTh2dkwrMWtlMnZMV1lRVzE3SCt0T3lvNUhiWWdzR3JYclhWbkc5Tk5lNEZ6MXV6TnJ0b0dNSDVuRm1GdDhENUpIOUxub3d2YmtYYUNjQ2g1eEgwWS8xSnFuTmdmN3E5UDBOVDIvbjFqN2VUUzNiek51ZHQyalM1ZlkxcVNhVTJKMi9qcW5GMVNGeW9kMnlzTSt2RXlXOGRSY1pNbzB2SHF0cGI3SXAvNDVPVC9rTmFsWG9jN2wxdElXd2NGbmo0TE5yb2lPS1IrUmNna1ZacURZVlBwcXR5eWRVcXhKYU9DZUNlOGh2bEJhMHRFa1RIcVN3U2FXU29lYW5UWUhoR2FWcFUrbzFTN09xMDZzMnNTVjJuMnIrWTVDNmprZ2JiMklWcUYzNUtnSTIxVERmellUS1Q4aDE4NXgyWjhIOERUSlhNTko3bTJnZ3RYallQenZMMENpVTJJSzhqWGIwMWdQM1cyWGtYNHpyM2FueVhVSTRISHhXdDkxTnZaNm5XUFBUNnVDamZ0SDQvbEp2TE1uNWxrbzBpeDNqOE56RkROeEt5dmVTcVUvVFFHcUFsbXI4dmlORys2OHFsT09zZGYzWklqNEZmdDNEelplWDl5Ni9hL3paWjRpaW5ta3ZaUVp5aWlVR0xkQXBZQlJXbkVra1ZOTmNsZXJxbzZIb3RiYlVralI1M2ZTWTM3V1l5SmkwYTNkNnBOUVdKTGM1d0RTbnJ3QitHai9BR3VtL20vK3RUbC9lN3BWeVB4aGZqNkZYVzlrM2NzN2NwSEpoRmpab1pDcWlPNm40a2dsU05rRGUzNEgxNjY3VldtZkU0UjBpRXVoUDhmbnhOcGp3K1JoaXRRbHhIT3ZlbW8wa1VpaElrZnFWRGdtUU1LZTV1bTIwYnpLalVXTkx2b1d2OXJwM3h1ZXlYa3ZrRjFhNDd4V3pzNHJXd2VSK3g3aEx4VndTT2twSTRxeDVVNmFGdFpLc2RiTUlhYy8rSlkxNzViNGRQa3hhNWp5ZTFqV1ZKVXNwcmlhM2hGd0N4NUJqK3BxY2dnNGhLK3Rlb2JEVzduUWJKYXFJUGtPUndLd1NRM01scmN1c1RSUnFybEkrd0krUkVjaGtVckc0akVUU0JpR0pQUmRYMWJpZTROWkxwMksydmZJY1hkTEZZNDdIdzJ4Wm51c21pQUxCeGpBUll0enlLQ3Bia2E5ZUtWUEhqTGRMa2JiQ2d5d2o1dTV0R3NGdEpMcDUybHVMRXhCRXQ1SVVoYUpUeWlKVkJSaVVNckFrQ2dGRHF2STYvQXV4eUMvQTRzaFl6Wm1aVWFaemUzTUVNRnVZeVpaV29oWkNQYnhEQTlEMDMyMUhORHF2Z1BobmN5eVpIanQ3aVNOSEF1a2tWMmQ1bFJlNHNMeHNPcDJXalVBNGoxMzIwQStuUU9iVEoxbTl2Q0wyVHlDNStqc0xhT2U2dUxhRm81cnFWUWU2a2NTa2Zya0MwSCtZVjMzM2hUR3JNbGt2YXRkRUNzbkRCQTFyY3hDZUdMSlcwRi9CRGRQR0wyTDJzeGp1STBmOXR3U1Q3VzQ3ZkE2dnRpZFBUTWxGTW05UzFBTDhkTWMva1hrU21hV0MyV1BIMmlPVHdZR0lQTXFjVFhpdFgvU0NQbjEwMlJ2WW82eXg2Ly9BQ1Bzb0xLdzExQkRjcGNUUnJITHhBVmtBV05nSDVKd1psMkZLMEk5RFgwMEJaQktjb2xaS1VPR1V5ckpjcUQyRUNIM1JrRWhBZzl0ZVRBQTEzcU5VSlNYdlJHTStLeVVXTVRNdkxhUVdVMGN5Uld6U2hKWDdkVm9uRWZ1TWVCb3RmdzZWMFc4RFM2QTFlUldZWUpBN3BoNDJ2SUtWWitJcWZkRVBjcWl2UUd2NWJuVlZxNkl2bHB5R1o0REF6M05pcFp5RVhzMUNRL2lXTkJ4NVU2ZmhYUXk2d1Nsc0ZXZGcxemRpYTZySzd6TkZJd1dudWtxUUc1ZE9QRW40RDVWMWJSTDZDdk1mbU5kM0Jqb21nazdhL1RnRVNPUGFBRVhjRmdLbWczSi9oMTAxMTRkeXVyWkRzcElMbXplTkVXck9LU1JEZFF2SktsRjI2aWdCL0hReXQxUVZhYXRPU2JiNFZKSW50MkI3ak1vOVFHTEdyRXFSOGZRZW1wNDA3TlNWM3p0YXJvTC9tdUVzemhzZlBGR0k1WThoYlJUc2lpaGh1Sk95OWFWVWppOVRyUXdMYTBwNnlDNUw3bEFSLzhBeFVlQVhZaUY5aVlKWm1XclBKYnF5RllnQUNHSWFsYTFBSnJxOU8weHVjbERhLzJvbHY4QWJMdys2aEZ1bHNPU3FrYVF5TzNFTkdPMk9TZ2tWNC9JYmFlMlBJdWxtUlY2enJWRkl6L2Ivd0FibXpHYWEwbS90RjRMdjZmSHlSUElycnhqVnVCUmlVUE1rMFErbWlhWjhpb3JMNWtMWThXNXA2U2VZakhlV1pPMnlZeUVsbGZ3U1hUMmx5SE54WlhIMVVsRTVGZUxvZmFnVmVQR3RPdXBYejFjYU9TRk9PK3M2RFBONTlIaG9MVHhPZTJ1c085eUZIOXd1SWtrdHByYUpxTXduSnBHMUY0cjNQWGNiNnpMY1YyOVg3dkkwYTU2Snc5STZNRzR1VEplU2ViWnZPZmJtZU8weHlMRFpTdmVDUjdXOFlqdWNDU0E0Wlc5MVU2Y3FIcm91bC9zNDBzaUJyMSs3ZWF2b01lUiszUG1lVnhuWXkxL1pJTGVRNUZibUdPVVhDdkFwa0pIT1JnVkpEZTByWDAwT3VmamRvVlkvaVJlSFNIYWZrY3hlZTI5bGcvSTREanBjZGtJN21US3JJcVRTUXlOSmZXUTVMT1hCS0RrUlNvcFUwNlZwMHZHZHJVMU1ma0pWdEMxT2FZd1VzNkVNSDd1d0NnbWhYNS9oclNremlVYmo2YUMyZEdlRVNSR3JwVlhMSkl3SFE3VTIwaERIRG5jeGJYL0FQYjdUTVhVVnU4aUNPQkxpV2xTQXlmMVVGTnFmRFVZSGtOV3YzTys0YVF5WERlWVg4dHhCRzhzYS9VdklRWnlzVXBQY0RDckkxRHFQMjYrQTZ2YnhDZUsrK2YzR3cxbzVzOG1sMDE2VXQ3aTN1TGVHZFhqdHlKSXdmWU53V2JvZE5iRlJxR3RDYXkzbVoxTGw4V3VmTGZPZkM3L0FDbWFseEZsZjJjVnc5bFl0WlA5UXl5Q1M0ZVJ1TXFsZUxobFNxblkvaG9ITGFsYnBKZm1HVXJlMUhxRDd6SzVmL3UreWxHSHhaanNNekR6dTdaelpSenZmUnZBM0NOK2RFckxVT1c2Z2JhdFcxcC9BcWU5TkRyYTQvTjI5NUZhVzNqTTh5dXN4ZVpaNFdqNDNLKzlnenk4U1c5T1EyOVBubjN6Vmh5dyt1TzA5Qnh0dko3ckVSdzQ3TzJsK01xVkJqZUtNejJ6cHhDODFlS29GVHN4WURXSmw0YXM5MVgzTjNEek5paXlrVE1vdDFmWHM5M2ZXVi9aNGVXUG5Fc0NMTTBzcFkxWmluTGlPTGUzclducG8zQTFTdTJVMkNjaFBKZDJTYVF3L2JmeUt5c2NKZjRmSnovMjU0NVo1TE9LOGNSUnl4TW5LbkZ3QzN1VTErTlFORDgzQzNkV3F0eGJ3OGkyeGIwdVQ2NjhYVHl1SkZ4ZHoyYk00NlY0YnVGWTJqUGF1Q1VpZWhBQjRFcjdlbXFjV1Y0N3VVYUhJeDF5NDZ3L0ZCL0YrTDRlZnhUSFN4SWNaYVc0aGVPNUVqTkpjL1JvR1dpbm92NnVQRVYrUFhSV1RJOStuY3pNVklVTVNQSzdlWEM1L0xUWE0vOEFickdSYmVLQ2FhMW1sdDQ0WGxpa1kyOHNlME1pbFNYN280bEs2UHhWM1YwUUp5YnRXN2k1NGhjZVFYL2x1VXhxd1BmWWZ1L1JLM2ZyREE1SWRINXFBM0U5UjFUaWFHdW56S3RVbzZqWU1sbk12UXNIQmVGWDEvNUhrTGhKWlljbGF2SWdzNStMSkhHQ1F5UURyd3FBT1FvZlhRZHM3VlllcGE4V3N5T25raXRCYk5qN0plZVVzN1JaRXRtUDdWQ0pFM2s1QmpSYUJ2aCtXaDZwVElTN1NvUXM0REIyOWtMdkZYbDcyN1BOVzgwVmlieWpvOXpjcEk2ckc0YzhZNDBUalJtWWU3NTZ2dGtXNVdqb3lEcTFSMThUbUxFeEczbWxzcFFESmJ5TkVhRUVWallvZC94R3VndDBrNWFFdEdCdlBNV3pSeXlLZ0RTUWlaQ09uT0E3L3dBcWF2eGRDRFIxMS9wSzh2dHNqOXJJTUpkU00wdGxjelc2Z2tuOXB5SkZVRGNVSFBRSElhcmRwOURXNDAyb240RHY1OHNzZVF2M3NsQm5hMFM1amxKNkdKdURxMUJXcEhRMXFOQTNqc0gxMGN3VlRqOGhMajhxL3dCWkE0dEp4V0RtNnNFQ2lwQklBQjNPM3dGTloxdlVkQng3cEtXeXZ2SXZMOFhoY2RldGIzMXBOblZ1SlRCWUdiZGhKSlVtcUVtbzY3L0RSMkhpMnZaU21rVTh2M1BIaHh6UnAyOEFGaGZ2QmFYYjNnOHY3T09lYnRwYXl3STdSOHVOS3R1eEJVZ0VVMFRtOXZhUzJhL0VFNFh2eWN2Tm8rMElEZmM3TGVNZVRZUzJ1TVRscmEveUZvL0lvaEVjcm93OTNzb0QxRkthSTRtSytPemxhR2I3dnljWElTdFJ5MFgzL290OHFzLyt4c2o0eGZYY2R0ZTRxK2RvSTU1RmphU0M2QVlGQXhGYU1yVnA4ZGFVZW81K3IwTGcrOStCZnlId081dUlJbGtudzd4Wk8zWWprS1FrcktLN2ozUnUxZFJ5Vm1yQ01OdHRrY3g0M0VZK1M2RnVGVmxaMlNPSjE2Q29aU0tWTzQycFRXSExONVYxTENYRFI1ZXd1OGFtOXRkeHlRTkpIKzJZeXlGUVJXblN1bnh2YlpCT2VtNmpUNndWRDRmRmU0b3NMNUNscTkzTlp5dEdhQ083alU4bXI4WElIOFBucldzNWc1VlYxaGpYNURDMTdqcFlqU2x4SFFxKzN0NkU3VjlOUVZKdlBZczNQYkJxOFR1QmxNZEpqOGd5dmxNUS9ibExFQm5oNnhTOU9oRzM0NnRXamdwR0h5VElZTTRDN3RjamYyc1VmWlprV1NaRVlNZ3FLQWtIcU5QWlNvSHJhSEp6YmQ1U3hjMnR6aXAwbGtzN2lxZHRnU0RISVhqWGJiY0x0cVZVMG9aQ3pVNkJYN2tXblBzWldCVlZMcEZuaDRnQmVGQXlrVS96SXdyODlKRFdGVEloTHV6dE1rbzVUUlNLSlZPNDRzT0pPM3dPbmx5TWZMTVlicUc5aUk3a1pCZHE5Q0R1Q1BXdW43RHB3NUhDeHdGamZlTVpHMHNsVU5HeG1nY1VPMU81R1IrWHQxbjcycnBtbHNWOGJFS1BIUTNDZlVRRm1JNUVwMFBjQnIrV3RHVE1nZzM5aUpMZVMxV1paWGtqMkIyZFpGUE1ENGRSVFNrWURZcCt4YUc3aFV0ZEtURlNuUmo2bjVhaTI1anNTU1VTTUhqdDRiZFhnRzd1cGFSeWFIbURVTnY2Zzc2ZG9paTRQdDNtSWJ6S1M0WEpleTJ5b1czZEtuMlhFWkx3T0R0dnk1cFg0NkV2amNPT2hmUzdtV1Y1NVo0MS9ZZkxiN0RTcVhndTErb3NYMy9wcVFCMTNCNUpvakhhYWtMMWl3dGhJbE10MWVmdDJZakFtVTdsbVUrMEowM094MVlWZ1hLNVNUS1RkMVNzVVM3cGJyc0ZKNms3KzRuMWJTU0diQnpPd1A3dEdIeFViNmNZeENqL0FKa2JVUHhCMzBoR0xNNGFzZzVENGpycENOdHRQYnh1R2tQRnR3V1pRNEZSMUFJTzQwaEdpUyt1VzI3emhmZ3A0aitDMDBoRFA0QjRsYmVaNVNlenVycTdoK25nYTVLMk5zdDdjT0VJQm9qeXdpZ3J1ZVcyaDgrWllxN21HY1RpMjVHVFpYcVBrSGdQaU5zcnJZWVRQWDEwYWhac2hjUVdOdVFIS245cTNpbWMwSW9SM1JRNkdyeWIyOFBscUZXNGxLU20zUG5wL01hN0Q3YTV5OEZxY2Q0eGg0ckdhbi9VU3czZVE0aGdDclZubWRXTkdEZm9wU3Z3T29PNzd5TldsZWlVL1Vjdkd2dGo5eGNyYnBDOTZsaGJLeldveHRxWWJTMzVBdHNSYUdGVHVCN1QvbXJVNm92YXFhbDZoRkxXU21JWDQrQTQrYi9hRzR2dkJMVERRUXdZM0lXZmJtdjd5eVZaUklZcWwrTE1CS2FFY3R6MTJOUnZwWXNheFczN3QzeEQ3WGVmRjlwcmI4RVVUWldXRlhEdy93Qm90bXRieUtYaGUzY2o4eEtSVVZPMjRZLzBsZFhYeTJuVUNweDZwYWRUZjVINUJtcHJDMXViZFk1bzdPVkpVZEZBYVJveHhLbFczVThXSTlwK0dxc1NyTFQ3bG1aNU5zcnNXeGdjdmo4NWpJM3RHTFhNZkdWbXFTQkthZXh0K3RLZ2oxMWw1YTJvNGcyK1BhdWVuWFU1UnN1M0xlVFpDNGpndXJSSlh1ZnFGQ3JLZ2dvZ1VxcHB4TzFBZXZYWFIzY0tPNXhkRkxuc1JZYjY0aG5HV003UXhmVUZRNnFXWmxlck1QOEFLYUhZN2pjNmxhcWEyd05Xelhxa1BZUEJZN0tXK1F2NDRUUGZXUXRyK0oybFVXMFZrR1lTTFBGUWx3VFJTd2NNUFFHdWg4bVMxWVhaeXZuNUYxS0swdnV0UzgvQ1BITWxQYVlUeUZiR2F6dk1malA3YloyY3FJc0RKTS9KNVc1amtDVEx6VmtPNmlsZGN4emVSVmJxTjZXY3RuVzhIaTJ0YXRrdjIxaUFoNVQ0NWl2Ri9HNThyZTFSY1hDY2JpVkVyRGpOTE9aV3VtQ0Exa1ptRGdIYnBxdkJtdGxzcXJyYlYvQ09ocGNuSFRFdHowVlZDK2I2L0VycWJ5SExRNDdPUzNGek5ZNDZPL2h1N08rZGhIZlEzWWliNlowNkZpZmZ6TzZqa2EvcTFxNDZKV3FrcHRIVHQ1bVB6RzhsYk84cXM2TjlmTDZqN2ovUEY4OThmaXcrZTRXdmtjVU1sNWU1YTNhTmJhN3gzRXFYWFp1RE5JcW8wZXhCcVY5cDAvSnI5cE4xNlBTUEJnSEF4dkptVmJkRnJQYUFQZTVPM2tTNWZ2UE5qcGJzM01VaklPWEN5dDF0N1VNOFk0cnlCWnEvanNLNkZ4MGNMeGo5WHFibklzcGJiNi93NkM3bFBIVGxjTkxqUzMxTTEwcTNrRXNKQjdKQkt4OG1PKzNLcEsxOUJvN0ZrMjJsYVFaSEp3NzZ3bk02aC83WDUrKzh3d2R4RmtQZlA0ekJLMStHb0dMdHhVU0U3dHhaVXF3L3pWK1dxK2Jpcmp0Sy91ZWhid005c3RXbjFvdFJVd1dUZkdaakgzOWpQMnJ1YklQSE9iZEQ5U1k1QXZkb3JnOFRHVmJoL1VEMDBkdG1yWGtaYXN0eWE4UjIrNGRuYldtTmk4anlxUng1VzRtdmJ5MnNLRnBGanRCMmllVEFFdXp0emFxMW9GOUJvUGozYmUxZElYNWwzSXFxK3A5ZjVDLzRwa3NUbFZ6aytWYVY1c3RqTHFKWmhNakt2RXhNam96OFdCL2E0OXRsNUZqWGNhdnpZN0pWMjltbVY0Y2xiYnQzZE5DdXVXc0hGMVBmL1dwOU9zSXcwY2tuS0dPVXFuN3ptaE95amx5QXBYYW1pZGpqU05lb0lycnZPblFSL0xMbTR1Yisvd0NiRzVnZVY1QTVMU1NPR1A2eTVvU0NSWGZSbU5KSkFPVnQyWVg4UDgraXRjYW5qZWFka3NIZ1hHUlhROTMwOXBkWGtjOTJWVUFmclJPUHJxMjFaSzFZSitVM0dMeWNNV1F4c1lodXI5NVpKcExVQ29GL093U0VnY1F5eFcwSUhFN1ZiMDFWTWRTVDE2QmY3ZlhzTFo5NzdOMmZLMTdmMWtrOXRJTzNDMHhXT0Z1S0dRcTNCU25iSXI3dXZyb2ZPdlRwOEFuajYzMStKZlhsSGsyUDhzdlBEY1BpT3hJajNVWDExc09FakNSdUhLSjFVMHFRcFpnQ2ErdXN2SFIxdFp0Rzl1VjNTcThTUmxZN21mSlh0d1ZZSWtqSkh5RzVWVFdvcjEyb0svSFdOYVg5VDFiQzZxcVM2d1FNYU85T3RxVkE0TUdZanBWYXNGQjZWb053Tlc3UjhtWkxyM0UvN3FxMTFZNDNEeE1ESm1MeVBrQlN2YnRnV1lFMTNISmwyK1d0TGhVVmJPM2djcC8yTEpPR2xGMXMvd0JCdWp4cVlXendXQXRVaVVvajN0MENkeDJ3VUJhbnpZYXF5WDNOc0c5dTR5bzZxRlBVUy9NTTVhMjF4YU5QQndtZG5XNVVrRWdzZUtlMENtd1VOcWVLa3pCcmN6TFN0SnNvWW9aM054WE52TFpvR3VPKzl2YXpTZjBscFBkTCtGRjl0TkdVbzA1OEpPTDVPWk90cXJYYzBwQW5sZDlGZlpLWmJFY1lvWTQwaGNiQUZWTzNYclZ1bXJzS2l1b0J6Y3FlUnF2UkpJTllDT08xdjhWRGJTa2YyNkY1cHAySHM1TjdCeFlqZW9ENzlOVlpaaHZ4ME5EaE5LOUtyKzFOdGkzUGV1NXVKeVdEcXpWS2d0eUZ3OVNhVXJVQ3Vpa28wTVRKYmRhei9HcHZ2YlcydUxObXVrSldvYU52ZHpSaWFJVllWS240SFRxelRHdFZiWmFKa1BsRjFid3g0WHlpWHVSeTBTMXl3b0N5ZjVKdmd3Qm9HNkhVWGhWbnVyMThDZGVVNnJiZlh3WUFpaWx5VjdjWkdVVVdVL3RxZjZZMUhGRkg0RFVtNFJWU2pzNUczRDJxUzNVSWxIdHRsSGFVN2hTU0ZKL0UxMjFYWndqUng0MVpwTWJzL200UEZzUi9lcEkrNUJETERCMnVoWVNOUWtmTlFDdzFDbE4xb05EazMrelNVR3NCbHJQTkpZeVk1eExhM2tzY1FLR2xPNDRCQkhvZCttbGVyclplV3BWanpMSlJ0ZUVGMmZkdnhYeWY3aUJyVEh2R2xoWmlVV3RzWE1iTk13QzBRRUZhS2dwdVFTemE4dDRISWVETThtU2x0MTNQU2RKT2w0RjhHTERiSGVWOXhKTnJzdjhBVVY4RDR3bmhIaVdNOGFJRW1SZFhueWt1dzdsek1RenBYY0VKWGo4TnRHY3JsLzVPZDNYN2UzOHd6MjNBcVZoT1V1L2o0c3c4Z25lM3d5QVJsR2thT0haeng0S2FoZDk5MjFHaTNXTnJEWGRrNitZaWZjbkpYNldHQ2pkWXhhU0pQTEd4VXZUdEFSQUJQODNKcWcvTFhSK3k0VnV2YnVjbC93Qmp6S3FXTmVNdjZhQ0JlWDl1TWJGWjMvTzBpY3NwaVdRdEt3aUFlV01FVktqbjI0L2FQUS9uMDlNZnErQnhWOG5wR3FXRjdaTy9id1drbUVoZ0R4R1QzVExNRU1zZHM0cC9SVXl1N2RLY2E2cmpyUFVrbnF2QXREd2p4Mkx6UFB6WlROOExqdzIxc2JTU0MyeUVRYTJudkZpQWxjcW9BTFFyN1VIOUh1MnJvT3FWS3R2Unkvb0dYYnMwbDBoR1hsL2hmaVZuZlcwZ3dGdGtGdVpvRmh0NUlJTGFQdHlqajc1VTdMbENxeU90RUhRc2FpbW14dTh4TEtycXJYWXJMTitOK1BMNVpmZVA0dkEybVJlS0pZdTdidXR0YWQyUnlpVTVjVVZCd2FuSm5jOVQ4QVZTMXRzdHNHYVU5RWEvSWZDZkg1bzViZkg0bTJ2Ym15WVIzYVQzdDRyTGNoakdlTUFtS29rZjZRdzdsUVFmYlhVYTVIWFdmMExIaVQ3RXp4cVR6Q1NiNlRBNVBKV3VJdHgyb0x1Tzh1SllFaEJLdlVTcWVYR28vd0RiOW8vS3NNcnBaZXBKazZLeTZhQkxGWVB1ZVA4QU95ejJRZ3RWdkpHTUt0RUJQTGN5VjVGMWlSelYxOXhadUZLaFNkVld5dFc2SXZXRDA5V1MvSThmNUo0L2pvc3RINUZkSzhEcmJTSWJkWkpFTXNoaUtGRWtSdDFZTlhqMGJjamJVY2VldDc3WVdwTEpnZEtUUFEzdGwvS1VudG9MbWUxYVlScmRLWWJTVmFPbFNITFJYRENvci9TS0xwbmJIcS9BZFV5YWR3bDlONXRQTkk5d3RoTGNFSkxOT3pYQ3V3Q0tCN1pFSnExQjdkdWc5QlRWSDM4VDZObHl3WkYyUnN3T1J5K011cnU0eVZqM3J2SnNHWVc4cWR0U2tLaE9SbjdKNUJVNnJ0MTYwMHJiR2trK2hGYnBjcnFPZUc4NnM3ZVMyaXlsZzBFTVViQ1NkWUZrbFlzRzVGVEU1V2g5bzZWNjZEeVlkMnFhQ0syaGR6WmZmZTM3Wlc5emRZK1RPdzJGN3Nyd1g4VjNISkh5VlFIV3NhallNU0tkYWFuajRXYTJxcW12aVUzNWVLcml6aC9BSzIzM0krMG5rRXVHTnptOFExeGhWbC90ZDNKZENLU0JaNGpFNUFlZzdoQkc0K2RmWFJ2MitRcS90YWNBZG5oYmxXSnd5dmpEM05yRGgvSU1WSkJGR2lLeVhsc3psWTJKRmVKNjBISGM3LzRndkZuVStrTnBueFArNE5JK01ramVXRzZ0cEhLaEhLekpLTnh1eDRNM1hrUUtEcnF0WXJMV0dTZWFzd21aMjhMVE5iMnBTQ09Ja3JiMElMbEF2SlZCQlByMVA1YWpzYzlCM2tySFVtWE5wRmZ4d09uUGd6T2t6Vk5YQlN2RUE3VjlPblQ4TlYzMjJocnhKWTI2U21DTFdMSlkvSjUxTXBjUldzVXpSaXlodDBTM2p0cmNiZTVoUXU3SGtTNzAzUFFBSFZ6dmpqYWx0YUdyUzcxbmNNT092QmRTZHkyN2lSWEROSXJ5RlFIVUxSZUJWalVHbzZqcDA2MTAySk4yMElaRWt0UUw1MWtZTFh4UzlrbUErbnQ1clNhNG1BYml2RzdpcUtDcDY4cVVOUlRSYVNiVUlxNmFqQmJ5eXoyeHVBaGFPNEVieGJ0ekVTaFdQc2tLaWc1QmFtdGQvanE5cHJWbFB3Tll5RFBsTWppelozRVZqWVVpanZaZ29odXBwRjd6ckFBN0VLcXVBemxCVnFoUWFFaEpwVjY2aVV0OUNsOG5oSXN0NXplTzV1SThuY3ExemIzVUw4R2plQ0JRUzZTTFEwakI0N0hldjQ2bGkzYkZESHk3VTNLQ1BqeWp4N0VYRnpkWDY1UHgrNXlQZHpONWVjbHVPOUFBMFppNGUyZ1lGS0xRMUczU2hiSlN6dDBTOEkvaVFxNnVwSjgremZoT09mQ1N5WGdrdUluRHp4aVNSQkNYamtNYlN1MWYyUTBpcTFEVGx1ZFYwcGUvelJZOGlycTEwR3Z3K1N6bTh4dWJhQzZrcmVXVUV4alFveFNQdXlxV1lHdkV0UURiOUk2YmFmTlNGV2RGMGtycmVaN3NzcDdXd1dDU3poYVJDWTZQZGxkdGtwWGZZL0UwMEZkWWQyMnM2ZDQwSXAzNnY2SEdQbWw5OXZ2RTg1NC9rTUJmUklyWjk3bkp6VGhsTG1heW5nTW51M1pDWEM4cUNtdWg0eXlXVG53MEJlUTZLeThaMU9Mbnh0K2xyY3ExcklzZ21qS0JWUFJnNDl2clRXMlk1akxhNUpiSzJJaG1EcTBxdFJYclFjVHZ0ODlJUnVsTnhiNU95a2RTaVNMYk9TNEI2cWxUVWpiY2FRanl6ZGx5RjFaY0l6VVRSbjJnY3VGVFFrZWg0NlFpeC9FY1RqYmE0c3J1V1dPQXJQSXpLSXpQUjE5cWdSOGl6VkIyQTY2SHU5eWFDS1ZpeUxsOGRuODZ0R3phWW15Z3VYdndZcHBjcEdMUTlpZU5BV2FQdkZsMllmMG4vSFEzL0hDa3ZUdnFDL0o3L3dBb2d0N1hKejJGbTRObFkzNHVMWlpPMGpXRXNRQ2xDeEx2N0t5TVFBSzdhZXRhYm5BMXJYaEZxWnZ6TjNhS3d4VnJjZjM2M2lvTGVTMXVJZWF6QUlCSzdSaU5PSzBaVFU3MDFsVXh0TnUzUTJzbDFaTGIxTmVhZ2x3dUprdjdrSkRsYnFXRzBSUkl4dDQxNDh6SEdYUGM3Y1pZbm0xZVRIcFFBQ2E5Vm9YUXBkdHFtZFM0Y2VKTHJ4bUFsM2Z0eFExdWhJdkF0SEpRZ2JOVWxlbkplbXVheVdyUzdOckZadHFDSkxpN0NhT1NUSVFHWU9yQ01UQWQxZGpYa2FVRmFWUEgwMCs2elUxWmRDYjZDMW1zamUrT1hVQnRJSTJzWnkwVjUyVDJsaWh1MUtNeUJRU0tTSi9SNm41Nm5nVzYycjFDY2lYMkhwMFpJOG84YnVQSEhpa1NVeXlpT05MWEdvd1piZU9DVG1uQlNUeDdoTkJ5YXUzNWEyTVhyVXRHQnZTYmg2aTdrTTdjVFc3UzkwR0tlRXpTcE5Fb2JpdFlpajBxckthL0RZajhkRzQxR2dOa3U3YXNWZkhMUEV6d1dPUXRQSDdXNkY2SnBwN09ZbUMrdDVMWlRYaE03UmxVNHJUdDh1S051dm9OU3pZN1duMU5GZU85YWRheU92Mng4bnRzaDVITkdNNWNTNUdRM3NveDEzeFlXODVjTzZxVmNxNGZuSUVkU28vM2E2RXk0WFZhd1hZc2xiMmhETjV6WVhsOWU0bks0NjNzamw3aUZyUTN4a2RKWjVVVWxXN2JHakFLdkV1SzcvcUdoNjI5T3EvcUZMR2xacENoOXZaYnkwOGlmQzUyZDRyQ0dFVzMwTndXTDBsVVZaV0JLc0ZrWXFhZEFmVFRaLzhBY3V2aVBqMFVNb1h6YkhQZ2ZQTTFqN2RIYTNlNEU5dnozYmhjS3Nnci9FalhSY2QvY3hxek9aejAyWkdpTjVCYkdhd3RiaGdXVVB3Y2Y3c3kwL3hBMWZqYW1FVTJHZjhBMHIzb3Rzem5QSGJxV1NON01DN2lXTml2SVJ0MjIzQkhRRlQrR2hlYlhvdzdoVzFhT2p2dU9sMW1zZGJ4NDI3YXp1ciszdUliYStDOGhIT2k4a1lnRDQrMGltOWRaK0pwV1VvME11dFdrY0krVlJmY1Y0SG04anlsMU9JcG1nVzM1dXljRkZlYWdVQURiMDIxczQvdHpGVXBNYko5eUpzMk5jUDJvdE1ONTdoTVpLV3Y4TmxZSGVDZWFVTElKWHQzNmhlSkR4eXIra2orT2xiSmJZMzNMTVdHanlwZG1JV2V4elRTSmJUb0syc2dNaXVEUWR0aXNnTlBodnE5T1VDV1VObzMzSDIza0p1Zm95by82ZE1wYkJKQ0NiTWhYZlkvNVJ6L0FQcDFXc3FmMWd1ZkhzbjhwQjJPOEZ5MlV1OG5hWTVwNWJ5eWprbWdnaUlkajJrTXJLQjFZOEVjamoxcHEwb1NDa1dGKzVHTmpSY1hrOHBIRmUyTWw3YXBBMHdTZUdJU2Q0VWphaEM5cHdSL0hUU09wSWtmbS8zTHdqczhlWGxmNmRFa0R2N3p4WWtBam1HNlUxVzhWSDJMcThqSlhvMkg3SDcrZmRQRW1Yazl2T2tYSG56aFhidWRDT0hIcnF2L0FCNkZ5NXVYeE5IaTNtMlp1L0ozVEpOY3lSWGNrZ3ZyZFhNZ2t1cDFQWmtWU2FHUVBTaDFiYXNxQWFsL1ZMTEdzUEpzKzFsWXdSMkJrczdSMnRMcTV1ZzN0a2pXckFrQ3UxZDZWL0hWVmFxcjZsa3Q5RVFjbmdjbG1mSXNYYVhXUml4dHJuV09NZTdzKzQ0amNxWGhKbzhSTEZoeC9WeDkzUTZzclpQVWhhWkZuekg3S1dYanR6WlF4M3MrU2E3amRacDdobGo0WENHdEJ2MHBUVTB5RHFFNXNGZ3ZDYy9aMmFRTEJnOG5ZbHJoaFdiaE15RkhjT3c1RUN0UjhCcXB0MldqSlJCT1JZUEl2dDI5a2tpbkwrTGNrdUIvOTh0R0xkdGxPOWFML2hxVGNQNGp4S0s3aXRKSTdCcmFRZ3hqMzI1UmdSVUdqQ2c5UnRzUjY2bVFCY0g3eThIVnVTbW5yVGtDYWc2Y1lmOEE3ZjVFSk10ck5XamZ0a0UrbjZrcVAvcUdndVJXZFVIOFczWUJaYXp1TVg1SGVZdUU5dUV1MDBSK0FjVkhXdXcxZml0dXFtRFphN2J0QTIranVWM2tqWDJ0UlhBcnNCMS9MVmhVQTdLUDZiSzNsanhBZ3Y0KzdBRHVLL3E5djh4cXR5MG4zUWxvYXJhYzJkOHJPbjlSVngwMk94MWVNTjluZlMybHhIZUpLVktPRmVRSG9hamcvd0Q2WEN0LzZ0UVpJZjhBN254Lzl4ZU1ZenpYSEwvMWRxb3VKUXU1V3A0VHFma3JnSFZGUFRhQzJ5ZGxKUkY1L2M4bW4xMFNGMDVFUEhFcFlJYTlDRnJ0UTZKNkEvVUV0N25QZFFBallrVkcrbkdQZ3pBYkVNbzJHLzhBdDBoR0xBUFVqMnNPdWtJMXZJd1duSlcrTytrSXdqV1NacUlSWHI4UDhkSVJ2amhNUllYQ2o1ZmorT2tJZlBzOTVkLzJqOXlNTG1XaDd0dnpOamRScXl4cjJidFRDV1l1T05BV0RHdncwSnk4WDNNVnFobkR6ZmF6VnUrek81Y0VNRStXdWpEYVdkckxjWEFrTU1pcTVhVUtFNW9qTHlGUUswMzNxZGNUaDVkNTJXYXJ0ME84NWZ0OVkrNGs3N3RURy9oOGpHUXU1TEMybnpHTG1qanZjVWtVY3l4ZDZBTWx6YnlDUTl0RE9sSFRaazVDaktwTmRkamh4SzJOUDl6T0h5M2U5OWpDMXcrUXNiNlRPZU1zOTdacUlzbmJRWGtNTVFhZTdrSXU3T01EdGhTcXhDUlJ5NHJJZUxkZmJjOFNtTFFVNzNBNVRXRnJrcDRtVzh0ekxjVlpjZmNNSEQ4Vi9kaUNLeDNCRlNBVHFMcFNzdUE5Y203U1J4Yjl4TFNid256QzhzWW9XWEZYZHhKTkRHRHhLVlBOb3l1NHFoWUVDdlE2b2l0OVVXMnU2V2g5elZnYjMrNVhFMXVRaXhPUzdOeDVjR1lmcTlmYWZYUXVTdTBOdyt0d2lialpiN3hMS29Kcmd5NHlkd1VkWDVFSWYwa2tpcHBUWUgwMUM4WksrYUpWeHZCZlhveWtaWkhhR1RuTURHN09Lb0QyRFhhaTFvZHFmRHByWTduTmRFVHNQaHJyS3p3NEtCeXN0NUlrY0FaaDIrNlcvV2VQOUlBUHBxdkprVkU3dnNXWThWcnRVWGRsdjViN2ZUZUU0YWEzOGZ2VXY1THRaTWJtSnJPM2tidHNybG8vcTJsTElqaFE2VWlwdDdxNnc2YzVaN1JaUjNVdjlQNm0wK0E4S2UxejJjTDlTMW9Mak1Zdnh2d3JBNWU2dFovSjFrTWswTWlLOHR0YVFKM0pRSDNZVVVxQVIxcnJCelZyYkpkMVRWSTYrTDdIVSszdHQxM05idnhJa2ZkdktScmdjTmdqTVpGbGI2M0lSek1uTHR0UHlMUmUzY3NXRlRYb05hUHR0SnM3cFJHaStNRVBlR2xGSERXamZ3S2VzOFRsYy9jM0I0TjlIS2ozRnZITTVLSnlweDRiME5RVnJUMXByZXRrcmlTOFRtc1BIeThxMW4yMWorZ3g0bXdud1BqZjAxdWxMaktCVkVuRnBPY3hMSTRCL3dBcTdFK25MOEJvYkprV1RKTDdCbVBCYkJnai9lTThrVXVPd1VlTXRpend6eUdDNExjU3JtTmFEdG5ZOVM1MlBwcWpyWnRscjBwdFhRbTI3dGo3V1cwamQ1bFNGSTRlZkJ3N3V5a0FrVVArWHA2N2FkNmtLeFJRbUJyL0FCRjM0OTVBdVZ3QUVYMXcranlGbElIN2MwYkNoRWlqK3BKQU4yMi9ub3F0bGtwdHQyMStCbldyYkRrM1Y3Nk5lSXQzTE1VbGxuampFRU0waXRTUUNXTXhzcFdWRjRGZUpia3FONmsvaHErdWtRQjM3NmFEVFo1RzZsc01MNHplVFJpeWxsRnhqWVZ0NUx1NGU0dU81RXduTEZDZ0MrNGowNjc2cGRGdWRsMStoY3J1RlY5Sk5OeGk0ZkNaYnFlNnBOZEdHUzR0NVhVdGJnamxERzZxNXFKZVVvZmJsd0hycVNzOG1uWXJ0Vlk1ZitnankzVTZDMytxYWFlMHRua3M1MUN0YnM4YzlYV3FEWXh1L3VBcnZ2b3hKQWMrSUp5RVZ4Q3NiejFSWlNVakFCVXJHUGlkNi9NSHBxU2hsZGw0Z3k2eDF0TkVMaU5mZXJOUlY5UUJYWUhiOGRXVnM1Z3FkRkJqWldlWmlSbXRhTXRDV0ZUeHBJR1NwTk9JTzVIWFUzYXZjalZQc1doNHhjcERmdjhBOXg0YTZHWmpFTVVDMmJEamVSeXhLa2NhaEFVSEZTcFU3L3FKMjBEbFducGVnZGh0RDlTMUxpeEhqR0d0ZktjZEhNSkpMM0d3dmVXekczVzB0SWJsMkVabGR3ZVRsT01nOXhPOWEvSFdaa3lXMk9PK255Ti9nNEt2TXBXbFpmekQvbldZeHVFZXl0cHpKTGFoYVNHMjkxZnFHUEppd1UwMjkzL3kwQXNUdFp3ZGp4ZVQ5dWp0YWRmQTA0TnNXYkZibUdaR3RTanpwY0J1Yk9xRGlLOUt1UU4xQTIxSEpSejVtbGp6MTJTbW5JdGVYZUo1Sy96V1A4aGhtU1cwc0QyRXMxSHVJazRzWkZJQnFhbWhGTnFhTnc1cTFUbytyT2Y5MTRlVFBldVN2U3ZiK0ptWkhrbnlVdk1sbHRrc28xaFpuWWxqM0hPd0pvQlFhYXk2SXM0ZFdtMi9DQ3N2TWNwRmQrUVNZK1ZuN1hNOW9LcTdjVDBGZDFISFJmSHgrbVVaWHZISzIzKzJaWW1DMytpeDJHZGYyWEZ4azduM0hrMGhIYmhKcC9sNWJWK0dpY2owYlh3TWZIajFwWDQyRlJMVDZ1ZGJZTVFseE9DUG10VEp2WDVBYW51MnFmQkdmOXZkWkx4WTV0ZEtsam1wWkY0dkZIQll3eUZRQ1NSMjJJSHhySTJoTnN1djFOcjdxVk1qOEVxb1NNbkJMTFpyRWtwaStxdWk2dW9OU2tTMEkyQnB1U05hRkhET2R5cHVzZUpzdUVaVXRWRjdLR2tsQktsdHpISDdpQWFiYWFybnNLMVhDMUl0MUxEYzJOMnM4eGxTUldDcXpBZ0p6S3JRZkVoYTExYTZ0UUN0cXoxQy9qRnBiMnVNdDBsdVZZMEpQTndXQUpOQlN2b1BUVkdSdDI2R254MHEwMVk3WWVDMlNLYTVoY1NSOGxBN1pCRlB5OWRDWnJOUWFPSGJNaS85MUM4K0h3MklnUFA2dTVhVGlPb1dHTUwvQUl2b3JCYUxOK0NLUGNIT05MeFk1L2JaTWY0YmFZZTZJaTdGcGV3M053OXh5U0ptV1ZTZVpRTTFDUlRZVjByMmRyL0ZNcXcwVmNMN0hVdmluM2c4UnlsbFlQSExjUzVQSnpFTFoyVnBlWEN4bTZsWklTOHhpVmFjRkRGdVlVZkRYRmMzai9ZZTJyVVZUNnRMejhlM1ExTWVQSmxwdmpUOGFsZWVXM2NsN21iaUpYOTBCZVJoMEZUSnlBL21QNGF3ZUxTS0orU08vd0NCajJZay9FV2NyY1MzRVVNTTZySE5GUDNTaVBXcUlnYmtBVDBxUUQrR2o2VlNjbzFjTlBVVi93RGRUS0pqc2ZpcmlYM3RaNHRRcUFrRHZYazBreWcwcFQyOFNQdzExbnRPUFJyeFBNZit5WlY5OXRkbS93Q1g4d1RpcnJGWlBHd3lpTGhmeXl3TEJ6alYrQ0Y5bWRtcUFBMUdMVjY2Mk1sSFcwSTVqRlpPc3dNdU90TGZIV3NWaGtjbDNiQzFhZTR1SWxxRXVabzJpMmxaYURqNzFXbnJVL0xWTjNLbEYxVkQxT2dmQ0Zpc1BFTEN6bVJXa2x0WVk1bUlLQnJpNU5YTEFHdnVZZm9Jci9NZ1BJNVpmVndpSjVMNU5nc010eU1nVXlXUWdXZVNMSHF6OXNxUWxhRGtpaWc3Zkl0R2VPMUZJQnJLMUxXV2hHdHFwK29weUR5T2ExekdiOGh1OE0wS1FDQ0t4V1RnaHQ1WVlSMllvbmxDeHh4anVnOGlwYmdCVDllcmExOUNxM0xJV3ROMjEwQ0s0S1JKRXM3aTFlMGlFYTNlV2xrUGV1akRiTjlROEVNdkVCMmsyTXJjdm1RQnVVa3ZvUHJIZ011TnltRXQydHJGTHBvKzRnZ1dLY2x6M1pRalZNamNDRmpKcjI0eFQyMExiRFZOc1VrL3VRZ1prYjJObXZVdFZpN1VFelMyY2tyZzg1NFlXRm55VmhXZ1FNKzQ0a2RGRlJvWDdldXZmOE0wSzUzSHA2b0hlWlRYc1BqK010Ymk0RnRCY1N3TGNRQkFzcGRDc2pPd0pxd2tLZzdMU3JBZGRUeDRxcThwQStUTFoxaHZRTi9VV2NWdmdKRnZZM2VOTzhaWGlKWjVTQTNiY3FlS01SczNUaUtmaG9PNmMyMERNYVRWZFIzeDF2RkxjVFhxaUtTSjFSSnB5dnMrb2dxWVNQYi9BSlRYK0JiMDFuT3Jxb1lYS2ZmVW56UEhkOWlGb1ZsamJrdjFSUWN3WERmb2RWcVF0RFg0NnFTYWxvc2JxeFc4dDh5OEQrMkdOa3pIa055NU1zL2J0TWVnYVNlWm94dVVqSUNtbjlUTlNsUjY2S3djYkx5R3ExK3ZnVThqbFV3SlBwL0U0aCs2Zm42K2ZlYVhmazJPdFpjYlp5eFFXOXRhdkp6ZFk3ZU1JQ3hVQVZKSEtucHJ0dUh4djhmR3FUSngzTDVIMzhqdkVDcXVWekVKNGk0a1UvRFJtMEVKQ2VTNXRLZnZocWVqUm9mNCszVE9pSGxrdFBNcytpMFI0MW9QMUtuRS93QVJUVWZ0b2ZleVphL2NqeWV6S3REY3ZISXRLUEhMTEdkditGeHB2dG9mZXczYmZmUDdnMm0wV1p2a1VWQVZieWVnQjZqZGpxdDhlajdJcysvZnhHcnhyN3dmZUx6Sy9URTQvd0FodlN4ZFMvZmwrb1JRVFNwRW9hbzIvRFZPVGpZVXBkVVc0czJWMmlyYU96Y1Rpdkpac1BoYmxQS0x1N1ZyWlNYSnRYaWE0S0F5VVZJQ29JSW9xMHFPbXVWeVoxVEk2N1VrZExpeDFkSjNPUTVMNHo1UmNZaVcwdWNxMTNaM0pqN2xySkJBc2ppSmxrb0hSSTZmcHA3ZFNwbG5wVkZiU1Q2dGh6R1d2a2xuYlc5dmE1SzJrRmpSeDM0cFpwVzVLNTQ4ek9Dd0hOUVczcngrT3E4L0tXTk4yWDBZMzIwMzEvSXp5OTM1TmdQR2NqbWNqTGpidGJXTkpKSkRIUEFPSlpFWTA3c215aitXcFljbGNxVFZYNnZNcXRGWDFLTXhiK1I1SDdsNURMVzdSSHRZdTRoTVFVd3hudk9HaVUwa0xFc3ZKbTNEY2R0dGFhMjQ4Y0lwYWQ3UzJNUGgrSTh2OHR6c3VJOHJTMHgyQjhYdkdmNmUyakxUVFh3UXVqc3pNUVk0dzNORjQwSm9mUWFHNVBJcldzMFd0aWVIQzliV2ZUc09jK1Y4Zlc2L3M5MjF2ZHd6QTJkM0FTc3lKSjMyV3IxcTNjY3N2b0FOOXdCck94WTcybzdLZngyUWZhNlZrbXdGaFBFc0ZqY0pEbGV3MXJIZE84clBqR2VDUzVsK3FGcWlJWUhRc3JrNzFZOVJvNzEydHEvcnFDMnRTcTlLQzNrRnJqNVlVeDdpVzVzWi9yN0dlL3VieTRqV05iZUpwQW9idWdIbXNaclQwb09tbzB4T1puWDREMnlhZERscnpIQitKMllzdklyWEpmUVpOTXZaVzhrY3l4cmIvVDkxMVNXUGs4Z0lqQUIzNjlkZER4N1dtT3FNYk9xeFBSbk9GOWpwclpzemJxclRQRE1RWjBYMlAyNXl2SlNvcFExcnRyU1QwTTk5V2E4YmJ6UzJZRDgwcEs0QlBJZnFqVS8vQUt1bWJoQ1NrbFpBWHR0QlpUUVhNeUF4SjdlWnB5amtaTng4YURVRllUVUd4NXA0ZktFamtOWUoyWS9wRlNzZ1liR2xmWFZnaTRjUmhyT3d1WXAwUnJHRG1qcGt1NkExSllXZEkrQVI5d3dQOGhvVGUzS0NYUktHV0JoTW5qci9BRGQxTko1V1lxVzBiQjVVdG1hUjJETHdLc2cvVHdYb3V3OU5WM1RWZFVpeXRsdTBiQXVmeTl3dU5UQTJPVXNiaXdNRjlhdk5jUXFqd2t5U0JZMUtTZTVHWGp4ZW16SDRVMUpiWmxvWnEwZFN3ZkdjMmZJb3JGWDhuamdueVdQaXQ1NFZqTHdoK3pWNnRVY1hISnpSdHgrV3MvUE5lbGU1b2NkSzhTemEyRHlDWkNHOC92Vmhrck1FTFpYRjFHOGtjam8vYklVaDVLc3UxUGxxajd6YWhMVXVlQlZjdGxrNGJPWDJGd3E0aksybDFMTnlUamQya2FOQ1JJMWFoRWZ1YmxUUmVGZmpySno4VjVIS2NCK0xNc2NkenlMN2grSnkzSmdseUZ4YTNnVlMwVnpaM2lCR0IzTHlDSmdldkdvL2pwdjhYTFZkRjlVV3JrMG4rZ1V4MWg0bDl4c0xucmFMS3NKN09HTkdsdFZWSm9lYlNGU2U4cTdOUXRRZ0RVcTRYajlWdmtKOHh5cTAxVDZoRHlMQzRPSHhLM3M3aHBiaTd0b28wdHJtOERTM3QxRmJsUUZibVN6VVV0SVZwc09taThPVnR1WHFBdXNQcG9WOGZIUmxjTk5ob2JlNWZKbEdGdk1IN3FKTXhRbFR5SHRSK0ZTS1ZIWFJ0THc1R3lZazFDNml0SGdjbGo4L0hpYy9BcldOWlkxeFYxR1hTWnBJdVRjSElibWdLMVViL2h0b3lyVmxvQU9VNFp1KzJIMmt6bHpjVGVYZU8yZU50TVRMTkpiY1EvWnV3ZVFvMGNpRGp3VXJTaEI1VjFWbjFVTjlDZUpPcmxJY2NuNHA1YmVXbHREazhQYWZTNHFlYVJiL0FPbzR3TDNKVWxZaVJkaXA5Ni9udm9GVlZaYUMxWjJjTVE4dFlaRHh5NGlYSDNUWHQyTGRuc3BZQzBpcTZ1RHhBTy91QmF2U29JcHA5TExVbkZxbFovY3Z6Q0c1OGtzTXpmUUpIZFhOa3EzL0FDa1ZGRTFzU0NVcWFrRldIcHJWNFdPS1JQUm1OemJUZWZGQ1ZrZnVwZzVySTJVVnE4cnlDbFk1T1JES2FqWUxUcVBqbzZ1T0FCMk5YZ24zTHdQaG5taDhudVJMSkRkd3RGYzJzUlV0N3dBZmYwMlpWUFRVY3VQZldDM0ZrMldrdTI0LzFWZmIyK3hneHMxbGVXcExpVXlSQ09RSzROYWozcWY0YUUvdzM0aG4rWW4yRVB5UDdoZUNlWC9XMm1QdTVqUGR4TUxkSGhJa0VxdHpWdmJVVjIzK1dycTRYV3lZTmZLbW9DZVE4MDhjdmNGaGN6WXMwbVI4YXZZVGtBWTNXU1B2SVVaUVdGQ0NVOUQ4Tlc3WmxQdVJyZUdtdXdrK2JXcHhubHR4S1N2N2s0dUF5bmtwUzVBWnVvSFVrNmZIKzBmSS9YSXhZbnlLR0sxOGZ5RTltNEZtMCtFdlVaVko3Y3FLS0UxM1VqbnQ4dFVXcHExNDZobGN2cHEzMjBGanh2SjQ3dzc3azJlVUphQ0sya1dUdE1DVU0xdEx3bFdnMkt5SXJqLzFhSldxUUJaYmJRWHRGa3ZHZkZoQktJU28rM1hsckJRQ2ZkaE0yMHBDTld0VkJSU3YvRVBqb3AxVVA1TXJsNkZVZmNUdzdGWS95RHliRjRpOW9MQzhtczRiV1Voa2UxbFh2MmxLamFsQWxhN2dqVldSSlcwR3JxaEluc1k4djQzWjh1TFgwME1ranNGQ1BLTGMxYUlrZEdIYklVOWZkcXNzMGFCK1RzSHgyVmVlMGxVeDNrQ1hGdEpHQURXMms0aW53WThRVHBFV29aWksrWlcyTXNiaXdsZ1pHa1dET1lwbE5VbEV5OXE0alpSMVlLUzQ0L0Q0OWFsWFV0NktTRi8zSmpNZ3NUV3JyUEJISXR6RThiVU1Va2Nna1VsUlRpVkkrR3B3UW1SeTh0OGxzL0xNRXQ0a0F0NytDUmJpUlZQSUVBRlhaRFRjVVBUVGRHU2JsQTd5R3pUTFlYSFR5S2s4SWhaVWM3T3J5THhCcjZLZWxQanFOSVdpRXhiOERzM21odXJRS3ZPNWlSSk9RSkRka3NqRC9DbjQ2bXhrSjExYXkyVjZvRlVhTnpDNm5ZaXA0ZzBQekFPbklrQ2VScmUrbWo0OElaU0dibHZSenNmeXJweGdwWTNMMmwvYnpJNFJWWmV2VFpxZ244OVF2WGNpeWppeVlkOG5tc3NuUERrb25DeTI2a1NwUUJuWG9RQ09wRytnOExkWEhZS3p1dDFQY0dUMmtJVXkwYWpkSzlQaG80Q0ZUeUNFdy9UNUsyUC9BT0NTZ0FWb1ZSalhqMStQVDhkU1F6SU9TRUpsU2EybVNhTndLc3A1RU1SME5PaDB5R0pkcGNyY1F4cEl4NHVwaWtORFVVRk52aWFmL2s2Y1JhbmhXWXlWMWhiL0FBMTNZczlyTWpHU1dWU2thTXk5dVllNm42NkJ4b1RQcHFFNE5kR0svam5pSGt1RnlmOEFjRldMKzF0S0VWek11NjE2OFJXZ0kxTzk2MlVkeXBWYVpMejNpMkJ5RjVjcmtXTm5LeWZVbStpQTVEaU4rVmRpS0d1cXNlUndvRmFxa3JmTmVMUzJOMlA3Tk0yVHg3N1EzYVJsT1JIVlNwK0h4OWRHSnl2QXFhSXIrTjV1aE1zQ3hBYmtPd0JwK0ZkUElvSUUyTW50elJ5cElvYUtLNlVpU2JOREZpYXFvV25vQlNsTk9NWm9yek1Ia3FVOVFOaWZ3MGhFMHlSUWhQcEFBM0gzTjBOZFJpZW81MDdoUHZINEZaZVA0YS9mSngyT1pHUFdPK3QwU1dXU0c4am9vY0lJMzVWb1Qrb2Zxcjh0Y1huOXJ5MnpXaXNxWm5wb2QveHZlTVM0MWEzdkRTaUlsK1JHejMrcU94WDZkOGRKZlpZMjh5VFJ3VG9MV0JlVVppbVVTY2k0NXE4bkhpZ0trai9McmQ0ZkZ6WTY3ZEtyNHljMXkrUmd0YWF5MzhJTjhmbHVaOGk4ZXhHUnhHUlFHL0Z4R2JVUWgzaFM3SDc0SllrTldWT1pJVVVrTlJUbFRSZXl6Y05nVytyVW95eWNpMy9qOGVmR1J1N3ZKMmwycHlzY3QzSkdUT2lJdmNSSWVDS3hDTFdpNy9HdXJGUkVkN0krWWpzUEpjSGtKVEdrRXVMWVh0bkVOeDJpdEg5NUhObVlHcEZlbzFWYWtQUXRwZHQ2c3JESHp5NC9KUnJHcjhKNkJsT3hJYnIrbitrK3VxTXFsR2hodTYyK0k4ZDZHOVNJbVJIaW1qVkdsVDNqMituR3BicVBVNkJpRFVzMWJwQlRSeHNKc0xVT3ZhRWJzOUZVdEhJOG5GaFUxcUFGTmZrTmJHOXl6bHRpaEJueFkyOWhKZTNjaGtYSnhLalkyOGdLL3Rvc29FcjEzL1N2WDVFNm96cDJTWGJ1Z3ZpMlZHN2QxMFoxSDQzNUNtZisyY2sxczlsTGtNaGZkd29LbFRISktBdmQyNVZLSnlJMjI2NjQ3azR2dDhoVjFoTDhRZGZ4OG4zTWUrRjZpQWwxRDVoNVhsTWhabUszTnRqM2d5Rjl3L2VDUEtraWxXRzU0b25CTitSNVU2QWFhODRzYVZ0WnRvalI0MUs3dDYwaFI1NjlDb2ZNc2pZWkw3cTI2dmEvM1JEY3gyNzQ2UVVpdUxLTnUwMFNqb3JFaDJWdndPdC9oMGRPSzlkdWt6NFB4T2U5d3Q5M21LcVUyYmlIMGpwQllIazNqTnJpN2ZJWkdLMWlodGJtY1RXMXBiUUxTM2hpVmUxRUJVMUpBRFA4VDExaTRlVmE5a20rM1h4WjJGZUpqeDRyYWVlaTZSMkZtNndlU2t5R01tdTdReDJvRXNsejJ6UVJkK1FFS0FvTkNwWWx2YU9vcnJTcGVxM0pQVXgrVmh5TlZzMUZkZmxMMC9xUzRjUTJNUzFtSWl2NkNmdHlSdHlWZTJ6Y2llb1pxY3VuNmV1bSs1dWZoMElMakxGU1hGbnFTY1hZU3oyMWpiUXlNWkx1VUJxanQvMWhsSFAzVkk1cVR0cSs5OXN2d011bUtZWGllNWJDNUxtdVBqVjB1bWxsYS9rVDJ1c0R2ekNrc0tua3BVQ3U1SjFMRmtyRXZvRFpzZDdXaENiRllZK3c5MTVhdFozdjdscXp1VExLTG1LU01NNndoRzd0SXZhYTA0UHZUYlJ1NXZwcitQNW1adFZlcWgvaitBYVM4Z3lmbU9PeVdDbW1zN2pHd1c5ekF0NGo5eG9yZEsxY2oydnlVRWdQeEg2ZXU0MUNzMXh0VzdrMmxiSW5VWEx2S0prODgxOUpldmRaQzhEUlJwY1JtWU1iZ2NLT3dKQ010VlpmYlQ4S2F1cldLUkhRcGRwdjFJUnZPTU1zRjIxdVBxbkZwYW1JRjBNc1lDU055a29RZzY3L0FOWHJxMVY4Q2wzOFlBdHlHdkxkbzdzbHBMRm10NEt4bjl3OHFOeUlhZytYeTFZbEQwN2xUMVVQc0JaTE5aQnhrQkZLbU9SYWhUU28ySTYwUHcxWW5CVTZqejRQNDFkNU8ydjU0VEV0bGF4ZldUM1I1OTB3SS83bkJBT0pjRTBUa1J1Um9YUG5WV3ZvRjRPUGExVzEwR1NIRWl4eEdQekdNbHVZTUZraGRxSVZQY25TMmdrcjNXZXY2cThCN0QwSjFDMXVxZlVldFZwSFF1VDdmWGQrL2o5cE5tSmplM1VNa3pRM1RLSXliU0VFeGlTaE5kd1Y1Vk5kWTNLU1YvVG9kdjdSUzd3dDJYZlJtTjRMZWY4QWN2OEFqMjJQRnVSQVhqU2xEMS9VQjE2bXVoMG9jcnFkTlhGR05WZWlCcjJsclpFejQyWnJPV1M0NHh2R0JKR1pGOVN0YUZQVW5ZMDBSdmJVUFVEZUdxYzAwTXBiM0lDSXRjcENZcm1UbjlkYm94Q3Z4MkpqTEdsRDYxMUxaWHQrWU4vazNtTExUeFFEYklOQjlKYTJrRVVsODNjRVV2SnFOMmVDRjVLNys0ajJqMTFZNnFDZE15Y0t2VXF6T3JIRG1wWmJpNGpVR29Mc3lvdEdiZWpIYXAzcHJRNC83VGsvZDdmODBzemh2NG1ueUV0b0lpa3NJdDhlZnFyWmlvUlR1MzdncFVzeHBxeTFOUG1BcmwxVnJOTHRDOGpWaVZ1WUwrS2Q3VUcxdGd3UnUvYkdwSlVWSTdub3EvSDExSzZUcXdmRmVMSnRhTHpSbms4ak5EWjIxdWJLYWVGNUpibTRsaDRTcUc5NVludHMyeWN3YTZiSGpUdDFGbTVNWTlzZFhMSU56Zld0ekhhbUNSWkxXR0lxangwcHV4YW0vclg1YW5halRCOSs2TmRFQk12UGR4VEpCR29hS0sySm1Va1ZERU5VOURUWWF2d3FzU3dmSmEwd3ZBR1JTek1pMnNxcFF1a1lLajNEZ0tsVCtCT3I3MWtEWFVzM0JXTnRGRmpoMkVDQjU3dVgyZ2xsalVvSzE2ajNqV1ZhemJlcDBPT2kycjYvUVdNZmY1TEMzYzJReFFFdHRkT1pidkZIMnhTZ2tua2xhOEhvT3ZRNkt5VnJaYmJmVUJ4NUw0ck8xZS9ZTFpiTzJPYnl0aGtNU2FSV05xUkpGS3ZHU0tlUnlXVjFQUmdBT21xcTBkRkRDTFoxbHVuWFNGMExjKzNRZ0VqWE44Z2x0OFpqcnpKelJ5S2pvWklMYVJrcXNnSVB1WWF6K2UzOXB4MWNMNnMxdUhWdUoxT2hzRytIOGI4WHhObVNpMzFqaW9iZUNBcVF6VDJsbW5LbEJRVksrcDE1L3dDNVVWOCtXMWY5MzlEUzQrUEpzclh0L0JsT1JnM21TdWkvdWttS2hhYjFJNU9WRys0RlJveWxZb2t1eDM2U3BSZVJvelppdElMeWFSRkxDRkVRa0RtRnI4Zm5xZU5ONkYyS3lVVzdMVW9UN3o1WmJqeTY3d2NjcCtreENXOXZjcXBOREpad0xBaWNhVUxjZzI5ZlhYb1B0bUhiajNQdWVIZThaL3VaM0hSZjZqTGpnMXJpNHNKRmJtV1Q2RXlYQURBS2J1ZHcwUE5sQkttTUFIZGZucVdSN20zNWxOS3VxU0NNdDlhNWRmcXJoZ3NPTWRGVjBGUkpjOGtrWlFvb0dWR0NkZjFNMjlhYW9hZFdvN2wrbGxyMlJlbDM1NFBIWTduSFdsbGRYODBmYWdFMWpHMHdTZTNoNUdFTlVWWlMvTGI5TmQ2YUNkZDNrRVRHdlVCNWJ6dVd6OGV1STdQeHpMUGY1RzJFZHRLK01rbGlrakFVT3NoVkFDcXNGcUk5aTFQU3Vya2w0cjZsTGI4R1Z4NHBtYlZiRzdtejhHVHRNM2ZYY3R6OWNjYkpkVHhWQ1J4cUlleDJQMEp5ZVRqN0swQXBvaTZsZW1ISG1WVTAvZEtDM2xubUhoVGlDT3l1NTd5MnRXbWx1STdpQy9LM1VTeWtqdkp4Vm5lUnVMaXFnZTNlaUFEVlNwZnJvWGZjcDBJOFBuZmh1UXRJYlBKNWExeUVzbjcxM0RmM0lNb0R5aFlyVklqRjJ4d0NCcDZVNW1udUlycVR3MjZ3VnJMVWtXM2tVVnRheVpDenY3RllKVElicklySXNhQ1FxRTVHTUdVQUpEU0tNdDdRemhVUVUxVmt4N3RHaS9IbFMxa0NYZVhtOGttdytOczV2ZGRaSVNjblpyZ29JNE8xRCs0U0MzRUdnUmtxRHZzU2RWVXg3WmI3SXR6NWQ4SlFwWmIxamdJY2ZHelNMd0xScXN0NUJXUXIybU1aZDBkdVRTRUEwVlR0dHJJeXR2b2FWR2tNMWxJWHg5eEMvRVdwa0ovUzZoNGlvNU5zSDVEWWptU0F4NkRwb1hMVzB3V1luVlBVbWk4bGhqU2VTbllSQWdsRFZDY1NwcHpwK2tWUFRqWHBwclkydE80cXROeWNWLzZuOHJOa3Z1STltdFJhNDYxdFlvb3VmY3BKZEo5VElTM3FheUJhL0JRUFRYWWUxWWxURFBkczVuM1BJN1pvZlpGVFMyTE1iU0VEWmdTZlhjTFUvd0NHdGhtVWtUQmp5OXk3Y1RSWTFKcjAza1VhVFlpUXVOVlJKT3lmKy93L0Q5dXVtYkpSb2FueHFSV1VMOGZkSkRJOWZ3bGRmOW1ua1pvd2t3cS9XUVd0S004MENHblNrZ1gvQU1kUmIwSGExQnh4amM1VjRsdUVNa2dwL3VVMzBwVURHN0VaVEtZRkpyeXhrYU1NMGNVeWRGa1JneG9laHB0NmFhMVU5R1BXelhRNncvMDU1K2VETVkyN3NwVEZpTXdVaXY3UW4yRWx3aGNEY0Iwa3BSaCtlc1RtNFZaTlB0OVRhNGwwdFYxT3lKVyttam1sYVh0MnNVZzl0Q29WZVBRRTFxYTducC9QWEs3VzZTbjNnMkpVd1JjSmRDZTFFbDdCKy9LeHJBcks0MlpsOXZUMk1CeUJyODlVUEJEMldlNUN0YWRWb1EvdXBhc2Z0dDVHc2t3VlZzSkZvTndLVUlCcHVlbE5GY2JCZFpLT2RFd1BKZGJXVjE0b21Mc3ZDZS9aaUtDOHVvdWNyUk1yU0xJWnZiN3ExQlJTUGIvbTFaenI1Vm0wbmFIOE90TEpUSDlCUCs0UzNkN21zVGRZcSt2TU5aelh3eDkxTGpKWHRIZFVpTWt6ekVGUjIxb2FNZHZ4MXM4ZXJXT1hEY0dieUxwNVhWUFNTUmlQKzN6NXEzaTJLZ3VteFZoYUc4dWIrRyt1bzN1VnZyZm1pRjJmdU8wak1DM1hhdlFhcnM3ZmIzTjZ2dEJOS3J2dFMwWGNNNEtXekY5UGFZRE5YdG1QR29vV3gxaWpMZjJGckpTUWY4dVpDeG9WL3BQRTlkU215U21QVVZ4VnR4T2g3YjRMN2orVVE0cnlQSVpTMXpHTlowbmtnYTJObUxkMmpLaU1pSmpVUDBkajhLYWhsNUZLVFdJSHg0blpwN3ZxVU45elBIYjNHWDE3a3I2MnRXdWJLNWdpdVVrbDl2ZHRwa2tWTzFKVmVKRk5sUFRyWFdyeEw3bDVNQTVWSWM5eWhNZ2IyZVROWEU4VHgzTTVubmtDZ3FGZnVoMnB4MkZPbTJ0V3FoUVpqY3VUSHhxZTVrUjBNMHAzVTFMTnNIU1JXRzU2RWRkUXUzQk9pVW9LM3YxQ1dzUEdROFkrYUV0UmhUbHkvcXIvQUp0UjNUQTlxNnNnNVM5a2h5bUx1UjJtRTNFTThrVWJrR29HeEtraWdPM3cxY1ZsdE5ZWFVsbGpibis0U1M0a3RieDMwZk5DVW5ZQlFlQmpvQVYyRk5CVnQ2bW9DV25DY2pqWTR5MndXUWh2WnJwN2JHM05wSkliZzIxdEZJZ1dSRnF3N1NIK3NmN1JUVWRIWG9TdE5YSkp5OTNlUVd0emY0ck4yRTlyQmY4QWJkcDRZSFZVdUlvM010RUk1bm0zQ20xRHBSVlJLSFZyT1lZdy9ibVgrNmZiKzJ4VjIwQ1QyOFVxeHp4d3JFNGx0WGtSSDdvQTRsUUY5eE81R2dPUW1zbTVmUTB1TFpXeGJXdm1FckhINVhQZlR5WFhsQnVyaFFra05qTmFyRnlrUCtRUUZHZGhUa3hxTjk5VTcxVnlxb245dHRRMndMTjR0NUUyU3NidWZ5SmJlenVKcmxZN3kydGpHMGh0ZVBNbnVPeXNQZDdldTlkWGZmZlJWS2ZzS1piTldKYkM0eTZTM3hVTjFjUlNTY0xpNXU3Z3ZJN0tDcElxQUY0OGdhcXg2alVNdGJXVXRsbUc2cTRTSFB5akgrUndlSDVxWHdLNW5zdktEWlJQYVBheXA5UTh2ZFc2Y1VlcXNwV0p3dnlQdzFSeHJWKzVGK2dSeTZOWS9UMS9NbGVOanlsL3QzaFpjNWVYcitUckg5WmRZNitWVXVGblJuQ1RCd0FTSEFyUmZidjhxYXB5M3FzejJ4SFFuZ28zalc3OTNjTGVLK1dZekdZeDViaWJoM3lybmtoWlQyVDJXWnlPSlE5Ry9VT2xOR0xWanQ3VUU3bnp2L3VHTEgyNWFXMnVlOEJZVFJ3OTFtTHVwUEVNb1BIaHlXbTVJSk8vck9pMmd0NnlDZkVQTDd6eEhFVFlHR3dlZXdpbmVLMW5LTEF6bVNzbTZyU2xXNW92clZkVTVmM3VHaXpDa2xyMkh6SHlueWF6bS90WmlhYUdXVDZ1em1sWXBLMG5GeHpRR29GQnNRQ0FTRHFOS04yaEU3NUlVb3F2TzJtUThoOGd4ZUl3OFlzY1hlVzF4Y1JYem9IWml3VVJSd2dVNHZFeWx0OTZjZC9UUmRjVmFweUIyeld0MDAwS3orOW5nQVcwamd5RnNwZnNMLzFDeHR6RW9VY21KM1g5WU5SVVU2YUp3cDB0cDBCYzNyU25xYzdSZUw1T0JwWUpWU0FBbFVLTFZ2a1R2c2FhTmVaQUt3czJZdjdkdGN2SmN5TjNiZUlIdXh0VVBVOUR0NmFweWNpTkMrbkdiVFlHOGc4TnU3VkxlZkdXenl3TnlTZmdDZU1pbjE5ZHhxMm1WUHFVV3hOZEFuaC9GYmlYR3RFc01VTnpMSkVKcHBIL0FIRmpZMDlvMk81NjZzV1JOd1Y3V1doNGhkWGplRlozeE80V01UV0R6ckNrZ0RzVWpZeWNpUjFKSzZUNmtsMElIbHJ0bE1QZ2M4c3l5eXoyYlcxeTZxVS9mdFhLRVVIeU9vMVVTV1hjcE15OGN6RWlXbVJnVysvNmlPT0s4aFNlTVNxbmE5MGhBMkJxcGJxMWRSdXRVeWVPejJ0QXZ5cTRNZDVaWmVPYTJ1UmFYTVV3UjR3aGRiaGVFaGJpMjZjMGFvcHRYcnA4YWhSNEVjcmxwK0pkY2toek1jVms0c1pCNWY0cytQblB1NUhMNElsWWQxQjlZNDZOVW5mZlI5WG9uNDZBelFsZWJaRCs5V0dIOG5rdElHbHpPSmlneUR4T3lrM21KZmh4NGtkU3F4KzdiUTkzS1hrV1ZnclNLMmpqWEkyODF0T0RiWEN6dzhXUWhiV1lCbDNCL1ZVVUJBcHFBa1Fwa2hnaWlaQk1XczdqdE0wZ0hFUlNiQ3RLME5PR2tOQTEyVnZGbE1OalpER2ZyY1ZjVDQrRWsxTkpUM1kxSTI5Q1FOUWlMUHpKUktBR2M4ZmtGek5kV2g3RnpEVG1ZcUpJV094WDI3R2g2anJxWkZvMjJuazJVeGNNZG5tN2NQWmlyQzRpQkhXbzl5L0ErcFhTZ1VqNWdjemF6NHRUWlNwY1dFaU9oaUxIa3RhTWVKNjlmUTZxc25EanFXVmhtKzJuaXg5eExjNDNpMzAxd0hLQ2dEaHFCbCtWUnY4QWxxTzZHcXNUMFl0K1kyRHg1Rjd3cCszZWxpR0IyRXE3a2Z3SzZ1UkN3cDVLR0dhR1M2akZMbFZEcFgrb0UrNFVPM1hmVGkwZzAyc3EzVUt3eWc4a0hyMHBRNlF4R2hKamFTQUsyOU5tSjRxeDY3MXBYVVhWTnlNYkV5VWtETEJOTElrY1JvWGozREEraEh3R3B3UEpEbVdLNTVSaVF0YjNTTWxXSnJVN3JYOEdwcHVnd0h4TUJ1SUx5eFJDYnYyeUpHb3F4S25pd0h4TytuYkdRV2x2b2ZENFFscmNDNThrazR0TlJBOEZwVUdxVlA2cE45L1FhUS9RR1hublBsZDY4alBrWkl6TW9WeGJCWUF5ZzFvZTJGMUZVcU83dGd3elhsd2FYTnhMS09wVjVHWUQrSjFPQ0JjV0F0RG5jVGJ5U01YQ1c0Z1pRQnlhTUx3WkNUOFJvYkpkVUNjVk43Q0VVT0FnWjdISDBpdTRJeEw5UEp5TG9oMkRlN2NrRWFGZVRKOGcydUtpY0xxTE9YaWRnelVQTGZyNi9FNnR4M2EwS3NtTk1WcExYbEpVcFVBVUovQTZzcy9NcXBXQUprc2VZR1lqOUVnTEtmbjhEcTJsNWdIeVUyczBXcGxraXJid0dVeGdHVDFDNzAzK0ExTi9Fcko4T0d1Vjk5eVY5amU2MUc1UHJRbnJxTzlEd0g3ekIyMTNqVGUyVnFJMXQvZEtsUnlSRkZIQkIzTkRRajVhR1dScHd5VUNobHNhOW5jRGY5bVZGbWdZOUNqajAvTVUwVFMwb2U5WUxZK3crZUp1NXZHSm1ESXJDK3RReG9lTlFzNkNueW85QnZ0cHIxN2lvK3hZbVlndHJPOG16TVBPOHdWK1pFeVN4Z2lTMmxqYmlKZVB4cFEwOVJYVWFwcGFzdDdnU3p5U1lTN2t0NXBVeWRxU0k1eFNxU1d4UGJQVTBERkhOYWZEU3RNYURwNmdYeUR4UTR2THpwWnU4Mk9XajJFd1l2V0lyVUtENjBvUlg0NnozbGxhOVRXeFltdGV3VnhrOEZ0WktJclpHTXZOWkhBOXpLeTFXaElGS2FEdExacFZoVlRTNmxPUGlQSXhIVllKYmlCMVpZNUlGYWFOaEdRcEFZQW1pMUFOTnZUV3dyME9ZZVBJdTBvc2J3engvQXA0OWZYbWR2bzJuTnUvWXRlUWlyMjQzRER1T3JCeUpIVlhBcXY0NnpPVm51cnBVWGZxYS9GNDlYamRyUDVkUHhxU2ZEOHhMNDVaWkdQQU9rc01qbU9aM2lNNWpkSTNTQjR4eUNpclNjT1ZEMTBOeWNQM21uZjhhNmgvRnkvWnEvdDYvbjhJTGo4QXRZN0R3Q1R5R0NaaExjV3FXOFZ2S2l4eGNvOXBpRTl6T1NRMUdhcE9zWGx1YzJ6dFB4WjBtRi84YWRlbTM1ZWYxSzV3R016M2kvbFdUejNrdU0vdE41YldUNUtaN21NcWJScGxNUVpCeUtreVYvaVNOajAxTStTbVRDcVV0dTFqVHVaZnQrTkxQYk5sVzJGUHcvMUdyeGI3a2VPK2Z4eTQ2eVkyV2JBZi9vcDJSVElLL3dETWliMnEvczNaZG0yMEJ5dmJyOGRxM1d2bDIrSnQrMis5NGVTOXZTM2crL3dEWDBsNzlYZUxiUjJsMDcyY3BhT2NrUVNUS1FVSE5LOFNIWXRTdndGZFU0ckx6V3BwODJqZVBiVlRvUVBNc1dscDQvYVJKSUxTMXRiY05MREV2QXlUeTBSUXl0N3FjUVdMRTE2YUk0MTI4ajd0djhqTDVlTC9BSWZUNlZWZlZnendlem55Zmt0dmpJbmY2ZTBrTWJTS2FxcXRScEpIcWFVQ0Z1SStRK0d0SE8xWEcyKzV6R0tYazJwdlExWHVabGxYT1RtNmVTYWFjeXhRZ013YUV5RllqV29BOW5TbTIycFZ4d3E2RlR5dUxlWW5lT2VUWVB4Yno1N255RkpzcGpMZUNZMjRqdFJjemllNkRIaVY2RUFtdnUwWmx4WHlZb3A2WEpuVXpVeDVmVjZsSDVzallmSXZpYnkzemxoSGFzYlNXRnJLZGxKa0lkWkFsdktyRnlDdjZxQWZJN2FzdlhjblZ6citKS0ZiYTl5ajhkZ0xkeXlYU0hKWkJiVzBhK25sN1V0dXF5M0R5bmlHb09RQ0RsdjA5VFRwcTZxUzAxMEtyTnhMaEVXZExXM2hXMm1oRWwzYnhSa2Job0ZsU3ZKeXhJb0tqM0tLZ25ycWFsdWUzNWxlaEx2bzdlNWN3WlV3V3NzWlZZN2VFTjBxREk3OGlBVlVIMmZqcHF5dWhLMFBxWVI0YkpXaUpkMmFMZTR5NWtsZzdGZURjbklWWGhMVURHb3I3SzBPMm4zcHVPNUZWYTFYUWUvR01EbllIeStPdjBtVEYyOXViWkxHRWo5ZDBydWtqRW5lakhreU5VcWZsb1hJNk9IMzhRcW05SjE3ZUJFem1kZ3lNM2pPRnNyRjJ4OXBZeFlxMzRQeEVVOGdWcG5kU1NIcTNOS09PaTFHck5yaHVTbmRMU2p5TFFteU1lSXNwTWZqcm51enkyNGdCVXFyUkJ5RUROeEIvVVJ2OHRZanB1YnN6MG5EYlpqcGpxOWYwQmkzTVR3V3RzSmV6TFRsRW9rcXBsSEpPSko0MG9SdnBScklidW5Ub3p5WnlrU3d2R3BhVnh3bFUwZXUvY0lUbHhvQlE5ZW1wVmNzamRMYkhpRWY3MUJhR1cyTG85dXA1Z245UlZVUFFDdERRZGRLMUpLOTljZGZJWGN4ZC92R2VGekRkUTBxOFFyeDdpZ21vSTQxMzNPcmwxTXpJLzdxNk9TdlBLb0VpeHIzYWRxZTZQdVpDcEk0S1RRTW9JQVByc2RIWUgyN0hMZTRYZHVwWC84QWQ3aTNCUDhBYkxSaXdKUHNZRUFuNEJqbzZ0YXQ5V1lIM0d1eU1JdktMaUpva2l4OXA3ZGludkFaZm5SdHFhdSt3dkZrVm1mWklnVFpHN3VZekh3VzJ0K1hNMjhiTWtOZmpTcElQK0dwVm9xK1pVN05rcTB1dUxvYmdsR3FDYnVKZVRFVnJTUk51NFBtQ0Q4OVBaU1BXelFabHlDM2FtTzZZTDlVMGNRdkVxWVdDQWNxTWFjVC91dHZxdWxFbG9YM3l1eHZOdXFYdG9rYkFSUXhOTTcwL3dBM3VMVXA2MDFYYTNYNkZsYTlOUjlVUGo3VzVZL3R3NDdISkZDYTFKYTQ1RTh5ZWhOQm9KUTM4V2F6VHFucjByK29nd1gwOER6K3dHSzJpN3JxUDFWa2IycnVQVWIwMXBiVSszY3g5elRZSHZMdTZseUF5VnN3aHVtb3FsUVFzaWhSczYrbzlOV2JGMEtkN21laDFEOXR3OTU0eG5aSjVQbzczSVd0aGlGaGlIY1IzeWwxREN5OGlwSUFWL1NoT3VmNWk5V09zU3Q2ZncyNm5WOFp6amRuMTJ2OVAxT2h2TXJhMWh0SnMzS0ExdFpyS0JhcWVJZnZPbzVCdlFoYWdmanJ6SzJSdThmL0FPeC94azN1SExzc2E2NmZrVW5hMmJOY204VjNVd3NRQWgyL1J4SDVqVzdXVldEdWJKYUlXTTVta3VMeHJGaTB2Ym5ScFdjQkVrV0oyMjY3MU8zNWFMeFkyb1lIZk5SelRvb0tLODhrWEtaM0lNcUlMbTl2VElRcmNta211Snk1TEVkS2N1bnB0cnYrS3R1R3FmZ2VIY3V5dG1zMTBrc2YrNXc0bTFnZVFtYisyeUVUdDJ2WkpkVEFnT2hQVUl2VW5ZS05BV3J1dDhRNnRrcTY5aWJqNDRjdkxIalZkamNUUnBsWGliMnh4ekdhWm9oVmVwWGtya05zVDZIVk9SMnE1WHdDS0tycTU4Sk9xZnRCZ1FuMjJ3Vi9lcUxtK3ZrTjFmM00xV2ttZTRsa2taMk5OaTNKaWZqMXBzTkFjeC84bW5RbngvMitZMnllTTJXVXZZZHA3VEYyTUFqTnJBelcxdXdrSEowWVJxQTRxQnlISURydHA1MEUrdXBIU3d2b1ArbXNvUUZkMFdHNmlMd2NMUno3NC9jWG9DUnlMa210ZVIySEhVbkQwWHpGOFJYei9pbDFjd0dHMHlGM2owall4dkRCSzBsbzBYL005a1FSVHhZQUlDWmtKVUUxQlk2ZXRvY0VYV1JDKzQzam4wbml1ZXlFRWFURzFaRGJTcll4eUs3dnd0VmE0bWtJaUNxNVBaamo3aWhUejl6TUNMYVc5U1VGZGtvS2x4M2hGcEhmTEY1RkJiVzdUbGxWVnRVTXdFWkc0Vm9KdTRYRGN1WEJhK2xCUUc2MW4ySzBsM0RQL3dDS3p4NjF2SUZXV0RHMjlnaGwrc1ZCQmV5cUU1Q1lMRkVEVU15TDFVMUJvbWhWeU1pZlNaL0lLZUhHNi9EOHh4eG5obGppclg2d1pxL3VZMktoQ0xtNGFVUnhoalJnV2lvWElmblhZVTl2THJxckptYjBoZmtXWThhV3NzRlkwMytlOHN6R0tzTTVkeTRxeHRvSnJjcGMvc2Q1NDFKTGR3TlVNVFFMdDhlbXBKSjQxWnBUOEN1emYzR2szQmw5ejdyeVB3VHdMTmVRak9TNURJMmwxYnhZNjN1SWxlSGsweXgwYmtEem9Ha096YkZkcWdhbGh4MXlaS3AxVUVzMlI0OGRtbWNtZVIzdWM4eHZaYy9rMVdiSzMwa1QzWGFVS1BZQWdvb0pvQXFqWFNZNlZ4cmJYb2M5ZTd1NWZVSXI0OWtYbXRTdG83SUVsSklVbjNjS2JrYVZycUJLcllSbXdOL0ZkeXI5RkoveVlhRll5UVNaTitnSTlOTnVUalh1T3F2VXdtdzk5SERJR3M1Vkp2U0JXTnVnZ1hmcFNtK2x1Vzc1RHg2Zm1RNzNHei8ycXhic3ZVMmtyZm9QVDZpYXZwOHRTblYvSWF5MFJuZVdZano5bXJvVmRybXhvYUVWQldQVVU1VCtZdTZCTnJBaHU3eFIxRm5kc2Z3Rk45Ty8yb1pkUVBlV3FuR1hoaklBVzV0UlVtbjZrbTFOL3VSRmRHWE45bVBJTU40MTRyUExtY29MRmt2SCttQWFzb0FRU0FvZ0JKcTRwdG9Ua1Vic25BWGd1bFZwblZHSSs4L2pIa0ZvOHVQT1J1TFNRdERiVFJXVXdISkl4eUNjMUpKQmYzRXIwK05kWWVmaVFucWpVeDhpWTBiR25FZWIrSVJ3VzhmRzVnaWhrcGFvMW5jZzh0eDNDT0JQOVcvejFqWDRtU3piMG40aDMzYXhwSkI4Kys1bmgwZmpHV3RaOGpHdHplV3Mxc3RoMmJpVm5sTkFuRnhHRitUZmpxL0R3c3l5VmVrS0oxQnI1cWJXdTV6SloyT0F6WG4rZnVzYm03M0dZeTNrRTBkN2pDeTFhcWxuRWJxcWlOU2ZjWFVEYmFwcHJwTDdsVktFL2ladElkbTVmeVBNVGsvRS9NdklwUjVYbE16ZDRiNm8yV09hZWVOSkxpNEpLdk90dkhGR3NmVkY2VjVFaXAxRzFMcXFWWVh5SjB0UzFudWtKWS9GUFo1aTZ2OEF3bnlPOXRiMkRsTEpmNW85Nk4ydDFhTUlXVmFMd1ZBRko2SDAyMVRhemFpNlQ4aTFWV3JvMmdqNGQ5eXNweWxmS1dQWVl5dEpsSjUwTWFUdzI1YmdvbWpDbVFqbVN2SnhYaUJxVHhVYklMSmVHWFg5bWZPTVZhNGEzdWJqTDIwS3h4elJSWSs4dTBnMmtsRHhuc1NTQWcwSnFTT1ZLYUV5NGJPOHBTaTFaSzdVbjFPZGZ2TXZqMmI4ZzhneWxsZk5rTXJjSkxkek1Ka1dIdTl4Q1NrSXFvWGlQYW9ibFE3OU5hZkdWMG82QWVkMGFjRk0rVVNTVCtRWndXaVVpbUVyd3BBT0VlMElhcUtvb0J0WGJSK1BvQjJGdnh5NnZlRTVWcEdORWNWcWQxY0wvZzJwVHJCQ05BM0pjWFgwcVNkeVJDSlhWYUZ2MWNWUDhScG15U3JyRElXZnZiNkcxeDEwMHJkNHNlNFhWV05UUVUzQjlGOU5PbU0wV3ZZV1VjV0ZneUMzbHhDRkFKU0NTWGt6STRJZGVvUEVkQjhUMTBKYTdWZ2l0RnNrYVlNQzEwMXJmM0Y3ZEY1Ymk0aUszRXEzU3hEZ1hVOEo0K0lMY0R5SXB1TkpYbE1leVMxUkx2YkUyMXhmM09KK2t1N3UwK25uaFM5czdlbkVGbzNaZXlxL29JREJSU3Y0Nmo2WTFROVc1MDZoYjdhWXU5dStkdU1xTFl3NWU2K3JyYWpzc0MzTkZwenFLc2EwcnRYNDZINVRTaHBkZ25qNjZOamRtc0xsYmFWYlBCWEhmakVjaHVKSmUzYlNxMFRWa2tnZVF0UUViY2FpdngwQlRJcG1BKzFkTkFWTFk1ejYyMERZYTZ1R2hQRjRwR2ltS3dPblJuRHVFNThpM0hqOC9YVml5VjhTRHBZQjNtTXVSa0VoaGl1VXVVOTR0SWNmY0FpVHU4K0psNEJTcWJWTGY1ZW1wdkl0djlTcXRIdUxCd2ZrdmorU3Y3ZTNOM0NwTThKK21rWG13Y3owQ0JtY25ZZFBhT3BweDMwQmt4M1ZXelN4WmF1eThTeFBJN2k0dXNISmN0ajNHVHg4anFrY081YXpsQ3BLbkVyMDRnU1U5R0E5RG9MQmFyYnFpN05SMWU1YWxmMkdSbDhjek1VUnQ3ZVREM1lXVkhlQmpSMjRQSXFrbGkxUU9WQWFWcjY2UHJmU1BBcWhUOFFrdmN2NUxLUEVQRTE1VWhSQXNrSVhsTHpWZll0ZGlDYWN4OE5WUEpidVBzWFUxNVBJUzQyQ1R4MjV4ODBxRjVaYmtTd01zVjBJWExNSTJaaXgzSEpQWFkwTytsV3ZlU3UxKzBBK3p6dzhVS2R1SkxpSzFIMGNqU1JDUGxITUFWRHBLN09BQXpma1BkWGJSRkc1a3FzdE5DVGQyeEUwR2VzTDU0YnJHdEpCYkR0QmJYbkVFTnV5Z3FBVmtoa1ZXYjFZMTJPaTVXMzRnMjFxMGVBTDhzeU4zbUhSVGFrM3Nwa21udFkyVWhYMllBb3cySWZpV0IvVjh0Rlk3ZGdiSlR1VlRjWWFTNlBjdkNqL0FGTUVrL2Y0Nzl5SUJwQXdGQ0RXcHBUVjFpbXFOZU04YnRybCsxREtrY3MzYlVSMTRkem1hTUFUc1N2cU5VV1NaZXJOQlM5OFZPSXZMdXdjQ1JOeUdWUXhadWxBQjYxR28yZFlUWXFUTUlYWi9Gcm01TFMyOEtKeFVvNWVpbWdJWUhiYW9PbzF6Sk10L3dBZDJSQ3dWaWNWNWZkcTBpVXlzTWJpMXJTci93Qld4NkNuTTZOKzdOTjNnQXZFbFoxOGlIZlc5bkg0dGw4UGJvd3VzTmtqTXJGZUo3RWpNaG9hbW9CQjFiUHFUOFNyYTlyWGdBL0Y3dTBzc2xZVFhVWWtMOSsybTNDcWtFcTBJYXY2cUFzdzArU3MxZmlMRlpLeWs5eStLdGIreFN6aURudExjMlJVaGVYZlFtUkNLR2xLeHNQejFKVE1qM1MycU93M2VDWm5IcDRIaGI2NFdSNzd4YkwydVFEaE9SYUc1S3dYTU5LN2d0R2gzOWRFVmZwYThOUWJ1RS9Jc1A0MWJZZnlUQjR5NEtOZ01zdVh4TEVNRitneWl4S0VKRmFxQ1lxZmxwT3FjL1VTS3JXMXVvY3BacVp3YlhLUXkyTXBkNlVOdFdTTlhyOHVQSFZKSXhObExjOSsxaW5RcGRXUlNyTXU4MExWQlkxMkpBVHJwRHRhaFR4TnBMdU85dEUvWGQycVpDQkJ2LzFGaWZlQjh5aGJUTkNxRnBaN1UzTnVmcHBQMHhPMHJxZTUzSGJhdng5cEcrNHBxdXJaTzBkaUxjV0VsNUhGSE5hcTE1TjFrVG9BVHhVdFhZY3Q2VTlkV0lpQUxqeDI2dElmcmNKSzluZHhrQzVoQXBFeHFRQVFUUnVuWFNrakJsWWVZVFF6bTB6WU5wY3NBUHFnZVViMG9PcC8vVy9qcE5lQThqSGtMK1Mrc0k3QzZLenlXNXJGZG9mK1pIU29xS2ZxM3BVOWRMcDFKUklxWEdObHY3a1dhSHR5aDFkZVZRQUdQclQ0SFRwa1d0U1krRGxpa1NONUlYbmMvdGhHSTVGZ1dxdTFQL1BTRVFKN1dhMWdsZTdnNUk3QkR4Ym0xUnRVaXVrSURYR0xjenFvRWh0MkZRMUNDVk5ldGFhZVJvSVJoa2dkWTNiaTZIWWRPaDZhUXg5ZThzRm4wdTR5MGNNaEVvcDdXNFNEM2dmQWl1bVhRYm9TTGl6eDFqY1d1VHRJVXVyUG1zanJKV1RtcE85ZVh4cjYrdXE2V2N1cjZsdDZKTGN1Z1p2UEhyYTZ1cXhCWThXeXJKRVZvcGFOeHlINmQ5UXk1ZG54Tm4ydjJtM01iYmUyaTZzOEdJd2tNb2pNVkdXZ0VqY1NPWFQxQjBMOTYvVTZyLzZqaEsyMkg4Wk55WmE2eGpwTFozQWt0b1RTV05XcHlYb0ZLamJiMHBwMDkzVkdGeS9iNlladGhzbXU2a2JERGE1aWZHWnVNR0c2aURkeDBvd2RIVWpneDYwUCtPcTAzVk5HYzR0RmwxUkR5VnVqMVRxb0FZQUEwb2ZucFZZMWtLOTlQaTdTVkZ1Smw3bFFoUmZjM3VOTndLMHA4OVgxVm4wS0hhcWVyTmx6aG81WXpISW52RlJHZlEvQWo0VjFCWmRyVEw3Y2RXcitnc2VNL1QyMlZsdGJxb2drWXd5VU5OajBybzIrdGRESVNoNmhySTJoc0w5WlRNSklOaUhxQ2FMdHhQeE5PaDlkRDFzMm9IalVsSmMzRnBjL1VXZkczbmpKREdUMzh3M3FZMkJCQkhYVWs1VUNOZm1OcXVSc1h1YlMyRnBGajBodTRMZWlxUmEzUUFtQ2dDcFZKcWxhL3dCSjAxUFRhSDNMWHJYNENOak1nMkx5RVYvYmtxOEw4dlZUd2Iyc0JRZ2pSWVBKMDNhZWNZN0MyZHhXS0s3anlOdUpTWExtMkxzbzVSb3lvU1hFYlZOVDExVkFRbkNGeTRzNDVIaHpFY0RSNHJJeHQycEdLdkg5UVc0dWlrVjJKRlJYZlViMmhDSHJDV0VkNzRjMXhKemU0eFRmVFNIanlkWWkzcFRmMmdnMStSMXorZHRYK0owUEJTMml4R2xsYVphVjdrRDZMbiswUUZjbjJsdVhGcUQ1VTBwYnJvSGJVclMraFhQaU9UeGVLdVh6bWJrbml6TTF1d3hWdEJKSXZLU2R3Z2xkbDVGQ0JWMUczTTduNTZYSXBheTIxNmR6bmNGNkwxV21leEVlSVFock1YYlhOakFXbHQ0MzRsWTdtUi9lcWdFaWhJUEw4TkorTVEzK2haVFJ4TXBmcU4zZ09GeURYR1F2TFNFVExqNG1rdG9pb0VkeGUzUHNpNGtsUjdEeWF0VDBHMmdPWG1yNlUzMS9KSTNmYnVOZUwzUy9iMDgyK2hjUDNaa2t3M2dlTzhTeEQvVDVlYVcyczRFdGlFWmVFYWloSzlCdlV0U2g2NnhlR2xma3U3L2FrMmEzTDNWNCsybWxuRlVVejVUY1o3RStBUVl2TTVLZTd5OS9HWjc0M2M4dHlWdDBua2tTanNXcDNHWmFLZmg4OWJ2SCszazVHNnFTVmZLTllNZmwwdnhlRHNzL1ZmclBndjU5Q29MU2VXMHVFdklaSGh1SVR5amtUOWF2dnVLZW8xdnRTb2VweDFiT3IzSncwZEMvYXI3blRacDduRmVRWEVDNVNhT0JiU2ZoMnZxSllkaTBuR2dNcFFMNmU2bngxeS9QNEN4cmRqV212eStCNkI3Sjd2OEFkZjI4MXRlejhmaVdUbmNsRGNMTkJNWVZ0b1E4TnkweThpc2dXZ0NBMStQVWpZYXljVlhYVTZmUFZXVHJwM21SSXgrU3p2aHQ1ZUcyNHlDV0NSWlp2YlNseEd3WGxJYWRBM3BUNGJhMS9SbXFjamt3WmNGcDZwb2hZOVhqdHJaaGNScmEyME1qWmNiZXhJOXdDd085QlVkYWRORnYvUXliUlZLSDhSRXcwVjljMnQxbGJlU0s4THJCZTI5czl3d2lOMjl6d2lFa1lha2hwTVYzMlVBanFkR1dhVGpwL29adEsyYTNMWCtac3cwZUx5Ri9pclh5aTRUR1RUM1JoeVZ5NUtSckdINGwyVnVTOGw5RFRaUjExSys2cWJwcm9SckZtbGJSeVlaZXd0Wi9KTHV6OGVLWEVpVExKajVubENzbHRXZ1lBZXd0eE5UNkJmbnBzZG5zVHRvTmtxdDdWUVJQSmJXdVVrU3JYbU5nQW01eGpaa2xxQXhVY1FDRFRyK09ybExyNEZMaFB4UjRCalp1VnBHVmh1bHJ3TEl5SXdEVjROd0pJUlFUN2p1ZjVhZlVXakd2RytNWUc4aGp1MHo4dG5jTmJ6UE5pNHFYUVBGZ3dpaWlVOGtWbkhLdlVCU2Zob2UrUzFmN1pMNllxdjhBdStReStHWnBNSDQ3a3I2empqaWttNXhYY2NzelRYa043TWVNVWxUeEN4bm1Td0lManBXbXE4MU56U0pZN1FtU2o0MWpaamdEYnYyaEdVczQ3aDBZU1NSc1dMU05IU3RHUHRVbFFxajNhcSs0OVpDY1dKV2RZOFJyemVPeEZsWWYyckhLSTcwaXNzanR4ZVFsYWgrVEUxb0s5ZmlUb0ZOMjFaMkZjYXhXaisrQU0wZHROTmJ4Q1pvMXRsU0lBQVNCSlFyVlliMU5keitPbTlUMU5MZW9Ta0cybHpOTGV3M0VzaFNNVGMxVW5nRUFCR3dGUUJxU1NnamEwV1hoSnV2TDFHU1paWFhnOG5FVG9DQ1RRY3VRSTJCK1duU0tzbVRTR0E3KzhSaEhPSkdDU01RekhZZkt1NTJIcnF5aTdNek03VlVtbnBJQ3UrMjBFbFdwRzdLVUIySHpIeDBkWG9jdnlWTm01MGtyM0p1RXVaSFVsRkphaHB1Q0tDZ0h6MGJpVmJkVEx5UGFRVGFCazdrL3R1SElZc3EwNDEycFQ1YXNXUmR1aUt0aWFUbnFhbVV4QmtMVjRqZHR5RFQ1YXRXcWtwYU5iSGtqS3BDRFplRGJBazBJb1IwMG9FYVk3bTV0aTBjTGtRdlZIamIzQmgvdkE3TitXa09OM2hVNXZjdEhheWN1TXZHRXFWYVJRUXc2UFRaZVBMMnR2cW5MKzFzSTQrdDB2RXNMUFhFcjR6SnVGVVc5MWRyYnRScUdsdW9VQ253OXAwQmpyRmw5VGI1SDdMUHhjZlFSY2pJc0NYVW51SW1saGhWay9WKzJBMUIrQitPanFTMnZtWWRvcklOaGdrdU1ySEVRU3pCQ1NPbFpucU9ucU5FUHBKWFNYWkk2NysxMXF2OEFiTU5BczgwYlh2a2R1eGlVVWhlTEUyc3Q2YWtxYW5sR3ZRNjVUbjJpMHgrMmwzOWZUL0U2L2p6OXRyenF2NWxwZmNHOGFMeGY2WXY3SkpVakZQV2dMSGZYblZGdXowWCsxU2RWN2JqblBKUjBQbE50YUpmd3pwSk9XTFNLc1NWNDFGS0VuYXAvVlQwMTFpd04xUnNadVVxNVd0ZEJZOGFqdFBJY3htOGhlUkVZZXl4TjVkcXNwRlE4WEJWY2tkS000SU90SjBlUEdrbjZwUnpHZmtyTGVXdlJES2VSSUovSnJLREdSRzZ0N2E2VjdjQnFtVmw5eFl0c0tGdlhYWHFkbXZnZWFRbmZRdGk1eDlqWngya0U3Z1drSW5ueUFsOTBBa2toNTlCUWtDVGdhQTBwOHRaU3M5ei9BQ05aMTBTSnVCWmtzTEM4bWphTDYvSXZiM1Z5dkdzbHROY0NKSWxVaXRDck9hTHBPczJYd0czTkpuWW5qTStNaXJpSWpIOVJpWVZ0M3hrVFVFY2JEbFZncG9vTmVuWGFtc0srVGZkMjZ3YXYyclVvbTFDZmNiQks4bHRLc2dNVWNmN3N4SVdOVktra0FFMEZOdmh2WDEwVlRXdlFFdW9ZSnVKcG9ReEFNQ1J1eWhtRG1Ea0FQYzdMN2dxMS9wSStmcnBTMTFIaVFUZjQzKzQ0bVczdVVhYTN1WWxqbWhTUm9vWGJrelJKTkxVU2tHZ1lyRzFLdHVPcE0zUFZkUm9YZm9WZDk2TEN6dHZ0emJXMXBLa3YxRjVpN0s3dUdsV1FMYXRPWnpTUzVQc1p5aC9UK29EYzhScXpHMjcvQUZLOGlydEs5eG1FbmhndFpMTzZGemw3MjNFcklKWWx0N2RMc0VLcTBBWGtFSzdOMHJ5NDdhc3RrV3NrVlR3NmhqSDR5K2p2THA1WjQ3ckdRTlN5SGJoQVdTSll3ZUFSSDJJRENNRmVkTjJLcnV3OXNpYWp1WFZ4dGFoeTFzNThsa28vcVdXWEd6dEZkM01oWjd5V1VvcmtRd3ZHWTEvY0VRTHVLL3JibHkzMEJhNldqRDZVYlVvVGZFcHJpNis0SGxkdlp4TEZhWGR4TWpoNW5Rb0lTcWNneUJXZms1QUZGMkg1YTBVdHVHcVpuMXRPVnM4LzFMM1NRZmFTNFMxUkk1cnpNV1Z1SStoWkxkWlhCQUpKcHQ2MC9qcVhDVTVVL0prZVhQMjM4amo2M3Zjdkh1c01ScDhhai9icm9IWkdMWGQyQzBHYzhoUk9NVm9oUFdvZHYvbHFwMXFXcTF3bkI1ajVSYmxhMkoyL1Z4bEsxLzhBczZnNlVmY245eTY3QktMN2plU3FWLzhBdWRLcExBS29sQlVrN2RDdnorT28vYnA0ay92WDhDYy8zR3o4UHRteEZ4M0ZJb3dkZGdmbHhwdnB2dDE2cGp2SmRkYW1tVDdsWkZwUTh1THVnd1BLdFkySUk2RVZIVWFmN2E4UnZ1di9BR2thVDdpZzFZWTY1amNxeXNlMUMxUTNVRStvMjAvMi9NWDNGMWRRSmQrWVJUeFBFY2U2eHVRN2hyYVAzRmE4U2FEMHFkVHJWcDlTdDJuc0h2dGJaSjVMNWhHSm91Tm8xdlB3QmpVTXJSQU1TcWdVcnZwWm5HTjZpeEpPNjBPeHZDY0pqYkREL1FXOW55bmhtSUYwMFpiajNHallqMjdCdVNnNzlQWFdCa3ZQVTJxVVVDOTl3N3kvdVBLc0xpYk5MWjVwOGJkZlV5c2pzS3h5eUVCU0N4RFBWUXplcHBUZlVzVkZXdG1WWlczWkN4bC9HUEl2SDhWSmM1VVhNa2tJaWpoaVNWSWlpQmU3Rzc4VHljT1dxS3BUMjBib1RvaXVTdDJvS0xWdFhxVi9FL2tXSHdWN2xMbXd0TW9jdXBtdDF2cGl5QjVwMWlnZHdRRmw3WjVNSStWUGR5NCszUlUxYmpwQlJEU2tKTFo0ckJlTVJQYVRZM0taQzB0Mmt2WjdpRUpjVzEzSkp4TWNjdHBLWGxQTXZKd2FOcUx0dFhUSjJkdFU0Wk43VlhyTFJOeGwvZlltTzFqeTE5R3IyNGt5RjJ0M0hBSVpZMlZxUElVcUdBWURraEhydlhwcUdSVE1JbmphUzFZNCtPNTM2RHdUeHE0bnlFbVB3MXpCSkpMY3hGZTNjM1Z4SVEvL0FDNk12YUE0ckhUY2sxNkFhSDJwNUxLTlM1WGRjYWM2QWZQWE9CejNrK0N2TDYxc012ZlNXYzMxTnNrQ1NWbzU0UFJBMVdDRGtWOUQxcnE1NDNXcmpRcnJaT3ltR0tQM0xzTE83eFRaUkxHMnh0d2tFZ3NjYmFJa1FBWlNlNDhhcUFyQWpZL0hwcTNqK20wVEpUeWZVcGVoVWZrQ0hHNWhZTEptaWdsdElabGpWenhWcDRLbWxDUjExbzBiZlV6N0xwQXUrUFpPOW5uU080dVpKSWxVa0l6bWc0c3ArUHdycFBRWkR0TTV1SVpWTEVsSkF3VW1xZzBZVjI2N0RROHVBcDBVaS81RE5QRmhsZU5neDdyTDdrUndLRmlmMUEwL1ZvaXJsRkRycXl4ZkZmcXJ2eG1HU0Y3cVV1WHQ1QkhjR0pFYWVJTXJCRHRUYWpEb2Z4MVJlMFhnblNzMUhLYnd1OVNHTzhmTVhLMk56Y1cvMUVTT2cvOEF3ajlzUDNYWGtLY3Y1NmpXN2x4RWszalVMVTNYR0RqU1M1c01WZlhDU2l5NHdCcFl5R25pa1JRSE1hZ3FLU2YxQ3U1MDAra2RwekJOKzJGaEdNdGxyV1RJM0V0MEhzNWJXN2lCU0pKSjRxY3BrWitEVmYyQm0zMjlOVmNsK2xQc1c4ZGV0cGxsWmZFdm44dGNXc3B1dkh4NDFhOXFaN0NqUXNYNGR0RVppd2Jtby9TNUEzSHJ1Y2ZBMVdzMTEzTTFzbGQ3aXloVkRIMm1zTGxQS2JxUyt2NWNuRmZXVmJXYTdnYUJ6RkVRVUJEN0EwSDlOTnY0Nmp5NzdrdE9nMk91enYxTGJ2N2ZISkpFWHRJeGNYaHJjbUtLb0xNQVNHWUEwQjJGV1ljdEIyU2VxWmJSd1JicngvRnczelNpT09HZDRXampFYmNRR2RCUUtPVktiZEI2NzFydnF6MVEwSmRVMTJBK1F6RFd2T2FXM29KcmFMbmRLalNxenVnS3Qwb2R5RWJyOGZUUVZJVjFQVU8yVFIvSFFRWnBYbml0cDVyVVE0OTdoSTdWQkkzTWQzaXhXSlJzQ0dZeDcraEJyMTFvd25iVHFEcFdxa24ySVdkTmhQWm01aWlhWjR3a3l3ZDhkeFNKQ0l4S3J0U3RTd3JVN1VPcFVsTWJJMEJieTlmSVhheTVTNERwam8rQmdnWm1hTlZWaUZvbnRvQVczRmFiVjFmczAwQjdPZFd6VmtzakptSW1SclFQSktrYXJDeWxRblpCSTNYa1djZ241amJiVXFxUGtLWGJxYjVzZm5MS3dCeVVJV05Kb2J1ZGdIdCs1STFWSkNTS0FaUi9UVVVQcXRkUVNhY3FVWE5Vc29sTml0L2Y3ckY1Uzd1NENKZzM3TFBlcldidE5SdXEwQmJiOVhxSzFHaXNkN1Ntd0crTmFyc2VmM3EyYTBjdmpMZ21FeVNJNHUrMnFDUUtIQS9iMkpBNjFydWRFUEsrb09zU2lERzBaNUxtSTIvS0hHeXlSdjJwZjNKUUE0WjVFZGtKVWloSFVWMFBhOXRRbXVPcmdiTW5qN1NObnk5ckxKY3dIbk0wMGxHWlM3VktualQ0L0RRaXZlNlZXRTdLMWxvRkc3d1VVU1RkNHRiekRsSkdDR1lFTi9WV2hHaXZ0dVlLblpKRk0rYVptRlBJYkRJWU82RGZRT1ZkUVJ1aXk4dUpORDFWbVhXdGh4UlJwOXpFeTVadW11d0lueitPVHlqSVpHQVQzR055RnRjVzAwVEFnczB5Z2cwY2o5TGl1cmEwYXFrK3hIN2kzTjltQkw1SUIyWldrQTdSV1hhaEpCSEVnNm1VR2xyNjFjUHlsZUJubEVvWWlvV2xPWFE3aHZkOE5JYzlobUZ1dDhrRjQ4Y055Q1lndGZhU1E0NVVQUXNvT25rUk9mSVRpTXp4NUNRU1BicmFPU1dLdXFFaFZOU2FyUlVwWDRhYVJFWjdtZDVuVVhBYVNGMG50a2syUGRRMGFsUjhCMTBoeU5rSnJxQ1pwWW5VcUpCTkE5QUFXb09TbmJTR1pOOGR6SDlxeWRqZE5Jb2V6dTFtQ0RZUEJLYVNpbTIxQzIybWVvNmNNZThna21KelV0dVlqTGJRT3hVTDdRMFVnSGFQSVYzV3RQOEFEVlRoT1gzTE5yYkF4dDhrd3RybUJ1YnRJU1kyY01ycXU1VjByWC96MWFRUFpyK0tpUVNYTWc0Q1htZ0N1UlN2RlVwMXFEVHJVSFNFUU1oajRMbEEwbHVxUmRwcEpVSzcrNXVLaFJUZXZYU0dZRU5wbDhNQzJKa1dlMFppRGFTZEJ4b2ZZVzl5N0g4Tk9NWVgzbEN5eExmV01mMCtiaUJTYTJ1QnN3RzFSMHJwSkNiRnVQekhPUVRWdWdzcklDcVJPbkVJYVVCVWZMVHdOdU5MK1UzODhIRzZrTXN3REtHSUZCWGNIcDZWMG9HazhqOGh1WU9ESklYYjI3dVR4QUhXbENLVjBvRkpQdlBLM3lFNk5JRWFVQUJuS3JTaWo0MHFmejBvSGsxUjU4dVdhN21TWFpWVldSWkQ3VFhvdzZlbWxBMG11VE9pUlFyUlJpUGtUMmtIRUFIb0FCdHBRS1JyKzNtV3d6WmUycy9KRk0ySVpYU1pHTWc3UUNzVVA3UkRFQStuejBObW91cHUrMzhuUDlxMkhFOVhyOFMxVzhwKzBXTVp2b3NTdDF3SUZZN0l2UStsV3VDTkRGajQvTHYrNlFiNUY5eFBITTdnNzNBV09Ba2doblVCWjJhR0FSeUllU3NBZ2F0Q09tbWJnSjRudGVhOTVuVDRpRmdNMmxqQmxiUGlacGJJQjdlTUhqeVUwY3JYb09MQS93QWRXUEh1aCtKbmNpMWNXVzlWcWtMMmE4dHkyVlFJSkREQlFnUVFHZzQvTmpWajhORTB3MXFaMlRrM3VvblFXWG9PUWtZSXJBajU3N2c2dkJoNncrV3RyekcyU1hiU0xkeUhzQ1hjcldPbTdiOUNDQm9ESmphYmcxc0dlclNWZ2Y1Vmowc2JpREkyMGZhaGRqQkt5ZERJUGNySDRmRFQ4WEk3ZWxrT2JoVmZVa1NwR2lsc0k3azFkWkFwZm1BZmVQMVUvRDRhczI3ZFFBbFJRb1doTDFZbFNVcjZCUVF3K0oyUFRVSlM2Q0c3SDJNdVRqeDB1VnRsbXdkcXNtS3VwNEFXdUliYTQ2Q1RsVVVCWnUyZWxkdFVaTnlVcnIxQ2NNVHFVNzVCaHAvSDh6ZVlpZWtqMlVyd2QzL09nUHRjRDRNcEREUjJPNnNwQjh0SFN6WGdYRDlucDRzNTQ3ZDRYSXhwS2NYUDlRSkdKVnpHaWhnQVFlbEFWTzNTbncwOXVvOUVOSGpubGkybDlkNDliR0lKQzhsellwRkZXR0JtcUhEb1IrbGxGVDg5VlpOS2xxZllPK1A1L0hXR1F5YTVxTlVzTTNHeG1nZ0JJWVNkQ2dKM3FDVDEyNmF5TStOM1NhNm8xY0daWTdhcnFoWXpGcXVNbmJIQ1NLNnNyVnU1YTVoQ0FrdHRPS0tXcFgzclNoQjlhNnFTL3dCRFMzcXkrSGNxSHNza1FsdFFzaTNCN0Z1eW9XSm1tNHFCUngxUmY4dlNtdGFaMFp6cjBVcm9UMHNyZkdSV2QvT3ZadDdtVmt0NXVaZVZrUmdvSlRjS1dBNWVuODlVdXp1MmwyQzhhV05WczExTDgrMFdCK3F0NlRMM01rcm03dkZFaXY4QVJ5TzZyQVhBZlpncWN4U3RLNjV6bk5yVlBUb3ZQeE8xNGVSVnBzYTFtV3A2ZUJHOHV5Vi9jZVRuTlFDYWUweEtGb2hKKzJ6dGJOeWtjaGxJWUx5WGMvRHBYVlBGcFZZOXZld1prdHFyZHFmcVZQOEFkVEp5K1I1eWUzdFltZ3RJamJRU1hGeXpkeXFnbXNpcFZSVm5yNjBwcmY4QWJzYXhVbDlYSnludldlM0l5UWxDVUxVcXU4aGFHNmV4aW5ScFVrYU9TYUorVVhKQ1Y5ckwxV2c2NjNVNVVuSTJVT0NReGxzekV5eWdTZzgyZU1tZ0kzQkJvTlJhVEpUQlp2MjMrNkZyaTV2b3ZJMW1taktGSXJ0Q0hJa2tia1RLci9xK0ZRMVJySTVuQSs1clNFenAvYXZldnNQYmxscngvbVd2a0h4bVJrdHBNVmV3WGRybHBPY0lnVU1vQ0xUa3hmOEFTQlZpUTFEVHJySncxdldWWk5RZEx6TTFNdFZiRzAweFA4dHlVbHI0bGtqRENJN3JJc3RyR1FGTWpzNUx1QXFnR2lxZncxcTRhVGRlUngrZThZM3AxQmZpc2FUeC9XVzM5dngrTnZMampmU1c2bUNYaGpsNU96TzdrS3JQTHpJVVY5b3AwMWZtY2RaYmo5UWJBcDFVSmZ5TitTdzBzTjhSZzhPbDdpc2tMNTRIbmRHZ1dHM2xhUHZDUlJ0VVJOeHIxOWRScmVWNm5EWDhTVnFiWEZWS05lT3RyYkw0ek4rUjQ4UTJNOWxhd1JMQlpNSTRacEhnWkNlSnExV1pxc2VtMU5LemRXcXZXV1JTVjA3TFNQQVZFU1MydTdaN3UxZ211VWdhR0dHNlptaVJtRlZjb3BVR2dvVHo5dklBMDlOR055bnFCN2RUeWE1dDRwNXNaYXFoTjdPc2NtUk1hcHc3cWlzYnV3cHMxVHlyODlORDZqdUZvTXZrTU5xWlkxc2NvMTFZNDFMU3d1WnJZMVI1Sm96M08yV0NoalVzcmtrQUFBMTMxVFNlNjZsMS9qMEkrSXYvQU96TkpsTHJGMjB1TGE2am5hT1gzbVRuQzVQSkVZOFZWWDVMN2ZWZDlTdXQyaWVzRUt2YTVhMExLOGF1Y1hsSm84clpGWmJLMzcwMFU3T0xpWHZWcEd2Y0sxb3FrK3orbnJyUHlWdFZRKzUwSHQySlpNbTVkSy9xVEpybjZybGQzcUxMS09EaVFDcis0RlJRQTlIcnNOdENxVm9kVEN5ZXEzWUVSd3BaV2hsTVlscjcxVmE4d3N6Z0ViQWIwNkgvQUIxWTlTdGVqcHFRVVl6M2h0aUdSWWF5OW9pdkZTM0lWSVArV2dJR2sxR3BDMlYydEQwZ2pYcUdHbmJsQ3pFQjVVNmpreEZEeUE5ZmxwNk1qbWIzYU5BZStRUGNSd2hhQ01TY2FzZDZNV0pJOU50OUVZMTFreWVaYlJLQVhQRktZaXBIRUU5emVteTlkem9zNXpJMjNERk81czJ1TGczeFUvUmoyMmhPd2FuL0FMbFBnZCtQOGRXTjdheDNCbFhlOTNZaXl3c2lCUUR1S0lmNTEzMGxkdnNXYllVR2lPeDdzNnhxdkZuSUZmalg0MCtHcnZ2TDVGTHhJZjhBRFlDeW1nYTJoc29ibTZFUmVnalFzUUR1VFVlbjQ2Q3RkejFOWEZUR3F4Q21CQ3VCaVh1Sld5QkZvaUVDM1ZMZXY3ZitZa0QrcjBQdzBkUldTOFREeU5PM1NBcGIrVzRLMENKQ1kxalVtUlVXMmNLRzZWQURqYzE2NnFlTEkrbzZ2Q0JtZDhzZ3ZUSEZaVzhmMHNiZHp2SVpJcFZjMXFRR2R1dGZVSFYrS2pYVWZMbDNhZGo2M3l3dkl5bHlTNEFaKzR1enF6N0FzdjVkUnRxeDExbEZhdjJZZDhkV081ek1Ld21zWWRLTURYa0lsTC9uK3JVTWppckw4TlZiSW9PdVB0bGJYQi83VXRwYnFXR05iUE9aZEl4QVN0WkpvTWVqUnVUUnZhei9BSWE1TDNGZW5JMTFWYVY4L1U1WjFuSGV0VkNtVyt2V0YzQ24zWXl6NDdGd1drVWpQTUE5eUdjS1dBTEpFcE93RkFTTmNmd3NPL2t2eWhIVjhTMzI2WHkrQ2dvOW1taWduWkxlU1JaV2V2RmRuQTJxR3IrV3V4V05PT3htWDVFUytzbm1DdjdPRERlWnZNcm0ybXNJTVk1VU1xSXMwbmVsVnBFMkZVaVByWFJYMmJQWi93QzM2R1JuNVZIdThGV1BxVlo0bkpFbmx0cExGYkxjSmI5eG83ZEJ6SkxiQUFDdnA2K25YWFNaSjJzNHZGKzVEN2YyY0Z4SmVYR1JLM01jTG1PMlZDeXh2T1F6dUl3YWNnR01hYi9EV1dtNFNYVTE0VTZrekVYRFlUSjRoTW5hR2RzZlBIZHlHVmk4Y1U3UFZZWVVBSmNFTXBDamZsVSt1clo3bExUNk12ckdmZFM3OGZOeGxzeDRSSlpYc3BLODJ1TGVPNGRZbG9yUEd4SXE0RlNSVGNmcDFqVjQyTk43SHErcHFXNU9WMFN2clZkQW5mZmZpWEc0OFpETCtDNWVPMGxWcDJ1dTViaFpDeW5pMjdvNkFFN04xQTZmSW1tS2xYKzdVRHRsczEwME5NSDNzOWx2a1c4VXlWM0xkUksxdEFsM1p5TUlXa1ZqSklobkJBYW8za3IrTk5UdGhVdzMrUXl5UHN2ekJPWSsrYXhtUzB2UENjbGI1dUl2SkNsbzl0ZEJXQjdmL05WU0kzQVZ6eTROOEswNlA5dUhPNFpYZlNCSys2djNFOGo4bHhXTXdsMzQ3Y1lXMHRKNHNqZEVsMnU0emI4NG80VUhNbmV0SFBGUlZmYUthbFN0VTIweU5yVzBUUVB3dm1tQUZqWVdtWkY5YTV1S0ZubzlsTkwvQU5aQ3JBa0dJU3V3VmdoVS93Q2IwalVBS3o0ODZ5aVgzbzdCVzI4MThXeE1QOXNqbm5qbUNnVWt0NzFKSkM0SDFVc3dDQXgwWXNzY2FWTlJWajBwWC9qdDlZYUp2TXUzVVlwL3VQNFVZNFIvY2phMlVjOXZQTTl6YjNOR2UzUkZpWGkwUldUaW8vUlViZzlRZFp0K0xsM05wSTBzZkp4Yll0SXUrRVpYd3ZGU1pLNXpGeXJRWHR6S2JRM0Vra0Z3OGZQbWtxbXRUeVpWa1plbGR1bTJ0QzFiT3FYZEl6NjJyV3pZRS8xRGVVNFRML2IvQUJXTXNNcGIzOTYrVGh1TGhZV0prTHBiU3JJN29RQ29MTUtibjh0VzhLbHE1WmFoUVE1VjFiSG85WktMOFY4Z3NMZTFFR1J4TU44WTZjSnlxOXppUUtCdHQ2VjFyWlZQUXpzYjhRemM1TzB2cm9wWVkrR3lpaGo5MGFxT1RzZHp5UHBTbXFxMThXWE93MjJ0MzRtRDJiM0RMMzFQRm1pcHhiNTA5TlFjZGlha0N6MzFqZnkzYjJWbUxPeml1SVlyYUpTV2IvbUtPVEdoTlR2MDIxQ0MzYzdJWThVY1JQOEFXeTVXeDV4VzVDVlJtNVVQdzlEdU9sTlJSTjJjc0ZlVTVEeGV6czAvdEdOWTM4MHFvcG1MTUVIVTFBTlNTTmhxeEtTcTltbExSdk9KOGFObGFUWDBFc00wOFlZOW9raXJDcC9EcDY2Wk1kU0pIa0RZcGNsTllZdU9SSWJhSlJKUEx1elNOOEIwQXBxeEp3Vk8wMmpvTUgyWWphVHp6RXFwNEFtY01WcCtnY1MzVWV2VFN5dUtNaFRXNk90UEZRbHJEU2FaSXBwNXIxcEJOUmlzTWpJUUFLN1ZiNDE2VTFoMzE2R3ZYUlFMM21tVHNQSHZKOFZrVnVZNEZueFVpeDNNa1gxZmFqZ3VFbFVoVnJWelNudUh6cHEzRFd6VG54S3IzU3NtaVQ1RmkvN25pTGJPWEdWdFlJYmExdDE3bDUybzN1SGpTVXkxWGVpZnVOUUUrbTNycFZ0dHR0VlNGbHVVeVVWanJ2STVuUDJtS3gxeEpEakxPNGp1MW10SFdhRkxrSldFd2lVRlMwYWpud2IrcmJyclFzb1U5d09yZHJSMk5mblhpWDIvc01QYTNWL1kzcDhzZS9aSmJwNTRSSmMyamtSZ25zSXFGdWRhdFg1R3ZYU3gzdTNvOUI3MG9scXRRNTRWNDE5by9KTHVMSGp3YSsvdjBYY1Zva2xranRZWUlTdEo1WGxrZnVNUlZ1SWpvVFRWT1I1RnJ2MExzYXh2VFpxZS9jSHhyUFc5b2x0ZzVZYnp4NXBoYTIwZDVleUliRzREVWJ0V3lzRXExQVMxZW82VTBzRjEzVGtmUGpmWnFCcjhPOE95L2o4RDRQeG5DWWtaS0tFTGtNdmUvd0RVU1hNc3BGUlYyQkNvSkZKQ0FWUHJUVldYa1UvZGVTZUxCYVlyQnArN2YyaHVMZkhTWkMxdW9MVTJ0b1piMktCcEZhNmxaU0dTTkdlU2l4MTNvd0g0NzZxNHZPbSsyTy8wSmNuaXpUZFA5VG1iTzJMNG04d3l3enlOQmY0Nnl2UXNwcTY5OWR3RDFwVUVqNWE2SEhmZFBrekZ2U0V2Z0srSXlONDE2a0VrdzdhaVJQMHF1d1EwRlF0ZlRVeXBEMURjeGxYVjVhS2dESGo3ZjZndFR0djEwTEZuMkN2U29BK2NsYisxWEV5QkhSSlFlRWlLeWtNcWlwRk91cmE5Q215MUhiN2V2ZU40dE5rbHZKSW9ZVEZKTkJBVlFrS2VQdFFvUVRUa05RelAxSlFUeHFVeDJneWR4a3ZISXZvcHN6TXRwRkM3eWxZVnRGa2lsWGtBenhnaFFBT0ozb2RRYlZiUm9TVlcxSk90OExsMnlXUGlseWkyRjBUY0xDc2oyMXhJT0VYY0FZcEVCVW1NYlZhbngxRldVUFFudGNyVWhlSVM1M0MrUjMxcmZYRUZ4SzFuRmN5UU5MOU54bGhta0FBY3h5Y21VTWZSZW9PbXUxYXZRbFJXcmJWK1paK1cvd0MrV2xsenVReGt6TmwxaHVPT05YNmlKT0hDT01oRHhabUtpdk1VMzlPbXN6Rjl1bnBYUkIyVGZaeTNMZmdaZU9lYTVGZk1yQ1RNM3NrMktnTXRyZTVTZTJsc1BwM25CQmlsTXl4ZzhDRnEvd0RUWDlXbG54MXRScWlXNG5pdlpXbTNRdSs5KzZmMjhodExWWlBKTWFaaW9MRzJuVmtIYklGWEsxb0QvdkdtczU0TWxrazZoRmNsVlo2bWFlZitKWFZ0YjNkbm5NZkpiUmdNSkZ1WW1rWlFTdkZGTEVpb1BYNGFaNHNrYXJVa3NsQmJ3ZVV4L2xlS3gxamdIaHZrZGJ1MmxkSlBxUXNkdk9Rak9YSFNUa0hUYjlPMWR0VWNpcnhXbXdUaXlWdFZ2d0sxKzVQM0w4ZDhHcFkrUlkxMnlOOFZ1VU5pNGxoZmtXNXlCcXJ4NHNxK3dzVzMycHgxcGNiaVd5K3BNRDVITHJqMGFFT2IvVUg5dWJxS1NHK3RyMmo4VEVJWWhzeXVHRE00YXA0NzBHanYvcjdybzBDcjNDbmRFS0g3ei9iMVo0M0V0N0dHamFLZFdpSjVvR1lveFlmMUNvL0RULzRlVHlJZjVsUE0rZys2dmdKUnJaYnVTV0NVOG9ra1dVT2oxcFd2SGRqMU9uL3hjZy8rWGplaGNFbjN2KzJPUnNjeU1yNUtrZHhuY1JqNUpJNVJPQkZtYkhtbkZBVW9vWmVCNVZvU045RlpjZHJZMG8xQnNlV3RNa3pvVlpQNW45djd1NTdrV2R0SFNnV1JaR0lVdUJXdENQVTEwRFhqWkYyRFh5Y2J0MUprZmsvaVZadXpuYkFLU0M2U3VwRHFEeDJCM0d3Rk5XTERrblZGVnMxT3pKbHA1YmdySzVqanNMeTJ2ZG1wRkV3bWFoOTQ5cW1wMHp4V1MxUllzMUgwWkt1c25rY3BITlkyZGJXSkJITmR0TU96dzkzNlhEbXZGdW5MVk5hMW5YcVR0YXpXaEtpc0lyMjB2Z2xwR3d0SVNKUkg3M1lTaFIzSXh4SElJMVY5cE9wdTZxMFdKcTlXbWN6ZVcrSitmNGJJWFMzZHV6UXBPNnJjUXFGWmlvclYxM0lORFhwclVyeWFOR0pmajNUZWdudmIzYk95WEx6U3lvT2J3SXhERlI2azdCUVQwMjMxZXJLSkJvWmxrY2U3UlF5V291TFcrY0F2QXg3c0FTbXg3bTFHK1JHbHVYVWRWYjBCOXpqczVaOGF5dEtyQTBaWElBQUZmbDhkS3RreE5OQXhyaklSTVVOdzFSV3RHSjFJaVpRNUxKSWVVTThnNmdFRS9ocENOaHlHVmpLU1N1ekszNmE4VFg1VkEyMGhCS0dMTjVCQThNVGNlcTkxRlpSK0RiSCtXbWJTSEdEQitONUo3eFpjM2RKYjJYYjVGcllySkorNStrYkt3RmZXdTQxRnZUUW1xbG5RM1ZubDdTM3Q3SzVtdVlyT0pyVzhsdUNTWjBoWXNoVndxaGlQMG1uUWFwc203RjFQQUQzenBiMmR2T2tNVWx6SUdTS1dNQ3FseVNEN2RxaXY4dFdxWjFLaVduTVNrSkdJNGpzaUxTTnZiR1NUeVliVUlKUFVOcE1Scm5sS3JGY0tQcWI1eUhuTGNVb0NwcUR4NkNnMjBoRVB2VHlDUlVtL2ZqQTVxL0VzQ1RRZ2dBY3FqVWhnQmtzUkZjd083S3F6SVM4WEd2SU1LRWNhNzEwaG9BczlnTHhESWtiRnR1Y3JJZVJmY2tMVHJUNURTRkFQZkVMWDNJUTQ5TmpVSHArbmZTVEdnMHRpNDZVSTR1ZHlwSW9CWFVob0kwbU9JTkZwUnEvcTJOTklVR2hyT2dvUXBId3B1ZnkwaGpVYlZRZGhRL0k2UWo2RnByZVVUUXlza282RUdoQjBtcExNZVMyT3l0VncwUE45OXdyYksyZU50THZDV3RyTllwMjdpNnRCd2E2WDI3U0FVcCttdFFhMU9xYjQ1aURUNDN1THg3dDB2Y2lWbXZNN1RONVY4NWNXaDdib3ZjdGU0STA1UnJ3VTFqUUU5QWR4dWVwT3FuWFhvVzE5eGRNV3lzeElBd3VUdTduSVJXbjFMQzBsSkNwUVU1bXRDd0ZPUnI4ZFhXU3FwZ3lFM2UydlZrZkwrUDV1eldhNmp0V2F3TWpBVHdrVTlwcnVLa2pUVnkxWk44ZTZVeG9MRGlWbUlwN3ZVRGM2dUJ5d3NBd3pQaGQxYkFBWkRDSHZ4dDBidGcxSTIrUlA1alExdlRrbnN3dXZxeHRkME1mMG4vZWZqVU5vTGhMTjFaZVZ3Nk5JdmNqM0hMajdoeU8xUjAwQS93RGh6Tm10U2VSeDl2UnlMUDBFOWt5VzhzcWdzR1dScW50aVNOaXBVa2pyOFB4MGZYSnVVb3hiNG5Sd3c3aDViZTRyREk0RWx1YXhPTi9nS0UvQ24rR2hycnVSUVk4U3l0emg4OWM0aTVsRnZZWmRsUys3b0RxOXFLMUcxQnlJTzNydHEyNzNVMDdFNnRwa0Q3emVFZVFZaVBHK1Yza2FYTm5rRittUzhoS3VqaEt0QVNWQS9WSDBKRmFEZlZmRnQxcVhaMUszSVR2dDU1UWZFL0pZYnkrQk9NdUZhMXZRZi92VGpqWDViR2grV2picVFTamhscVo3eWp4L3d5NXlFZU55RWVUdjdsWUhmRWxaQ0pMV1pnNGpFcXFhTUFhMDJwOGRVTk8rbll1ZGxVRllEeUR6bk8rUVI1YTRrbXdtQXRhSnp0VVNLZU9FTVVqQzFQSTBOQTNIZW1oOGxhMXJwcXkybVIzc3A2RDU1dDVOZy9KYmE0d1hrOXdrTjdGRDNjVGZZK014WEJrYm9Ha2RpcFNocVFQMWRSVFdUaXJkUGVsUGpQUTI4bVRHbHNiK25VbythL0VseGIydU9sU0o3Y3VRWEpvSnJqMnU2ZzEvU3ZLbTJ0aFZoTnN5SGJjMVZNSzNKanRNUEhPWVJQY1BOQkpia2htY3gyNTRLcThhbGViRmEvRUtBS2FHcW5hMGROUDFORnRVcW05V3Y0SFJHSmx0L0NrOG56d2hTYTFzWWJheVNhR01STzF5a0llNVJSVXR4U3E4dVRNYXIxNjY1ekxPWlZvdEpiNitFNmZVNm5HbGp0Zkk5ZW45U3JyVHl5K3Vycks1TllyaWVDT09UNkV5R1EyM0xhV1ErMDhqVWZwRGV1L3gwYStMV3RhMWxUMzhSbHo3V2RyS1lTMDhQUDhBb1FzbXNPQjhKeVhrT1JqVVgyVHVWdXJBRkZxV1NNbU5pcEZLRnBGSitlcnNiZVROWEhYcFhSZ21iYmk0MTh0bHJkeXY0SFBna2RYTGhqenJ1ZlhYVkhBRTQzdjFJVlhQRjZBTjhHcDY2akVEdGs5V2hDaU1Eb0tnOURWaC9ocUVFdEMzdkExV3d3OXZiUWxteUY5QlBKMndqRkZqbGpKSkpVSDNzb0NxRC9zMWw4ajFXOGtkRHhveDRscnJZOTh2dnJ1NjhndGNTMXZ6a3RGVzV1SjE0aWFPYWNpTU5HdjliUmxDb0IrZnBwOEtTcTdUMUJPUzI3S3ZnSHNqaXZIYzNpMndsbTBjSGxDY2piM0Z2d3VHdnJ3QkZaM2tTZ0RVQjJDbnJ5ZmJReXlYcmFYclg5RUVXcGp0V0ZwYjlXTDU4MXVQR1V6MkF2b3hjU1dHTWp3MWx4TWhVOHBIbUwxa1VNZVJtY3FTT2xQeDBVc0t5UlpkM0lJOHp4N3F2c29GaXd1VXNiR2EwdDhzM1pXVVhEV3lwMnBFWUVIbEUzUGl4VTdBRmR4MDBYWlMrZ05XMEtKMFBmcFk3bTVOcGNOTmpNaTNjS05rT2NjVnphc3UxWkJ0eEpJWTBYVFRDbnF2SWJhbS9CK1o1TGxMczJOdmEzRnNjZ2JlNzdXU3Q3UldNY2hqSEdJOTBBaGk5UUJ3SFFmR21sdDFranZmUW5ISCtOTGIzTVNXOXppYjFaekJOWVhnYVNXTjE0c3NiRmd2YlVnSGw3UzFhYWp1dDhTemJXUEJqZjVIQXNEWWl4eDFuWUFUeC9WU1RLVE1seEc2THo1TUZBL1V2UmFFYmZqb2ZFNWx0bCtSUkNoRE40OUxIRjRQYlN4UVJXS1MzVXg1S3hpaWxKTkJJcTByN2dwNjZGejYzK2gwM3RmcHdOYUtXYTdtSE14WTJMSkpZcWJDUkt2ZFFGYU92NlZGQWE3Y2FVL1BRKzVOdzNxYk95MUtlbEtQSUZXbDlIY1JPTHpsRkdRcXl4a2hGS3g5S0E5YVVwVGJWbGxEQXNPUnBQY05PRHNzQzJHdWI2K0xzazl5WVJMYmxFYUtPQkN6R2pFY2wvVnR2MDFZcVNqUDVmTFdQSW5UVVY4bEhIM0liaXJxeVI4b3R3YUQramxRR285YURWVlgyTk85azBucklBdUFrMGlQTlV5eU9Va1lHbnRwMG9Qa05GNGw5RER6M1Z1dlh4QXNWbEpmM042Ym1aMnRPOHhlMXI3WEFORlRmOUswQXFCMTBadlNYVFV3YlZsdVhwSm5leHJjVzlOZ1NLbGFBQUU5UDREVkJkMkY5NGtrVlFwNWdBRWJkSytsTk9LRGJqN2VsMHF0UVUyVW5ZVjQrdGY1NmR3TlZRTjhZTWpSZVB3bWFLM3lDaDcyWm45aTJ0ZU12RWlsSGZaRjI5ZmxwVmo5ejdEWGJiMnJ1SkhteGdsekJFSS9iaFZZRTNMK3lNY1ZGU2FtZytPaXVQTVNDWk5ydEhnSjF6RkMxWldIQmFoVklwdjhUVFJhQlg1R21PeXVwWmpGYVJOTktCVlJHcFpqWHAwR21iUzFIcW5iUkVxWEM1NjJVM1Z4anJxM1JLRXpkdGxVSDBOYURUSzlYM0pQRmRkVXgyKzMyTnpFV1FqeWswQml4cFZoemYyR1F5Q29aVkk5MzRpbXFNOXF0YmU0WHhNZDFiZkdpT3FQRXpmL0FHZnNickovZDI5bHU3KzdaTWJnSWNjV3ZrczhlR2U0YUJSeGpFWWVRaGlCWDlIWFhOY3UxZVhaWWNXbHV0dTB4b3ZvZEZ4Y1Z1UFI1c3JXM3Q4eUo5NGM3aTduRndlU1pHSjQ4UGMyc0Z4WjIweUJHbkxVa1NOaHVGcWFjdDljNzdiaXZYazN4MWplcmErUjFTeTRWd0xYczVyS2Z4OEY4emtHNWp5V1l2YnU1cnhSdzExTjIzYnRvbGFLQXFFamF0RjE2UlNLVlI1ZGt0YTltMXBKYitMdWJIQS9heVlTQXEyU3lTUXhvaThpMzAwSzdVcU5tTHZ2b0oxMzVxcncxRDFaVTQxdi9Kd0xQMi9RMjJReWx4REYzcnRMVVJKSkdRcFNXUSs0Z3Q2alIzSS9iOHpPd09MU1dmai9BQmxKR3RvTHU1RnpkV1VmT0dTUm1lR0pnU3pBQWZxbGR1ZTUyMjFuMnR0MVFlcXlQLzJyOFd4dVQ4Z2EreU1TeUxidzkyQm5RTzR1TWpNS25jamp4akFST3BvVFRRK1M3MlNnakhWYm9aZUhsc2NGN2N6VEcwZ2x1YktIbWpkdnZTa3FTVVZva1VPQVNvcDcrSitHczdFKy9TUWk2MFVGTy9kbG9oNDFrb3hlWDEzZDNpdmNYMXpkTW90MFh0aTJoalNOMVVpU1VrOXV2dFZkeHJReHB1T2dKa2hHK0hDUzRIR1loOGhlbm5ERkNibUdLRzJZZDUxWnh6blpGQktxdEltVS90N0hjblRQTHVzMGgxUkt1cHJ3dDlrSkxsN3E1YUNLNnMwU2Eyc0d1SklJWTNlSmpKemtLbDVwa281cTFCeUFPdzQ2YklrMEtqYUFONG1EeWRsY01WNHd6QzJpamgvY1UzS3lHUlhrYVNScHBKSnBHUHVMc3ZGZHlQZFFUckswSU5TbWUzcHdmam4wOXpCYUs3cVpJYlNDV0l5U3pGS01yS1paSm5qUjJKWnVWQ1YzRk9XeW1lcEpLTklBR2J0WjVmSzRJSUpUYjNXTXhuY3ZvQ1Y3WTd0eHphSWhlWVFFZEZZdDhOS3I5TGZhUnR2cVFZeFVQMWtVNlhJSzI4U3JjOXBhek1qTkkwdkNxZ0tLb25IWlB6SFRUUXRDVXZVblhNZmVaK0NkNjVkT1NORXJRd3VwVUNzakVGU1AxVTMvQUIzMHpxa3lDc1ZoOTlyZUt6d09EVXhNTHFTNWtlV1prU0txQ0dvQ3FvRlI3dG1xYS9IVnZHLytWNmFRTE9rc0sxMTNma1VyaUhLb3hwVWJDaHJRZTBEMDFwMkFLTU80MjVhRzdlWDJrOFZTaDkxZVpvUFg1NnFhTFU5UnJpL1hLeWtLd2tMRTFxVHhXblUvUDBPcVdHNGs0Qk5yN1llWWVwbXZJeFRZQTBrQkhYOE5TN2cvblBjYTdFaHNIbEN4TEFNQ2FBQTdNQ0JUMTFVOUlDNlU2eUp1Y25rVkxLWWtDUXpxeXlBMDNWYUE2dW90V1U1WG9uNWpkbDVQK2p4cDVWWXdxYWVqZFNTUnF0ZFN4TFJNcmkra0s1WElHdkpWNDE2MDJIejMwUXVnSS8zdGpaOXFMTzV5ZmxGdmJXZCsyT2tNTjR6WGtkTzRpUm9zamNhZ2lwQW9OTm1zcTBiaVN2R3QxbHJCMGw0cjl2OEFHNUdTRzl1THE5dXJ1UzRMWE4zSk5JSGVBaFNLOFpFNGtIWnVLNyttc2JKeWJkRkNOVEh4L21HN3o3YStPU05ZenlDVHZTUXRITkticTVrTVVUdnprRU1mY0o5NFlMVW1sZXZvTlVmNU5waFBxRVBqMWlUUmYrQ1k3RzI0ZTBlYTVmRlcxeGQyRHpYTFhLOXpoSVZZUTBLc0NXMkVoK0ozR25mSmNwUHVRL3gxckhZcW1NeFlxeFZNY1Z5V1dhM1hJNXQyVklaQjlRd1VkcFFnVk9KMlFxb0I5TmFUVXZ3QVVTY2Q1QmhQSTh4YXplUU90NWo4ZThkdTJNdDNSOGlzaUFCM3VRb0JHMjNGRmJrM0ZWcUthaGtyYWxmVDhaSlkyclcxK2h0ejFyOXhQS3ByckxlTytMUzRYRVF3eExMWjVpZHJCTGg0R2VRVE5HcFVjZ1dBUU1lVlJVOWFhV085S2RYdWZrTExXMTlZMi9FR1dYMjIrNkZ5TWJkK1kzdGppY2JkeWR5QXpPOXhMS0s4eFFxbkJPUU5BMGpialV2OHJHNXJSTnRFVng3cUhkd2l4cDdyeXZCK1pNdGhpSHpHT3RJditqdGJQSXdvelhLUnFwazRNd1JvMVhpSy9EZlF0c2RMMGg2ZklKcmt0VyttdnpLMjgxcy9OOHBMRmtXam5zcnUydDQwYTNtbmpsbGtSa1BlYUVLU2lxQy9GVDhQbm9yQnNwcEg1QStaV3RySlFXWnVHRnJnYXh5aVJMUmVVdHd5eUJpTGlTblpwK21NZE9KM3FOYkZYcXpKc3RFTDluZHlqSi9UaUdBTXN6SjNCR29jOGl5OWRTWkJJWkxLUzZlS1JEeFVOQjdhS3RXSUt0US93MUhjaVcxbWk4ZVo3QzlNZ2pZSUZZb0ZGQ1JXbTIzdzB5YWFIZFdobSsxelhtUnQzVzNMeHh4QU1ZYlF4cXhLeTdVRW9hdjZxNnJ6YUluaVVzc2UybG5zY0xsclBJWmE2U3JYS3JZUlBCMnk2bGlsUUl6dFVMME85ZHRWZjNMUkZxaEpxVFhIZjQ2OWpzTGlQUFBOZk5jTDNPOHRxNlFodVViVm9vTlc1cWFrZEs2ZU5XTk14cVFzUGtzamErWTI4ZDNkUnlkMksrdHg5UFp6M0xQYm5nVkg3WUpjdlNvUEgyL3cwemEyTWtsYmVYTkY1ZGY0ZkVpeXZwWmJLOXNsK21XYWZqd3VMZDVPNlRESktQWklwSkhIM0VVcFRwb0w3YXM5TlExM3RWUjBOdDc1dmk4aGhMakRyZFdNZGcwNHVETk1zSGFrL2FFcGhWR05mZXluY2pjOVZHcTdZR25NYWxsY3lhaHNNM1dUaHNzREhmWmllQ3l4azhjVW94dGtpQmVEU0VJcU5VQkdhZ0xCL2o3VjFYOXVlaStaWThqU2xzbGZhbVBFK1NISW0yTGZRWTZXU0d6Rm16ZHFLTjNQSU01SkRNVlBVZzAzcFQwRzVNMGhlSlpqZTRrZUxlVCtOZUQrYWVSK08zMTNZNEdLRHR5MmNrdjdjc2tKakVqSUpKVzZGeSs0V3BOYTZvNU9ESm14MXNrN1B5SlZ5VnBkMGZUdzdGTmY2bE1qNGw1amNZN0QvYmJobXJ1ekJOeEZpby9xRUN1T1E0bUlNRC92Y1BYcnZyUzlycmZGUnZKNlo4ZXBuOHhySzBxNnRlQnpaYytNWjYwa0F1OFZlV2hxUTRrdDVVTkkvd0JSM1VicnJkV1dyNk15M2pzdXFCOHYvVE1SY1VBNUVvWHFsYWo1Nm5Na0dvTTRwSTFibkhNcGMwSTRPQWExK1o2YVF4TlAwTDNLcGNkMW9TQXlpRmxxRFhvZVFQVFNFWnBGWU9XanRsbUZ5UndpanVPSlFjdWhKVStuNGFRaUxjMmR4YXpxbDFISkU2MEJOS2JIWWZsODlJUVk4S3Y1c2Y1ZmliZ3ltS0tTWklPNFJ5QUV2czZIYm9kUXlLYXN0eE9MSTZveTJjd005dFoyZHpjVE5OTUJMZnpJcDR5TGExZzQ4ZGxkUVJVcitlc0owYWNtd3JWYWp1ZldrK0pudXJtVkdueHRyYlkvdDR1VXl5V2tqU3FLc3czOS9JaHYxQSttMjJucldFTmEwaWI5d0o3dkhZaTV6Y1Y3SVpvb1M2M040eVNxNVJQZXl4bFJRdFFoQjFGZmhvckhSV3REUUxrdlpMUmxPK014eFhGbmtMM01YQ3BrNzByYzhqL3pTWkJUZ0ZHNUFxTkU1cXZTRUQ0YkpTMlM0NEpibU8zT0d2SVZnbVM0YVJaa0pEdENxU1VQTGlSVU4xK0c0MVU5UDNJdjNURzFtd3lZVmJhWVhFd0NBUnJJRXJLeUdSZVFWcUFrQ24rR283YmRpVTBTS256a01WcGxKbGhibXZQbU52YnVhMG9mNTYwYXZUVXpYRTZIMWphQzVxMGdUOXcxSExaVjMrUkduYmhEMVVzTVdlSHh4ZFpidTNrZTJOQy9ZbTdiZ0RyeDVodjVqVEswdUNXMGRybndMeDA0MThsWVo2L2doVURoYjNNQ1NGWlQrbEdralplcHJ2dzFGWDFoOVNUeHRLUk51WlpwV2tDelBWMVowUHVqYXY2dHhVOUthbkJXWEI0L2R4WDJBeEdSVkZFc1pMc2FsRlBKQ2tuUWJtcTZydG9XVmZjVjdxN2d4K1RlR0taWXh6NXdvVzRNWW05eUVEYXV4cHFTUkoyVXlFcmVXOHV3NlFqbVNlYmdJcFV4T3BBcjhLTnZzUDhBSFNJR3lLK3RiZCs4aklaQW9ROXNxYXNEVGl5Zy9PaHJxTlhLSjJVTTN6QzF1SnBBb1R1U0FTRmFnTXlzT3Erdi9ucXAzdFY2NmxxcFcvVFFDM1NDR0YzVmU0RlBhQmxxSkdkalNnSUI2VW9OWG9IYWh3RHIyRTJ0OU5hcVVqak5Iamw1RmFSU0RsN1ZibHVhMDI5ZE9NUTU3RXhBdnhDU0ZpUXpFY3lhZ0xRMVBRZFJwQ0l6UUFxVkVUQlZBQi9RRUJJb05xbXBQcnZwQ0lzbHZEMkpLTUIyd0tHb293UFUwM3BwNUdnSHVpdFgza3FLa0FiMFBwMDA0eEhkVlpkd092b2RJUkZsVUE3VXI4K3VrUkk3RHFEME9rSUo0dVdKZzBUSUM0V2pML21VYXF5VmJpQ1ZYQk0ralN3dm9wSVRST1N0UTdVT3E5OHBwbCsxSnlXbmpQcDhsanBjYmNJcGl1WXp6UVZGU1IxcVBYUU50SFBnYXVHSWRlekt1eUdQalNOYlZyWHM1TEhUL1QzMTBxOFllMkQ3V2NpdTdEUjZjNnpvMFpkcXdvaldyRFhpNnY0LzVGQzVBZXd2UjlQT09xTWtuVC9IVk5udXFFMW82MlQ3TWFmRzdlWHhqeWE0eDh5SmNZb3l0SGJWY1ZLeWlxdDhpQWY0NnA1RFdTa3JxRmNQZGl5eDJKdDE0bGVUV09UVzNrN3pkeHJpM1c0Ym5KeTl2SkEzcUtLQ3VxY2VkYmttWGN6aHZhN0p5SnNBdWNYTkhmY1FVN3BWMFd2TU11NVdnRzQrQjFwV3hxeTBNRG9UY3E2WGx5WlllTDNkdlM1UmEwMm9HVWJpamc5ZW1xbFRiOENUY29lZkp2dWxnc2o5dlpmRHJpeFdQdXBEOUpSNi9TeW9RN05RRnVocUZGZWgzMVZYQy91U1gvZFd4cDl5a3pmWUdHNGpkcmRydEJKSDNoTlVCNDFJRC9wSUZTT21qOVdnVWIvSEk3Q1NhNmx1SlZhVzRsTFF5eXd5M1phMGpIRUtZNGlXRkJRQ25RNnB1cFdpSklJelcxMWxwVy83YW5jbTQ1OGx2eWxvak9qS29oZ2prWnBpL05SU3ZIZlZEaGZ1SnFaVUIrenZiN081MjNYelBIUlFaS3hoYTFZM0xpR0tYdkJ1SWNLQVZvUXg1ZkhRaXhWcW5zZWpEYjVua2RkNmlDdmJmSG1UeUVBVzNDQzJqY3pTSGlFTFBIeUhxQUtMVCtvNzc2S3ZiMGVaWGpVWG1ORU5malBqMWxlU1krL3VMUG5adjM4bEpESEtpZzJ0cWVLS3hjR3RYNGdrYis3Mml1MmdlVG1kVlpKNjlQcWEzQzQ2dmVqYTAvZDhrWEI5MkxzNDN3VEZZYU1KQmxja0d2NzZLRlN3V1M2Y2NtRzNMcTRXcEhwK1dzVGllck8ycGFwb2RGeTIxaWZTVyt3cDRQd0hJNWV3U0tlNXVNYllTU0dXZUlFLzlTbkNxc0lXV3ZKUzFGVW5jL0RhdHVibTBwYlJLejdlUStIZzN5VjFiclg5ZmtWZjkwODlkbkdXbmowdDE5VFc2bXVpd3F2R0dJbUdKU3ZRRTdsaDhkYlh0K0ZiM2VJMFMvaXpDOTU1TmxpcmhtZFhiNUxTcFZRRys0cU5iWnljSG9RbnArV2tLQnk4SzhUdXZKaGVOUGRMWlkreWpEU1hNaWxqeWNrS2dBTlRVSzJoTStkWTQwbHMwdUh3cmNqZHJDcjNMMjhIc1ZseXFtSVNXN3BETjlQR0kxSzIvWmlBVm1PNVBFQjNXbjlWTlkrV3pWV2I2clZXWDVDUjVETk11V3NmTHNIQ0lKWXJ5NHRwVW1NaVMzY1lsWlVVN25taUFCVFRjMTMwWGhpSFMzaDlER3l0N2xrcjFuNmtpSExYVUYvZ1ovTmNjdHZqMGFLNnRwN0dNbTRWNUpoSTd6S2hCUU5VVVhqdXZTdXBLbFl0c2N2eklXeVdtdTVRbDRGZitSZVJTWmJ5ekxaNlo1Mlc4blBDalVrN1VJRWNaSmNOdUZVZFJvekZqVktLc2RBREprZHJOczE0MjV4SnZKYmhybDdTTnVQRmdTSkFDQ0dVa0FncFU3MEhLblRWbGszVWpXeTNTUFRSQzB4RU4xbkxLYTZ0NzlIa3cyVWtrZG9JcUFNU0RJU3A1cU9KV2dZQUFpbWhiSnpwcDRodGJKclhYdzhqWDQ3azVNVm0xdUpMMmV5eHlYc2NsdFp3TTRVSzlaS0tJeHNHUHFQNDZsWlNpdGRldmNPK1QzMW5uY25kWk93dTQ1N2VUazkzYlJvUkJ5ZFFpc0Z1Q0c1TndYbjd0OXFhcW90cWdzL2RxTGx1azFvUlpwUE5EZDNFVFFYRmxhY0x3ZG9rRVVMaHVEN0xYZzQ5dXJHMTRFSWN4T3BhVnhLbGhZV3VFTnZKQ2duV1daVm9vN1FqQllMekxFQWxqeStQODlaVjliTm5XY2R2SFJWNkJYeHk4eUU5aEhrV2tlTUc0dVpZWVlEM0J3V1Rpb0MxS2pyN3R2anByS3EwQjdaOGp0dTZFakwybHBlWUtlVEpKeXRwWkdaV3RRSXBoSkk1RlJVRmFVSFRqdlRVVldHb0x2OEFOdmFzWDlTWUh3eVkrVHg1N1cxa3JqNEEzUHV4MGRWbXJ6NWlyZThydHpRN0E2dGU1TXpiT2pqYjJGUEt3NTdGaWMzVm9iakZ0Vm81WVFaWVZqYmRCekZhMEh6MU90YTI3d3cyL0l5VlVQMUlDMmQrbVJraFdGdUhGcTFOSzFGQ2FmdzBTc2V3emxrVm9TWnJ1RVdLQjQzb3duRGJzdEsvUCtCMUlFczU2a1dkamNvNml2dXJVZzBJUUNuWC9EVERFTjRFVkNGV2dYZjIvRWROSWNId3VuOTBoaWxWM2lGZWZiWG1Rd1hjOFJ2NmpVbFZ0TitCUmJKdHQ4UTFQNVJiNFM0ZFpZek5rcGlET2lrRVc4U2o5dUt1OVdGZVRBZXAxTllYWmFkUDFJZmVWYk45L3dCQk52NTJ5a3pTQkNxU3VlY2hwK2tIb1BnVG9pbEhSQWphZHBBdVdUdHpRUUtvNG5jS1B4cHEzRzVSUE1rbW9Iand6R1JtNGU0bFFpY0JRanIxRE1maDAwUG5zb2hNTXcwMnVVTlQzRWwxZHN5UnRQakxMbEZFYUhpODNIaThncitvTFFwL0hReVcxZWJEbGwzMm1ORit2aUc4RHh5V2J4bU9qU2tFbDNhMnlKR0IwTWlnZ0tQOTJ1Mm9QMCtyd0NheGVLcnZDTE8rL01PYzg1dXNiQjR6Rks2d3p6WFYwd1pZK0g3U3JHaExGZmkxUnJCOXB6NDY1c21XN2pkME5yM1hnNTc4ZW1QSFhkci9BQU1mSlBHWnZLckI3cS95bDdiWE9Jc3JjaXhndUlEYklJYmRBWXdBckVkdEVkdDZrME5UWFZGNjE0czN4cFgzMmJianhmeENlSlg3K3pqWlZiRWxwbytyK21wVi9tbmlKeFhqT05PTGU0eUY3bkZTNG5OMWNWUlVCWmtSZVlVS09KVXRRYjYwT0Z6YlpjdGxkSktpN0lBOXg5dHg0c1AvQUJUYTFyUnErd2wydWJ5NytQdmhzbmF4R1N6dTVvckJvQ1AybmpRR2FSalVoZ082bzVhNlNsS3RxMWZBNDdOZTlWOXUzWmpGOXQ4YmFQaXM3TkVGbnZwaDI3SlMzdW1tRWlvS05YYXZJMWF1Mm84bDlGNWtPT3VvL3dBVUUrUHl0NWpUUExickZDcjNQQWs4WVNWQldwQm9ISTRnME83SFdmZHBxVFJvdXhhMzJpeGg4Y2l6T1F1Qzl3MzFjUWpaalJUSENPUUJOQXRWRGluNUQ0NkV6NUZiSFhzRVV4dFhZODVISUxOL2VvNDB1bzI0UTMxMnNTb2tzNlhZYUtOUjNhckdDaURiZ1NvUEluZlFhbEpUSFV0aVpLeis0TnFveGRwWjVISUxkeDVHNnNvYnlhSzNVVzRlR2FzeGpuYm0waFNJQk81dWRoL1RRYU93dHRnMlJhQnhicTNaYkxpc2kydjdjSVFGa1FUM1BOWTRtUEJLS3NKRFBKdVFQWFEvcTNNdlcyTlNMZVlPT0F6eHkyc2x6TVdLbEVLeEJsa0toSXYybGtJNWx5M0VpbytOUGN6ckpLOEJuUm9CWkswanRaTXRCYVF4U1pSclVSd2lRUVhLUXM1V0pFaXFnQXFxYnlTQSsxZHFqWTIxZm1SYTdJZzVEQUNGSTcrR1JobFlMV0NQSHIyeWpTaVZlTEZoK25sSlNvOVFuQVVCNWFxM3QyanRKY3FKVWtBNW0yWEgrYVpDSlVubk1NRm5BdHhFcE1PNkdRLzh0RHlCTkNLOVFLbjI2TFZ2VDh3UjE5WHlDRnZ4bkVlU25qN3drQmVSU29VU2RFWjBhcFZnRElhVkh5K0dsMEZDblUwejIwLzA0V01FMk1xaElJWTJLTEhWZzFVclJRUitqbzIzWGJTYmtpSVArb0o3ZU94OFlnUkQ5U2tkNjAweGJseUNkcEZITGF0S0hSUEVuZFpsUEsvYWluY1V4RVRJVCtvbjUwcFViYU91d09nWnNhRzVJQjQwZUlMVGZjTUJxcGwxZFJvZ2tRUEt6RGtraFlBZkF0Nm5mNCt1cW1FNC9Ec0I0R1ZZWWtKTE85NmxLL2lkL3dDV3BGRFhiekdteW1NZmptUmVXanFYQzBydlUwMy9BSlYxQ05VRnE4S3plcUZUUHVxcmFoZU5UTlUwMm9Rb1BUMDFaUWhraEpESG5HTFdlS0xiTjlPRDEyUHcxWFhxeXl6ZTFTSVYzU1RNWHZ1OXRCMTJKMitBMWV1aUFucmRqMzlsYnNRZWU0K1oxNUlzVjVVQ2dyK3ovRDRkZFF6NjQ3RDRYT1JmRTYzOFRtaWdpaEp0WkRib0N3RVlYc2dOS1ZLMGpwMUN1UGFmaHJuYnZYNEc5U3VtZzFYOHl4U1JnekZWeUR2R2toVldxd0twR2xWb0VTbnVDN2tjZFJzdFN4TFRRQTNVVTE1WVhsemZKRXNadFo3Wnk3Ymd4d3FPaFk4MjQvbzNYL3hIYlRzbjVoRUxhMTVISzNtbVJ6VUdKdExRMzdTWGwvOEFUZlNJNVJ5MFRSOEFKSklaR0JDajJweUZmOXZUNHFhdG5MNWNqYVNIR1MzeHYyNHQ4SjVMNDNkVzF4NWY1R3QxYTQrNXlFQ0NmR0NKMFJXaWxZTW9YdHRSWldKWlc1Q3UyMUMzWkxOV1hwcitaWmFLSk5kV01PSThuKzNCd0Y4TTNtTEJjcEQyck81eXVTcmN5M2dpN2ozTThVeFJFbExPRmppWmZjRXFhc2Fhcnk0c2xtb1RqdzZRU3gzcWsyM3I0K0pDeFdkejFqRGdwL0o0N3kwKzNtVWphRzJ2cnljeDJ0dlpKTUhvWXl5c3p5SlFEdTBvdkVqcnAzU2xtOXY3dngzSnExcXhQN1JndWI5OHhlVDN1SGhReTNTOWlOd2drVmJkK0xLdGZjb0RCdGlXcHRRblYxS2JWNmltMTl6MEVEeU9lZkQzQmd4MTViNDdMV1ZqRkZJTWtwWmFOS2VYSGhVRW5kb3dCUXFOV3Bwdm9WTk5McVVGbjJsL3NtSEZ4Yy9VdERKZXhSeGNCR2tjYXpWOXBGQ3dZMWJmcHJRWFVCZlFXb3JpT1BLeXI5T3ZkNzZ1WDVNUDZ3ZWxhZXVuWXlIR3piakhicEZHb2tLdUdhclYyQkJGQ2FlbXFaaHN2MTJvaDNiTC93QmNnaFVqdGxuV3JiaFNOdGp0V3ZwcWRIb1F2MUpuMndZM00xeWtFajJNU3F3azdkWERJNVhrR0xNT2dGZHQ5TmxhMmthS1dXeGhzQmsxbXlGbmIvU0dOSkNJM2xzbGtOSkkwa3FqR1RraG9mWDIwcnZvVzJSYU9BeW1ONnFUNjFrbml3VnNKTWhhUjNpbTNsN0NXNHJ6Z2RLYzJTY1ZDZ0U3cnZwNTlYUVVlbnFmWWJONTlQdWw0elp5NWEybkZ2bFZ0b3JpT1I2OXU1aFpHTkF6Y2VsTnZVRFVNeW5EZUZyQkxDMnN0VzNwSjFwbWZIZkYvTGZFcDRJYjZPNXlPRmltbHVPVVRyQklKeFU4MGxYaEl4SS9VTjFydHJtZUxYUGpvbmJxL1BzYkdhMUw1TkZGZXdyVzl2NE5qL0hMR2ZFWUhIcm1MaTNqbnM3SzZ0b28rNFl5R3VaVmtFYnNBbSs3KzJpNkptOXI2eTE4Um50cWxDU2Z3RkUzZmoxdDVEYTM5NU5qL0lidGJXV2E5dlJhSlp3UlBJNnZHd1o0MC9VQzZJUXBiaUFhYUt0T3ovYnIwa3FxMXU4Zk9BOTluYzNZRyt5MWxlWkZKL3FwSTVvN2lhSkxORklMaWlWSVZnRkhVanB2cW5sVmJqYXZvU3czMGU1a1A3cCtQWS9KNVM3eWZkZ3U3MlhGQzVnbFY0M1JVdHBXUlRFeEpyN2l4TEx1d3FTZHRQaXZlaVNhaFRxVHRYSGR0dnJHaEF0TWJoTWZpc1RkSml1VnRrYk5RTWhZeVhGc3l6R1JWbFl5SVZkQ2pLeFJoNmJldGRXN3ZVL0ZGVzNUeVlPdFI0elllVVhWemozbG10cmkxRUtDNFlYY1gvVGtjNVdGMTNPVEhtclNjUUNlT3JtblpLZXhUTlUzQldYK29EQVltNjhJL3VGbHhrdk1UTEJLc3F4eFc5SVp6MjNVcERHbTlXVmdHL3BGZlhSZkViVm9ZTHlrblZOSEt1dFF5eVZiV3N0d2FvM0ZPbFNhYVp0SkNEZHZoUks4YUpWOXdDZVJDdFUvUHBxdDVJSlZySmUzMjd3SGgyTEQvd0RkSXM3dVc1Um9RTG1UbkpFUUFGS0VzUUFLK3EwMjZqUWw3V3RxbTlBNmxhMTdJc20yOFk4QmtFVjFIak1MMmkwY1lQN0xBeUtSeEtqdVVVa2VnUHowRmZrV3EydlVGMXdWYWxOQTd5S3h3VVdVam1YKzJwa1k3ZFZ0akswY2RxVmlrWW1pQmdpdnhYNWN2NDZzeFpIWmRJUkhKU3RYbzlTVjQzZFlJTG41WWNmWXBIWTJjc0MzbkZUSHpZUmMrTVpCNU1hOFZCTktra0hWN1NsRkNiaHNySDdsdmo1L0hSWjRhelcweU9XdklyZTZtclFtQ1Z5NVdPTmlBcTFqV29UcWZ4MFhqcXVzZ2wyMmlTLzIvd0FueW55T1ZsOXpTVzhQWXRVK25FYzBhRkVia3habDZlamZqcHJUR2d5cVpaUDdlWDl4WVF0YUJiU2V4YU9XYWJhVmFQRDJwRkFKcDdoeHB2b2ZkRGNoVzJVbzBOTS8yK2E0bU10SGE0bWhNdVFGdXJSeG4zQTFWVlB0b2ZRR20rbHZnaXFKOXdKZCtBWTA0NjRrZTJhVzdpbGVLUm5QSWhuVldWNm1yRWpsK2VuV1d3enhWMnlJMXpoWk1CS1ljMU1MU0tPbmJ1TzIwaXNXQUlGRitXKytpNjNWdWdJMUJyZ2x0Skx5T1BINU8ydTVwU0ZSSkk1WXlTZlQzSlQrZXBqOVJqdnZJTXRoTWJEYjNrUVhIdkxTa1NwS2pPTjZrY1VJTyt4T29RcDh5VzV4QU9zYmJGWnZPMnNjc3M4RHlPV01MUm1MdUtkeXFGaFEwL2o4TlBhWTBJcUMyc1o0amMrT1cvY3d1UUQ0SzQ5eVdkMm9aMExNR29qclFnMUhyMTFYVnl0U3lQQXJEN3VZbWMybU15NzI0Z2xJN1UwYTBvdktwV2xQVGJiVmxSckxTU0Y5dXkwSWRXbE5HWmU2WFk4RlViaitZR3BNaFUrdmJPS3k4N2U2aEpTQy9UdnhrRUVWbVU4cVY2ME9tMWFIN216N2kybHliS3l5OFRzczF2TTFzcks5WFdKd0dTcEh6QjA2R3NtRVBIWjdxYkJSUGVUTlBOeUJMeSs0SWVWT1IvQUVham9XT3JYVXh5TjlhSmtmbzVaS1hSVVRDcUYwa1ZxOUR1YUJ0L2pwRVdaVzBnZU40NUk0bjdnMmtWcWt2R0NUN1gzL0FKNlF3SGZ5SHg4aGtaR2psRFVLTkY2Zzc5TlBER2xHWlZKR2piaXd0cnVObG95RUdqYkQ4QlhVVTVIYUkyTXc4WDlwdXVBLzZvTVJYMS9hM3ArZW9XdEZrUFZUVmdocXNqQWhxQTFKNDBwK2Y1NnZJQXlRa1h2YWZjRURqcEVUMlNEaWZ3M0FPa0kxUnkvVFhFY28vcEk1QWY1VHNkSVExeUFUV3lzdnUyRkdyNmRkQldoVzBDcWExZ1o4TmRsWTRaRVlySkZ4NUFkR1RjNy9BUGpxcG9MbzRDbmtQaTk5UEkrUXhzMEVVV1dzMGp1dWE5d01yVkt1T1BSZ0txMjNwcHE1RW9xK3hmZkM4ajNWZlhxSTgxOWIyMXY5SEhCSzlyajNGcTJRWVVVeUNuVWRSdjAxZnRiYytQWUYrOHExMlJvdEpIdUdtVnM3VzlQTHZTeHJHekx0MjU0aUtFbjRIUXJVT0F1ajlNbGdwY08vaThzbHFzUzVBeHRCQ1pXVnVNeDlwQlBRSHJRbldidC81RjRHMWJLcmNacUZKejltUElMNnd1N3ExZXhqc2drcGVPT1htektlbFFTUnZUWFExcW11cHhsbnFMMzkxdk1oY1EyMzFQSHVsWWdGL2FqRlRRVnBUYmZWcXFraUhVbFhIaXVlak1rVU1YMUhiRlNzWjVNUUJVMEErRk45Vi9kcTlTYXBib2hla1daZG5CRk50V3FDREhuN1grUlpIRTViNk95dW50MmxkWmtLKzVlVWU1cXAyTmZYNWFIejFsU1dZM3JCWXNXUms4aGU4VEo1V0JjaEM3WEpkNGx0cHJTNVIrb21RMHF1M0hqMUkzWGV1ZzcrbUlRVmoxYmszK1R0bDhyYXg1Qy9LMjg2RmVPV2NtT2VWRWpCYU9SQWFNc2hXb2tKVC9oMVhqeHFqMCtoTEprZVJKUHF1NHNaRHdMSjR1MmtpZStobndBa0pidVRpTUxMSkV2YjVCVk1wNjBZVStXbnJ5YTJmVDFGNzR6U2laUSsvWXZEM2VadlJaM0JpbnM3T0VNdDRCSklqcUhMOEtQeEFhT3ZyL3U3YXp2ZElWWjZlUnVleTVkdCtpZW5VYXZMQmNaLzdoeVFUMjZ6MlNKRmF4VEJpeDdibms0S3FWYjl0RlpoUnE4aVB3MWxjZHF1R1poL2o5VGN5MHQ5NUtOSS9YeCtBUnR2SjdYSlpxK3VXaGFMSDQySjNsa2NDVVBERlZWVGlhMDNiOVhYUWp3T3RGckxzYWxjNnMzV1AyOXprTHl6S0hMNSs4dWtvTGRITVZ1cTdLSTR5UUtmaWFuODllZ2NiSDl2R2wzUEt1ZG0rN250WmRPM3dCQ0p5SFRmVjRFbUY4YmltbmJtNG9nRlRVMEIxVGE4RjlNYzlTNWZFY1RZMmZqYWk0Y1JtOUU5eGRjQVhLVzBYR05DVnIxTE1XRmZ5MWs1OGplVFQ4TTZuaTQ2MDQrdjkwL1RzUFdGdGZwN0NJWGJNczE2SUdzNDIyWTI3bVFCZ1c2QThTSEpyNlUwUGRsZGVtcFdFZmptYnp4OGl1TVRlTC9iOFhmekxIYXpobGtsZzVNemRpbzJKS24wcXBwVTlOYUgzYVUyN2xyWmZpVEhXTytSMjI5RS93QVFTZkpmS3IzSTRuRTJjV0V1c2RnTzRJcmVSaUxhQTltTW1NR1ZpU1R3a1pqeUlQVFQ0c1NyZHVVMk5seTdxcUUwaXJjL05iUXZaejJjUlJaNGpJNExCcWtPVjZqMTIzMW9VMVdwbjNqc0RJYnUzTEtIckd0Ulhhb3A2NnRLaXhQdUI1ZGhQSWhqYmJ4L2xKWVdTU1NPcktVWlhQQ0pGb2V2R0tLT3ROVTBxMDIyV1d0S2hFUEEvY2Z5L3dBZDRKYVR4WFZrSE1odE1oYnhYVVJZclNwWmxMaW5wUmhxTjhOTHZ6SjB6M3IwWWY4QUU3SnZLMXpHU3ZwN0tDMGhOdUpaN3lKNDBpdWJ1VmxTS05JS0kzOVRWazlvVWROVVptc2NKVExMOEZYazNOeG9FOEZKZTQvTjNjK1R1bHUwczJrbDUyZ2RtZjZaeW9YaVBpMUsrbE50VlpJZGRPNFRnVDN5K3cwWnJOWEdjaGp1SmVVWUNpT0ZYVHRzV25JUExoVnFiTFVmejBCc1ZiUjFPa2VaM3d6YjB2c1dqNC9qNDdYRjI5a1VNUmpSWG1jQ2hkSS9jZU5hY2VUSGYveDFVM0xrQmFqUUM1eDFiRzJNZHY4QTh3Tzh6bDI0aml5a1VyK2ErbXBWSXdMMW9iYkc0ZTR0YlV0R1pKZ0hSVzlISkErRlJRSFZqY2c5WW5ROHRWT0l4MTEyR01NckVSc0FhaDVPUE52MWVudTFGMmxseVVJV0wrUzNpeThnaWppVmhEeUxSb3FOVTAzSVZRSytuOGRGWTVkWllOZTBXaEN0NVhjZlM0ODNFVEZtamFvWDRsdUlDL2hvckVwc0NjaTJqY2lQRjVMZnd6U09aYThtSUtTQ29vUGdSdU9takxZYTJNNVpyTHVGOGZucGJ1SW8wRWpsbUFWbzZFRWs3QW5hblRROThNZEdYVXo2eTBGamNSWURIM3VVcFM1SUVWdU9wTXordTM1ay9ob2FsWGR3Vy9jU20zMEVPSU5NV2FRTzhqRXN6YjFZdHVUMTlkYWtRQUJRbDF0TzZFS01GTEFVL1VSdDAvTFZhZXZVbEF1UTNRaXVvNWJoTzZzUkpDblpxazE5ZFdOU2hpeHNiZEI3SHMyYjB1YjFtRGNUUXhwVWNtUEhvVkhUNTAwSHRhY1c2QnRjbTZzTHFNc0V5d1czMDYxU0JGQ0lCMEFYb05WWk5iTU54MmRGSFlsR0N5TVUwdVJ5RDR1QllMaWNYMGNxMjhxdkRBMGtZUjIvOXhuQ292cnZ0cU5iTmRGSVRrVld0WHRUN2xsK0ZlZitCWXZ3Yng2d3ZjOGo1Y1dpUGtWSDFWMWNHNGxKZVhreVJTVlptYmVyN2RQVFdIei9BRzNrWnM3ZEY2ZTNZM1BiUGR1UGc0OVZlM3E3OTNJOCtINWJGZVEyR1ZueDFpMlN0MlFLMDk5RExaMlpVdHhhTVNzc2pGZ3A1RlZqcVJyRzUzQXRocXZ1VzIvK3IxTlZlNjE1VFgyVTVyMzdmNmlCOTNibXp0bEFGVStuaWppdFlJd0VVUk9HY0hiMEFLY1JYOGRUOW5yWjllL2NmM0cxVngxWitmMUtPeWQ1TmFlSzQ3RS9TbFk3eDU4alBkaW9OWlplM3dCUFdxeFY2NjczRFdYUGhvZWFjaHY2Nmp0NExaV1dNOFh0Yjl1TnU4c2p6Y25yV1JwVzdVU05VMDRIOVZQVTc2SDVGNXZ0Q09OaTlHN3RJN3dSUjRtN3VvOGplbTZjdmJWN2haWEVaWUdNRnRxZjhxdE5CMmJ0WFJCU2hQVXNuN2VlVFQybUx0TUZCYnZmK1ZUU1Q1Qyt0WVhSRXRMYVgySkpKS3lsUVNHcXExSjlkdEQ4aXRXazI0U1g1bDJLelVwYXRrM00zUG5kL2tibTZ4ZUhhemxob2tzalg5dXF5aHlhSXBBWXNTQWFtbGFWNmVsT0sySlU2ejhpZDY1SFk1bzhzKzd2bU9HeUxlT1pMSHdYSzJNcXlRUXhLT0tHQm03YWt4OFF3QUpydDd2WFd4Z3g0NzFWa1plYTk2VzJzZ3IvQUtqUE5iVnhMRmowV1JJbWhpSGJDb2tjbFMvRlJzQzFkelRwcTMvR3hsVDVGekJmOVMvbk1NY2R2RGJLaVF0emkzYXF0UUFldTRGTnY1NmcrRGlibG9tdVprUkFUNysrUnBFMEg5cWhaVEtzNVlCNG5NcTEzTFJrVTZucHF6L0ZvVnJrM1J1c3Z2NW5MSDk2SEJSUGRzN1NOTk04MHJjbUZBUVdiK25xbzZBNzZaOFRHMlMveXJ4QnF1dnZia2J5NG5udXNFWEYwVU54RjNaaEc0alFSaENLMUswRysrK25YSHFpUDNyVEp0YjcyWGt3VVRZR1FoYWdFU3YwSUFBQTQwb0tDbTJuK3hRWDNyREI0ejl4TW41VGNTaXh4LzAwTURVdW5lNDR5YzJCSTRoaUFTVDFKNmFqYkZXcWtldVIyY0FmNzI1TzZ1c2hpN2E3dHZwNUxleWtLaFhXU01ySXdBb3lrMUk0NzErV2xncWszQStlN2FVaURqU2V5YUExSk80OU56cTZ4WFhvRnNlNU40cFgybnV4L3dBUWZVZkhWYkxFOVJqdG1TV09SaTRBQmNqYnFldnlIOE5WTUlwZU5KQk1NeE1Ob0IxZTZCNStnMmNqL0RVMHVwVE13Tm1OSlh4cklPS0U5MWFzcEcvRmR4di9BT0dxWDFEY1V3eEx6ZHdrMzB3TG5ta2pBZ2locWR5VDZhdXFvQnNsMDRHZktYQ1J4WXBaZmRTMmpyVG9BYWdhZ2k1MmhLUkZ1YXRsYnhrSnJXbzJvU28rUDVhdlhRRWFtN0c3N1YzTnRCNU5GY1hGd3R0RWx2ZS92U0hpaXNZcUxVa2JlNGpVTTM3SDhoc1RpeU9uUEZ2T3ZHTEdDSzR0Wm5KaVVLR3RyUzRhTVNTTXA0cXBVa2xsNUduTGJyNjZ3Y3VISTM0Zk0zTWVhaVhpT04zNTFoVGYyWDFFeUpDa1l1Z1piVzRrdU9FZEdVeEQ2ZmlEdFZxallVL09DNDFtdjZsajVGWlBzajV0NGRKNG5jdC9lRTdLeFRRR0pvSldBWmhYanlhTXJ2N2ErN3Jxbi9GeTFjRm4rVmpjczU2dExxM3ltSzhUeFdHdElKc21sN2NaQzdzQXBTWmJTMWlqWWlWR1pBUkxNM0dwYitrNjNuNlcyM3AvRXdLK3FFaHR6Vi85cWJYeFIzODdqVEwrVzNVaFdhenhkbERiV2NDU01vUzFTVUJlTkc5N2tOSXhyN3ZocXBZOGxyZWw3VVcvY29sNmxJeGVKZUZmWUdYRlcvazJLOFVFanlzcVc5eG1Xa2VCWlIrdGtpQkpZSzlFUS8xR21nT1JseVZ2c2QzOGd6RGlwZGJxMVNIcnpTTHh5NDhTL3dDOGN0SEpkdzRoVmU4eDk0bmJzRWhhUWNvVVU4RkRNT0pKTlhiUVdETGI3djI2OUdFWkt3bmE1WGVPcy90N00yZnp0bmhiVzV4Y1VsdStQaXN4ZDI5dkE5ekd5aXF3emUwaHFGVnBWdDliSC9Jbldzc3ptcWJYYUJjOHF2OEFIWS9FWGtGdDR0SExBOXRIQ3EzRnU5bEhOZVNxcmdHUjNrWnlVQjQwYW9vQU5GVXhyZDExS2JYZTJFdERtRFBSengyQzNrOFhadDF2Ym0yaWhpZGlxTnM3RDNWcUJ5QXIxK090TlJKbU1YSjVyUmJ4cG5XUVNsVWNjV1hqWGlwM3FOTzBNaG10OGtFa2pDeHQzQkk1NDFBSHZKMjZWOWRSMmF5UzN1SVBoZXBJWkZFVENXYU5rWWxoeHA3U2FiVjlQanBsV0IzYVRkOXVib3haV1N6c3dzYlQ4a2trdVdMS29aR0JJNEJUVWVtL1hTdiszVVZPcGF3dC9JbzhqUGl6bmtZVnRsZHJkR2pNck12YlNoVmd4SVZhKzNadmlORGVtSmd2YnNtMUpEanhKeDlqZVhEMjJPdVorVjNiekM3V1F6aVJTNFdUa3pFS1JUMjBhaHJ2WFUyMDJ1cEZOcEdyeUM2eWNIMG1Uc3NaallNWmJUV2M0dXJXTjRROGhrQXBHd0FlaTg2U2U0ZkxUVnJXV3U0OTNacFBzZEMrTVMrTitUNEMraW53bHpMYjJFMExYOGR0YzNoczdyczBBU1ZTNmlwUnEwYjAxazU2MnE5TFJKcVk3S3kxUVN6OFhpYzhZRTloSmNpTzNqbmUyZ21uc0xTUVZIYjV4Tkl5cXFLUDZxMStHK3E2WTcxZWpMclhwM1VqcGhibklYTmtGdHl5UHdaSGpYdHEwUUpWbE84WjJSV0tyOGVtK3N2TFpxeldoczQ4ZEhSTmtXK3gyRXljS1dPV3NiYktXeUk4UitzaWp2R1ZrQUZUSXlWRGN2MVVaZlhWWDNyOVU0L0lzL3hhTmFvclA3aStNUVl6STQrNDhXaHQ4UjM0ekRraGJSQktXSmZ0MVNKUW9aME5hcTN4Tyt0amlaWGROVzE4UGlZM013cWptbW5aa25HWVhqUGI0SEdlWFQyY2Rxc3J6TEpZck5pYldSbnF5bVF5S3p0c3ZKeDdPUm90ZXVwM3ZHdTFOL0hVb29tOUUzQ0JkajRuY0M5dkpmS2NoTmNTWWlWSkxHTEJRV3VOQkZ4R1g3NlQ4WDVLeTFTT01BOG01VnBUZXhaZHk5S2lmSFVwZU4xZXZZUy9NTUhkK1IrTCtSWTYwR2R0TE93dDJtbWx2WmtGbVNxcTBjTEs5dkZJOGpGUUdESGFsUWRGWTI2MlhSZzJYMVZmVTVDMXFtYUc4TEMwMFpwMFY2ZjdkVlhIUlkzaTJMaWxaUkxibTU0a3MwUzlXUmV2NTZIdElYU0lMMDhaVzF0WHN6aWNUSEVqUmlia3NIN3dHNHJRS3pPcEhyNmFwMmFhbDI3WFFjSWJtN0RXNjNzYW0wdHlMNTdHNWlRUWxWRlZkb3dyY2dTTmcxVDYrbXE3WTZ3NDZsdGJPUXRrYmZsZUMxd21LeGNNOTdHRWx1eERHQ2s2cTNiS2NZUjNYTEszdUE0Z2FDeFpwMGZWQm1URkhxWFJpcGVYRTE5UGM0ZTl1NDdiSFJzeG5ndElYRjY4OGNnaWRlVWdaVlZXSTVPWTZNb0ZDT3V0RkpkUUJ0OUdKdWE4UThkOGl4OTVhUlptOEdRU1dOQVo0NFNnNzRscWdWRlhjbEI3MUkzK0ZkVzFzNmxONjFhRUR6RHlUeVQ3WVpoUENySjdlNnhrMXJiMzFuT1ZrYXNjZ1lrMVoySlBMa0NhL3dBTkVwYmxxRE8yMTZBbGZ1eDViYjJ3Vm9yZVJKT2Naa1pXL3FQS2xPVktiMTB6eFZIV1d5UTBlQitlZWQrUVoyM3hsdWxtUktTdHpMTXJFQ0pBS2crOEE3SUIxMVRrVlVXMGRucDBHL01XZHpkVEs0dklvMHVIaERkcUhqSTNFa01RR1pnQ0srbXFKN2hGdWd2ZmRMeGw3anhiSUwzWW1tdDFKUThBV0pzNkhZajFaZlhVOEg3aWpOVkphSE0xdE8xdGNSWEM5WW5WeC82VFhXZ0JsKzUveDlNaDRCZVhOc0E4cUlsM0cxQ1R3SzFxS2ZpTlZycVd0YUNKZStTLzNUQVk2QzF4a2xsMnA0SlpzdzRQWmllTTBMTHhESHFOUEdwR1MzN2U3dWNqYVJUVzErc01Wdjc0MXZJdzhjaEZHOWhpS01DYS9NZEthcGFWVXk1UzJDdk8wdWN6aHIzSDMwUml2NDRrbXQxQVl4bGxBZWk4Z09KR2xpaUpRN2ZWRlplS3pyRzNhbldpUFNwQjNJNjlORU1IUWQ4d1NCRXhPVGdRTDlQSVlxZEFWWThsTy9wWGJVVVdSM0NPVnRGeUhqdDFiaU1BeVJsNFpGSS81aWptbFI2SGFtMm1WaDcxY3dBZkZaV254RXljaUdSMU5UMG9kajA2ZkhUclJqcHpWcndNYzdEOUxQWjVKQlFXMHBpTDcxN2N3cU54OERweXBvbGlXNVF4VE5TU1ZWMmpRQXJ0OFdQVFkxMGh3S3VDZ2J5T1VJeXZESVJNaE85ZVhXbngzMDQwYWpSNUhhQ08xdDNWakFrTkVrZE9vcDBHKzJoc0tpVUdjaExTQUZqcnJzM3pLbE96ZGdTUjBwUU1QYTM1NnZhbEExSEFLdmJONDd1ZUpVWXdxM1BseTlpcTNyVDQ2ZGRDdGk5a0lnanhUS2QxTkNQaDhOU0dKTWhEUkxLQ2FIY244T3VrTUQ1cU0yMU4raE8ya0lZc0hjQ2ExUkhOVEVUR2QvUTlOVVpLK1JiamNNWWNUTVZMd01DcnBzQ2V2QTdqOHRETU1vK3c4WU81a2xpYTE3elVGV0EySHRiMG9hZENmVFF1VmR6UzR6N0NIbjhaZU5uYnJFWXdKRGI1ZUFTeVJ6MVpXbWlGSEtVNkVrY3RHNDdwMFZuL0FHZ0dmSGI3anJYKzQ4d1V0eGYyZHRiU1NNaXU1dExxRXUwYUdSVFRjcWZXZzAxMXRzeUszV3grYTBDOTNqc3JiMmw3WlJ5Skd5c1hGb3JFcldOaFN1MUNBU09YSWFyVFVwbEwzNm8wNXJHNURJV0Z2UGV3UnNzNnNzaVZlVHN0RFRZY1JVOGEwNG45STFKV1ZYb3l2YTdJcm5LWTFjZGU5dEk1SXdvQkFsQTViN2hoU28wWGp0dVVsTnF0T0dPc045ZTNjTm5rOEh5aHlsbXFOTE5IeW9IL0FFdFUwNGdFQUhqNmpiUTJ4S1Zib1hTOUd1d3Y1ekZTeVNHVlVqRFNNS0xDTmllamJWUHI2YXN4MlMwR3lKdHo0Z1d5dUpNSms3WEpwR3NodFpRN1JPS3F3QjNVZy9FYmFJYWxGSzBaME5jZVJoYlhIL1FXZHJINC9sK3prb3BMaFlwVWFWS0dXM2RXcHhxVkZKRFRXZlJKYVc2aGRyK0FMeU9ZdnZJYzVrRndlTHZvY1hKYmhJN0cyNHhkNlp0NUpTZUpkNDE2ZXphbTQxRnBWV28xWE5rWTRQS3oyOE1PUHVvMmE2dWU0SlpJbnF4WkdKWlFRS2NSVm1QNnE3N2I2Q3lVWFhzall3V3M5TzdMWSszdGhhWVA3Y0hPeHM2eTVpelpZK2JnVkVqU0hrRlU3RUtGQUFxZUlIcnJFNStTMXN1enNtZEw3Wng2MXhxL2V5Sy9paHU4djVDOTdjU0c2ZzdqQ1pRcEVOb1kwU0tMaUVGSFpTUlhsVDNhTG10TVVkUDQrUHdIMjJ5Y2pYMUtlbmFzZnI4eUI1N3o4VHhHVXVXdWpIa3J1THNTV1FkZ1loeVZZMUtDcU51dTU2N05xM2lKWmIxVWFMdURjN0o5ckZlKzdWNlFjOUpFVzM2L0VuWFZNNEtHRXJLeU1yZ2tIZ2RWMnRCZFNramJqTVRMT2JlM2dUazg4c2NNWVBRczVBRmRCM3YxWnBZc1RiU1hpV1psTFJKcHJxRzFVakdTcEhqN1VxU0VrRnFZK1JZNzFZbm9QWFdkanQwYjY5VFo1YVV0TDlzUXZrTnVjUjhWQ25LV080c2NKYXgzdDRxMEw4bzAyQk81Q0taUDhQanFxajNQemVnTms5Tlo3SkZUK04rUWR6eCs3bGFPOHZudjdtRVhkcUFvaWNJWkpuY1NVcUdqQ2lnK0ZhOWE2MDh1TDFMdENNbkZtaXI2dVdOSG0zbXVGOGtrYkNZSEhySjQzSThFc1ZoZWNvMmh2WmYxeXJTZ0FDaWhCSjYxME54dVBiRzkxbjZ0ZGZMd0NlUm5wZGJhcjArSG1VTDVQZGZWWnU2SzhPekMzWWdXSlNrYXh4ZTBCVk80SDQ2MjZLS294THVXRFlJK2JiOVA4VDhOV0VDV01mTEl3RVFJYjVkZjVhanVxUHRaWW5qL0FJVGk0OFkxeG43cVNLN25VUGFPOGdTMFJHcDducFZ5YVYvU1Bsb1hMbGFmcENhWVZFMkdid2k0dnZGcklpSEhRNUt5YTQrcGEzZWVJbDUwanJBem8zQXFzWjNJNittcU1zWGZXQWpFL3RxSW5VTWVQT1o3UzdoaHVaZXhjWEphNVdSREZOelpoSjBvclVyeXJ1ZERadElOWGdWZHBYWUc1NjBrdnNmL0FHbTA1b1dtckJLcElZRTdMUWltbzRuRDNGbktxMnRubm9XL2tiU0h3bjdXWHQvYzMxMy9BSERINDFoOVM4N2xwYmwxQVhtc25NZnJZRDAxWFIvY3ZIaXlqTFg3ZU9aY3BITmR2OTJQSzE0TGVYNlhxUkx4UmJoRko5T3BYaWZUMTFyVzRsR1pOZWRrWG1NRnQ5NFlKMXR4ZjJLSzBkUzhzTEtTN1UvVVE5UDhkVVc0YjhTN0h6RXVxSFRCZVUySGtNUDFkczdpTkpHTTMxQTRBeU1PUktzYWl2eG9kWitYRGFqaG1qaHkxdXBRQXY3aFh2N3VlS2trTmUyemNxaHY2alEvbm95aWlxUUc3TGRJbWVaM1JOdloyeXlCSEI3dXhJckh1MzVucHRvcmpyMVNCOGw2UUpTd3U1MmFxMEpOYUhyL0FQTFJzZ01EVDQ3YVR5dC96RlZQY2RodU9JQUg4em9mTjBMS3lZZWFYNWU5c3NVaEZMWk83T0JzTzdKMC9nUDhkUndZOXVvemZZZ1dVVnc3TFNJTlFnMTVFZkt2VFZtVnBMVmpCbVNOa01NVXdBNElHOWhxQUtra210TkNhYXV2d0xLektCOHR2ajcrWTdSczRhbXhBYXZ6cDExSk85RUVwWTdEZloya05vQkJFa2EwUWNuWFlzQ05nZmp0cUUydHIxQ0ZWSW5CRktHSkdvV0lWUnZzSzEyMVhKTktYQUw4NG5hSHh1U0toYm02UWc3SDlSK2RlbzFmeC8zRWViNmFLcHBzU2JYSFc0QTRBSW9JRy9wLzVhT01nNjArME5zMXA5dWNVRVVQUEozYjVsVWl0U3p1UzFUV2dVTDZhOC8vQU93WG5KYndTTys5bVNyeDEvNVAvUXBUN2ozcHlOemZ5WGx3b3RvMTdrbHc5WFgzVVVDcHBTZ0ExZjdUVGJSUjFacCs5dmJHUHBXdFJNKzRidzJscmdjWGEwYTBTeEZ3azdNQUhOejFvcHAwSEduNDY2M2lTNWI2eWVlY3hxVWwwZ2MvQzhPc0dDeGVSdUdyYjJnN3NjRXgvYlprYjJpakFGcWc4VkZhQUg0NnF5dEs3OFN6RkxvbDJHUzd3VFpUdDVESVNsYldXWVhNVnBzQTBVQVdPUGt3citnRXVLaityUXk5Q2d0bmN5M2ZDWnJHM2t2amJCMXVaNndXcGFOUVptUVZWZUpZSFlFQ25YYjAxbGN6YzY2R3B4SW5VT1pLMW1sbXNJQnhlUmJ1Um1WUlJWQVFyNzR3UWZiUUFWSHVQNTZ6S1FnKzh6SzFPUHZOK00rY3lNazBYYzdsNkkyQkNsK1JuQUtramJvS2ZEVzl3MjlxQXVaVlIyYTBKZmpIMjV6dm5VRDNIanZqY1Z6QUhlSXN6cEdyTkZRTlFsYWRUVFdtc0dUckxNcTJmSE1iRVM3Ny9UbDkxMVF0RDRFMDBZMjUyOHNNMjN4QVVjai9BQTFMMVY2ejlDcUsyNkpMNWlzUHRWNVF1Tk9SUGo5dEhaeHpOYnlOTGNJa2d1RWZnMFpqWlEvSU1LY2VPazhrT05mb1V1T2tJWUUrelhsZHRGTGNUNG5GQllFZVI0dnJyZG1QYVFzUlFVSU5Cc05SdTJxenFXNDdWYmlFTHFlTFpseUZYeHVQbDhwa1lWK1lDYXBXZXJYVi9SaGI0OXZDdi81SWc1TEJYMEdRRmxsTWZEWU1RSENmcjlsSzFGRkJGUG1OV1V1b2xObEdTajNRNCtRK2VEWXkwZTV1Ym1CRkZ0TlB6UEVBS0U0ajg5cTZIZG02d3d0NDBycDFGYjc1TmJmOXcyRnZiQXJERGo0eFFncVNYbGJlaDM5QjEwUnhFNGZ4QU9XOVVJbU9ZbUpWQTJwVTAycm9xd1BVSzQ0cVpneTlPOXNLMC9TSzZneWFJdHhrTG42bU43UzBFMXRiZHd5eXZLNjhpMU9RUUszRVVydHNhbnJ0dG9pRWxBTzIyNUNjVHVvc29ucU9OdzZzS0FrTWl5RDhEUTZIZFliQ0t1VWhzc0pHVHhtZWpjaTAzdVkxM3FwR3dIejFRK29WajZDWmxRUjlMSVZDRm5hZzZxV29QWGM2dnFWMjZKaC9PU2ZzMksxVXNMUkFhL0tvMk9xNnJVZTFwcXZnS0pkVnlsNEdKQUtqYzlTS2Y3ZFhKYUZPNkxNZHZzL2JXOTc1ZkZhWGNYZGdtdGI0R005UWUycFVpZ0pxRHZxdk0ycU9COE1PNk94UEQ0ME50a0xHeWlCVVBERjNoS1drQTdZVnp5WXIxQXB4cnRybWVWTnR1dXAwWEdpc3l0Qk4rNnkzbmplZnhGN2dvc2pjWktiNjB6UTJoWVR3bE96elk4eFIwVkNBdTFOOUVjRnRxeXQyanFDY3pxbWw5QVhrcy81TEhnMndXUHRjaGJRencyNzMxNzVCbEloRkFJWFZtZVMzdDNsZmd6VjVSbGxMSGJSMWErcWJSOGwvRUV0YjA2Zm14YTg1OGxYRDIxbW1ieGk0M00rVDJEb2N6NDh5eVNYVWNxaUlrb1kxdUlVZWhaVUVaSkIyTktIVThXT1oydlJkbU5lNlNVcnIzUnF3bmgvamVNOFJ0N2pMK0hSM050Q2ozWGt1ZDhqU2E3djRsbmNMWjJOckhHNk5ISVVwVU1RZVRjajBXdGw3NzdhV2M5bzBYbVZVcHRVdGFlWjViVytRdWMvWll6N0xXY3R2Y1h0bXVRbjhkbmtrZXloN2FLaG1WbFZYUml4WlFlZjlQWFZHVEdrbTh1c1ByM0xzZVZ0eGowOHV3UXViN1BlQllhM3R2dUxGYlgvbEZzOHR6NDNnaWt4eE1sNC90K3N1cHBmMnA1WVFhUTJ5MC96TjZhaGlyVExadWt4MzhmZ1R5dTlLcXQ0a2dlSFpQeWp5bkRYMkM4YXNiUnJxMHUyekdhbmhuR0RzNWVTb29rbVp1QXB5WVZYNDFwc1JvdSt6RTl6bnc4UVZPMTFDL2tmWlR3N3o2d3hUWDkxYlBjWU8wV1MreUY1RE9sNHJFbi9sMmtLVFNnSGpzR0tLYURTWElvM0hkK1E3d1hTM2RrYzdYK096R2R0YnVQSDQrUnJPSy9hV1lrbGlzczZEZ3BDN2lvMytIcHJUVFM2c3pXbXlCLzJINVBrSmlJYkNVR0hqQk1PRGUyUlZHeHFQZ1IxMCs1Q1ZXd3RiZUllVnlUZlZSWXBuZ2lZdEk0VjZqc21raE5PbENDRHBPeUVxdGtnK0RlWDJjUXk4dUZuVEhTUjgwdVhpbWpRck1LSVFXQUJCNURwcVAzS3ZTUjlqaVRMRmVFZVM0VE1SM0QyTE16eVJWdHc2QjFrcVhvZVJGQVFHcFhUdXlnYmE1TEF0N3ZMelo1N242R0pIZTBrdDVwSnIyT014OWx0bURJR0tFSGpVZncyMVNxcmFXN25KN0Nua1dVRjNZMmxyYnpvYnJ1endDN1FQSVpZdzlmZWdxQ0cyOWV1Mm1oS0pFcGFBZmtNbWN0Y0NzYzFwQWxsZlk0U1FqNmdGSW9yWW96cUI3YVNNeWh1Tk5TU1c0alp1RWRGL2J4ZnVwZllhYTZreGVQeGVCeUZuMjVzbmVYUDBrVVN2RVl6SXlSSis2VlYvYnlJM3BVbldUbnZqVm9odG12angzMnB0cElIM1BsWGpHTm12c0xNMVkvclJiTmN2YnVWWVdxMFVySXlQVVZBT3kwMVpXcjJ6T3NFTjBPTzBseS9iQyt4M2tOamM1Q0NhUzhpdFpxRjVRZWJxaXJ5K0JLMUh3QTVlbXNYa1kycmFyNkd2anpmOGNJSlpDeFZXam5QTitKZFJLeGpXcXRzcktxZ2cwSHg5TjladVEwOFdSdlFxajdzUVNSZUl5WFVWejJ6Wnl3QXl5TVlvWTRKcmdxNUJMYjg5bFlCQjdmaFRXcDdYa20yM3lBdmRxK2pkNWhYdy9PNSt3aE9SeTV1N3pIM3FQOUZMWWRxN3NGVm8vd0JFeXl5UktqSUJ5TEJtQStXajhsS3R3WStPelRUa1ZmOEF1dkNlUlp2S2VWWDhpMm1Cc3JhMXNNVmRaR1JQcTVKWTNsRFRJRVlVaDV5RWc4VHRzTnQ5V2JIVktxNjl5S3VwZG4wSWVlOG14RjNZWGVEbnl0dGRYOGthOW1ZVENXM2J2Q2pKelU4ZTRVQkZXcFQwSHh0eDFocDlDdkpaTlFjUFpDMmhoeTE1YVc3QnJlTzRsaWhkVFVGVmNxcEJIb1JyYU1ZTCtMb0hNcVVxV0ZRcCtLbmZVYkRvdWZ4U0dDM2pobTVDSWpnSG1taUxLcGtQQ2dZT3REV21nTWoxRGNWZEN4cktmTldWM2UyMTltVGIzVnBNclFwajdLM0N5UnlxT015elM5d3JXdEFLZkxVRkZpMStsNmpoTmFUTkhiU25NWnE1WjJ0NXhhTExhd1FicUtqdVVYOU5lcDVENWFhSjhDVGVvWThtdVRhclp6Vzk3TkhLeks5ZzU3YzBET0txb0tJQXo4VlozUEtUMTZmQWF2R1RrS2ZLZFlnUjU1bnVMd0xndTVKbjVlUnlPZnVJUHBoTEV6Zi9BSU9pUlZidEJlQUE1VjRqcjY2SmhKUUQ5WExNN3Z4MU1CSEhGZXkyUGNWVHhuaFdhVVhNcFlTaVk4bVlBOFRSZHFpZ0EzMHEya2phalJTdjN6TFhsNzRwbDBhRzRXS0I4YlBmUWhsTXJHUnBFN2daVkpiM043dlhSK08wZ0dWT1FiWStIVDVIeGU3ditMR1N5YU83N1k5WVZQQ1E5RDBEVnJwcnR6b05XcWExTEkrMU1VQnZaVngrUGhzc2xZcnhXZVFzNXVFVmlXbFZJZ1N3SUJINWc2RXlhZVlWU0c5ZElHSEkyTnBCeXh2MUVUWDA4Z2xpbnVmcUlRSTVsTGtLSkVZMEJyOER2VFVhdlFuZXVxaGtiTFFwZlkzSVcwand6OXRQM0E4c2l1WGhqNE1kb3lLT2VScHkwOUxPakd1bFphbkgxNWF5MmQzUGJUSndrZ2RrZEsxb1FhVXFPdjQ2MHpPT24vdE9ENUY0UERia2xqSmJ5NCtRSDNVTVlLZ2tIclVGZFZ2UXVyMEtzVHg2ZXh3dDdqc2ptWHRjVEU4c2x4YlJ4cDNHTmFkdmM4cWxnQlRVTjdtSUl0RHJob3JkY0xiejJUS1lHaEZzSWJxNTdid3NQYjJpQ3JGWFJsSTZVK0IxRzB0dE5FbDBEdVFhK3ZieUsrdjFpaUVrY2tjYVJTck5SazlnSklvTnpKdlRVcVYycUN5ZlZLS2NqdHBNTjVOYzQrWThHZ25aVFg5SVFtb1A4RHExT1VWMlcyNDZaZUo4ajRwY1dxbFpUWmwxajlIL0FHVzVoaHR1Q3AweEpxR1I4REphM3RoQVpXNU1zWVlFRWloQkRlNzA2YmFoV3UyU3k3bEppN2pabnh1ZnVNYUlsTUx5RWc3OXd4eWJqZXZRQTZzSzhkb2NRRjhuYm00eGtzSlpYYVJTdEZPd2tTcHJUcnVWMGl0b0Q0KzdNdGtaRzR4S0FuY1lyVm5JcUtVSHhwMTBoa1M3ZTVraHViREl5Ujl0Rll3dDBIRUg5T296ckJKZFVNdCtZNzZ3bUIyYmlkNjE1RWJqNWFyc3RybEJzV3RWb1RReGVLTzZrb3pRT3hCci9RMVFRelVwWDExY0FFUzh1NDdxUU9xUnJSZUlVeWNxZ2REL0FDMHlVRE5nTzlpNVJrT0tHbnhCOXczOU5UR0k5bk55dGpDMWFxZHZ3T2tNUjVlUU5CNmJlbWtJMzRtNyttdlZWelNPWDJHdm9mUTZRNjBZNmdPancza1E5dEFybnFPdWdyYU9BK3JsSm9QV09RRnRkd1NibFN3RFYvVHhKTlIvUFZOcXlvTDYzMjJURDJUeEszLzBkNDBWUHBxdGJTQWprck5zYWdFbWgrZWhhM3RWTmVKcDJ4MXZEK2dtWnVDWEQ5aHJPM0NETFhCV1I1aXlxTGdVSU5GK1ArT2pNVDM5WDBRQm1YMitpL2N5VlBJSVRhWkE5djYrRThieUlobmNIalIxZFdGRHQ3bFBycEw4Z2RxSDVoRzZzN08rU3d1TU5sWkxMTVR5U1NYcnQ3KzQ5c29aQ2hyUkN5bWc1ZGZYNGFhcmpxcEkzUzZwd0x2a245cS90TTRqdFROZEt5TDlXd01UaGpTaEM4bURWM0RBZmxxekZPNUExbEtraitHWmRiSko3SzRJTnM0N29CRmFtbkU3RWo1TnFXZXN0TWppdERHQzVlTnlaT3hCT3Q4eXl3ekIyam1XWlFFTGdEMFA2ajhkRGg2NkNSNUpZaDdtU1dOQURJeFdSVlBJQmg2ajVIUm1HM1lDelZpMGhYd0x5Q08zaXVjWGs3QzF5Q1c2dTh3dnl2OEErQnJ4RHh4azBia3Y2MUNuNDdham1yM0lVWlo4SGxlRWd2cmUxeDRXOXgwVWZmeGM1QWtGb29ZUmU4a2N1QkJIcFVldXgwRHR0clBpYUxkYkpSL29hL0FzWEhrN3pLWkhLUnJlMjl2YVBGU05Rc0V0eElwaHQvMUx4UTh6dWFBS0NLZkhRUE12Q1ZhdUhLL216YTl1eE8yNjdVcEtQSnQ2TDVsay9kTE1MNGI0bGcvRXZIYk41SE1FVU1sdlpzTzVIYkVoWENWcjdqVTBZLzdkWlBHb3VWbmRyUFJmbSswbXR5TTF1TGhWYVZmOFV1NEY4TEZqSmFZeTM4ZXRKb0h5VXM5ekpjM29MektJR0NxMGlobVZXNU0vcnVkL2hwK2FyYjI3TlBhdXdYN2U2TEhOS3RPejZ2OEFpVmovQUtoZklmN2hucmJCUlhBbmhzNjl4bEZBVEhWYW41bHk1T3RmMmJERkhkcUpPZS83Qm5VMHhKOU5YOFNwclczWmlCVC9BRzYzck01bXRSaXM0WklrQ3Fwa0xIWmFiaW5VYmFHczB3MmxXaXd2RUxPNU42cndvM0t5aU54SXJBS29sYjJSZ3Mrd0JMQWsvTFFHZXlTMTdtM3c2VzNUVmZ0VXNiY1pILzhBY3F0MUtJMlNVUDJHb0QrNldoN2c5VHQ3MVBVNkgwblFoZXpqMUV6UDJlTHh2Z1hsWXVMcHpjWDcybVBobG5EKy91ZHAyVXRYMkJWS2x6NjBBMUxFM2JMVUg1RmFyRmFIMTBLODhiOEdndVlieTVNOTdqY0xqcm96K3dDNGorbWFKaEhMd094WjZLVzIvUWVtdERKeUlhV2piUmxZdU8ybTVoSVI4cG5ySkdlYWNUVDMwYTBFNkt0dnh1R0I5cmNEUW9CMFdnMFhYR3dhMTB2aUl6TXpzV2MxWmlTVDhTZEZJR0MyTng4c3l4T2dOWGZhblduVFVMWFMwTEsxN2psWjRXUjQxa0N5Um9sRk1rQW94YXREdWFWb0NUUWI2RDNRRVd4dG9zT2JGZUFYZG1yd0xuSkwyMFVJNHVudDFVZHZpVElCd0h3b3FNR05LSGVtaDYzeXEydTJBbDB4N2ROMGpEYTJUWVBGMjJWekVFbHVrdHVpVy9ZN1AxTTByS2FGeWkvMUNvM0ZWcnZvWnZmWnFyQ2EwMkpXWmpZM243dDFrcmVLVmx1V0x2RmN5YzVRcFdnWXNGUU5RMVArelVMcnMyYlhBcTFSM1NKK0V3OTAxOWo3cVlxbU5qdUVra25vU3pkcFN3OWxPUnEyeFlBMEdtVmswMTNncXpWYXNuYm9SdjhBVVg1SmJKNExiWWV5dWxtbHk5Nml5S3JiaUtDc2pWQm9hY3VIWFJIQXhOWG53Ums4L2tLMUlYZG5MVFFnU0FJT2dvUjYvanJlTUFZTUJnMnlFNFZsTFJWRlNOeDg5VVpMd2l5bGR6Z3U2N3M0c0g0akpiV29FZmJqNE1wVUVNN0FBayttekhXSHUzNWRUb25WWThNSVVyV0RzMjBGcXRPSVVpcDM5eEFCSHkwYStvSlNFdFJPOHZuanVjb3lxR0N3SnhDbW00YWkxcitDNkx3TFNUUHp1YkFXVUx5b1FWYWdxZlhvTkVBdzZlR3hROFhjTUJLd1VGUzFXb1NUVUEvbG9YTzEzTGFKdHdoUHZwSk1uNUhrTGtIbCs2d1FucHhUMmorUTFiV0swVWxiNmpGanJXNURoQVVGS1YvVi9DbzBMZTliT2RSNEpPZlJiSzBrbmtJN2l4aFVWUVFGNUQrZlhVY0tsNkV0VnFWMUc3dk1sU2FsaHVQMWZsNjYwU3NzekVBTGo0cnFXUjVHSkxqdWtramlEUUN2UWJhejhqOWNJMHNTaWtzRDIzbkZzMTZSTmJOSkRYMkdKdXRhMTlyZmo2SFYzK1BwMTFLcThuWFZhQkh5c1h1VXh1S3RMTzNtbWE5dWxXT0ZJMlorWVQycUFvSkxVUDZSdnBZSzdXeGNuSTdKSFRYK252N1dlRVgzamJaanp1T3d5TjJYV09QSFg5dzBUeFIwUmh4amltVWxtQmJseUJJOXRCMTFUeXVmancxYmRiUFdKckVFSzhQSmFJYVhrL3hvWEo1WGp2R3NGNDVlWkR4bXlneHVFc1kvcG8xZ2thUlNzcWNTQzhraENtaXNBUU5oMTlOY1Y3bHlNWElwcGp5VnZheWw2Ylg0ZHpyL0FHakZ5YWNsWTcycjlxSlNoN2sxM25wQnlaNUhMYVg5eGtySzJVTEVlOWJ5a2I5d292RGtUUWJmRDREV3J4YVdwU3JacDgvUFhQbHV2alBtVjM1ckxjNVhOSkZkZ1JRV2hpc2NlbEFyTkRFS0szR3BxQ0JVSDFycnFzQ1NySzdubldkK3Ryd0xmdE1GZFhFTVN3Sk5jUnREQkJEalNWU0ZHUUQzbHExNUJnRzIycHJQdmRKeXc2aWNKSUl4NU8remJXTmppNnhyY1F2YW00Y0JTREtVVldVOGlEUXh1dzMvQUVqZlk2ZzZkVy9JdFZrbW9MWjhOdzkwL2k2Vzl4ZWw3cUc1VElTWFVQTmJudHBJQ1c1S3JEbTZxMVZJOWVtdzFsOGpLdHljQitDamFpUW1zK1doaXVMbklwQktZeTl3bHVvSWN3THprUldjQ3JBbWpPMjROQW8xbitscVlER25YU1RrTHlLVkpKbzVDb0F1TGg1RzQ3VUtxN1ZwOGpTbXRyaUw4a1U4NnlWRjVzN0Yvd0JMMU1kOW5NUXlCQk5leTNkMUlaVTVveXl6dUtVREJ1ZzY3NjYxMDlGVjVISE8vcWJMYzhpejBOcDRQNUhrN2dScExqOFRmWERvRmJ0MFNDVGorb0tTRFRRV1N1MStRUmphYk9GTEh5S0dPOHRGeVdPeE9NeDE3TkJZUVhsdmJ3M1BhbGFTTm5lYU9qU0NzYkJWOVBkOHRRaVhBODl4UjhreTMzRHh4V2UyeWF3UTNFc3FXVUZyRGJLOGtjWmtxMzdjWVpRZ1RldWtyZUpGeVB1THZzOWc4cmlseTJTK3NSc1RIOWRaQzhyY202djNaSStYRXR4bFpEN0FPaEFxQWRMdTBTNlF4Qis1a2N3enVUc0libDV1ekpQYlF6VFNCcGUyckJhTzRKQllIa3BJNjAwR3JlcVdHZjJRaHArMTVqbHdDeUJRenRNeEtQMTlsRm9QNGJhb3lxQW10eXVQdlZNcitheWlNVWlqdExOQlExMnB5M3FUOGRFY1g5dnpBK1UvVjhoUnNBM2FRZzFOS1VINGFKWlRVSjQ2cGRWQUZDekZ2alFLZFFaTkF4c05tTzVOQmFPVXgwcmM1VFVjZ055UUQ4TlcvY1JROGR1d1dqVDZjWW9KV2dhUTA2OUkyLzhBSFZVeTJYTlFsQTNXYkJzRW5FZTB6RXF4TkFDcXNkOVVQcUdZMm9GVExsdTVZVVpaQXRXRkQ4V3IwMWJSOVNySW00REdiQ200czFkZGx0NHp4Mm9ldlRUSVp4S2tWR2tWTXJlRmRsMjIvVlVmRFZpL2FWdHBYSGY3THN3ODd0eUpPMnFXdVFmdW1xaFNrSElHdERTaEExSE5IMjJMRC84QUlqcW5CSmRMWjNyWEtoTEs3alcvdUVVcTZzMEtHdmFVY1N4L1M3ajRkZGM3a2N1VjJON0dtdEgwTkgzRnlOdEdmRGJPR0JtdUo0cjdGaUMya3FGanVFaUptUElsdVBDcjBiWWJhdTRxYjNGUExpVUJMdkJZU3doc0xkYlhLMzl0anpHTHU0dWdwakVQMUVwUXdwRVVlZVdYaWpLUUdLeHFXNkhSQ3RaenF2a0RXclZSb3hmdE1nOTc5dzJ5UXRwOG5aNEN3a3UxaW1qQzNLUGNUcEJHSFNJR2xCR1hVYkdoWFlhdWEyMDhKS3F1YitTTlhrTXY5M3hpZmNIeHFlOXk5bkpjdkhlZUY1T2Q1WXhPc2JxclJ4dExCSW50TlFSeTMyVTEyMHNkblcyeTNoKzVEWFNzblpUUGdGL0NQSi8vQU1XUGorWWJ5SEIybmozbHZsVWR6ZG1ZeVRTM3JXTXppTzJ0b3U1VUR0bHVQRU94NHFXSXIxamJibXROYk5wYUVsT0t2cVVONmhMeVQ3aUw1amhWeCtZbHQ3cVdXMm1qUGg5a3NiWFJlRlEzL1dQT3NpaW5FTkpKRFFSanF3MUN2SFZMYUtQL0FDL2tUZWJjdFhxKzM4eEx3UGlQbCtHeFYxbjdmeWJDWXl4N0FWTGEydkpKTG05dDdkd1pDUkdwTlEzR09yVVU5YTcxMWRmS3BTMnRsZGFPTkdrRGJiTC9BSEE4dXdUNGpBMmoybUxpZVZwY3J3TmxiUjhveXNrekVTTkc3OEFTT0tnKzQ2dm1sWDVsU3JlMWZJcG1DL3RmR2ZKYmkxaXlVVTFxd2dhWElXcm1kS2Uwa1YzSmI0a2FOaDJxQXEyMWhxYnpiR1QzdVlhZktTbUs5bVc0REZaWkVkbWk0bm1PRmZhVlZRZHEvaHB0ajBGdTFadGg4eDhUaWUrVVBOSk8xeVRhdlBGSkxHaXlnTXpkcXExWXNTUGRVK3VuZGJENzBqVGVmY0FaSHhtMnhadnJ3RzNWbWVFcEtVWVF4ckhHb05Tb1ZUeTZmbnBLc01UdktTQnQ3NW5ZM3J3U1RPd3Q1aWp6d3cyNGpsUWlpajNBVlB4K1owKzNxUTNCeS84QUp2RTJ5TnZjV3VCZWZEcXdpZHZvMmpZbFVUZHFWNVBWV081K08ycTYwY2Fzc2QxUFEwTjVYYXk1TzV2R3NMbWV3a1NQZ1RacUdFajFvaEs3QTdleHE3L0RUN05Pb2xlSklhLzIyK3hzbDFsc2ZsNDRnMDl0REpGRy93Qk16QlQ3V2RtQ2dpcTg2RDAwOGVyUm9ocEhRdlQ3VC9kWE41dVBIMmZsT0N1czFpNGJhTEhOWjQrR1ZsbmdpVk9CZHdPS3lDaWpqc0NUdm9MUFNsWjFnUHc1TDJVUkpjZUt5ZGg0bEZpZkhNcmZ5WXZJSzhrLzlzbm83UUc1WG5TWXlEdE9Ya1lWNDlPbFZHc3QwZDIybEsvVTBkOWFKS1lCV1lqdkdKdWo1TmU0MWJheGFDOWhzSklzZWx6ZlJzb0NpUkluWWd1OG02SUR0cDZKN28ycnFQZTBwT1dLMkl0cm5JZVVMamJuUFpkTGZDekZyeGhsMnVzWnhsS2lLQmJob295MDdseUdpUTFXaDIyMWZtcWxSd2xML3dESFVxd1didjFhWHhMVCs2WDJ6eEZyNHBmWkpKcmk5anhVQzNKczd1YTV1SU9NVEs1RHh5ejl0dHFtaktSK2VzM2ozZGNrSkxYeUw4dDdYcTViRURGZU9lSlpqS1l1NXZmRjhNZ3ZaaEJjeElPRm5Fa3l4OXNDSU15Y25kbFZxaXRXSVliYXZ6NTdLYVZiM1JJMkxGVnBYYTlJOCtRK1BlSDV6eCtMRlIybU90TVZjR2JsOUxZV2JrelJxT0lTUUQyZHZZVnJYV1hUbnV0bHVtZmlGMjRlNmR1cUU0NWIrejRIRVc5bGJOQmdJTGVPUnhFc2NhSDZOMlc1YnRxc1pERm5IOUpyVDAxczRzYXMzTDFBTXR0cVRxdERocnp6SC8ydjdnK1EyWFlFQ3BmM0VzTVNWQ3JISTVsakNnK25FalhSNDJ0cU1DNml6UHZFWkJiNWFnYmlWa2ZnMjIxUlVkZncwMStnMWVwYjhMaU14WERrQzJtajR2Q2g3bEluQjVoVlU3R29IdFA0L1BRYlFUUnZxV0ZOS2tzZG9qSUxlS2EyamlFMTVHOEpEUXlsS1JTeGdCMlpHWGV2RTAzK0dxYVRJUmJxTWZqb3ZiNjhmdVRPeTI1Y2NrSEpSR1JGRkhRb3loUGFLN0QzSGlQanE2VWlxcWw2c001TjUzanQ0NDR2K1RLbHZMRzN1UldsWWQxM1VBVjJYWldKcnkxQk1zdTlOQkp0L0U4dWNYbEwrenpzOGVSdzBhTEhhUTQ5cDcxcmVpeHU2elBJaW1Pb29hRFlyWDAxWGE5YXRlWlpTbHJWMDdETG5zTmNKYVkvRFdCT1J1Y1RhUkxkOFdpYUVtZU5aSVJ5RE1IZHVKQzFyeE8vd09vVmNXYmZRbGtTdFZKZGlqL3V2YVRQNG8zN2JkK3dhS2RKSElqL0FHMFlrRGlXWmk2OGlDVFN2WFIySnd3REpXRVd2OWpzRmFlU3dTMlVxOHJQTjQyV0JRM3RZRzZpSVVnL0lrZE5HVnh5bXlyZEVJQVlIeVY3YXd0YmRZR3RNcGlKbXgxNWNHZ243UUJYaUFONnFTZmRyT3RXR0VWZmRrVHlySjNNbHpGbFVoTnJjQ0paNGFVSmtCbDRxUUtDbytPM1E2aGpkVzJrWFpLMjBjR2VUaVdPNHZVaUVrOE5yZFBGTXR2MElpWG00SzdEaU9YeS9ucE1hM1RVNTI4OHhIOXU4bHVFRlRGZHAzbzNZRUU3bFRzZm1OSDQ3YnFnTmsweTR2OEFTNWZMY1BsY0pLNURRTkhleExYMFA3VDAvTUpxVFVzU2NFYjdyNFNldys2YVlONDBqc2J5NS91MGFnVUR3SWhsQVA4QTZxZzZodFMxSGVvdDNGeEZCbTcrMHQzN01jcXc1QkFXRGU5cXh5Z2NhaWhLaHRPbktGM0hMRHpXczYyTnRkTkduZHVlVURMV3V3TlNHSDZmMC96MGlRaStkd05KbXJYTUFLZ3lVYjh1TzY5eUdRcDFIUThlTlI2YWpqMGxFOGltSDRobkJGa2w0WDRkWTdtRW9zZS9FeWdCZW9CRlNyZGZsVFVwR2RXdXBCc2JHYkIvV3dkNkhsUWlGUzZpVGlHMkhHb0krWU9uNmtRWm5ZTHExekZ2bExpTXhRemNvaDJodHhqNkVIMUhwWFRvVlhEa0lTUEFxb1FlN0h4RWpQOEExb0hBT3hBL3piSGJVYXR4cVR5cjFhQzZsdkpaNUs4dDR5NlJDUWNIcDBSOXdkOXQvVFVwa29ObkpweE5ieGR4a2xHOGttNjg0eFNvSTI5QnBEaGZINVI1cklTeUVEaEd3ZUliRXVOald1cTdkQTNGYlJBK2Exdmx4MDJPZ3ppdzRpOGo3NXMzTWhCbUxlNUpFUlc0bFQwYm9ScUt5MWZZcXRoZlpnbTR3MXZCTkRiQ1dOeEpIRXpUYmdDU1JmZXRkdjBuYlZ0YnEzUXB2VjFjRFhpUEJjRGs3V1NhNXlUKzFULytDSWdVTUR4cHhjZ21oL2pwU1Jncm5JWTlzSm1wc2E3OXlJTiszTlFoWGpiZFdBOVBuOE5UUkExWGdSV3AxcU42ZW1rSWdrMGIyayszb0FEc2V0YTZRaXh2R1pFdnNhdy9VNVVzdnlib3cvRWFDejZOTTB1UDZxd2IxWXIvQU1CcUQ2RmFkZjQvSFZaSXM3eDJXMHZNUEhLaTF1ZUJobUpyVWNUMU9nOHFobXJnZTZxQmZtdmpzV1J3Rnphd0hqZElvbHRIT3lLOFB1V2xLQUU3aXVsaHliYm9ueU1HL0cveUs3eHNjcld0aGtjWWtsd2NnalJaS04zZVYrOGpEM1ZKcjFYK25SdHJlcDFmeU1mWjZGZXV2aUU4VmFlUlpXMnVvZjdLczBObkt6YzdobzRWQmpOT0xPN294K0FPbnRDalVHM3ltb0lMdEpOTmM0UzNzb3JWWXAwVjRMbWNkeFdOQVVSbVhrZCtoLzhBSFRPc1JhU08vd0JPMUlYTW5HY2JkbWEzUjRBNWRGQktzVmxRMGRlblExOWZqb21qVjFES1gxMEo1dm84ZmJXdVF0WmJoNGJwTzFKQk03SGlhbXZia2o0ZkhjSDhOVnFzMmFaYTdXU1RrOHgrVXhiUVRpYTFXMVppVWltWGsxYWphdk10dlhTdFcxV29aRk5keFhsNDIxL0ZkdkdseEZJeER4eVZFYkhvUTNFZzAvUFJYVkZSZEhqbjlweVhpNldNc1VOdGRjaXkvU0lpVHBNaktlRW9EY1pZWFVpclZCMjMxbTJxOTNpRTF0Q0xQOEV3TnRqSU1oRkJPSlk4aGtJMnVZWVZhT0cxTmhEM0psWGhVZTF4eDQ3QWdmSFhNWjg3eU5PUDJyNnBzOUE0L0YrempoT1ZlMnNkbzdDZmtjbGwvS1BMTDU3ZTNramt5azBOdGo1VVdsTFZDcWx1WkswREp5ZXZML2RHak1XT21MR3BmUlMvaUNYdmZKZXpoeGFFbzhPbjh4NGZONGp4V3h0clRGeWlXNXVZM2h4azVaSGNweDdnZG1KcXZ1YlpXRlMyc2Y3V1RQWnUya2RUZldYRmlyWEhWOWY5VGxYeUMrYlBlUzM5OHRlMXo3Y2ZyN1k5cS9tUVQrZXU1d1VXTEVxbm0zTHkvZjVGcm0zSFdiVHVJb3lBQ0NTNTJVYlYzT251OUpaR2xKZWc4WVBIWDhOcmRYYTJ3ZUszV3JUdFdQcldnVnZuU3UvdzBIa3N0RFR4WTdLcmNkQmk4Y3RvWjhFZTRuLzlabTN1R0pCN01OU2VSMy8zcVYwTG1iMy9BUHFIVWo3TS93QzlodVRPSmFQZXpUUlZReFJ3UXV5THZDb0hFVXI2S3Z3NjZhdE5BWEpmVitBZytjNWk5emR6RDQxYUdSYmVWbHZtUVNjeExQTWdKTk90UUtmanJRdzEycmN6STVOdDcyVkg3ek9TeThlOEJXYXd1SlJMa0xXR3lXekRBZ3pYQlZwRHhBb0F5Q3RkL3dCVkJ0dnJPd1RremE5bUg1MnFZb1Q2bE4rZStWeTVmRjJPSmVHSzNqdFNESEFrY1N5SVVYaXhrZEZWaWFpbnUxc1lNVzJ6Y21WeU1xc2trb0svVmVicXEvcVlnZngwYUJGbFlHd2h1aEJZUUF4WGFnS3JIWmR1cFA4QTRldWdMdlUwS1ZYUUt5VzVuWnNka2xlWXljK3pjUmdOS2pyN1JSQ1ZLN25ZaXY0YWltbHFTc205R01tQjhabHo4Mzl2eDEvQzl2WjI0a2wrc1JZbzM1SGkxWGpQTXNCVmd3M1lEMDFUYk1rcGFMYTRiTndtYVRjWldObThjeWVNdVByN1VPSnJsWFZrbGVSUjJ6WG43UXNkR0lXcDA2Uy9jbm9SbXplMXB5T0Y5TlBqcmFPMFdCV3M0VlZlNnhxc2pDTlY0bWxOaVR2OGRac0sxanRxTjRzS1VEUDRkZFJ5Mmd2VUJjTzhybU5pUDIyQjRiVk5LR24vQU1VMDlxd3pEdmszYWxKLzZoTXcrUjhzeDJKRGNreGRtQ3diZjl5NWFwNkgvS3E2Mk9GV0t0K0p6M050TjQ4Q3RMQ3hra2NiaWhQb0s2TmR2QUFMRDhkdGJtQjdlS0tRSVpIVUVsRklwWHFhOWVtaE16V3NodkhUZGxBMytVTXlXMy9VWEN0RUtGandJTE1yY3VKOTFOei9BRmF6Y0NUY3dhdkpmUlNBSVNIZUlNdkJ0NUdwdlNsVDYvR2cwVXdkUWhEdTJGMWRYVWplMlVsaHlMYkV4VUFVVUhydm8vR29xak15ekpFbUJNaFJRQ1BZU1FRYUI5Z052V3ZYVnBTTytMNFdHQ3VNaVVDekpGSVhZOWFSTFJSLzlXZ3NqOVczeENhTDB5dXBYK0U1Z3lPUGZJU05qME9pNzFsUURJZnNWQk02Y2lZK1I5ZC9YODlaK2xiZDRMVWt3SjVsT3l3bU5uOXp1QlhjVTQ3VXBxZUJlcVNlU3NLZXdsV3E4cnBLdnhOYThqNkg4OUhnNC81Q1EybUJrTmYzVmdJTmR0eXROdjQ2QTYzTkZ1S0ZlNDVBMTFHRHlvV0FCSFhyclFabkhTWGhkemo4VmtQdGEyYXlrVmpqWk0xazh4TUpTWXlEWkpCYlExZFF4SEpnNEZRQlFIZldka3ZhdGJPaTNPT254TkxIV3RycFhlMVQraGMzMjk4WThRdmZ1QkJjWmFkaExpS3ozbVBFOE1hck5EUXdySXFJcnFCUXRzNXFCL2xyb1BCbTIxMzJYNjlRMitIYzNXclh6OEQzN3NZV2F5Z2t6RXZtV1E4c2g4bHU3YTBnVzZFUnRyV0JibFpaQkFJWE1Sb0ZDKzFGQTFtOHZuTExtcGhTYWRaczVVZHREWDlyNGYyNjVja3o2ZHZYeGFSejVoN2g3L3lJRXg4aGRYYkY2KzdtanVEeE5TZlQ0L0hSN3FsVlNDMHU5OW40eUk5N1BkWlh5cUM3elRoTHVTN0FsanFBRVZXQTNvYWJEYlk2M0tKVnBDT1dzMjc2OVpPaE1PWmJleitwc1pRL2tHVDRXMkp0OW1qaWpFN1FseUFEVGlDeEo2MFRXTGxVMlM3ZHpZeFBiVnZ1SDdXM3hPR0dWakVhclo0aTQ3VnJNUXFoekVqUm9BQ2RnekVENWdVOWRVNXNyYlVkeXpGamlXdzloc3Y1QUxLeCtrOGJ2SGhualdTK3VwcDQ0RW5tRXBZOHJlUW9HVU13QXIrQTFSa3JXV213aWppTkRkNW5sczNEaWNsZndZTEl3Y0laWERYcVFpTzNpNEVlMW9wQ3hIVWdOc0s3YUhyanFsRWwvd0J4ejBPVWM1ZVJCRW1kU1dTRzRkVmVvMzlxanArSjFyY2VqVGNlUlR6c2xXcXQ5WVozNTlpc05GYi9BR3k4U3NaUXF2SGk0SmloWmxMQ1VjMnFOK3ZJZW11bzVGdHFVZUMvUTVUR2syNUdYN2hSWXF6KzMzbEg5Nlo3ZkYzT1B1UHE1bEJuS1JwRWEwQzhTUVc0clRicnJQdTNaQnRVaytod1RnNU1QYVhXTDhkOGxhTEgrU1hJbnVKNzdJUVVGdk9aRmFCNVVkaWpyeEJIdUI5bENOd05McjBLMjQ2azc3aXlXOWpFVFlSMmpOSmJRL1VUNDloSkFzdDFMTEpjQlpWSjVNQ3lLeW1udDFGTFVWbnBvS2RyNUdMa3RrTGEzaXNzakY5REsxMDFYZjZpM2tFck9BV0lLZ3gwSHlZZyttcHhESVRvYVRrWk01bkV5T1JjU1RYOXhQY3pNUlRrWkpwR0orQTNIVDAxbVp0SmcyT0hWV2RFKzdIL0FNQ2ludHNYYmR1RG5DMDA0S28xQ3pNN0gvS1J0VFVMZXBmSWxsVHJaeDBrcVQ3clhEemViWkozaU1BVVc2SkdXNWtCWVZvYWo0Nkw0NjlCbjhoemNEV0NrUnFWMklBcFg1NnRaR2lDR0xCYVlGanhCTGtuMDZIVVdTWFVOUnZTeG1OS1UyQStkTnV2cHRxc3NqU1FmZGxUSGlWNlVFN01QbVZIU240Nmt1NHJOTlZYeEdTMnBKZzQ0NG43Sk1wL1RUY3FHcDE5TlZQcVhVNlFuQXFYcUZyaTFqUDZ2Y3JBVk85ZXRmWFZ5NkZibm9HODRvZTV0WXlSM0JBZ3ExQld0YWFqVVdUV0JORGY5ZGMxcFN0UC9EVjNZSG4xRHA5bzN5Y1hudU9qdzhVYytSdUZ1N2VHT1lzSXF5eGNTVzRnbWdCcnFHUkowY2tzYmF1b09uUEhMZnpxOXc5NU8yUnM4WkRienlSTmJDeE10MHJJZ2lZVWVaVUFvdFI2OVQ2NnhzanBWSlJKcTQzZXptWStRT1BnZDM1YkhHTWxtNUo3ZXg1UzJNRnI5TllTcVI3UTZNWGxJSUM3RFloMjFZc2l4cjByK0pIN1ZzcjFlaHB5SGhHWk50SmpvZko4b2tzeGxlNlpyeTF1WnlrTUhDS0dQdVJoRmJpcEZRUVZJNjlOVkxscGF0TDZFcmNWOUpFM3lLN1p2RThqRjQzZkRBdzJ5UWk4dEduYWZJM3lKY2hIYTdsQUt2SUp1WUtPVlduNlJ2bzJ0dldwMVQrZ002LzhiYWNRQWZJc3g1dEZOWjMrVjhSbnNiNjZzWXNkaVlZemJSV0pqWU95ekVNWGtERXYzQXlGQjZmRTZ0cnMxU3NEMjN6TWFqdjVIblBOdkxwTFRCWjNPdG1NUmV4ckJlV3NvakVheU0zQlZoQ3J4N1pvdEdlaEg1NldQRlYrcEtHSytTeWNOaWczamNkamgvSk1qNGZZM2xuaFJlUTR5L25nRWtyUldrYzZ2UEJDOGhxS3Z4clEwTlBodnFPK0xwV1pZcVRWdXFDRi93Q2M0ZUpjYTFsRkpaM2wxSkt0aDQ5Wm9seE84RkdpaFZ5Z0prSklVTlVtcEhMa091bmVPVnIwanFNc2tSSFh3Q3ZrOGZtdmgvaE9Hcy9JYkhISERXVFNYR1ZzckJ4TGZZNTd0aThpelJSdTUvY1FDTDNMKzJ0ZjFhaGh0UzkyMVBrL0VsbHJhdGRZOHl0L0J2QXJyelhMVGVRM0dLZTJ3dHl6MitPeDF0R1kza1ZWMjNvUWtZcUJ5YjlUYmF1ejhpdU5kU0hINHRzdHVoRXYvRDhoTGxENHpCTEhISEplR0FKT1llWmVCbWpIY21qQlBCZmRRTWFrOU5Ucm1UckpYYkRGdHJNTXA0ajVERFBkd0phUjVOOGE2eHh6NDk0cElrbHFPSWtJSWJZVnF4cnFTeUx2b1FlSjlrUGsvd0J1ODdZV2NDNUcxaXlXUmpGckprWHVHb2dzNWhYZ29VcHhXdnRBOXpIYy9MUTlNOWI2b0l2Z2RkR3RTSGErTTNtRHljVmphL1Q0ekkzRTl5clNXOVN3YUZheHhJU0RVZTlObWNIcld1cmQwbFRva0JMMks5dHIxY2ZMY0dRU1c5cmQzTU5ySHhVWERGbVBLbEJzdnZiM0JkL25wNVEwRmdlSS9ianl6eURBZHF4N2R2aDcwL1ZTWE4xVGd6U29TaEFQSS90d2ptT0IvVVNPbWdjL054NCt2VU53OE85OVZvdkVROHhpdkljN2RqRjQxTWhsVXVscGo3S3dNazBEeEpLWXkvQ1BrRlZuVnVKUDQ2TFdSVlUyMEJMWTNaK2xTV2Q0M25zamdMUnZEc1BIbEE5blBhTk5DUVBmZXhNVGN0TUM2N2NpcVJCaVJ4V3Z4MURidTlUajhkQzNjNjZMc00vazF6ay9KUEk4SlBKaXJXZng5bXRYZ3htU1FTV2htdUMwYmZ0S2xBcXlFMG9Lc1RYZlZTaXRHKzVacmE2RzN6cjdjK1BOaC9IOHA1RXVSRjFiWElTYUd6bGUzRWNCSmpSNDBqWXFoVXVFUXJRMFk4dFpPRGwydGQxVC9JTnk0cXhNYUlTSG1zTWpERkZib01QajhGZFNRWXZCSG5PZ2JkNUxxV1RrSGxtWThtZVZtK0ErV2pidTFYSFdWMUs2VXJhdTdwRE9qNTRKUEovdDl4ZGhjM2VUeHNUaU9NOFVlZVNKWFExYmZmYXZMV1FudHl6MlJhOWRFYzRZakMrUytaUTQrN2dudHNUaHA3dUtReUtDR00wVXBLZ0ZSM0F3YmQzS3FDUHlPdFRKUks4cFM0SzZaSHNqc00xM0w1dGhNdC9ic3A1SmlyT3p0NExpV0NLWEVDUjRPMkRJR2Z1VGhUeUQwNVNpbis3WGZWSzR1TnJkczErSTlzOTA0M2ZRQzVTRHhhNEdOV0hQejNtY25FbDFkWlZJTFB0dkxMT1dhUW8wYzNiajVEbXFCcU5vMnVPN2IwaEZEeVZqcWNqZmQzSFhXTys0VTkzZHpHNGJKaU84N3JSTER0SlZTT0tFZ1VwOHZ3MXM0djJveU0zN21LdGxKOUxsVlp0MWJnNUEyNkhpZFdzcExZdGpacllReVhpM1NwTEdGTXRsRU9RUjJiaUc3b0NrMUhWQ0RvZmEyRUsraFoyQ1J2SThHSnNWamNqbUxHM1BGd1oxdC9wcFNPWUphRlZVSkxzdXhyWHIwMEhsdFRFL1U0a0t4VnZrWHBVZzJEeXFLeXNvWGhzT3hGTnpteGxySEplUnFySzRSMVpGbEFrSktHcmJjU05YVnhwdnFVdTdTRGwvZVlhLzhldkpUWlRZMmExdWJjVDJ5ejNpeG0zbG9STUZNdkV2eUI1RW1wUHJxdXlkYnJYUXVUVHEvRTM0RElUWVhGWVhQNFpZWjhRZnFyU08yeU1za2t0NU1YRWp5VE5XcFJRS3FGNWtuMDFUa3B2Y01JeFgycVY0QVBKNWl4d1YyY3RKbXhiWm55U1MxdnBseFVJanRJYlpaZmIvQU04RkR3R3lLRi9wTmRUclZ0UjRGRGErYkZ6eXU1eDF4SDVWaXlMcDRIRDJrR1JGeHphUmxaYVN0QWthUmxYUFRvQURUYnJxN0dub3dlOWxxaCsvMHdaaU9YQllTNEJwTmpaNUxDOEJZYk1zZ2VKZ090T0pDblc3eDY3cXRkelB5YUtTWjUzaWNGaWZ1QjVaSmNZeFV1aGZDN3Q1SGtraWpNRnllNTNDb0JEQmU1eW9LRGJXSnlNZXZVME1ONFV3TGZtSG1OcGxiRlZmR1d2MDBTOXExa1I1MnVGUmdHY245MWFqa3BvckNnQnFLYUd3NGExdDFMc25JZGwyRmZDK1I0KzZYTHlUMnZleWZaUzVFYVNUd3hUU3hFSTdFSklSVVJrZm11aU1sTzZaWFM4ekpYSDNMbGh5SnhtY2d0VFpONzdlZU11MG9hckZsY014Sm9meDFkaFVTZ2ZKYVhKTyt3V1ovczMzVnhzRHZ3Z3loYXdrM29QK29YMkgvd0N0VjBRVmwzLzZtdkdNRHc4ZDh5ekVOeGNKQWY3ZlBhd09xR1VFMVVFRXFhYjdzRzBzaWE2RHFHaXBzUFA0YlpaOURhZVBuR3lOWlNXclk3SnUwVWM1a1BJdVN5eWNtVWphamVtZ2JPOGRaK0FUV3RVLzVrckhaZnhxenhOMWJ6WTYzZ3lGVEdqRlRKL1EvdUJja0ExQW9WUHJvbEx6S1pSam5iR3pmeFV0YjNZdTU3T1kzY1JWZHdzaENPUWY2aHlLc2E2U1VNbFBwZ0Y0NjltanMxa3M1dU56RHhsQzhqczYxallBK2xWTmQ5dExhazVDTGVxaDVsODlrWUNQcThTck05ZUU3eTBEQU1hYmNTZHRPcTY5UWUxNVdxMU5jSWh2cmRJcnBXR0l1Q2tzbFhQS0o0aFJuVW5jQ3JHdnBweUlVbXdGbGJZSjdxenlxNUR0WEM5NmpxeFNGeDdRUXBydXdGVCtHa085VUo4OTFPc29rTGt4WFM5cVlOVVZxZWFCaDhqMDBtcElTWndUbXF1ZS9VZ0VSTUtvaXUxRHZVMS9qcHhpTEZjQzJhNDVBQm5ZdEdPcVVweUovd0REVkdSdE9FRllxMWFrd2t1NTV6eUxFcHNSVWpwcWlJTDVrOWZJemxTck9YalhmZ2FVL3dEaWcwa2hOejExTThYazcyM3ZGT05qWjd5WmhFa0laUXJQSnNGUFBhaDI2YUxWdXpCTDQ0MVFVOGcrMy8zS3pjbHZjeWVOU3hQQkYybDdIRnVRQkxlakUxMzA2dlh4S25Wc1RzcmpzbGpaRGI1V3ptc2J4RnE4RnpHMGI3YlZBWURVNWtpMUFHTE94Q3FUUURZamJiVGpCTEI1aTh4dHdnZ2RWVG55S3Z1RDZFZm1OUXRWV1JPbDNWeWhsWHlabnVIYTBzeEk3Z2tMSSszOFFQNDZIK3pwcXduL0FDUElOZUdlVjVMSFhOdGpZNEkzZ3VtTWNqU3N3VlhyeVRvQ2R1ZzFITmhUVWs4UEt0UjZEeE5rc2srUG5ueWx0QllvMG5adHlUTklaSGFvSm9yQ2dGT3ROQmZhVXdqUi93QXk5dklyL0szajJzYjI5cTF0YWxwQzdmVHhsVDNDUWExWjJBSnB2VFJOYXB1UUxMa2hSK2daazhrc2N4ajhabmJ5T1A4QXZOaE9ZTW5Bc2ZiRTF2SXhkWlFvcUsxREE3ZFQ2YWk4YlRhWFFwclpScWdMNUhQYjNtVVNUSGxmbzUzclpTM2Z0ckZJZHhJVjVIMmVuclRiZlZsTks2OVNuSjFsZHlKNURnTDIxaHVyakxYZ2ZKb3l5aTFDOFVaSG9PU24rcXUyNC9EVThXUlRvdEJYeHV2VUFXVnlveFY3YnpreVc5VmxXSStoWWhlU24wSU9yclY5U2FLMDNFRXpGNUtDejdNaVkrT1V5UWtHUm5kVHpaaU9XeHBWYWI2ZTlOeWlSSmtmTXcyTTFxWHRaZTQ4ckdRVi9VRzZtdndCclRUMGZZVEoyRnpOekJoN1dXREhRTXNjZ3RIdVkyWVQ4dDNETU9SOXg1VUI0MEkyMzFWZXFsa3F1RWRHL2J4c2tuaE5yYzVBbFk4azg4VWtJWHNySEJJeXZJNmxHQVVNcUZCcmtlYXEvZWFYVkpIb3ZBZC84V3NyUnY4QUlnVytmUmJyTnBpY1lieTRhYU5MV0RtRUZzQ2hTWjRaSksrN2FNVStlMjUwcVlYdHJ1ZmJyL0F0dnlkTFZwV1lmVHc4NS9nSTJWYVB4enhlNWZ0aEwzSFc0TXJTSnhacnVkbWlqV010VnZhU1hKclVnYjYwcXI3dVZKZEcvd0FscXpMeUwvSDQ3ZjhBY2xyOFhvbytCVW1OdDZoWWdEei9BUGNJMk8veDF1WGZjNUxIWFFzVEJXbVB0b2c1aWVXVWNVTEFWWGs1b0YzcHZ0djh0QVh0TE5YSFZJWmMwajIzaDcyVE9JN3k1bVR1TEV2RkFsV1VBc1Q3cWRQNDZIckR5SmhUWC9DMCtyYUpGMi85dnhsbkJDcFcwaXRsTWx1d1FKSkdLN0VzS3FhaFR0MXFkVlZXNnpiNmwrZTIycXF1a0EwaThHQnNzeGRTSkVxeVBZMi9KZWJtWGwzQzJ3QUlVRWpmUkhlRVplc1NMMS9iMmR2bnhkZ1EzRi9aTEdsd0FaWklFZFZRVlpJbExOVU4wRkJXb3J0b3ZITnFRK2pBc3FTdks2bzFlUVpmTlM0K0RDNXVNeTQrRnBicjZ4STJJQXVIWXNXVmxIYktiQlY5QnRYU3BqcXJicTlTckplMjNiWXJueUdWSmIvMlRDNFZJMUFsQUlKcU9WR3FBYWl0RG8rblFEdDFOT0Z0L3FjaEVwM1ZQZWZ5MDkzQ0hvcFpidmpveDF1RURzWTd5VXRIYnpnVjRFZzlTUjYraDlOWnVTWDhEWXdPcTY5UVRkNUxLUmVSS2x2TER4WldoaWxuQ3N4RlBkdFJUeXFPcGNhdXJqcTZhZ2VUTGF0OUF2NDFub2NKZHlTNUpKSjF2b3piNDB4eDhZcEkvd0RsdTFDVzJTcDl2THJxckxqM0tFV1k4c09XRjhTMXA1QjVCL2NvcmlXM2pGMEtXYTh1VVVFU2JNekFFVVlEYlZkNXBTQWpqTlpjM1dGSWM4bW5taXRwSWlnU09HTDlzeUVNckFzVHlxQ2Q2VTYvbG9ISFhVNm5sNUY5dlRzZ3g0Wm5jcko0OVpUdGpMSzBhNFpvTGUyK29aSkpralVzMGkxUTlhTXhHaWIwU2ZVNXY3dG9VbzV6OG56U1ozeTNMWkdaU2tsemRGSWxRODBWWTZScUF4cFVVSFhXeGlydG9rWWVXMjY3WVZ4ZHRIK3JtdklmSFRPS3FZSUllTUFiZDVYRDdtTXJ3Q1ZvUDZhN0Q0RTZCeXBtaHg3ZXVUenkyOXM3djZhMnQyOXp1Q1J5NVBUNTduclRwcXZEUjFXb1Jtc3JPU0JPOGNGdmRYYUVySUZNYUl3Nk5RbmYxNkRWaTZvcnRvbXhENXM2UEszRUNoWnExM0xibmV1dEw0R2JiVmtLQ1o1THNNRUJOUTNXZ291OUs2Y2dPZmtVaHgvaDBxMW85ejJvQ0sxM2M5eGgvd0RaMEd2VmsrQVcxdHgvRVd2SHJSdTJqVUJER3REODlXNUxhcEFvOFdFbjA3cnhoQkNlNXQ5aXFDdncwTmt4dU5XVEUveTZaWkpvVjZVQkpKTzRydHVOVzhkTlNQWjZJQVkrSG5mUWhLTWVRRlBXcC9IOGRFMjZNcnIxR3J5eWJ0MmpXeWloSVZRVFd0U2E3NkR3cjFCMmQ2UUttR2pMWkNFbjlOYW44Um8yM1FDb3ZVaXdCYXZpZk9zWGs4bENtUXgrTnNMVE1YZG5KL3lmcDVBSmtoa0tjcWR6a2ltdE4zME9yT3RIT2prT3BoV1RMVkxXZFg1ZVArbzhmYWpMM2VmODd4L2k1K21sc3ZJcEdOL0ZlUXJXWDZLSnBvMGFhak90ZUhCdU96ajlRTlRvYTFvbzNiKzNVNkRsY0xEamRYamJlNTlIMlhnV2w5MnNXM2kxN1lZbU43SEhqTjN0M2xrczhlenRaMmNjTmtZa0M4bFVzN0VjM29vSFFiMHJybDhYSXB5TTlyVjlTeDFpZkhjd3pIUjQ4SCszZmRML0FQRk1vWHh6THJqTW5EZGxpTFcwaHVidVFJUGRJeXhzVTJQVGNqWFRQSHVYbWM3OTUwNmRQMUFuaVJrem5tMW5OTEI3WnJreWMycnlCY2s4cWV0S2pSOS9UaitDTXFucXY4em9aWklUSmpMbFpWbnU3dTVhM3RMYUpQM09NOGZDaHB1VFRtN3QvVCtXc1pUdWhlQnR1TnExSEh4MnpLZVpTWTE0K2RtNGp5UGNjOHpKKzB2YlZBdzJJNUZpQlFiRDFycWx3Njd1OWRDV3FjZjdpM3JSemFXOFZ3aU04emh5SWQ1QnlqWnRsVStwcnlxT2xLMUhRNTkzcUZKUUpIM1p5RWxwNFJucEdMTVpZWXJkQXFsZ084NlZabkRFRWhXWDUrN1RKdHRKK0paUkpPVGlQTXpKSnh0cFdvOHNZaldwcVR6Wm1JL2xybytQV2ZxWlhOc2swbjRINmQrQ1dNbHRnc1RHSFVZK0N3dG9WU05tSUpSQURVTU50dlFkTmJmS2FtTzV6dUhjbnIwQWYrb0c5S2ZhSHl4TFJYbXVidTBqc2JXR0ZYZDNsdUxpUDJxcWcxSlVIcDhOWi9SR2luSzBPQWZ2QXNGM1A0djVFMTNFY2prY0xhUlgxZ0FlN0ZQWlJSd2xwVklGQzRWU0I2MDFPdjdtVTIxU0FWamxja2NaZjJndW1pdDVhWE1rVVNxSTNsYVB0cU9LOGFjcThUL2hwM0JFenNNWGRYeFpZb1p2ZHhWWkZSbVZTekRsV2dKSTA4d09sSkl0RWp4bDh0dDdoQlp4eUZXbEZKS0JaR0hJVUIvcTFtWnZVbWJYRGV5eW5va1hEOXU3VDZ6eHZIQndwVlZNaFlnbGdUVmlRS1VyUSt1b1c2d1JtVkpRZjNPbitvODN6YmhSL3dEaEhBQUVzQUVpQzlUK0dqTUM5Q0FPUTA3dURUajByRUtHdGRqOE50U3QxTE1TME4rTFluMmNxSGpJYWZFMUEweklKaGNjVXRKbURWWGl3QU8vVWROdHRWbDZXa2tLNjdheVkxWWRxUlNra2dWcjdkVFhSbE5scWcvRE1SaUZTZ0xjMjNwVWREOFBrZFZkeTFQUVhMeGVGL2JKdXRGWWdkRHZxMWRCbzFRWnpDVm1nWnF1ZXlsTnRqMTY2aFVmSXVnbm92Qzh1cTEyT3Ird090R3gxK3pwbFAzSHdZdDNTSzRlUzRTR1NTdkJXYUlqZmpRL0xUWC9BR3Y0Q3h2MW82cHNjazlsYzNHUGh1clp1eGRyTkdxRU1IVmd5OG1ad0srNWVtOUtVMWt1dlExS3VPNGR3OTE5VUxtSlhFazAwUmFDQkdZdFZUVWtLcVVLaFQxY0gzYjdhRHpWQzhEMUMwc0poaWhuVkdaNDZ0OWZKY1J3SkcwcjgzVnZjRzQ4bFZxY0VabFhZc05EWG9vTGxkMXRvYy81THh5eVRFZVN6eDVXNmpUSjNOMDk5RCt4SDI0NUo1VmFPSkowa1lJeXJWeVpPVmFjVFVhMTY1TmExYVJsdkRLczEwN216eXk5czRobWNUL2MwbHpveWRoaXNmTE9JYmdyaW9EMllWZ0trbU5oWG0zejNicUYwVFNyaVg0QXRtcGhlS0ovM0grek9YKzIxelllU2VNK1FUM2x4ZUZwMnQ4aHdTMzdqY3VTUXRFRHhiOUxMVUVEcm9MaWU1ZmQzVmFqYm9YNStLazVxeWRlUitZK0IrQlA0ckxlV2w3bFF5WG1SdFZKWmJtOXlkWkpJQXNqaUo0a1QyTVdVNzlOeHE2dTNMZmMwNC9rU2JlT2tKcWYxL29HUHR0bWZ0cjRQNDUvM0RaNEVXR1R0cnVlTEw1V0JZcmd1MExVU0tLYVo2UnFBS0JVTyt3V3VoT1RpeVh1a3JUOFMvRGtwV2piVWZEOGZrQmNkNWFNMzVybDhobWJEdllXYWE0dkxiRzhlOGtreFJUQ3JTdWF5czRIV2hBSnJUMDBWZkE2WWxWUFh4QnFacHU3UG9Mdmp2bnVadkxkempaK3hjWW9MYVcyTnRZZ3R5a0ltSVFFTVFaSldBOXRWOXBZc2RUdmdyMzFUSHg4aXo2T0RTOHRuYVRjTGkxWnJ1MXU4ZE5laTZZUEpKY1hVaXRKSHpqSHVjOHhGVU50N3ZocEtxN01WclErbmRESGtjaDRqaDVzM0ptYjZPQzZScmk1eDFqTEtFaGp1ZVRMSEhFaDRyRzhjVkY0a050UTlTTlNWYldpQ0ZyMVV5U005NVhMSjRQZzdLTEl4SmtieGJTVEl2TkYyYmRZK01sd1RMSTZqdU1TU29DdUdQYzlBTjY4VlA4QWt0b1BreU4wWGlDN09hTHlIT1hNL3dCdXJWcy9ZWXVVT3NGcXZCcDd1YU5FbGFPU1RaVkFHN1ZGSy9EVmp0cy9lOVdNbHY4QTJCakgrSTNDdzV1ZjdvWFMydVBOc3VOc3JEQXlRU3lzWk9VOGlNMFRCYTBYaktGSnIrV2g3WmxacFU2K1pkWEZ0cTNmOGhvbnp2bldHOFFtdFBDY0ZGZjQ2UzV0NDdFMzd3bzJPa2dZQ1dDYTJra1IzTGhlVWZGdHEwM0ZOQ1BCanRrbTc3ZHU1ZnV1cWVqditRdGVMWC9tT0U4YzhsdWNuaFpzU2NuT2JHQ09lSVc3d1JEbkxIOU9RUU41VzRBS2FiMTBkYlphOVVuTUE5ZDlLMmIwa3h3RWVYeDJkeWNTWnZEWUNDSEd3VzJRZTR0cGJ1WmF5TVZrSEJsckx5SFZxTFFqcHF5MXZUb215cXFsNnVBcmU0VEdSeTRpOXMvTGNoa1Z3YnBQWngzbU9SNDJ1WlpPSWFpekpJRUVwQjQwcUI2NkgzWGFhZFVwTG9xbXRYb1Q0dkxmTlB1RmUzM2l1VHllUHNzT2VCZTR3MFZ6RmxINVNoaEhFazhoV0wzUjBaeXhwMTBOWGowd3haSnQrZlFJVjNsbXJhajh6WGNmWXpBVFFSUXk1SE1jdVRYRjNGYzVOR2U1YVFFOFhrRWNnSElLQWUyM3I3dFhmNUZwYjA2ZUJIN1ZXb1UvVXREQngrZFdkbStQeGVieGNWbGFFTGpJZTFKY2NMYmdGaUJsTWFEa0tWTlZQOE50Q1grMW8zV1MzWmR2d09kRDQ3NXhZNWZKZVBERTNXVGdXNWtnaHZiSm9ZQzEyc3dsa25JREIrTG96ZjBoZWhwcllwbW82cHZRekw0N3B0SWxaWjd2TjVXd3RzbGdwTWpCWi84QVYzTmxmM3RyYnRjQmxaVlVTTksvT3ErNVNSU29HbnRlc2FQOGlLeFduWDlRcGE1QzZsenl6UytGelkrSzNpRHdDUEsyUWpRUkFkaEN6c29LTFFIaUFXM0pIcHFtMTRyQ3RyOEM5VE10TDZsRS93Q3BLSW5MNFcvbHM3V3ptZUs0RXkydHdibVE5eVFTeDl5c2FBVVZ2YnhxS2V1dERpMmxNQTVOWXNVMFpoOVRBUVR5NGtNVC92ZTRiL25vd0VMZ3hNTjlsUEdZN1cwY1NyY1N4cDJDUXhKSFJRT1FwK29zZHFhb2Q0Wll0UzNQRlBJRXRjR3ZnNzQrNGd6Vm9zOEN0RGFGdStqcHlTVlpBd0ZSSWZhM0tpcjByMTFsNWVPclpON05ISG1kYWJWb3dkalBHN2hMcTBtdWJjNDZDMFBLK2p2THkyamtsYmlEWHR5eW40dCtrMFB0Tk56cTk1STZmb1ZySFBVWVRpTHZ5T3hzN2ExdDdiSFc3S0VQREpKZXU4VVV0RUd5QUIrNHpFbm1RYTA2YXJ1Mnkrb0F4L2ovQUpMNDE5UGpyZkhESlgwVWQxWlEya015bThidXlxL1N2RkEzRS84QUxia0VyOHRLemxha0tKcm9CTDN4Znk3T3h3UzNsdlpXYTRpWXBPclhDcTZMOVNaakVCS0JYZ1c0OVRxeFhTZWtrZHJpZk1qWnJHNHk3dTdiSlhHV3hrRmJlTkw2T3JzcnVpb2lNSGlUaXcycTllaEI2OWRXVlZvNkZOblZzei8wejVJd2VSZVZlUFB4alBjUyt0eEdhZ2NYS3R3Skc0cHdwdHJjNGM3bzhqTnpkQzl2dlY0L2UzT1c4ZjhBSk1UQ0o1c25ISGJTSVE3UnU5c1NGN2dBS2dLajFCNi9MUW5PcXEzTCtNOXlLa2srMkVsNVkzajN0MWFZeUNONXBiTm81MGt0M200aFNGajVsNHg3UWFIL0FHNnhubTIrWm8vWlZ2SVFzZmc4emhiZTY4b2xuczJ3dGxlL1NYMXlseHlXU1c2alplRklnenJ5WDNvZU9pdHlzNEI5bTNXUUQ5eWJKLzdiSWUvWnZOKzFkRzFzbko3VVVtOUdKVlFXQk82amZmcHFlR1NtNmdycXl5RW1OeWVPeTBIdGx0Wlk1Vkk2OG9uRGovRFJTS2p2cjdsNGUzOC8rMWVXTm95c2ZvMXkxbWVKWjZkdnVxVU5kalJob25KU1VtaFZ2ckJSUGwzM0QrMG5rWDI4c1hsU1dmN2kzV0xSSXJhMVJ2OEFwc3RGUkE3c3dBVWMxN2dveDl1MU5aeXhOV2tKZVdhd3dMNWRsL0ZmSzh5UHA4YWxqZXlSUTJ0ODlteVJ4VDNnZ2pNenBHVTJySUdDNzAxUDlxSzIweU5ZMm1JSXVNY2s4c0t4d1hXTTdNeDVFdExKVldQUWRhVm9OS1pTWTZYWUIrSnZoKzlIRmtJbUVCZG9id1JidUkzSEVtbnJRNzdhZXhQRXRTVkpGaTRJWkJmM2IzVTl2Q1lRamtIZEpLY3dTYTFvRHNkS1pLMm8wTUlwTVlVaGt1cnA0b3BKQ3RxaFVMRVltUEUxSy9Ib1RxUXRCUHhVald0MTlMeU1TaHpFU2xhbmZZbW5VRHJwMlFrSjVJVDNObExiU3lySk9WV1dNRmFPR1NwL1Y2bW5YVERneGJ4b1lxZzhMWlRYbEgvVXhGS0VIZWhJOU5TZ2lhcnFUdldzRHFwUmxVeDhXRktsYTBiZmZvZERYNmhPUG9leGg1SFVSZ2JSaHpRZlBwcXJRSVBKQ285MzlKLzI3ZE5KSVprU1FvS0RsNmhRZmo4L3kxTWk0TDUrMEgzS215cko0dG1wVEpkUVI4cks4SnFYUkNCMjNQcVJYWnRWWk1la2xjdzlCais3bUJoOG94Zjl2TWEvM1cxaGt1c1ZOWDNOSWhySkRUNE10S2ZQVmVLKzF5UGRObzVOZUlGaWlEZXU0UDhBNGExQU15aXM3Z01IN1kySUtnMVhvYW5TRUc3YzBja0FjQUtVR3hGZi9EVFBvT1RMRzJMWkZvUkord3ltU0hmZnVEcFN1OWQ5Vi91V3BJUHg1bFV4MXZJNk8wa1Rkb3NYYjJ5VjNJSG9OdFVQRTVMMWxTVVFSYjdQV0R3aUQ2TWRodVB0YzhtUHpBOU45SlliTHVKNXA2b0gyOXhqVmd2THlLeER6b25PMkpkeWVWYVNLNFUwM1dwSHcrZW5kV21rMlZKcnFTc0prY0lNY3h2akxJbmFrdHAwNUIyTWNocXZBYkRsSHN3L1BUV281RW5QVWcyOTNJNGl4K1Z1Q1l4RzBjWTRTTktJM05WSEYrQVVHdTIrcDdGMVF6czMxQUZ2SUlMaWVJRG5ESnlqZU50Nml1NDI5ZHFnL0hWN1VvaWlVK0xNWlFwUGJ2WjNhbVMzdUdMb0NGUEZ2YUZxQ0NOeHFNeXhRR0xteHhVVWEvU3pTTXY3YlBiMndNa1pOS0U3MUk5d1BYVmRGYWRVU2hDL2k1b1k4cTFvMGtrZVB1MjRzc1lVdFUxNGZxb05tMVpkU3A4Q0s2blQyYzhodE1KZFlER05kUTJuajJJSWdUbVNYdkxpT0pUS1VBcVNxTzlEdDFycmtLWWJaRmUwVFova3Y2bm9MNVgyclZxMmxWZm13Wkk3MlBrVWVQdG1pdXBiUzNJK3NsVUszZU5DNUpBUE10WGV1NHBTb09wVlc2cmIwMTZCdDVXUlZyRm5WYXZ6L2lWOTkyc3RaM1M0ekNXVXd1WEVrbHhlU3NnV1JHVnUwc1pOQWQyNU9SOGRhZnQySnB1N1Vka2Mvd0MrWjZ2WmpxNWZWK1hrRFBHOENieTRpdElWN2wzTVFzYWphbklFMUxHZ0hUZjREUldUSVp1SEZMaEZueTQ3QzRpeHNaY2hjZDB4cVZXSVVraWhKRmFsZmF4WWsxTGVsUUthelZlMTI0VUd5c2VPbFU3dWY0Q3puTXRKYy8ydFpJbWd0STNSNVlaZU1nZWxTamI3MG9kdFg0NnhKUmx5dmJYU0F4bUxpNEdQYXllTkVnY0s0VXlod0dZTTN1WVZBOVFRS1UxVmpxcDNDelpYczJ0YUNqZDVqL29JbzcyUnJTMnNKMmtSL2RWcFpWalhrcUhxVjNvZEdxdXVtc21WYThMWFNBMzRGSGEyT0R2c2pscG5zclBKWDZ3eFpDY2R4NWpESjNSSEdyS1NLOGVURnVyY1Y5ZFI1RGJza3ZEb1J3VlcxdHYrN3FDYzM1V21XeWR4ZU1za0ZsZXdyYVR1R0c0aFo1cHd5cUtIbkkzWHBxN0ZpZGF4M0I4dVZXdkxLY3Y3ZzNkNVBja0VDVnl3Qk5TRjlCWDVEV2tsQ005dVdNL2c5ZzAxdzF3UjdlUVhsU3RBT3AvbnFuTTlJQ01GWmNsazNOZzNjbG5qaFJrdDBJakZLTVFnSE4ybzFCOFBqb0pHZytzd0tkdDI4aFFGdWVTdnJqZ2ltTU9VRE5RRUVIa0NXYm9LRDQ2dmVud0FkTC9HUno4a041RkpZWXFaSVlwc2Zia1k2MGtTTXBFbFR5a1Uxb09aVUdwSjZmSFF1TFdiZUlWZXUyRkhReThVdTVibkkzdVFuTWNUV1VRVnhFWTFTUXlPRU95anFxaGd0ZmpwdVJwV1BFUDl0VCs3dThFYnNwbmJMSXhORjNBakkzR0tBQW5tejdLcEh4MVZqcTB3emxjaWxsQ0RlZnlMNE93V1dhTGlNRmlKbkxEYi9xcnNCRVdvOVJ4OVBqcXlpbHg0c3lNOXZ5UlFtSHhqVFMyZ21LaEZjeVNzQzNJbGgwTmRoVFd4ZTIxU1k2VXNlN0EyNXVoYlJ4dVFTb1FKUW5iclE2ejIzMURxMFNVRmgrT3lDUmJ1Y3dFV3FTcGJKd0h1ZnRidFdoMzMwSGw3STB1T2twMEVUTHNMM3lmSlhrZkQyc0krbXhFUzBQb2ZYUk5GRkVtQzJVM1lLejl3eHhhMFBCMkpIdDIyMlhjYXZ4UnVCczF0Qk1rZFJBL0Z6emFvb0cyMytYNWFOQVQ3SFFTVFhDSkUxWm5JU01VSDZpUUJYNWI2VGNEcFN4bSs0NnlXbG5pTVlaQkk4eGt1WkNvSVUwcEd0S2s3ZGRCOGQ3ck5oV2FWV3FNOE1vaHRGUXJUaUI2YjdmUFQzcmJkTWxDaUEySkZTQ1YwVmllSWo5S2U0am9hL0xVTXJlaUVWMTVEZExjWGJFRXN0UUVOUDh1aU1OWXFRWjc0dW9PVWlrTFY3YkdUaDhSR09YK3pVNy90SjA2a3J5Vy91THhSUGRJa1V6aXJSeDhpbzJBRk9SSjFWaXFrM0JabHM3Sk5rVHhXMmx1NzRSUjFhU1NrVUtydTNja0lWUVB4SjFiZm9WNCtwMFg1bDlvZnVMNG40ejl6ODdrL0g0c2RiUy8yYTJ0QkhQSGNockcxUEYrMDhkQ3pjNDdjUHNEVTlPdXNkZTQ4ZkxhbEZhVzdOZlNUV3hZc3VKWHV0UFNHL3dEVGI5b3N4SG5QL3dBWS9sY3lyWjRPNHZzWmpMQ01GSld2WUtXODBybFJ4N2FGcFVHOVM2L0FheS9lL2RNWEdwOXBmdXV2bEJwOGJKbjVWbGJJMUZPbWlYK3BGLzFHWitNZWNPbHJJT09NeHdndCtMVkNTWFRxSGI1a0tyZnkxbS85ZHc3c05ydGZ1dCtob2U2WGVPbU5kOXRuOVhCVDMyOWtnZTd5MXhkeEdlQzFzSktKSlJneG1aWTBIdUJIWGZwNmE3TE1vU2p4T1R3dE51ZkFOK0FXb2lseTJaa203YzBVVXZhdUdIT1FDZGpHWFN0S3NXOW8wMmFZU0k0VXBueUxYOFl4Y2E4YjV5clppYUZZYmRMaVZqQkRhMjNKWFlOMUJsN2JzU1BUYjQ2QnkyaTBMcDNEOGEzS1gxN0ZsL2I4aksrUTUrZUtScGtzSlpMY1RzT1FsWnVEamkyeEtvQ0UrVk5CV1Ryamw5dzFRNzdWMkhLeUszOEJRUnE5Z3pKQzd5MWpXUnd4Wnd5bHZldEFUL2svM2E3YUJ2Wmw5YTlvSzkrL0dSK204RWxpamlqSDExMURHWEFWU2lSOXlYaUF0TnkzWDhOL2dKWWF6WlQ4U2RZVXRlQnlKYVdVT1Q4eXc5bGNIanp2N0tKRnFGWDkyUktsdmtBMit1dTRVelZMdXptK2ZHNXoyUitwa2R3SGpXMnQ3KzNTejdmQ1NHU1B1MVVmRUVBYjlLYTBMMTFiZFhKazQ3cExxUVBON1dEeVB4RTJVODRhT1M2aGthNXQzYTNqU1MzNVNwVnVTc1Bjb0cxZEEzVFRoYUIrSzZhbnFWVC9BUGlBOEhLUVg4V0lzTHErYjNTeVRxYm9uM0NnNU1qRWJWclRZVjY3VjByS09wWnNUN0dxMXR2dEppN05jaVpNSERhV3dQZlNOcmFLVVNiaEIydTZYSEhpMUtydWRXZjQxdkRxVi9kb3U0UThLbThVOG10NzZYeFM3Vzh1cllkNjdEOXRYVkZvbnVESTVvYWUzajhEODlUeVlIU201eEFxWmEyY0xxY05aaVNRK1laeHBGTHFKTHBWYzBZZjVRQjArT3NyUjBVR2xoVFdYWFhUK0JjL2h0MU5CNDVhMmFqakMxdEN2TmQzNUdnSjRoVzlvUFU2ZzFMYktXL0E1djhBTTUydVBLY3pLK3pQZTNITGlOcWhpdFIxMGRpL2F2Z0JaSE5tYjdRMHR3ZVZLRGRhYjdnblNmVXVyKzNxU01aSnhDRmpVTWo3RHJ1UnBtUnFFekxIOUhPalZKS25ZamF2NTZyYUxxMlVPU0pPL3dDN1pnMFdNV3pyWDQxWkIrZlRVL0g0bFU5UGdIRm00WVczN2JCdTVLd0E2R20zK09xNDFMUDdRRmRNejVXMUpxUGF6VUhvVHZYVmk2RUoxUVl5c3lDZEtuM0NLTXFLZGRxblVVaTEyVUNlMGxieTdZVjl6L0xWM1lHM2FzYlB0a2lQNTNoRU12YVI1blY1U09RUU1GQmFtMnc2blVidDdYQTFQM0l2eHIweFpuT3pCaEkyUEtweURLaXlKMERIa3dCcUswcjZWb0tuV2VrNFhtYUc3VWRQSE03a2l0d3dYak5lckk5eE5NRXVBeGpGRmJtUGNRcC9TaWxWWGx1T3VxY3FrdXBiUTN3WmhNZTltNXlVTU05dEFKTGlPNEJDSzB3WGlXYWhDR2dYMXIrb0hwUVZQRTlkTkdXckpWUnFVbDVqNURmWFdaem1DTW4xdUd2c2pGYjNsOUFvTWNhL1ZTVFBIR3lraG5rNTBjbzIxZHpvL0ZpVUswYW96OG1aK3FxY3BoSEErRGZiS0RQdzMwdHZlNHZMS2pYOGVIZTVhOHRZYmprZXc5d0FvY01BVWJpalB2VUVDbGRSdmZLMDBub1NwWEVyUzFxRGN6NVJrN3ZPWkt4SkMrYTM4OHNkdkhiL0FMOGx3THRWdGx0N0pZdzhYYWV0ZVVaMlFIa2E2a3NkVlZOOUVWdTluWngxTm5ubDFuY2pleGVNK1RYYytFOGt0bzdTM1RFVFU0VDVGNWdqVEhqM1ZsMklLamtwQjVkTlR4T3FXNnVxSTVLMm1MYU1zVHlyQmVHUTRKOFIvd0JwTGs3REVTQ3htdWJkNTdPNHJhc3F6eU95eU5ITEl6TUdTcWloTlBRMEdwU3plN2RFaE9TMVV0dTJVZ2JtY0I5c3NOYkxMZ2NObWJ2THNpVXNNamUzYVdrSE4rRE1JSUg1eVBHd0FLbVFVSXJ2U21ucDkxdlcrbndRMS90d25XdjZndkZ3ZmErOXhXQ3grUjhVdnA3d0oyYm5KMjF3SU8xT2dZTVJNNmdCVjRVSDdsYSttckhqdkxhc1FWNlFrNnlIdkZ2R3ZBN3ZPcy85MzhndmNYZ1Vqdk1mZ0puU1FKUExLVWpaRlprRE16SDI4aitGZFJ2dmE3YTlXVzBkVmFkZE9pSlVWLzhBYXViTHc1S3c4VXg5dmw4ZzA5N2s3N05oc2tFbGhsbzBhSXhFYXlHblFSbXJHbTlOUmVDMGEyYlhoMEU4dFpsVlNrTCtGK1VONUpndklNMW1MYTN5TnpGY3BIZ1o4bGFJdHJaVDNzN1JNeXhTS0FZYmVOVWtQTmVvcDAxWG13cVVsMDh1NCtQSzRaaDR4NUY5SUx2SFpTMlc2aHZIdW9udjRoRFlXOTQwRThrY1NNb2FJTXNnWldxQnhZNmZKaFQxV2tFcVplejFBM2tHVmJKNXZKV2x2Zng1Vy83Mk94Q1lXMFI0K2N4VXlPWTVGazRzNnIzQVAwZ2NkL2hwWThPMWRJWGlSZVIyODMwZ2s1akp6WDJHdlpQSjRyM0IzVi9mRy83dVJFc1VIME1KUEZWK2w1RHZkcU5lVVlxYXVQNmRUcFZKK25zTloyVll0b2ZYY0diOHludFBHbXVXaUdZdllMbkh6WEk3c0k0MmJHYnRLaGpCVlNpRWxEc3piblU5Nm9wOENNTzJqN2d5OThKdzloYzVXNHpIbFRYbWZXemhFZVBzYlJZWXhHczBkc1ZaWldsV1V0M0QrbHErM1VLWkxXamFsQW5qclhxM0pMbjhWOHBUR0xCYVl3V01uYlpyekpYMTNiMjlyRENGZFY0T1daNk43TisxVWJqcUs2VHowVGlTeXVDejZJbi9BR3N3T1B4T1pTVElaaUxLWnE5NFF4V2VPdHBsdElVc1l3RlZIbEM4Mzk1Sko2bmVtaGMrUzF0RW9YNWhlRENxMWJlcmYwTDZ0WUxPYkhTVzlyeEdSaldxZ3B5RVk0OEtoZ0NGNUFDdjg5Q042bGxVMDVqUm5pdEliYVlLRWhqVGhJWWs5bkZpUGVlVkNWRlM5YVZKcnFEZmZVZmJES0srNDlpY0g1RGtjMUdHV1RLVFF4enR5a1pHaGF6ZFFTcXNHQ2pzYkRxT2xmaHNjUjc2SmVCbDh1S1hueEtrc3Z1dm16anpsYjdFdzVCSUJMQkEwdjdkRDNVVDIrMGdDc205S2loMGQ5aGRBTDc3OEF0amZQWkovSU1aZ2NzMEFrRnRMSFBNVmREY1NTM0N5bUlGV0pVQUp3QjVDdlRwcUdYRjZaUlBIazlVQ0YvcUh4czE1SmJlUUJYQ3hjSUppNmtCdTl6a2pZc0FJK1JEYmhUdDhONjZseFhDZ2p5WmJrcEVOVzFFbE40bVJxL0xkVC9zMGVCRnQrR2NuOFdubWhkNHBFNWhKUTRWVExIUnFIK3JkS2dVOWFhb3RNbGk2RmxZaklHWEE0YnllVnZyQlkzTW1QdjRXL2NwQmRxUXFPZDZqa09TRnFiRUN1aExTcmJRdWo5S1pBODB5RnhiMjZ0QkRjUndTM2dtZTBGWkZqalZRQUZjcldsZUxLT2xDbzMxS21wRzcyNmttLzhBSUpyS3lzYmpEeUdDMXRDSldqUGNXRjBkWkdVdnpDdlVFY3FkT1hRZkNWVnJxSzFuR2hPOFN6K1V4dDBiZ2hKSGdtZ3VJWTlnRUxtTlpPS2JFbHdhY1R2djBMYWJORmxvTEUybUZQTWJDNnRMM3pQRkswa1ViNHV5ek1iRTl5U1c1alpETE1qMDRpUll6djZIYXZUVkdKcHcva1c1Vkc1RlE1V1N4dW9yaUNDMnVMYkhUTXZham1tRXM2amd4VjVHUEVrclE5UjZIMDFvcGdUUGZ0TGtEaGZ2WmowaWtjTmtyZHJjbVdpRXltTHVLRytGV2pBMytPak9MYUxvSHlyUm5XMzNQbmp5bjJreUY1WXpudTJNMXRPNVhpZU1kVEcrM1dsR0ZlSjlCb3puVWxTaW5qM2h3VXlsemJYR0lreDJOaUV0eFoyUXVJblltcHVtN2FFcWVRNUJTeGF2cjh2VGxiNG1uTE51dVJSQlZ0bERjTmp2S3NUTXhFek1sN1BFaExqdTJCMmNEYzdpUnlPdEtiNk1UaHJ3QkYzRnk1aVM4eDAwaVJMeTVkcVprRy9KUUtqYyt2b0thSVNnZ1YreVBIREpHMnpRUC9NSFVpczc3LzAvNXBmSmZ0TmlaSktUUzJ0dk5oN3RUVGxTM3FxZGZqR3lqV2ppU3RqK0JTM0Z6bW55ajdaMnVKdFpiSVNRV1UwMXpKSlBGa0owVzVpY0Z1RlZHNlY2Q2xWSTlkWlR2RGdMMjZDdlpZaHNmY1IzTXR6YlhQMDhvQnQ3ZVpKSmlwTkF3SDZhZm5xTHRLZ2FJQ2tNc2xpNlQ1UXlXY1NUcE5hdEpSSkNhcXg1amNsU1A0K21uUzBIbUdRN2tOaU0zZUMySWFPVnpjUXlMUW9ZNWFPaC9LdWxHNnVwZFcwV2NHVTkzTWtnbStsNzhqc3R4T2YxUmtnY1NHUTdFVkJQNTZkSkVNbldUYkxlM044a2t5V29nY0lzY2NNaWdlMUdINlFCMEg5V25Ld1BFdHRiWkdDNWRTMDdsWktnaWxWQUJHeEkxSVZkR2pabHBsZ3lNMG51SGNVTXNZNjhXM0pINTZhcWNha3NpU3RvQ0lvRDJIUUFHZTNsS0J5d1VjRzNWdDlqcVJWQnJ1WldXSVJTTzBqb1NTVDhXOWR0VVhyTmdqRzlEWFpUbVB0MTNZQURmb2Q2Ny94MUM2YlpkamFYVTNOSXNrRWFLdEhUa3JBQ3UzcC9qcUhjazNKQmNFZ2h3ZUxDbFNOWEpvclpaMzJTOFRteU9XR2Urb1JSYU53RUNWTC9BSitncnFuazNhVUlndFhxWGI1dlBMaG9MTE9zalMyOWhPTytxajNHS1VGR093T3dCcjAwSGpVNkU3V1p6ajVFMWpmWm0rdjhmRjlQWTNFbmNpaktCRHZ1ZmF0UnVkOWFsRTFXSDFCbjFBc3FrZTBqa2ZrTnRXRVNHL2RSZ3dVaFc5ckhxUGxYVGlQYXl0R1ZWeUN0Q2pkQ3BCLzJhYVJqSlpKTGgrejNPekJjTUhsS0RsKzZxME5GNjcxMHpjSWMyTGo3YVNTVGprUVhqaWFXSkRHVmRuUVY0SGNpdEI4ZFFkcmVBOEx4SWRsZjI5bFBHUWtqSSsxd09WZVlKb1Fvb0FPdW52U1NLWXcrUFc5bGljNkxUS2dRNDY3QkFlOFV3SndQV3ZJQWlvMjJPeDFWZmM2eWlkZEhxWmVXdGlreUMyV0x1b3JtMmdoZTVzTHBYTGt4T1MzWWR6UXNVM0FKMCtKdHFXU3lKSjZNVC9xWXBaREkwUlYrdFVhbTQvR3VyeW9LMjBiM2VNV0sza1NRMmp2SUlTM0dYakx4NUFWQUIzMzYvbHF0NldrbE1xQXhiK0Y1WjZ6MlYxYkJKVlYxV0s2RE9CeEhYajZEVmJ6SWtxc1VNcGEzRmpjU1F6RGpLamtodXBQcHNmWFY5WEtrcmFMdzhvdUlyV1hITVk3ZkozR0t0Rmh0b1laTzhpdE8vY2s3emcwRDFaeVFQa05jN2hUdFBWYm4rSU93emVoMW1MT3EwUy9pR01lVXBkWGs5bUk1Y2tuN0VTUnVWWUl5b25FR3JiRFlIMU5lUjBOZnNrK2hzY2JTenRhdjd1blhzVkRtTHovdUx5Ky92bDk2R2Jzd1ZJM2lnSEFiaWdOYVZycmN3MCsxaFM4djFPUTVPVlorVGEzYWYwTEU4UVd0eEVZNDQ1NW9sYVZJWlVabFZsOXBLbFFLbWhydjBwb0xMME5EanZYVHNGc2pmWDd2a0syOXVuOXZpa2toZVFGMU13QmRnRitIcHlwOEJYVlZhclRYcUViclM5Rm9nRFp5dk8wOTltWUpMbTRnQWh0NEllRU1hU1NMN2pzVFZWQkZkV1dTV2xkQ3AybXMzVGJSOTVIY1MyZDdIaTdDTVNLYXhPUUtxcnk4aklBS0gyZTdpUFgxMVpoVzVTd0xrWkdvU0ZmSzNGbGtiNjFzRmtpWmpOOU9yVElTaWhDVjVrSWR5Q2FMVDRhS3hwMXEyQTViSzlra1RyTEdXOXhsTWg0NGw0bHJEamtsbnZNdmRxOG42QjdZaXF0U05Xa2ZjTDYvUFMzdmFyUjE3RUhXTE9zOUFUNUplSENZbU8yN3R2SmtMcEdTWkxRSHR4eHVHQUt5VklJclgycVB6MVpqVzYza1VYVzM1bGNVTEhicWVnMGFEai9ZU2Y4QWIxdGJ4M1VMc3hGRzdNZ1FoejdpSzFyME9oclZkOVVIVnNzV2xrSEpMdktuR01vQnRvTHFJeXd5WEVsZjI1YXIxVUhjME5BZXVxblJKNmx2M1c2T0ZBTHM3dTh4YzlxbjB5eTNVYkI1RGFTZjlTaXEzS3BVRFp1TmYvTFV0dTZkUWRYMnhLREdaek4xNURlaTdpZ1BHK1JHaGt1Z3FxcVJmdDFWa29hTHg0aWczL0hWVktiRkhnVzVML2NiaGRmRW4rTVJmMjFwQ2JpSU9vY3c4K0lKbVFBeGxPWTNPNGI0L1BUWDFMY1UwWFVPV0V6ZVJTUHpXTzdqdGxEUzNiTFNWcEpXb2pjcWozZFc5dTJxTHJacWkycmR0T29zZmNueWE1dnJJNG1ObUgxZHdzVWc1c1EwY1pCQVBJbi9BQ2duUldER3QwZ2VlK2tDNVlUU28vSlRIOEtVTkFPbngwUmR6MUJLOVE1WXhNcnBJSkZEOHdLc0NTZDYvd0NiMDBNMmd6dDFnY2JmeUM0eFdLTnNleE0wYlBJSFlGUnpsb2FxVmIwSHgxUmFxc3dsWGRLNk1SNFhzMGE0Y3lUVFhjamxtQ0ZLdWYxRWpxUUtuMTBVcU4vQUYrNGt5QjVBME11UGluRXI4Z3hwQVY1YjAzTmR2VS9EVjJPclRLY3Q5d3F2eFlBS05nTjZxZjhBdzFlRGhieGsyNlphMk1xMDR5QnVSVS8wMTlTQU5WNVAyc3N4dUxJbGVkWGtXVDh1Z3Q3ZHhKYldrVVVJWVZwWGVSdXZ6YlZQSHJ0cEw3bHZJc25mUUlRdXFxdzlGNjcxcUFQL0FJMjFGdVg1RkpObXVJL3B6REV3VjNhdFBXaXJ0MStiYXJzbjhpYWFSWFdWRXEzYnhzckJrWTFVOWRIVTZJcnM1Wk13YWtrZ2dnRUZpeTFCb1B3MVhsNkZtSko5VFRuNXk4M0VLUWlnS3BOZlQ4ZXVueEtLalpYNmhpKzFNeHR2TXNGYy9Udk9rRi9iM0xwR2pTRmt0WkJNeThSMS9ScDhpbEQ0bkRPdWZ1Ui9xUXgva1hqMXg0K2x0UFlYUzMxbmRTd3l4bXMwVm5PdHlZcXNvNDgzalVIL0FIZmpybStMN1RURGRYNnhKclp1VlYxYVNoZzN3WDdxcGEvYjdFZVBZbTdhMThrdExkdnFMeVZWYnUzODhyM0U3Ny9yRHlTc1NkbUdwOHoybkJueWIydXlYeVEvRzUxc1ZOc0pyektoKzRCOGo4bm5tdU1wYnhObEVWaWI2d2VDV0NlamtWY3h0eUpxVFErbncwVHhPSFRqS0tmdDhDemw4Ky9KcWxaZnQ2UUwvaTF0ZjRQRDVXYTl0NFpZWm10clpoSktRN01ITW9DaFFhMUkzM0cyanJ0V2FNMnFkYXRqaDRaWlcxMWF5QzR0emFDWjQzdDVOamI5eTNia2lGQWErMHZ5L0dtcXN0bW1XNDZwb2QvR2t0czVmMjBPR01iMlVabHRZd2pFTjNoM0dKWUFWUlZpUVVVN2prVDEwRmxheHphd1hpbkkxVkZsZmJuTzRmRjJ1ZlhJWkNDQnNjN0VMSTZvcjhWTWhia1R1ekVyODk5RDU2TzFVMFg0N1JhSkpkcDU3Z3paUlFXY2l4TVNVdUdlT1FySEdmY1pGNXhzejhndEF2V2plbWhMY2R0NmhLeWFhRlcvZnJ5dXh6ZHJqY2ZaU1NTT0o1R2VGNHBvbDJSQXJEdXhwdnVhKzQvbG9yRlIxY3Z3STF0dWNMVXAzN2FXUzVuN3llTldMeDk2SnNxanRFTmp3dFY1RVYvQ1BYU2UzcUhVNS8zQnpheCtrVUV0dlJRdGlBeEFVa3BLMVFkdmN4RzJqY2srUDZHWlZwUm9Tcy9MOVBiNCtNMnlpQXZQUEpFTnh5amlvbS96TGFBbjFTYVZlZ0R0UmNQTEN5anUwRElnTXc1Y25ER2c0K2xmeTBRL1ZWOXRCMzZXa2NxWi93QUs4b3dNMlF0TDNKMmNjVWNzaHVFZVNraU5jQUExZFlUNk1RRStmNTZJdzBkc1c2VkMwMWEvUXpzMTFYTnNpemIxMHE0K3ZRTWZiZk40ajdWWS9QeVIzTVdSdXNuYktzZllXVU9uYTduVnUyUzI1cDBHbGV0TFk0M291cFhMVzAvYlp6RG01M2tlOHZXVmxOek5JNzA2KzV1aC9QV0hTc2FHdGV6NndXOWlSbDRjQmJ5UldjYnhxRUhjRGxKVjI5cmJEWUNuVmo4OVUyeVVUaWRTeGNmSnQzUm9jNzVhUnBzdGRTdlhrOXhNekFua2FtVDQrdXRHblF5OG43bjhRbmJ0eGhadzFHQ0duekxDbW1aTk9EZmozS294NmtSMFVrL0ZocERvSVhMOGNkTUdCV1NsZVFKNkFqVmZjc2VpSWR2T0x1ZTNMSXk5dUZrNFNnbzFDNmxUVDFCRzQxWmFzSXBxNWE4aGl1aUZ4VnZXbEEwakpRVkZUMC93MVFrRVBvQVpDelpLMVlrQmpHU3pWOWZYcHF6c1Y5NUNXV1lHNEczdWFPUGw4QjdkUnFUc3ZBVXc5TGk2QjNxMjU2RGJWL1lvblZ5SGZDNXBrOGl0T3daQktlNnFOQTNibEJZS0tvM0ZxRVYrR212b21MR3Bza2RBMitHdEZ5ZDViM1Vrc2hYdDNFc1gxbHlHbVNuQSsxSFhjTTNIbFdsYWpXWTd2YnAvQTBWaFV3UWZ1QmliWEQ0bkdqeFd5a3lPUnZMcG9wMWlsdVRKS0doY2tFbWJreXhrS2ZRTlgrRXNHVjJzOXpJNThhclZiVUphK0dITGYyekZ6ZUwza0MzczZpOHlGeExPbkhoVHVQektxZ1ZVRlB4MkdpMWtVenU2ZGdSNDMzUmo1Smk4VjRaalVTMHNlRjhzOERRMjlya3BiaEkza0hkVjJoT3hkbDdiRUdtbnJaM0d0VlVKRTMzRXhiNWk2dWJhN25qR1NnVm50Mkg3TFBLVmVSa0xFa2NTR3FHMHl3K21PeEY1TlIzKzJubVhqbHJjWlh5VzB1RXg5eGNSd1kveHA3enRxMFBDTm11THNncW9WV0o3YXNlcmFENUdKd2xFK0lieHJwUzVna1lmTnhXT1d0UExmSmNkRGxMR3pjWFJISlZNTTdTRUV3UnlMeURNejFGZjFmR28xTzFGYXUxYUNyZlphWHFqN0krUVE0ZkhZK08waXlHVThvdkx2SVpmSzl0N2w4YkJaM0U2a3JNU1Y3ckFLa1FISDJxUzFPbXJNZGZIb2trVVh0cm90UUhnODE5MlBPcmxidndQQWlERnRKY1cwMHJTQmJOcmlZZ3pFQm96N1F4TEFEZGRoV3VvNVB0WS93QjNVblQ3bVNOdlFnNUR4LzdrWnZJSDdlWVRGeFhLdVlyaVM3VldzckdLUzNrTWs3TzdCUzBhRi84QWwwcnVEVGFtcHJKUkxleG5peU43RUVvZkY4bGk3dEU4ZHpzWG1lYXlzcnc1Q3lqdDVMRzFwYnhPc0VkdmN6Z0tPMnpsMDVVNUtBUWFqVWQrajNMYXZ6RnRjNlBjWjMxMW52RDRiZS95dmlOekhZWGJyZDJxUjNFRjVCSEZBL2RZVHNoZGYzU0EvS2xlaDlCcDZPdGxvLzRENUZhcjFSczhhdExqeTIybXp1RnlVdWJ5THdteHlNdC9JSWNWQTdSOFlJTGY5S3lOVVU0cldpYmx0eHFOcmJIRC9xTlN1N1ZIbVM4RE1tZkdXOHJoUGk5dGJMR3ViaGhKa1I3bXBLUldLeEZtazVuak55azRpUG9vSUd6L0FIazFGZFcveHFQOXFITnRJSER4V3o4RXhRdGJyR201eitmeXlXcVJadS9tRU1FSzNaSWFNS0JGMitRUm96TCtza0VFNkM1Q3lQcTRqc2czajJ4cHJTZk5nSHlTM09OOG51Y0pscjk3dkYzTnJISUlydWZ0dndrYUlGelVHaFVLMUNLT1BiMW9ScTNpWmZ1NDkzY3E1V0w3V1Jyc3d6Z01CaThYZjRlN2h5dHhmM2VVc29JYlJyeWNXa09HeDl4R1doamdRODE1U2lLc3JkQUNOdHlkUGUxbk1yUmVIY2FsS0pyWHIrUURHUXpQa1BsVnppdkdjallHM3RvNUxXUzQ1ZlVGTGg1RkxQSzZBSkhIRXR0eS9hRkIwK2VyS0pVcExYVXF0ZDJ0Q2VnNDQveGJ5YUt6c2JpM3Y0L044WGZpSmVjOWNmTTE1Y0V0QzBFcW1lc2ZIZHU2bi8ydEFaN0t6OVMydGZQNm1qZ1ZzYTlMM0ovSWIvRS90ejVyaXN0YjNWL2IyVmhpTGVUdnZqKys5N2NNcGlLc0VLeFFoWGtvUnlkajh4b1RKbnhlYytQUXZ4Ny9BQlVlQTBQbXN2Qkc2MkhqbHpIYmxlMTJwcFVBSGJRMXFzVWJIanVlblUvRFE3ZUp2OS81RjFWZVAyL21RcDh6NXZlUExpOFRqY2ZEY1RKRklxVHlTTXhqbStDY0k2RldHNDlBTlhKNGFMYzdPQ3E5TXZnaXYvUFBHTWprZy84QTNMY1EvVkV4eXZZNDR6UXZkUng4MVpZMkpZSzZtVUVzeTdxRHRXbXREQnlhcXMxNmVMQWMrQjNzdDNYeUFOdDRoNG5aWWlGSVBHM3U0TVBjckpkQ1M3NXlYTXl2Vm5aRWhTaXB4NVNWNnI2alR2bE4yamQrNWVCVXNWVXVuUmhqTjQvN2VXMlNtemxoZ2NkSGtyZ2NZYmx2cWJpM1dHUk9MSlJwRmpZdHVhOGRoMXJxR1A3MW5EYlNSYmtXS3VxU2tyejd4Wkh3L0tlSFhlTXhuajhObzNGMnQ1eGFSVzBrVThZVWdLZVBMaU5scVBUWTZLNDJQTFc4dTJnTHlMMHRTRW9PVW9LUGJTb1BWRzIrYTBiL0FHSFc0eklINzdkNVd5dDQ1b2NwTEl0a2FFb0VNeVVrRkdQQWI4aHhVZ2dqcHFEUktyTFQ4ZHRJY1phM3J3WHRrOWxsYkpvNzIwZHBGV05vNXF4U01rYWlvSzFVKzVXb2RDWkpiQ3FOSmE5eGhreFU5NWlVc2NuNUZpcFZNWGV0SGdXWitFalVoQmRxR2xDRjMrSUIxUzFaYXBGaWRZMVpNeGVHcDRiQmRIT1lwb1liYU9LMWl1TFM4bGxhZHBHWUFjbVJUN3VmNmxwUnRWV3l0V2lHVzFvbzZnUHpTTCsyd1grUnlmazFqY1gwc1NRR0hHUlNTcXJ2V1JaQzd5MHFPSEVNbTRhdGRXWTdPMFFpRjZWWFZrMDNXVmU3L3ZlVXk2NWJGV05tYlN3cURhVzZRWHRyUitjd0pZKzVXUWNhaXZwdnBSUHBXakUzR3I2QTYvd1BoMzlrWE5YR2J5R1Q3ZGcxeTJQdG5pZWJoSFMzbVR1TkZ4akVUT0NhbG5LQTdEYlVxMnVyUTBrTlpVMnoxS256bDlEaHM1NDc1aFkyaldrT091b2xtaGVXUzRra1ZINTgya2VsUzZBZzBDMDZVMGJoczB3Syt2WTY2OGR1NG44QThpTDI1dU85aWJvMjVabE1GeEFxbDRpQ3hhaFlBZjA3K2dCMXYzc3JZZ0drcTV6VGhNNjhxUXd3NUczdHpBekMyY2NDcFJpQUVaWkNTVW9QU211ZnZYY2pRcmFEekl0aWt5aHlHUThnU0t6ZGVFbHZhd3lSeVNKSW5BcVFDR0FIS25YNDduVlRwWktFcEo3bE1zM1orejhXOGR1WW84SllpL3RiaTNTUkxpV1NSMmZ2Z01raWU0THhINlNHMzJPK3ExYXo2a3JiVjBLaDhndG83TE9YZHZIdEJMU1ZCWGx0S29ZVUovSFJsSEtCN3FHZExmNlAvSkpHeC9rdmlRY2Q2Sm84bGFvU2R3NDdFZ0g1aU02MCtJNWxBMlhzd1A4QTZpTElZM3lPK25kSExaaUsydW9pcTdCaEdJNVBkNm5tamJhQXlVaTdDRTVxaWw4VFA5UGN4dUdWRElHNHRJU3BESUtoZHVuSWltb1dVaklOWmU0U2RyT2RrWVJUd1Jzd2xXb0FqSlFqY2tFQlZHK29VVDdrbWFzaE8xMmJKNFdEMTVRSXNJcUtLUnhDajVBN2FtbEJMZHJJUXY3Szl0ck5FdUhOclBDYTFsL3FqZjNWMnIvbHArZW1SWms2SWlTM1VkcmRHL3ZKbWU4VmdxSkg3WTJCNk9SODYvMDZjcEJKREpHd0pGWVg1TnQ3bERuaVFmd05OSVlsWDdTeVdzZHdQYzZnSVNDTmtPMVFmbHAwTzVJa2R2TE5jUlF4Z2NMbGVFOHA5eXIyK2hQOHRQSXg1bXNWTEZieHRaTWJtcDdUaEVPOWVoQUc1MzIxQjFUY2xsWDJNcnZEckhpSU1pSUpMV1NKRkYzYnVEdVFlSmNjcUVWUHBxTmxQUWRQYjFBYjVLT0pRQWpnQTlhalVQdE1sOTFHcHNuQzYxYU5xSGJsdDFHbldNWDNVWG4vQUtjb2JscjNLWGZ1V3pkRjdha0VWTzJoK1IwU0hvNWNuUWw1YTIrU3RIczdxSVBhekswVXNiVU5ZM1doQkh6R2c2TnBrM1hjdERqYnpPMXYvQnZLcjdBM0NDNHNJWk9WbEt3SVpyWjk0enlIV2c5cCtZMXNVOVNrRmVqTnYxTWJRZDZHUnZjby9WMUJwdUQrRmRPS1JmeU14S2xFMkhYajZWQjFJWUhkN20xQTVDc2FrSHI4OUtCaktNS3ppT1QvQUpKSTVQVGRmUWtkTk5JZzFpVnNNY2paT1hrN0JXamo0cWhVbGhSaFJ0NmdIVmRsYTJoT3NMVUN6d1dFemt3OTVYTEVKR3hYWUU3ZE5TU1pIUTNybUx1TlFzam1WVkhIak9CS0JTb29PUU5LYVcxUkEwajA4bUF6R0NneVUxbGJSR09pWE5CMjFvYWppaWpyUTd0VDhkQ3phcmRTM1NCSGxPSUU3MmNzWmdnUWtkNkpnN1Y2amM5Um90VEJCd2FybUNKVXQrd3ZaaWNzak91MVNwQTViNzBOZEpQVmpESjQ4SHU3UzRFbDliVzAxbVEwTHlLWE1qbXV6SzdBRHBXdStxTDAxMEpWQVBrbHJJMTlQTXNnbVZQK2E5YWdzUlUwUFRmMHBxekdvVURXUmE3Q2FHYS9hSlkxeU4yRWpVNDlBL2NaYVVBanFvaktzM0ZWSHJ1YVUzeElUU1dzTHhPbldXeWRyS0pmZ0RWOGk4aHhtR3pXVXYyUzJraWdXMXQzdDNDYzVKbyszd2pGQ09LazhuSU81MU40TWRyVnF0ZFNhNXVaVXZkdUlVYWVmNDFFWER4TkZFZ1hhU2xRUUNUODYwK090SEs1TVhDb1JkV0FheXdtSml2V25lYkwzdnVBS0ord3ErNFVvUXg2ZmhySHlOMmNka2J1S0ZWYTZnN0lYY055alNaTThMR1JXbWtXUVY3czBWV1FNUGFWSHkrUFFhbFdyWFRxVGRxeDZ2Mi9xemZnY0dzSGgxeGw3cDNpdmI2NlY4YXNya1F0d1lTTXpvS0FxaWozVjBzbVQva1ZVRDBvMWliZmpvQnNsZjQrM3lGeDVFNnRGYjhtZTNVRTBZRkJ3SXJVbFFOMitPcjhhY2JVQTViVmwyRXE4Z2l4QmdtU0pyeklSSzB1UWpvMGNjQlpnMEZDZDZlNE1WL0xSMVczS21FWjFrcXVlclB2K3BlT2E3a2trRStTdTVMaWZrUVRJc1pKakJJcUdQY0ovaHBhZEYwU0pST3I2c1VzOUszMVl0eTRjUUtGMjZmejBUUmFBZHVwSHhFSDFHU3RveUtyekRNUGt1NS93MUt6aEQwVTJTSDgybVF1WGFXR1cxa2hSaTRFMEFrY0ZxVkc1R2hsbFZVbEJvdmkydTI1UjU1UGtja0lZSUw5a0tYQlZKVWhVUXhFUXFPSVJVSUNnRGJiVFVpemJLK1Fuam9xZ2lTUkk3WnA3TzNOdEdoNFN5SVM2TnpwN2VUZXA2VTFiMWNOZ25uR2dXYUJHeDlvQ3dSclNCbzJ1QnlCZG1rWml0YVVvQUZVZGZrTlZONnNzcXRFL0EzVytXYXd2WGo3Y29ra2dXMGpFVkpIWXN3TGtMUTBOTmhUcFRTMlNpeDNod3h1dDU3Wk1XOTFZSjJHdko2b3NqTCszRGJxRTNvUi9VVHgwTTZ2dUUxY0xRclR5Q2I2ck54eGtzd3Q0aTcrcDV0dC9zMGZoV2tnR1p6WWtXZnRWRDBPK3hvZndxTlNTaGFsU0QxcERKY1hFSXBRT3dvS2RSWGovam9KdlF2MlBjak81dnZxcjZlT3ZPS04zS0lQOHFMUWV2cFRUcEJObkxjaTVFc2wxRmNYS0lDdklkd3MzdmRXTzNGUjZEUmN4Q1lCSGNsU0xDbGlJNUNTcU1Rb0JKTzRxZjFhWktIb3hqMXNkR2l4UFRlYWdCb0FlSitRMUNsdGZnUHQwa21ZakZ2SGZDVnFtSlBZbnJWajFKOVBscXJKbGxRV1lxK3BDbEMvMXVleUYzMFVQSVJRVkFCYmlQNWFNcnBWSXJ0cTNBMTJzYWlJQm1iMmdBMCtZNjZveXo0RHBHRXFCSVRQTHRGR3JWUHFlUjJvTlZPMm80RHVMZUc0N3R4SkNFY3NQMVVKNmV2NC9EVTFkb2hCR3RZU3NwN0xDRm1COXZyU3VyMzAxR05GMWJ0T3F5dEtHYXBVbHV2OE5LcjFoQ0cvN1VYY09DOHFoeWx6VjRyYU9hc1FZeDhpNmNCVWltM3VPbzViUWl6RXBzWDFIZjREeWEyU1c5dERlMmpIaHpqajV1alZJRlFaUGJRRGVnQk9nOVVHSnBvVjh6OXViYTZhZkkrT1BOYW9oL1pXUkhDT1FUK2wxTlZwVWRUU3ZycWF1KzVHMWZBU21YSzRtOGUyeWNYQzYvV3YxQ2xITlc1Y2xjRVZCSS9xcU5XU21pdm9aM2hzcnF4K3N2WnBvRURkdXh0Z3dJbG1rYjI4eU5xS0I3YVVOZmxxcVh1aEZqU2lXTXVFc3JHUlpZa3VqL2JDNW51NVVLaWJnSGppaVNKeVdBcXg5eDlBcE5OUWR2cVdLc2RIb1dSZ1pyVENTWmFEeFh2R0d6L2F1S3JSUTg2c1RJak9BT2FzSXpNQ1AwaW1nT1JTMlNxM2VJZHg4aXh0eDRmaGxpVzJGeG1HOE1DV2xvTHUvRWR1SVpabERUVFN5RXNoTlFlUmVUZmZyNjlOQ1pza3VlZ1JTZy9XR051NGJHeWZJeTIwbVZlSlhsbTRnQ09PSlF3TE93TEZxaytvOU9tc0hsM1RzMVNUVHhWMnJYc2M0LzZsWmJlM3lHQXM3WXh2SUlwNXBlMm9XcnlUTXJFMDlUMnhyUjlzVnJPMjdwb05uZGExMFdzbFQvNmY4dGpjWDk0Y1BuTXBITzluYS9XU0JMZVB1eW1TU04wU2lsbC96Nzc2N091YXVHcnRad29PUS94NzhpK3lpbHRuZm8rNXZqViswZmRzTWs0aXF5Z3gyNmlwSCs5TVRyS3Q3eHhxVEYveVpwcjJMa3VOMWZ6UkxqODV0L0pIdUxMR1dUUVd0alp5WEVzMTYwYWdrdXFFQUl6Z0FLZjFjdnkxYncrYmk1TjJxTnVQSVhLNEdUalZUdkdvY3hiU3BjVzBNMXVpM1hiWHVJdkxqMjQyUHVCSitKcFRXbTNvWmNSQ09NL3ZqSjVGZS9jM09TZU5XbVFFdG5maDdpV0JWZFpIajRpaVVZbmdxZ1VVSlhuVW5RK0dLcHozWVpsdmR3cS8yb3JXK3dIM1V2Yis5OGl5T055VWNKaEtTRVdzZ1F3eHFBQktXVlFRZVB1cnA3WHBWUVJYM2NsdDFoRHY3cDJlREhGQTczWmFZdU56VHVmN1RvZWxldGk2OTNLcTExTHd4TEY3TXhUM01WQkZMSEdqc1puWlFwSzFDVTRxU2FlN1dOZlMweC9BNk5LdDhLcnUxZnpPWHAzTWx3WkcvVTdzeCtQdWNIWFQxNkhEUHFGbGZqQ3lnaXZHaW5wdFRWWmF1aE1zaXZVMEFBVWZ4MHpIUk91cDFhMGxRTHlEQ25xQlRsVDErTmRRalV0YlVRYWJXS2EzdldXN2thNWwra1ZXa21OU3FrbFYvRGlvRk5XV2FhMDZGTlZ0WWJ1NUdmRVdZUUExN2pWWDRWR3FZaGw3NklCY08zZnhFaXY3VEVBOWFVK09wem9SU2hoSEtNUmRJZXY3YVUzMzZEVVVTYmhpbWFmVlhIRVZxK3IxMEJuMVl4ZUVUTkQ1Tmo1RkpWa2FWdmFDekhpb1BFQUVFazA0OWRSeS9zZndMK04vOHRmaVh0NC9jSmU1R1dlTzhRck1naUtHVXlNOG9jU0lwWThBQUtxeFd0ZVZkWkVPSlpzNXRxdnRSajl3WnJtdzhjc2pIR3d1VGNLTE0xQ0lIbVFxU2c1dnhKSk5DZHoxSHl0NDdtNEp5RkNVQ3Y1eDVEZFhma09Qd1VlWUZ2WVlDeWljcU8xSDIxZGYybzdkbllkd2dPSGtMRW11NE9qcVVoVEdyQU1sdlZDZWlJZU84YXhzRmpZK1I1ZTZudTdkSSs3ZDVDUWdkMlhZbUNCYUdTZ1U4VDByVmlPdW92SnJ0SjF4YWJ1dzVlTitIZmF2KzE1VHlYTjRLT1RNUXpkbkc0cHkvd0JPREtPNTNwdUo0TkZIeVhsWDJCdGpVYmFyczc2SldKMVZJbG9zREdZUzI4azhXc0lJZU43bHBNaWxoamN0TkJBajJiU05JQkRhbUNLakt5S3J0RkxIUkF5OUs3Q1h1cVdoK0UvSDRoVmZWV1JNc2ZCczdMZGp4L09DRzI4T3cyVGFYT1orN25kZnFtaWxNaTI3d3Y3STJqWnk3OFdvUUJUVnYzNnRlbnExb2luN0Q3OUVOUGxuaXVLdU1Ma2N4alBESXNybHJOaExrbHZKbWtoZ3g2SGNpRjVVSEl4OEhxd0RLbjlOZXNNZHRZZG5CUEpYU1ZWQUR3cnkyOHRJNWZIOHJqWm9jUmpiV093dDdESExJWVduSGNrTVVYWlZ2Y3hLeWR6ZGh5NG1nQk9vY3VqaE9uVnZxVDR0a20xWmFSMElsOUw1eExQZTV1Q0RJSll3TkcrSXNvVWtNNHVKMmpYdVBFRkZaRk1hc1c1RGRHK09yOEViWWVyOFN2UEx0SzZlQm93SGpmbGplVzRpMHlHR3ZHRjNKOVcwM1B2SXJXNnYzSGVJcEdzWWtYa1F0VFVHbGRYMnN0ckI2MWFzcEcvUHA1YmxmSU16SkZnSnJhd3lPTU5rdHJCOVBHc2J2eUVSN2NrcXh0T1ZDOGpVaEJ0VDAxQ3FTcXRTZDI5emtHV2VMKzRqZU8rSjRUSHhXVmxrZkg3ZTlHU3h6c2dqZWVSdDVYVVJjVEpFZ0hGbHFvb0thbWxWTnVPcFUzWnBMd05GeDl2dktQSUI1UmNYbWFpRVdabldHd3NrRTF4UEVJQ2cvY0xVS2NodXdGUnlhZytHb3Q5SVhRbXRKbDZzMDJQZ3Q5bFBIVmJFNU9LN2l0THlLNHlXT1dCMWtqL3R6ekZZNG1rbERFbnZPV3JHYTAyMU5VYmN3UjNhUVorUWVFV0htTjRQTGg1YkpNTWd0dkZHa0lpTWNSazRvN2NuWUFBRDJiKzdtUzJvNGNUeDEycElsbHlMSmFXMk9Ia21NKzMrVW14Rnhuc3B5OFp2VEV0blpXcnhPa3NOdkVZNDRwZ1FIb3ZiRmEwcVY5UnBxWXIxbExxV085TGZ5SkhrVnQ5cmJQRVIrTTRZUnpZeTZoRnIzc2R3dHBDVlppYXZHaktTelJzS2ZFZE5WdkRkUGRPb1JpMlc5TFJQeDNuL0FJOTQvYXBMaExObFpTckNhV1F5MTdTZ1JFamtWTGhhOGVJQzlhYUcvd0FkdDZzMVVxVnJvWlgzM2p5bDNDMS9iWEtHVVNkcTZFYXhNM2NWQ3lrQ250Nk1yVjJxTnV1cXI4TEczTFhVdnhXeHRiVXVubUFKUHV6bjV3elMzamhsOXlLcXJFekVIYzdENGJIZlY2NHVOUDhBYWlHOUtSZnZ2dWJscmdDTnJxVG5JRDJnMVJVa01wb3E3aXRLZ3J2VHBxeGNlaWZSRWJaWlduVWxOOXpzaGtzUjQ3bXM3Y0pDM2p0KzhXUnYwWXhuNkc5dFpMYi9BSmpGbTVsaVFhOWFBNkh2d3F2Y3EvM3I4ek95Wjl0cTJmWmhIQi9kVHdhQVQyMWozYnZGM2ppQTNMRlJlbUxtV2taVlZpeDJQSnFqY1Y2SFFkdUhleVc3U3lJMTVOYXp0NldGWEk5dTR5S1FlUFJUWFZxOGswT0dTM3NyeVNHUzBXV3NMcVZRbWdRQjIyMy9BSTYwclhqUnY4d2V1T2RmNE1oZWE0bk1aREVTS1BITW5QYXJESWtGMURhTWtzOHNqN3h4eFNVTkdxVFVEYWhwWFQ0c2xWYjl5Rm14MnNtNDBPVExYbEhjZGx3VlBMZzZzS0VWOXBCSHgzMXRtSUhmRUx0cmE5VlMzSHFEOGFxZHFmUGZTSFE5c2VOL0t0dlBOSzdsWlllTGZvTWk5MDdEWVZJQzc2aVRHSEh4MjZUR3h1cDNSMklXT2FTaThVY2MwWUExOXByeVB6NkhWT1FuV0dTTURadmV6U1FwY3hQanJhZnRQSzdLalNCeVM0NU5WZGd4NVVZSFExN3FvVGp4dHBrK0syc29rdzk3SC8xT0x4VjZqWmV4alF5cUxhNXJHL2NaUVdDb045OW0ycDhkUlY5WWZjczJOYTlpTGlMMmZKREsrTXpLY2w3V3Q3R0cxVWlSWGhsQ3gxSlpQNlN3TzN0NkRUdUU5M1FyU2RsdDZtLzdlNHpJNEhMdmMrWjl2QytNVDI5M2N2ZlhUSUkvK3JnZTNaVktrKzZTcSszNGpUNVh2cjZkV1J4TGEvVm9oVXkzaE9mOGh0NytlSEN6clkyc01WOEZ0cExlZVNLR1VnUXRJcXlNYU92NlIxSHoxT21WSnBOa2IwbVdKVmpMNWpJajI4RmxjdkZHbkZqT1pGUll0aFVsMlZRb3I2N2FNM3J4QmRyOERaWitLZWEzS05OYjJBdDRZeHk5enh4ZHhZdHlVNU1DMjNxTnRRKzVVZFZadnlIaXZsc01tTy91MGtaa3lOUmJRdk1IY1VOTi9RYit0ZFBXNmIwRkRHbkY0UE41Znh1QzdqZ2tQOWtFa2JOQkd6TzBVejl3U2NsSTVMVXNvb2RoVWpWRnJKVytKWWsyaXQvTExhVzF1NFRNanhUZ1VkSGprVGlOaW9xNEZkdEVVY3JRcWFIdi9UajVPTUQ5MnNTWlNFZ3lpUzQyWURZTTA2ZnQvd0Q4eFUwWHg3YmJwbFdSZWs2Vys4K094R1Jnc3M5S2tEdmpaVGJpU1VGNDFTVkdrQlpCU3BxckNtbys0MDlVcnVTNDFwckRLSWt6TU1NVVIvc09Ja3MwWnlCY1czZGpBTEhtQWVmT2hCVWo0ZkVhenRpN055RmIzNUFPZS83RHgyeVFSV3RrRWtDcWxKMlV5OVNHYmthRmFLQlhVckorSldSOFRQYXJPa3dzMGdtczVnek9xbFE0ZjJWVWpiWWtOcTFzZXFrbDVQSURPUnp5WFMvOVlWWllTdTVIRG92d3B0cHVqTFZWV3I1aXJHYmFIakhDaHZib2xlMmprYm9LTUZBNlZVajhkV0E1OWJ2RXQwSTVaVWVXK0RKY3QrcjN6RSt0UFE2UXh0c3VNMDdZU0ZKTGd1ZUZ3ekRpc0pCb1dKK1dtSEc2S0NIRDIvMFVDQnBHSHZsYzdzM3hwOE5NU2cyaDFSQXpidVI3bkhYclRwVHBwaHlOTmJmVlc5eGFGQzhjaXV1OURRc0NhMU9rb0U5U29aVkpEeG1uSUdtL3kxWVVtbW5FTWpVcU54cENIeng3N2llWWVNd3JqOEhlclpXclJxME5JSXBIS044V1pXM0IyMVg5bWxyUytwTlpMVjZEYmhmdUo1cG1iYTUvdVhrdDhrNkgyTkEwVUswSHB4UkIxK090VGgrM1lNaWNyVkF1WGtYcjBLL3pGL21mSU1vOTFucjI0eVVjUk1VYjNEbDNBNjBCOUJYUWVTaXBacGRDK3RuWlN6SVJ5d3cwQkxMdFdsYWYvRk5WeVNJenhtUnVQSDNEMEozcHBERUdTMkJOVk5ENkEraEdrS0QwU3NrYlJ2UUU3OFQwcjBQOFJwQ04xbFBFMFR3enFITlM4RDFJS2tnVnJUYjAxRnoySFJHRVVuTXN4QUc5VFhmVWhvTThmQ2x6ZEN4TVlrZWMwalozS1VhaDlSdC9FYWpad3BFZ3JiMkZvdjhBMFJ5THhSZFpZbmkzNTdiS2Qrdjg5VXV6NndTZ2haTEh4MlVrc1Z3b1lSZTBPdTNJMUEycHNTUFhWMWJTcEUwUlpwRnVDWWl2SUgyeHZ1aXFlZ0o5Tng4VHBReUpKa25pNzhFOFN2SEgyVWh2UXZLaVNvS0IrUy9HbklhalZQVWtiY2lvK21NY1V5eXh4MUg2K1hJU2U3bFVBQ29KcFhVa0psbytVWGlXMS9JTEVtMVpMZ3dXVU5UMzRvbzltWThCVUZsSHVvYWI3NndPUFZ1cW53MU9qNWRxcTdWZEljSkMvd0RjRzdzVFkrTzRISDI0dCtNUnZieUtpaWo4bVVBY2ZRbXA2Nko0bGJicjNzL0pFZWU2ckhqeDE4SlpDOGRrTm5NWm5SZUhCMERsT1lSeVBVZEtiZkRWMlhYUW93dmFORmhkWFdXblNhNE1jdHdYNG1ZSjI0MGdBRzFCK2tCZCtPaExwSmFCbUp5eUpmU3paenlNNE96Y3hZKzRuUXM3QTh1M3NLc2FFOU5TcWxXbTU5UlpMdStUWXVqWlkxOWpidkllT0pFWmg5TWxySmRqaVVqYTNqWitKUU4xUHRWYWZpZDlBcTZyZEZ1V2JVaCtCUzhua0p3K1BzemM0NzZtS1pKSTdVWERlNEJIOTBtNm1vOUFEdHJiV1BjM0QxT2Z0bDIxU2dKM3Q1Y1pGY0JJME1hWlhJMnNobHVwR1plTGhqSWt6c29OQ0FQMGhlbEJxRzNidThFVFRianhZQ2lqL3dDcmxzcjJJVEhIQXdJb2M5b3lGd2VaWmlqVU5TYVUxYjJsZHlyVnZhK3drM25iK3FtN1JyRnpiaVIwcFgwK1dpMTBCR0dQR29Tc3IzaEI0eFVVRWZPcE8zNERWZVI2UVg0TkhJenBjbVNnakFpalUwSzlONjlUU20zNTZGZzBWa2xhYUVmRzJsMTVFOS9ackVzakFSbUplQlpneGxWUUVQOEFTT0pZdHVOaHE1dFVTWm5PY2pabmxmSEo4ZmN5WXQzV1NLSnVkWVdKaGRFMjVrbitvVjNwNjZWY2llb25qc3RER0hFV0NUcEpjeVNRaTFZY291ZklVRGJVcDhmbDY2WjNmZ1NXTkpxUnFpdWtpeHR6bFlMbUNPNU1UeHRBQUM4b25YZ0NxTHVoVVZCWW41MDFSM2dJbVZKaGk3NnovdEVFRTFuOUt6RVJKSk01TlJFQTM2T093WW5Tc3RTVklnUlpKVGNaVy92RlBKWkp6SEc1SnFSRnQ4K3VqcUtLbWRkemFRdlpSU1Mxa0FqSVhyeUxHbFBVVUcrcXNrZHgwcERPUGU1K29YM29zVkdibVZaZ0FpbGdPTmQ2bW41NkhjQmxIYlR3TkY1RGRZaU43ZU5ZcGU3R09jclZEZ3l0UWhhRTcrbnBwNnd5TjkxRjRrTzNtdExXeStnNGxjZzdCZ2dLOFVqNkN0ZXBKR3JyUzNQWkZOR2tvZmMxM2loaEhGSCs2dlFjUnR2WG9mOEFIVWRWcXhuVlRDQ0NUM0YyeW8wQkZyRCt3Q1BUanNUdHUzenBxdHBkWkpPM2FOQ1FoWEgydDVlbzBnN2FNZVRBQ3ZCVC9TT21vZFdrWDFTcExFYnh0S3BOS2FsNUhDL2tOei9qclFzNEFFT2tZalNNTUY2Q2dCNmxqU25UNTZDYmJZWlZLSlpDeTgwY0VxUmc4UUtDb0ZSeUFGZnpPbFVxdWx1QjB0dWpQUzZaaVhQSWhkcUE2dlZaVWxiNjZnYWJ0d3pGQTVKMzMrZnBxZGJUMUlNd2tZVm9yZ3FCVFlHdFBXbjQ2ZHJYUVljUENiT0hzWCtYN2EzU1FHTzNpaGxOS3VhdTVBREtTS0FmSFZXYVM3SEhVdFh3ZThoeTJUSnVNQloyRUZ0QThxVEdCMDVPdTlhdlNyVTlBUnFpeWhkUWhOVHFQbUxic2k1ZEpJN2E1aGlXYWRVbGpxcVNOVVNLS3NOaU55UlVFN2FneXlSSzg3eWZqNHgwNHZpazk0alNKYnVzaVRQSGNpaFlnaFVxQ2ZRVjFPbFdRdFpGV0pjeXg1R3dTVnZxSnA0QVlVQ0FCRVl2eUpVRVZKQk8vd0NBMU5KYWtHM29QdmozaTFwbGNZdU90NUY3OGx2RmVUcXJVV09NTThmY0oySWFrZkxiYmY1Nm90a2RiUytnVlRHclVoZFN3SXhnc05nMWhhZWU0a3ZMWTNNd05XbmxaREdESlJSUk9abExEbldnOWZUUTF0MTM4QzNHMVhVdTZXYTJMWTIyTHlKWUZtQldLaHFDanBHYWtnQUVxVFUrZytXc2ZZL1ZKc1pHcFVEcGJXNlQyTUtRc0JCRkYyMURjVzVkc1VKUlRVRUNvcHgvanJFeTRydFFnbmVrNU9LZjlRTjFmZjhBZjgxdmtGNC9TUkwycU5VaURpWkU1VjllTGpYUzhDaVdQVHFCY2k4dVgwOGhKKzJkcy9qdmtlTHpua2tFMk53MTFBMHRqZTNjVHhRWEZDb0xSTzZnT0FmOHV0VDNESGErSjFxdFFEMm5OVEZuVjd2U0RvaVg3ci9iYTNIYmJ5QzM1RHJSWkdKLyt6MDF4djhBOVZ5YmYyblp2M2ZpcC92Tk1mMzYrMitIYVNUSCtYejJVMGc3VXYwdG4zUzZWRGJtYU53QUNQVFd2N2Z4ZVp4VTlsYTYrSmljL25jUGxRcjJlbmdhYmovVXY0TnpVbnpEUDNCRzY5aUZZZmpXaGpFZE52aHJTM2U1TmRhTDVHV3JlM0x0WmdxZi9VZjl2dUxscGZJYjBzYWxudUpsTGZOcXo3azZwZkc1MXV1Ukw0ZjZGNjVuQ3IweHQvSC9BRkZ6eUw3N2VENW5DWkxHNC9CMzYzOTdDOEVGMWNzSmdqUHR5SlptTlI4dFBUZzhoV1R2bG1CUDNIQTA5dU5hbEpXc1p1THEwdVpRUXltSzJVblltcmtzUnVLYkRiV3RQWXlWcnI4aTdqa1pZVXZYbWhOdmRXVnBQSHpKQWxkQUNTeHBTaFkwREFIMHA2bldkbWhxUEZvMCtMTmJOK1RPWkF3YVJLamVnSkg1MTF1SE56SVRWcXhzQ1A2ZnoxV1dvbjJiYmxUc0NFQnIrSjMwelJOTW4zMHBGcXlodDFJRENnRzFRS25WYTZrMjlETWIzMjlLZlR4cUQ4S0ZqcC83Um1sdStRVHZ3cTQyMUFvU1E1QkIyNDFHb3k1MUoyNkMrL3R2NHdTU095ZXU1NmFuMkszb3labVR3dVl4L1NJMDI5Q2VJcnBxaXNMaXNSTGNrSHF3cCtlclNwZHhuKzNjaXI1cGlUSVFFN3I4eTFLVXB2WHIrVzJvNUY2R1R4ZnZSZEhqMHlmM2lYNlo0M00wVnZXNUw4SW9pcEhHcWdLNGFoVTFRZTdqVDU2eUsvdDFOL2tyMUt5ZXVoUCs0ME1YOWp4VVlCbXNWdnFjSWVQMWhsamhaa0pqanJJMnpGaU9KTlJ4TGJWMVp4bjYyL0w1QVBKL1lsNS9NcDNMNGJLWE9Lc2xzOGRmdG1MKzRwY1BOWXVJck8waDlzY1pKU1NRdXhSV2JqN1ZVQkZydm8rdC9WMVVmSHVaOXNiam81K0JZVnY0dDVPK05zN0RPNUdIQ3BsSklaYm0ydUxtUzB2RGJ6U0dPT0JmMmpHclNVWitETXJmR2hycXFhdTBwVEJlbFpMYTNDWkQ4TjhueEdHdnMzNHJmNDJ6dExTMnU1b0w0bnUzU3VrYkFJcEpmZFIydmNDS04wUFhWOXNjcmQzSzYyaHVvK3dmY0hKWWw3QkxTZTFqeDlqS0pMS1JZMFBhZDBNbmZVcVdDczMvQUExTmV2cG9kNHF2cWd4S3lYa2JaUHUxa2J0WmJhOU52a3NldDZMd2k1dG9aSUhhUnFneUFnVmR5ZVJiK0duV0pMb2kzY284VklReDMzTnlXUnZraHVyNHoyZDJTbDZ0QWpkdWRsajVsUUJVeGx1UTVEMDY2cmVKTG90UXVtMWdUTytTNWkzN0Z0SGw3aVNmSHpUeHp5ckxJdmJWWForVXRLTXg5elVPNUt0VDhMYTJucWlyTnhWWFdyL29JT0YrOVBrL2pkL0ZMRmNuSTNTVHlkMkc1MnQrd1NHQjVNZVFkaXRBYVZwOGEwMFU2cHFHWSs1cTJneGVYZjZrZklzcUxiTStLMkVPTXZMRlZodUpaQUhiakl3N2tZSk5HREVLZWcxR21PdFNONzJlcHI4bSs4dmxlUm13bWZzcnkzc3BYdFRiWE1ObUZrS3lwY0dKakxFZGc3UmNIOXV3cUtINE5WSlNvSGJiaHlSTTE5MXZKYm55S1R5RzB1MllSSkpCRk9FQVNTT0FBY0ZSaitrQml0UnZ0OGRUMGlCM1ZzRXhmY3J5NlBMZjl3U1hoa3M3dU1KZHJLQzNEdU1PVWRRdnRhZzVCbG8xUG5wOUVRMnNWYlR6VE1XMld6bjBtUmxteGwrSmpOS0pHVjVrWmlIbEFOS3MzcUtxUFgwMU1yVGNnQ0M0dnJPeXZzZUxtUVF2VThZMlpTeFZsZEswcURROUN2OEFIU2tXMGl4Wm5MUll1SEhHVm50NEpsbFJSN2dINUNwOUR2eEErZE5LVU1wUlo4R0N1L0tZN3lMRDNneGwyekxjMkJtUVFKUEtxeWQySG5HYURlbkZXSDZqMU9oYlgyK1pxNDhQM1U0Y01NZmJQT1hlU3RyL0FCTTdGYmEyUVR3bVZRU3R5RFF4a2xSU3A5eWduYWxQWFVjaWhvTDQyVGRWcHVFaVBoODdkWDgyVXNKTHFCVGtJcDdtS1dJQm1VMjNFaU5wQnhRMVVQVXJVMEhycFdxUng1bTdSUFh3SkVOOUxhZlVSVG9WZjJ3cXJNUVJGSlVCaHlvQlZsNk5UOHRRYWxoaXR0VFVBUzd5TW4xS1J4aHBibUpoSzBIYmRRdEFBU3BVQm5wc1c0a0NsUDFWT3BsRHZMMDZtckhaKzF4VnZmY2dzc00waXgybHVSSElDNG1WNCs4R29oUjZPR0ZLaXRmZ1N6ck1BV1YxVlcvUFE3SDhjeG1Qc2NiL0FIT0xHMmR2azdwU3pYRVZzdHZMRFZGZFJJN3JYa0FHNVVDRDNmTFhKWDVFdTFlc2ZNMDY0YmFOYVNoZHlPZnRMNDMyT3RvY2k5MVkzTm9aY3BKSDJvb0VrbEkySjloRHE0L2JGVHgzNmI2THIrMU9WcjBSQzM3b2FlblVCNS95T1BDWkRJV1lqbVdlMDVDQkxjVTRRR05WWHREM2tlMk1oWFloZmNmaFhVc1dPMTZwdDlSczBVYnFqaFh5Qm1Qa3VXa01mWWQ3dVdVeG5xb2R5L0dueXJycmFmdFJ5MStyTkZuTDJMOTNYb0g1Q3Z3Y2YrZXBrVVdkYW5HUGtvN2ZKWTJPYUYrMGl1a2hoTEtZdmF3SnF0U1dHNVBvZFVaSkw2Uk9vLzRuRlduanZsRW1MdmJDenZiQzc3Snh4bWpXNFZuS1J2Mnp3Ry9KWk5oWFk5TkR1WFdaTEhvNEpma0hsM2srTHlsd3VFdUpzYmEvVDIwVmpiOXVOSW9wTGhDV2Y5QkNraFNBQ1FUNmlvMVhYSFI2dFNXL2R5TFJPQlRQay9tYVhEUVM1ZTdZSGtMb0xLZTBJa0JYM0tDeXVLc2RpYW1sYWJIUkgyNmRrVWZjdFBVcy93QzNQbGQ5WTQzTlpQTnN0em1ZTFcyanRvN3h1MFFzbHdZcEpIYzhpaDRzR0xjajd1bndBZVhHck9BN0Rsc3RlNVVuM1R1SUZ5RjljeFdZYTZhNWl1RzdzYU9VZzdWRVloZmFWTEZpQ1Y1TnNTVG9yRFdGQU5uZXNnUEUrUlhXZnZZTEtPQ0N5c3Npa3RwZnZHekpkdGJ3cWJrT1hGTjBSZUtiZjBqYlZscXdVcTdmekhLYkdZYStzWTg0Sjd2RTJXTGl0TGY2ZUdaR3VKUmsxa2NzODhoYnFTcFpTYSsvb05Rcm80RmFHTFhrZGxtSk9HUFc3U08zc0l1eE5KYlhDeXFZNDQxZDJZcVNXTEhsVWlvcjdmUTZJckhZZ3c1YytPWlRMNFhCWm5JRlpaSnJTR3p0eXhqTHlUd3lzaU5KeEpIRUt1MWYxVTNHcVhlTE5FblZ4SVN5dCt0MnRxOHR2SEhEallWUzVnaWtNZG55cTdRU0xFM09sS3VHWDA0MDFRcXVkTzVidVRXb2orZEcwdnZHVEhGSXJ5MnhXNFdnTzVCNHNWSkE5dERUL3dBdFdZcFZpdTdUcVZiaXNqY1lqSjJXVnRUUzVzcG9yaUVqcnpoY09QNWpSeWNNSE83dkxHdHN2NDFmWkdHTkRqTW5qSXNuYXZHcmRybkdxekp5NDFHd1k5YWEwZVV0MUZZR3d5clFjejNPSXo5dVk3bUswZTZ4c3NqUjIxekQ3MUprRk9OUldqYm5lblhXUTNVT2hrSFA0blAyUzJqWDJNdkxiNitqMms5eEdWN2hqcUdJSU85QlFtdW1vNnZvTTB5QkUwMWxkQzFhVlpvWncwYVNRdUdRcWYxVS93Q0VqVTQwRXRDZFlJN2R1MWpjTFBBN2JkZjFLR1dwSHoyMHpVb3NwYUFUZkY3ZkpHSzFqQWtrQmJhZzVscTdFZkVFNmtsQ0kzL2NaNGJFeTVTNVcxZ0tveWNtdXJoaUZSVHlyc3hIVVUyMDdaQktSNml4TnJZMnl3eHpKM3JsMmFlNEJWQks2R216SFkwLytCcUJPQ09jZXFpUnpjZHlVbWdvQXczUFRZa2pTa1k4RWMwWWpaQUdYa3dJMkkycnVkS0JHVVNzNlBMVmdRYWNTUXRmZ1FEMTIrR2tPaXUvSk1OL2JzajNGQlMydXl6eFZyN1dINmxvZlNwcnFhSzJoYnVZTzE3dVZUMEcyMm5HR1hCVHczZUZ2c2RJdFo0aDNyWndQY0IxSStPekQrZW02TVhWRW5EWFF0N3J0TUE4ZHdsUWR1b0crMWR0Ym5CeXFtUlQwWUZscktONGllem5saWxqREYzN2lyVnVRVmg4TnRDZTRZSGl5dnpDTUY1Um0zRXFha0JUK3F1OUFmdzlkWmdRUjVFaXJTTSszcnlGRC81NlFpTGNXOGJMcy9FYjE5cDMwOGlJTFd3Y0VPYTdkQ0s3L2xwNUlrT1N4MklqYWxlZzlLYWNhRFQycm0zOTRhaTlDMzlOZnhycENQWUE4N3AzR1BGcWp1ZXFuME8zejBoQlZjaGNxcXpkbHBiNU5yaVZpR0VpZ2ppeTEzcUthcDJmUWxKamtyaGNpL2VoL1lrbFg5eUZ6UldZQ2xRUjBKK2VucFYxVUNia0dva3pxOExQNzlsV0lmMUQ4UjFvUnEwaWVKT1kwYnR5TUdCRzFhSGZUZHhFcEx1NkNIazNlVDlCUnlTYUhmWWRkdEllUzNNVDRobko4a3ErUm1PMnVlTE5BWmZZekk1TEhrQUtMN1ZQRWRLZXZUWFAzNU5GU2FIVTR2YnN0c3NYNi9qNkZkWHR4TGxzOWZYc0s5MU9mMDlzUW9BNFFqaUtCZjhBWnJVcFZVeHBNeXNsbmt6TjllMzBIdngzQnozZG5KYjJrVE5NRXJjeWxsZUxoRzNOaVNLN21uR2xkQTVicE9XSDQ4YmFEdHZqNUxXSmJSNG1TM2pVU1RkK3FseElLN1ZvUnhHd3JxaDIzZkVLV04xMGFJbUNqeEV2bTZGV0ZyRWxsY3RKZGNnQldPT3JTRWtrQ2l0MStPcFgzZmIrWlhUYXN1bW1qLzFHbkkzK0dneHQ1ZTQrN2pwTFl5L1N5cVhkRFk4VUZRdEFwSlBxMVBpTjlCMXBkM1NhNy9tVzVMMVZHMTNXbndPZnZKekpObW9zYnpWaGF4eFcvT0lsa3EvdllyLzlXdW14cUZKeWVSeXcvTG0wYSt4eTBrVzB0SURKalpZMUhLUjFVS0VZa1U0RGp4YitlcWRrcC9tWC9jaHJ5RjI3dWJwVGVYU1NMR3N5Q1draDRTTnpQRThSVDRqcHRxNnRWQ1JRN09XL0VXK0pJTFZHeDZldStyaXNiL0g4ZExQakc0QWdNVElYQjIrRkNQalFiYUd5V2hoMkRGYTFkQWkxcmJSWFVjRW5jYXBISlZCbTZDcEpDYmtmRFZTYlpiZWlybzVNOGJlWGxtMHB0N0NXM3ZwN2dUeU0xRXBiQUVEOXV2TGMvQURWbDZidXIwZ0V4MzIvRTl5SDl4dkpJTHBwRWFkQWJmNk9JbFVpUmZkellzU0dEVUpvT2g2NmpWSktDVGRyT1VmWUcxdDVjakZibFhqVXR4Z2lMQ1drcDJVN0NncWROZDZFc2RWdThqQXc1bXh5NFRJd3oyOGZkZU9VeEFsNVZHem9uV29JTks2ZE9ycktjaTlTdHFGODI4YVdadWtVUnh3MnhmZ0tFcEl4TEg5TkI4QjdkVlUxY2VaZGtVVmtUTVRFNzI4U0QzRTFZZ2oxWTZPdGFFWncxUjJFbEZRTWdpS2tDZzJxQVc5U05DTzJvVXNUWVFnbCtoc0xtZC9iSU8zRXBTZy81aEpiMi9JTHFEVXNJcjZVd0NMdVY3dnV5UHpDMEtoM0ZPWjNMRUhyOGhxemJvRHU3aytlL2dNMGl4Umw1YnQrTGNSNyswdEtpdnhOTnRUVmRDcTFrN0UvKzVyMjF0RDJZRkg2SW9sNWNFNjhDM1UwUFVuVlRyT3BmdTBoYUVDUE15UElVaEhiN0pMQ1N2dEIzb0tEMU9wdW1nTzdkVGJuWjViZng2OEpaVDNlS0tSVVU1a0FnQS9LdW80MHR5Sk50MTFGZkZYSzIxc29JSnJ2MXB1VG9tN2M2RktnWWJPL2l2cFlFS1ZJYXAzSUFBOWVwMVMwNnlXN25hRWFNdmR1MDRaRkVqb3BhclVISGZiaUFPcCtPbXJYUWZJdFFieHZMZ2xHYmt6YmtDcEFyNmF1bExRcTFKTU9IbFpsWnlxOUtrZ3Vlbm9Cc0JwT3lTZ2ZiNGhXeXdDTlZsSElJTjNsSUM3Zkk5ZncxQjNKN1VNZHY0L1AycEpuNVQyOERLaGhoS3BIM1hJQ2dyQzRZOHZpRHB0dzBEVGg0OHJodzhzUWdzUmFvODE0cHVFaXJVRkNyTXpTTlNtMUIrcjhkUmxFbElzNXo3aFpDVW1DQ1UzMHNZalFYa3k4VUVjUkpWRmpKTlFDYWU0bXVwS2crN3dFaVdmS1p1N0pNanozVWg5dGZpZHRoc0JxelJGZlVZWUZpaXpHT3VieVJvWTRSMnJjbXBWMFFLckZpYWtqa2ZUcHFpZEhBUWt0eWtzbXd5YVltYTZ5TnNsdEI5TGpKWUt1VzcxeVpROGNNWWFpN0JsWFp2MVYyTytoc3RIZEw0aFdPK3h0K1EwK0F5WE9TVEY0NitzSlh6bHU3VzF6STBOYVc4RXhtWm1Cb0Fwa2RZaFFqOUovRFVNOFYxWFFseDVzMG1YVjVGY1crR204ZGUrZExPeFZKTG1jdklzbkx0cndXSXFPTlM4ajBVVjM5TlpHcnRaUkxOWjJxMG41Nmt5MTg2eGxsaFlUT3J5M01NYXdQTWtvOXRHa2RWbEVVbEZxS0xRbmxWbTlGMVhlbnFTZ2VyM1N6aXY3dVo4NXZ6L1BvdE9QSnJZT3A1SXRJMVE4ZHpRVkJvSzdhMitKaTI0MDJabWJNM1owWHdKUDNJKzZ2a1AzU3hXRHdlVytsc2NkZ1kvMllyVkpYVjVSRWtQUDkyUWlNY0l3QkdsRkcvWFI5c21zd0JVNC9hVVZ6RmpiYW9iNnBpcTlTSTFIVDhXMG5ranNKWUYvdU5pNGZGeUF5dmRPV0pxU1RFdlQ4YTZpOGxsMkxLOGVqL3VNV3RzRkM0QnVpd0c3ZnV4OWZoN1YwNnRkOWhQRmlxNDNIeGx3YVY0dFhweEJrY25iNDhRT3VrdDVGckN1NU9nem1NaWhNS3F4TktnaHBpdjhBZFZXeDNiTHFac1NVUDhBaWJzZmVXMTlrYk5iT0Z4TERjSk1hY2xSMVNsZVJkdlQwMUxhMTFLbmVyVVZtU3pMM3lPV1BBNUdTTzFra0VWbklxOFpJeW9MS3lGeW5QZGdEK3BmNGFEdmkzUkw3aG1ITTZibkhabEJSQ3NpZkdpaitSMXJNeFVFdHUweS93QTlSTEYwQ05wWDNIMUhEYjQ5ZnkxQmswVGNodkVmajdldm9hNmdpYjZIck1yMzBnSEtxUnhLUURVVUpmZitlbmowalQ2Z3Bmc245dHM0cVViaS9JZytoT285WEpaYm9nQ2VYOXpVY3R1MlFLLzVlbEJxWFlxN2szTktEZUdwSDZGb2ZYOUkwMVI3QzJDUmN6cjFITGZmNGF1S2U0eC9iOVlaZkxzYkRkUXJjMjhqdUpiZC93QkVnQzE0bmNkU0tkZEsvd0MwZkgrNUZ3NHk3c2NiZlpCMXg5b2VEUXNnbXRiZGlpUnN6Tkd2S0p3QzFBcFk3Nno3MG1xMURxT0d3dFBrN0RQaTJoczdWb2JoWCt0V2EySnNvK1RBRUF0Q0ZBQVZ1SUFQdWI0YjZwVmJVNy94Q1U2M2FsYUUvRzJ1Vm1na3VjbTExSmlnWTVJNTd5UzZNVHh5Z2grVWtrZzJRc1c0THkvVHZVR3VxclpsTUo2K1FVdU5wTDZlWUM4anhWamxKY3BuNXZJQmg4VEJjMmx0SmlySzJWcDdpOEtKR1FuTW9JeHlrWWUwRThqVWZJdkJ1U1NpVFA1R3gzYlRoZUNLbTgxbHZjTDl5UElibXdSVTd1UXVsNGdnZ01rekwxQVhhb3JzTjlIMDFxZ0c3YXUyZ25hNW03dTdCMXRIS3ZPS3ZERUIvUWFIZXRhMEZSNmJpdW90UXcrbDNha0dGeGRUU3JFWlBkQlVPOFk5cWt4dVkrUVk3bFZHMjNRNllkNnhKTi83aEZvV1VGSUt4eTFMRU94a0c2OGFnYjh1UFQ1a1YwMjJTMzdtMWpObnNsZXo1ck1SU0JCTE85dGY4WXh5NUpjSUorRFNFcUFBSlBkVGV0S1YxVFZKUUZYeVd0UHlFaTlpY1pDNHlVbHRIQVFwUm9RYVNBTHlCbUtrMUpBMkZPbXIxMGd6OGxmVTIxOGdMZVJyTGFudXIyeTdBTElBcGxGdEVPTmFBaGR5QlRldm9OdFRRTmRhQmJGWTQyMkNtZElCQmRSWFN0V1Y2dXFUcHhHeWtPS3RHekZRSzArQTZ4ZHRTVmFRamNqTkZld1JOTkN6UE1wV1JGTEl5MVlLM0FqancrRzVKSjNyMDBpVVExNGtUa0xjS0RJOXVXZVNpOGxacFM2Y1JLd05WLzM2ajhScHlMUnJ6TmxiWXZ5UzRTUklZTGE1aVc1QWlVdWtjTndpeUlFRWgzTkc5dkxwOE5KT1VWWktwV0lJN041azJ0VldvbGlLdE9UdVF3cFFrRWpqdU54OE5TR1NtMEdxNnR1Q2R5MFdSZ0NXWjJjRmdGSEhlb0crMWRxVTBwR3RVZjdITXhTNDVrbWxaV3VZNDVROGNZWXRLamM2ckdRR1lEcHkrVy96cGExTkxGYUs2aEhDNWpKck5id1hzdDBzRU14dVk3YTFjVzBJam92SlFvNHQxSzFadjl0ZFJkVjJMOGVYdGFZbVFaRmN5NHp6K3l1YjZhTTR2SlJURk9DdUlFbG5ESXF4eHFOais2ckFzS0VOVTZsMXFDTnV1VlBzekMvdmJpVXRNcWxwcnlzMTJTb2RrYzlWa3BVc3hyVDVWOVRxS1dvWGU3YW54QlI4ak1sd1hGV2VWYVFSdXRGQVpRR1FLbGFWcDZtdld2WFVuVFFHWEpsbWlTM1pyS2VzTFNST1pRNWRuZVAyS3dVeDFyMHI2K3BGUFRTUlhrcTlyME9oL0VQdk40aFllSTR6eDVMcS93RElQSjB0RUUxbGN4TWtzRndpY0dXU2FZS0FRdktsV08zVGVnMXkzSjlzeTN5MnRDcldlejZtcGc1Mk90RXBkckw4UUdiZk9aUHlrWEZ2ajR6NHQ0Z1pWR1J2TW92Wm51R2lqWmtFTWNnY3hqdG5pOHhYYWdLL0tlUGpyRlpTOTF1MGR2aVJ0bWVSYSttdjVzSStTMy9obVp5SDBmOEFlYis2eVVWdmJ4eTN1SmdNQ3M4akRndmVkUXZOb3dVREt2dVJhMXFhYXVweDcwMVVKUHQxSHRucFpiWE1ydm9jUmZjdkUyV0k4enV4amI3KzRZKzg0M3R0TXdJa1ZKNm50eUEvMW9SeEpHeDY2NlhBMjZLZXh6T1ZKV2NDNXlwT3JmNW94WDhWMi8yYXZLaXdzTmVaQzlnV0d3aWE1dk9LckxFQkc2bUZOZ1RISnM5TnY1YXF1bDNKcGxyZUc1QzdTTzF1Vmd0NysxbGpzMWx0ak9zTnpaM1VEbUtzWUpja09nVDlLSDA2RmRDWkZvRlkzcUhQSk1WbGNobGI4WFVGbUxpZVdPRzErb3VGamxlUnczUGh6ajdleXNDM1BwdVY1R3RLS1doQkZsTEUyZkI1QnN6YVl1Q0t5dVowVm94YlFYakpHWEFJSEtZeHFoVldIT244TnRYN3RDamFwaGhYRzUveFB4MkxJVzJiWVgyZUVJaHNZckFPdUlqblYwUnBKWmlBWk9Vc2Exb3ZFQmZuWFVYanRmVk9DZGIwcm85UVhpUEhQSE1qbGMzRjVybDRMZTJodGpQZHBaU0pIOVJOQzNOWTBGT1RjS3N2SWNlb0ZkUFozU1cxRWFxdG01WkE4amd3NlcyS1hCNHMyVVdQVzVpdG9MbFFzc3h1SVFEZFBKRzVQYlFVNExTcE93TytuclBkeVF5THdVRWVZUGtHK210OG5Oa2M5YzNpd1FYSGRTV3pVSXlORkxRSjdxSW9IN2lFL3dBTkVWcXVzRko1a01mYUxQbExUeUdOOGxtYlNaMWE2NG1CcFY5NDlrTkZBUS8wcUJ1YSt1bXRLaU5CNDhUVlA1ZmUzbVJGL1oyMGNkZ3RsYlMzOE1VSlNPU2UxSEZlMkdDZ01ud1gyOGE2aXFxSVk5clRxRHJlK09Ydjh2WnJISk9icTBLQ1JaRmJ1WFViaVJRSFg5c0dsZmFHb1I4OVd2b29LeURlV0Z4YldqV09TVzFndjVvUVlySXlTdXlMTnVsZUViQ3RCV3ZMVHpQUmlhS3JaU2pFSHFwb2Z4R3JTczdTK3pXVnMvTC9BTEt0aGJtUmhlMmxqZDR2a0ttZ1RkQlQzQTFSaC9Ub3I3OVhpMk1qWEc5MjVGREprV3RsZzQ1QzVpV056SEtGWWs5c0VyVUtLVTQ3R2hQNGROWjFtMHk4MDV3NVNDRGhCazdpN2dRRHNsNUdvVmRxR2lzeHB5MjVDbW14MlQ3UVBaTkFlNTRZOUxPN0tnc25HVUx0eUFmM0FnRCtHcjBWbWk2eVgwSkY3YjhoTGRLWGpISXFxOU5xRFNIZWhJeEVkMTVKTXJ0eCtwamNJOHhvckNKNmtuNW5icnBtSmFsalFXR013VUg5c3RZbWxrZEJJMFREM3RYY2lxa25mNTZpVDZFTnJrRnBKSklSVGlGRnN3TG1LbngzL1ZwaEdtNnVKM2J2eGhnWG9ycjdSK0I5VHQ2VjA0elFQdUxseis2c0lPNUk1VkhVOWFnNzZjWm1pUyt1OXUwM01VTlVQb1BVRGJhdWxBNE55TUJ5OW9ZbUpTYU04cmRtT3daZHFmbU5PTTlSV2hzcHI2ZVRIaFFzOGFreUxKN2FVMjY2ZVN0a2JFVFRXR1RXTnlVYmtZWmZ6Mi94QTBtT2laUEtiTytQYnIyd3drU253UFVmbG9qSGRxSDRGZGxxRjhuZkxOY1c4Nk51eWNTM3BUaURUYlduN2hrV1JLeFJnVUVScmd0dXg1ZjdvRkFLZkd1c01OTlpsWldMcSt3NkNnMi9MU0dNNFpYZHcwZ1psTzNJamwwUHc2YVFpVEhZdmN5c09TQlQxWWxSdlhwUUgvRFNIU04wZU1zeVZlNGw0SWFpcUt6VStGZXYrR2xJek5ReDlra01naWxWblZ1SURrOFQrSXBXaC9EU2tsQnArbXRuWVJtTkZhbTd3aHhVSDBvUU5JUkd1Y1JERzd0SGN0RXJiS0pFYW9iNGJiL25wU1Jaby90RjkyVW9WWlhxV28xQ3YvMVU2NmVSUVFIdHJ1RC9BS2hmY0VZbXEvcVVxZXBHbkdnMHVPYkV2MU85S2JiL0FBT2tNWjI5NWN4Z29KRFJpQVcyYnArT2tPbVhSNVI1dGxzdjQ2WHk4OGNrbG1rOHNqMjZvSTJsWnUzQ0J4T3dISlFLbXY4QVBYUFl1TFN1VDBycitHZG5tNTk3WVc3UFhYNGVRbmVMMlF0NHJaSy85VEtDNmtmMGsrdTJ0RE5hWk1YajAyMVNMNDhMd2kvUjI1dVIyN1R1R1YxYmtwZmdLeDFvVkZCK3FyYXhNMlJ6b3pvT1BqU1V0YUN2NVBtYk9PMXVIaUwzTHpCNURLV2FRVWpZaW9TZ0FXbTQxWmlvMjRlaFJseTllNVcxOWMyMFYxSGM1QXZLMzByUnJhMndUaTl4TWVaRWl0dHhVbFFmbU51bXRPbFcxQzhUS3l0VEwxMDZJTWVQNURKWE5oY1dtVWpYSGVPeDJUaDdaaVhrUE5DeVNGVFFtbjZrSFRwK09vWHBWV2xhMmtxKzdaMWg2S1A5Q3RjVk5MTmxaTWdsQzl1c2x3R1lBQUZSUlNmVDFHdFMrbFlNbXZXUjd3MlAvd0M4bGtrZWFjWEZvSXpJNmprRlJVUEp0cVUyTkF2U3BKT2diMyswdmlHVVc5L0FSZkpyNlM2djUyZHVTdEs3TFJWVDFvUGFnQUd3RkJvekVvUUprL2NBMUJkd282c1FCK2VyaXNlNGJvV2RnbG5HZWdwVWRDZngwSFpTNU5USGZiV0NHTWhOSGRKTkc1V2RTR1YwTkdGTjlqcDFYUXJ2a240bXk4bnVMdDB2SDd6d3k4bW1uSkRxaEpwWG1LbmJhcW5UMVVhQWpUZXZZbHh5M0xXTDNWdlBWcFVNRHhSTjI2ZHNnbjJrQXRUL0FDNmkrdXFMNktLeW1UL0U3WDZpNnQ3NkNic1EyN0xKTXBYbnpFRyt3QUhxTnZocXZOYmFvTE1OWjFRYThoRjVmNVJjcllSem0xdVM4YVNCVEhLa1I0cVdRRTdnMDMvUFZlSkpWaGs3UzNJSjg4dXNlbUdXMnRBSTVKWFNKQWk4ZVlCcTdOdC91Z2F1d0o3dFNyUFpiUU40OHNmY1VOR3AyQVhrZWxOcTdEVjJZcXdvYlBxb295WTI3WkhPZ0kvVFN2b09OTjlDd0dUQnJ2aTg2UlFxeVBEeU14b0NIUFJWNWRONjEwNklYbHZTQkh2WWlMcVhpNEIzSmR4dHlQb3RQVFJkZFZxWjlscWFJN2E1ajVUSzRFaGJnb3I3bmJvYWFsS0dnbjNWdGNyOU9GdU9iVEJ1OEtBY0dYYnFDYWpZNzZxVFJidGNub2pWYk9LQW5nUzRrWS9uNm4xMzAwNmpQcEJzelVweXRzTE9HUm1WWkE4aENtVDlBSUFxUHgwK05RNVpaa3RLZ0Z4NHh5b1ZCSkp4Mm9Bb0grSk9yOXlCNENGcmpiMkIxTVVhSXcvOXprV08vd0NHMm9XYVpKSnJvRTRjT2toTXNyYzJBQUprSVViZkFiVjFYdWpvVGhQcXczWllhMXArOHk4S2hWVldDa3NUc0tuYmZVQjVVaHF4dHJlTzRTQ0hIMGxwd0xGZ0N6c2FDbkt0T3ROUll3VHQ4UGpwYmFiNnV5RWNNQm83TzRFYlRxZVJqWnZSYUE3L0FNdEtSNEF1Uzh2d1ZoSUh4R1BpZTlwMjJsWGwydUtqalVIcXpFZjFlbXBxcmZVVGFRcDVETnk1QUlrc2ZLSVZZSXJNQnZ0dlhxUjhUdnFhckJGc3l0OExjWGJvOTJwc3JNbGZmT1dBS25ja2NRU1FCNmdhVzZCUU1NRnRoYkd6ZFlMbGxrbEkvYmlpa1dTVGpVYnlNd1ZSVUJ0aXgvRFVYTEVoY3ZMTzV1OG9jYkJMS3lxSFNPOGtDcUlvNDQrVW5FTFFFa1UzQUZTZE1ta3BMYkp0d1dENC9pb1BJUTNrdVZKRmhqc2R3dHBBd0ZaSVhrS3ROR055VW9pcWVJOXgxVGUyM1JkV3kxVjNhdnNPc09Na0hqbVBqaGQ1N2E4anNzWms1WGVSQThTR2FlNEN0c1U0TnpFakhZSGZyb2UxazhrUDRsOVY2UjJ6bmhIaXRuaklyV1dLOHZieU8xZ09OaWl1NWpZUnpORXNoSlFTYzNjc2FLcXQ4elFhQWVleXQyNi9NTyt3bzc5UGtGZit3TUhIWkpGZVduWWFDQ05aYlMvdVpMb3Bkdklva0NSTmRGQXdZOFZCWHFhY2lSb2UvSmJ0RlgzL0FCMkw4ZkhoU3puVDdrZmJiRFdubHlTWSs3a2lzOHZ5djQ0bERSb2tNbkR0OHFsZ09aY01LVkZEclg0dkl1Nk5OYTEwTXJrWXFxMHJ1UnJyN0hTMnNVTnc5MUs4TnlZZ3RHQldzb0JvV1lVREFzb0lQU29ycWE1dXNScUo4UFNaWjZ2MlB0VExIRTEwek9JWkRJbk5WWVN4aXJBcVZCNG9UeEpGU1dxQnNLNmIvTnRyb0o4T3FhbG02TDdMNDVMcWEzOTA3VzI4NklvWmtWa1ZrcWEwNVB5b3FVclhiNTZkOHR3TC9Fck1ERWZzWGk3UklDM0ZneWlzL3M0RjFaZzBhQ3RXTkF2SnFBS1NCMUkwSStkWmhOZUhTQVA1Sjl0TFhFWG1PV0syNEpld3p5eE1Wb29TRUFVNUdnYWxWM0ZhK2gxZGl6dXlldlNDckpncW10UEVoemVKMjFvb0VZV05FQlYxb0N3MjVjcWtnRUUxWDJuYW1yTjdZdGxVWTJ0cmpiYTdZUW1ONWhMSkNoQk1hOGtCSmY4QXE5Z0FydHZxV3I2bGFhUmpsYnVuaStXa2pSMGZ0TVJLeUdNdkcvY2pOVHRXcEovcHBXZzIwdHZycVNyWnF0dmdVNUZSWmwzM3Avcy84OWFKbG9tbXZiMjZFaXZ6MUVsSVR0WENuZXRPU2tyK0FyL0xVR1dva1hyQmtVamJreWhqV3UvWCtHb0lreVFEUy91RWpIVklRNU8vK2F1cC93Qmd2N21UNzJSSW9iSm5GVXB5SHBXaDNHM1RwcUhjblo2SURYSnJreTBSb0JFRFQwcFFWcDYwMzFLdlRVcmY3aVRrNUNaaVQvbFd2NGNCcFFKc1c2a3p6a2RlWFg4dFhGTEczN1hKRk41OWdvcm9NMEwzSEZsVUFzZHVnQkk2NmhsY1ViSjRvZDFKYTE3WmgvSjVMSzJ1NU1sQzlxelJySXd0VWlVdHhaSFFBZ2xSVWtVV2xLMTMwQ3JQWkwwTkMxRnY5TGIvQUNKSGlzRmtKWllqRzkwa1RMRk5leXlTd01IZ1htUXJFR3RkK0pJMnEzclRVY254SjRrcDZEQ0Z4RXNpU1RYTjAvYmxnYTJXVzZTUzNUdU1vREhrZ0MwSlpHb25YYllHdWgzVnJ3K2hjM1Z0VFAxNkVQenl4bTc4RWM5cVk4TmhMNnh5R1ZMdzltRXdTU2dMSTRQSXh0SVJJUUpHSnArUUYzR3NvNjZzRzVOWFBUUkZQL2R1WjR2dURsVlVyMnI2NWttUjQrSEFLejh4dzRIYXF0dVQxcWRhR0w5b0ptL2VRbHlUL1N4d2puSExJcGlkRUJSV2pvcFViRUE3L3dDR2x0MUNsa2UxSWpwY09vWm5sTGN5QkVzakN0S0VzdjhBU0ZHeDMwOEVWYUROcnd5ZHhrUkN5QWNTQUFxN0VqOVFyc1JXdjhkSklkWG1ZSGZMWkdLNGFLT1B1M0VNMk9zRGNJc1lDU1RHMWhMSHV1QVR4NDdLTlVWcjM4dzlaSnJ0NnFGOVJSdkp6TVduZHd6bFVDb09ZV1FMVUFkQVBhQitucHRYZlZxQXNscDFaQ252NHBJMHNwcFdFRUFDb1Y1SDlOV1FBMTNJQi9UODl6cWNGTHlKNkJiRWMzZ3kwZ0lrdW9yTDZnQVJ4dEVIdDNXcmdBZGVMOVA0N2FpMTBIcHJMOGlQTmNza2NONHpzc2lqOWdCQW51RGozam9TMU51VzlPbW5RMTNLVE1oYnVJMGt2V1c2Q25pMEh2YVJwQ2VWSFlVTGc5RHVPbndwVmhKUHVGUE1iaVBKeCtQVDI5b2x2Q01aRGJ4eUZRMHMzQm5pVVNGUjdtUXBYNUNpNzBHbW9va2xrMWpRVm9yYTRodWk2amhLNnF0S2dFa0VFa0tvRkZvYTByMTY2c0I0MUpFRnBQSWswNEhLTGp4N2oxazl6N3Z4QTQrNmc2RVZHK21aSkpqQmpiS2U4aXM1U3NqMFZvSjVTeURqRkhJUU9DaHRpeDl0Ti96MVcyRlVvM0RET0xqc3FQOEFYdUxRU0hzRHVBeXJjSGtCd1ozWnFsRWJnb1NsQ0tuZGRRWVJqcldOZFA0a0x6TEd2aTNhNmRGRnhqNzVaVGNnRVFSaVpBUWpveEpVcHdVaW40VTlkU28reFR5TWJxMjMyWnY4aXhkbkZrcjZ6aHE0akt6Uzl2MjhoY0R1MDJVMEFiaWEwOWV1bzFaYmZIV1FESGk3STh4SFZ1YlNVQ1A3QWprS29MVXFGcjFZOHVtMnB1eFNzS05VMXpDanlJaUR0UWRtUkFDNVFkcVJhZ2l1d0tocTcvUFVFU3lSRFNMQjhFTjFiZVBwNVphdzIxeGNXOXpKWjNjRFJ3M0YyOXVqS2tzbEpCVWNXWkQ4MWI1YWE2MWhnTlhDbGVJV3N2SnAvSXZIdkpKTW5IOUEwVnhMZnoza1o0UnhMT1JHRVZhdFJrSEpJMGpOVFgzQlF1NGVhdTI5V3UrZ1hpc3JVdEpuYTUyUzBqektYVi9LQ3YwZ210SkVwM2JxazZwSjFDcndTTWR6K25jalQycTNFSWpTM1dXVkY5N1lXa3lHRXpjam01ZklXWWE0dVNJVUpuVTBaT01GUXZIL0FDazhnRHZvN2pQUm9ENUNVcHJ3S3hEZjhsdmdTdjVIZlJnSU9uaWQxY0dYdHdLR25TR1FSQ2dKZHVvVGY0N2piNDZqWWtoNThXOG5tczdhRlR5akt4c0xhU0xrSDdwWlc1QmlHNHR4akNIMDZWMVJlcVpaVndOMmE4cWp2Y2FNbGJ5R2YrMnp0d2lnNXN3ZHlPRElwVUJsTE95aHY2Zm5YVkZjZXNGdHNqYUV5Zk1YS3oyK1R1MUJtbW5sdUx1SW84WEpuWXQxSjMyclZqdC9MUkNwMkszWnNXNzY1a2p3YlcxeGVSeXJ6K2xLS1ZjckVFN3NlNHFXcXplNXZ5MU5WVXpCQ1JxaHgrUmx6Mkh0cldVQzh5MGNFNVpqRkl4dDVrN1JEQjJBSE9SUTNGNmJkZFU3bHRaYldybEl6eDl2RmVTNUdmT0MydVljWkdxeUJaZ2duZFhLQ1B1eDFBNEx5cHdQNmlCcXUyaVVkeTJ1dWo3RU8xOGd0ZkRaYisvOFN0SUxwak5JcHRiZ0ZtaWptQ3FKSVpDUVNDS2JPbnFkWGEyMFpTMHE2bzFaUFBaN3l1N3ZzdGVRcGE1UUxGam83V1o2eE5CS3BibklmZHhjdTNLb29wcWR0U2RlaUlLMGtWY3JkOE1OYlNmU3pTWSs3dVpXZUxqOU1BRHlBYmtOeDd2WXJqcHBSRmlVNkpBeSt5Y2F6M0R5TXRxYmlRekJiZG1XR0VHcEpDOUF4NWJVK1ZOV1FRa25YaHRZbmp1TGhwV2RTMXFUSzVMZGtJanB1QVcyN3ZFK20zWFVPckhLNDhodFRhWmU1anBSV2Jtb0h3Yi9BTTlXcm9WdnFYSC9BS2MvS0V4bHpsTVJQTzBjVnlZWGpVYnJ5WW1OaVIvOU9vM1VrOGJobXJPNHUzeG1XeXVGZXhqN2djeUpOellBUnVlVlFxaGg4UnRUVlNVcVNUaVFKa2JPZUN4V1cyblo3OWw3YzhIZDVLMFNFRkgvQUVsdGgxcUtiYmFsVk5QeUdZdFg3ekxNaVhFNXVYaVJZMlZBVVNOa29lcEFQVHB0cTFFQ2RaWXEyemFLSjVXamdYOTFDS2RYL1V0ZWdwVFROanhJMDJlSXlNZHQyTWVxUldUa1JxSlVZVnJ2c0N2WDQ2aVNOOCtBZEhoa3ZacEJJYTlzQlFBUXZ4QjlLN2FVamF5YlhhR01zanlHV1VuZG5jcFFqcFFWT2tTazAzTXF3bnZLN3JFUU5rS3NSdDBPNHI4OU1OSkh1N2hKRVBaVG1CUU0vYk5kejhha0N1bkV5QzBhTXhsV1k4ZlZGOXJBK3RRQU5TR2tqeXh5Q2xLS1NDMWQ2TVA5bWtLUURmSHQzaG1pYmhLeWNTUWE4Z1BUOHRPaUxGWjNrK3VhU1JxeUdYa3ovRThxMTA1RUlYa0U4a24xRVRjZ1JSaDFCK0drbkE3VW1YMTBRaWlXZXNkd0RRZ2lxZ0hZa1UwUzhxZFk3bFNwREp0c0k1cUxCV1ZqdDBOUDQ2RUx0QWxGWXpjYThWQkJCNDFvVDh3ZE5JOGhPT0pXanBkcjJ4UThrWnlTS2VwWHAvUFNHYkkwa3dXZHBMVlR4QnFTVi9MZXArV2tobjFOaTNMS2dMa0JqUlRWYTBIOFNOSVphbnZlTEV0STM3YkVFVENOVnArQmFtK21IVDdHNTZ6Tkh4WWNJeVF2R1JDQWdGUlhoUTEwcEg2R0xXMXJLZVNWRW5GUzZBdS9yc2FsUnhCL0U2VWtUVGU0VzNtNFB4Rnc1RlF3Ty9GVFNsU1JYODlLUjNvREd0cExkakxGR2tWc09xT0E3QUg4OXdmNWFjWTF5d3dTcUpaMURPUWVTUmhqU254RlA4Tk9LUVZkNDZOeTB0b3JJZXJSZ015ajg5UElobXYzZy9zV0R4Tm5RM2VSbGErdjdaUVFJbGdabzRVMzNJTzc2QXhyMTJzK2xkRi9FMmNsazhWS0xxM0xYaDREWDRyaFpMNi9zN2RGWm1kd243WjVOd1U4NUhJMnB4QXB2b1RMZlJzT3cwbG82SGxHT3hlT3VyWmtTU2VPMjVmU0dwalpYOWlnRnFWQS9TZU9zVFd6azJ0Nmgvb1VCazdxeHVXU0kxUzNsbFpKSTRqeFhoRVN6QUszUVZGQnJVb21qS2QwMUhaaWRlM004dHd0eEpidEZkUlRtV1hZSDJrTXdIRTFVaXBHOU45dGFOVWw4REx2ZDIxUzFUTldabG50c1pkWE41SzM5eHVsUUxTU1F1REpzVllWb1BiVThmVHBxekdrN1F1Z0prYlZaZmNVclNDU1NObFJtNUVnQ05GNUZpQ1A4Q2RGMllHbEphTnBtWmZGUEFiSzR0cmRyYTl2bkprb3hVekllWkRTRGJrUDAvdzFtMnJ2eXRka2FWYmJNVTkyVkplT1dsb1g1a0FWYnB1ZHpyU3IwTTF1VFBISXJYY1pmOUNIbWEvN3UrbmZRZXExRFV0MmdOQ0NTTi9rSy9qcWlBaHRHcTA0eXZKSThnamhRQUIyOUN4OUJRNmRrVnF3NWpURTU3Y2xPekN5bVdKcEtBTWZkeTNvQ0NhVnJxcTJoZFNDTFBrRExiaVNTWkoya2ZremNxU2cwTlFkNm1tNHI2NmtscVFkdENkZFdtUml4QUZnR1JZUUJQT3JVSjVLRDIxM0ZkOXpxS2FiMUpYbFZDMXBMZjhBMDBTWEZ3WlhqakVEbDY3S29MRlNhOUFXT29OS1NkVzB0Ulg4cG5hUzdzNEMyMGFHVmxyVUFrOGR2NGFJeExRR3pPV1M4TmZSVzREeVVDa1VEMHFGK1ovTFZkMUpaamFST0dRdDd4K0xPckV0eTJCRmFFbm9LZkhUS3JSWnVUQzZ1VVdPTWc4d2lNeGMxTzRMZitaMVdPcFNGSzd1ckJwNXBXZXJPN0dGZW9SUTFLbjhhVjBUVk9JQTdOU0RGdXBHTHlxS2xTemQwN1ZKT3JJUkEzUi9XT1ZsY0YrVkFPTy9GQjBYNEFhZzBpY3NKTFkzRnlGRXJLcWcxb2F0WDhlZzFDVWlicTJncXRsWU9pTEZibDFRZENTRnFmV2kwRmRSbGtZbGFCR0hGckhIVmhIQkdCVUtTRS8yYVp1ZW84TStrdUxhMlBDQWQyWWdLYWc3SDVVR2trTUVsaXZaSjFXNGhkU1UyNEFpcURydFFVQitXbVk1c3RoTEZjbGZweDJvbVZsWXBVY2dLaWpFNzdqNW5UaVJEdVBNTVJqNHV4QkJETmZvU3M4a2toNGduZWhGZmRRNy9EVHFqWXBVQzdrUExaYjFtNzhzZkZpVHdVZTNmOEJUVml4a1hZd3NyYTV5alJ5UkNLQzNad2dtbEJRZXZJcURRdFFkYWFUMEYxR3JEWXkzalYydG9JbnVsaGtkYjY2WXd1VDZHT0pnUlFFZFc2L0xVRzJ4MHZBUEhJTGFZTVg0dTRMaVpFalFwelI1WjdtVW5sN1ZaV1ZGQTkzRWdFMHJYZlVWMUpONkN2a3poN25JSW1KaVpaWXlzaFdTaXFKQVF6c1FDMWY0MG9OV1RvUlhVRlgrVm5sejF0ZFd5azJ3WXh5dVQ3VWlsSmpBWURwVlNScXRVU3JCYzdlcER6YjRySVh1VmJFK0wzUkdNenQybGlrM3ZiakpGTEZjVFBKeFFWWGw3YWh2NlQ4TjZVOUp0MVJhMDU5UFJqYmNCcnZPM25oT0hzSkxuRFQzbHZaLzNBdUxlRmw0RXpzQ2FrczZpUWswcHlydnFqUk5YczQ4aS9WcDBTTDNqc3JiSjM3eFhrazBtWXRJbnN6TmJoMXNvcU5WUzlSVGNOekZXMlQ0K3ZONThxMWE3blE0Y1hlZWdvNWpJWS9IMjhkeGRYUXU3RzRtK2x4NFZJclZwdTNMU09LT1V5c0phMFV5bHVTZ0tSWGVtck1TdGEzVFg2L1VhOWtsMS9IZ1ZMNWZGbWw4anRyWVR5ejVabzR6Y1JlOTJpS1RydVN5ZnBVUnJTaXF1MUJRYTJlUGV1eHowTVhQVzIrTzR4WnZ6cHVFbGxkSzV1N3FScEpJNDA1U1FWTkZJaldQaUhJS0x5RktMeXAxVW1pbkgxM0xSZnFGMnpKS0xkZjBGVzF6K1N1cGJxU0hIelhOL2VSUSt4UVdsV2FNbzd6TUYvU25CZjhBNnR6MU9qWFNxUzE2QWF5V3MzNWxobzAzL3dCMFZodlpVZ3VKWUx1UzJVOXF6UzY0TFdPVGlyS3YvTEZSeFZoeW9DdFRVYnJEZ0kxbUViNGNsazFpTXN0N0hMYlhrc1VFbmNQSm0rcUFFTHV6VVZWSlQ5Tk9JMi9VU05VT3RaMFdwWXJ2YnF4ZTh6eXVRdlBPTVJKbDdpS2V5dDhiSnlnRVRzeVJyUHdBWm5JWnpKTU9LZGVLMFlBN2FJeFVTcGFGRGtHeVdieVZsNkN0YldsemtKN1FNRGN3U0dFUlJRVlpwV2tLNzg1Tmc3c1ZIY2taYUNuVDI2S2RvVEsybTJpRGtiQ1RIenpOSGJzYmlhV2l5b3hBQ3pHa2lxOURzUUtVVTFHM3BxVmJia1ZXckRZcitWUE5jZU01QzRsbExDSmtTa2ZJS0RLd0NBMVZRRlBFc3FnQVZxYTZ1b3ZVaW16OURLc2o5MGxTZWcvalFEUm9FVGdhcUJYZW9yVDRldW9GaVlSdGlVWWxEUUUwSlBvS0N1azNvVFJLdldYakh3YXE4Z0tDbTFmdzFVaWJOa0RCcjY3SEUwS3g3amZvSy9MNDZkL3RRbDFaUHlUS0JBcmc5b2tjZ3BwUVZQVFVhNnNuWUVTeUtNbTRqOW9NZkhmNENtcExvVnZxU01vNStyNHQwSUZUMTNvTktvckMrRFdhYmY4QXFKMWFVakg5dkwyS3k4eXcxM2MzQnRZSWJqbEpkTHdEUktkaklDL3RCV3RhblNzdlNLajlSWjgyZnNiN3krUyt2Wm9aSVdoZEE4RndVampsdUhYa1VRRWV4dUh1VGY0bWxkQnVqMkJsYnAzMUoxcmxJTGJ1YzdLOG10MUovd0NxeDhGd1l1MmxhUmlWQTZTQmdlSzdVM3BRYjFIZFo3NitZVlc2VGhxVjVCVmZOTUZpTEpXZkZaYTlzTFlScmZXa3RyTGJrdFNSVUhjSUVZVnFxQ0J2WDQ2aXNWbTRsRHZQUmRFekRHZVFqempPNVUzODF5bmpzajI5dGtjRTloYzNDOTYzaWVLTm1hSlpEV0huV215bi9Mb2ltTDdkVjQrSVBmSTh0bSt4WHYzMHNvby91TWtkbS9jaG50cmFlRnV2SlpJUXdKVnVQRTdVNEVWRk5FWUxOMWNsZklxdHkyK0FzM3hrV3lYajc2S1J5WGlDRVlpcDQ3QVYrTlB3T3BycVczVDJnd0pjWFZ4OU5BcnNUdzYwUXJWanNEVUQxMy9qcVhZR2gyY0ltLzI2V3lsVnAyRlpneFlxZWIxYXRBWE5LYmZMK08rbW1Telp0R3k5UVRXdUVubVZMZ3o0NUtSRWNFNVdoZTNSazRoS1VDZ212VWpWYzlRdmE5dFg1Zm9BeXNkMU9FV1l5RmtxcVIwRVVaa1JRRzVPeE5YSjZtdGY1YW1VV2h2cVJ3a2JXc1VuR1ZZWVNDV0hLaFNwSVdxZzBkejYwMkEwNVcwb0h6N1kya0Z6TjVYOVUwZHN0N2hyaTN4Tm5jUXRPWkxxTW1ZSlZqelFFTFFzOUZZa1ZERlJxbks0UytKZmdxNWZ3QTBGbExkY1JGRkxMYzNDRHM4UXFnU1VCWGs1YzhGQTNiZXRScGJpMTBucDFKOTVqTHFNY3BKRUVNcGtEQnBWQzhZbytUc1pLbWdvYTBCcVdPOWZWYnRTYXhOS1dRODFKOVRpOEZiaUdqd0pjSVprUW9ra1BQdmUxeXFMN0MwaWsxSjZiYWt1cks3MVVLQll2cmFYdnlFSVRieHY3M2VOaDhPSXBzZHpRZkg0Nm1ub0RYcHFGakFQN2IzaWVVL2RhS01JM0lEM0x5VmVKclNqQWN2ankrR296cVdiRnQ4eGo4YU5rMkd0aVpmMDNWemJ1bjZRRVdKSkkwakswUEVua0dhdnFmenF5U0g4UlZqWHgvRURQYzRCb0pwdnI3TjVqSlBBM1pkUkdrU1FGMkJWaVMvRW1yTXRBV2I4dFZxd1pseFE1aVRLUTIyYncwbUtobWprc0xubkhLNWpIL1V5S0dabWFRcUhWbEpvS003YmFiV3JraTYxdlJWblQ5UmZ5dkpmN1hjMzg0dThxMXJhUlRsYXRidVZEd05WbVlLRFdKVHpIeStPOWkxQklhU2x5L3lGaWtFRTcyU3EwWFllU09SdlkrN0dnNHlKejkzRSt2T2xkcWFtM29EdzVqd0NNTjFBcjBLQ1ZPMUtqSWdaWWd6S2FnQUt0V1VqK3JiNTZwZm1IMGFqNUN6Zy9NSmZGc25lV1pyTFl5WER0T25veVRSbENBUDZTSzFxdnkrR2pIWGNqbXJXMjJmeENXS3pFbGpGSkpLWkxwRlJaNG8rQlpGbGhsUGJibFJpcXFXcVFvSExjVjMxWGFza3FYZ2xYTW5rR2NrTXRuRGtibXF4Q24wN0NPTlRJMDBoWG0wU1ZhUXlEalExL2pxS3JXcTdEdTdZdC9jV3d5ZGpqOGZaMzFzYmRiU2hWWHU3YTRlc3ExY2hJSkhvQzIvWGJwcTdFMDJReVNWOEdQYlArNlEzOE50WGxBZnd0MjFuTkhkSTFEQklyc2xTcFpRUTFBUnBtcFE2TFF1clhIMnQyY25pNWJ5M2h2WTQ3bU95V1pYaWxIYkxQVndya0hrcFBFamIvQVNkSVpjMXFHTVRrZkdpZ3lHVngxMWZXME02cmVXejVPU0tCdzVLSXhqUkkyS3FkeUUzSHkxRFdZUmRGVXBhRWJLMlZyYTM5MGxaTXRKRno5ODA4bEdDQ2g0cjdCeCtITHFORnJvRE5HUzN0MWJpQ2UzUzF0NFlFUGJtdElJNHpVcUNvcXFrN2wvalhVR2xFQ0dUeHF3eWZsT1lrbWFSYnU3dDA3akc1dUZnbm1aWUdtN1NtUW51T2VCNCs0VnBUWVUxSGJvVDNTemZEaXNNMWtiKzJqUzN0b2tLWkN6bEROY2NCTEg2TTZvOGpBODBLMUh0T3BUb0w0RVBLeStQd3lwYVdjTWR1a3ZHS1dTNGhFek5Ld0RSSXB0eU4yRy9NdDh0UjN2cWlUcWpMeU8weDJJOGZpeUlNY1RLeXhSd1BEeGxub09URWNaR0o0VTJjazFQU2gwcXQySTJTUWxQbHJkNzAybUx0UThGNlIzaE4velNSdWVJRW5VZE91K3A3VytySU5yc2FiZ1FDK3NZdWNOcERKSVpHVXhua2dEaHFzRHR1dEN1K3BWYkVNVXQ3aG1NMEYzRGNYTjVjT29sdlhrNFBTbzJCV29DMEM3RDQ2clc1Nmo2Q0w1ZkZaaStqZXdEY09KU1FGektvWldPeXNRS2dEVnRPaEJudmhtV2JBWmxMNlJRWVdSNDNCclhmZFQ3U0Rzd0IxSm9TY0Q3NUg1dFpaTytndWJXYnV0TEFQckpDcGpwTjBLZTQxSzBBb2RRcldDVm5QUUQzR2N0TCt6N0x3S0w4bFYrckJyU1BZTnR5cnRUMDlOdFNnZ215QkJpYnk2eVVnZVpaWUhKNzkxVW9nOXhYcUFlb0ZScDVISGxWeCtKRWxuRXNkMFZDR1BzQm9uWUFibEtoZ1RYNDZnU0JweTl6SE0zOXV1TG1HSXNhTExJYXNDZlVjU0s3K21uZ2JjWlJUc1pCRGNYanlEWWlVb3p2dnZXaEkzcWFkZEladEc0WEN4MGE1SmxERjBIRlJ5NVVxQWFBN211K2trSnNoU05DczdkcnVLM1ZsTGRDZlNtMU5OQTZNVW5BY2xyZ3FEdHhJMkE5QnQvanBRS1NRdHhISkd4Wkdta2IyS3lrQlZvRCtvRUUwL0RTRkVFR0ZtSGNZVFZ0d2Vob0J2MUc1Qi9QVWh3ZGtjWGF6Z09WbFY2bjNkRFFkUGoxMHBJc2l4WUd6QjV5SXpraXZ2K1A1YVVqd0VVeG9BcDJ6MnlQYnVCdjhOU1QxSXVwbE5nN0tXTXlNcWhsb1NycnZ2OEQwMHp0SFlsdFJyZCt5Z2doaGlWYWU1MU80cC9BYVo2a1d2QTNMYWxJVXZWdG5rVSsrUDl2MjFVR3U5ZXY0YWlKb2pUWldPUS93RFVXaWhhRWh5bnVMSDEycUs2ZUJOR2NPVlJZeW5haWpKQUlJall2MS9FOU52VFNnaWE1Sko1Q3NieTJzYnVlWGJwSU9JUDRsUi81NmREeWFKSUVTTlc3M2RUb1JHVnIrTk9SMjBoakZDbHFzcjBkWkNvNEVEa0NBZHhzd0dtRWJvTWxjTVcrb2ZncUxUbnhvMUNLZXBvYS9QU0hOOFVDaUF4V2wwanF0QnpkZ0l3U2FqOVIzUHhBMGhqYjI0WUVqZ3VPVWs5ME9MUlc4cVB6QTM2ZTQ5UlhmVEQ5VFhOYnEvc2l1TzA0REk4WVlOeTlmZHNLVTZkTklRRGtheGlrNS9WRVNqOVZIRzM0Y2Y5dXBEQm5NWjJ6ei9tdVR5VWdXR1BsOUpZMjhWUUk0b0J3VUlOdHR0QVk4VHg0VXV2YzE4bVZaTTd0OGtYaDl1OGFtUGEwbmxXWkxtVGl0b0NDSXgzQlIyTEFVTkJ1YSttc1hQZmRNSFFjZXFsU0RQdVo1VmVXT1dlM29KT3pFVEZMR0tieXJRVkJPL1VIajYwcnArTmkzSXI1V1IwWlQ4THp6TmtNamJjcFpJNGhFRzRsM2RwRzk3OFI2S3ZXbngxcndsQ1ppdXoxYS9IaVE3ekpaR3l2YkNTSHRCNDRsVzNjQUZZUTFCemNmNTlxKzdvS2F1clNyVEtMWHRTR28vSDhUMjdobHZKamFRckplMllrZWRPNlc1c29aZ3owcnRVQXY4QW5xU2FycjBLcnAyMFBCY1kyR1dPeXNvb3lUQnlXY0tTd2xLbjlzVUtnOGlldSttaHZWa0UxWFFpdlBrTXpHc2NvN1BhVmc3TUdJU09KS0JWQjJvcWludDFPRlZrZDI5UUtrakYyTHQrcGpVNkpLQ1ZaZTBPL3dDQTFHeE9oc2FRbXRONjdhZ1NrWS9HTEU5aVhJWE5zWHN5NGhTZHYrV3JqM0dvL3FCRkZJK2VxOGpnblJTZzNEOU5CZFMzY2tjRzhUSThGdDdvbUFLMVBKMUNrK2xOVXpLTDZxR0Nic2d6Tnh4NlFSa0lBWkVGVkRIaU56VTlhMEhMVmk2ZFNxeVd1aG9pRnhjM3dzWmgyNElKMmx1aXpuOU1hZzFldFFOdW1wT0VwS1c1R3EwdUxSWVdBalo0OWlxZWdxYTdENDZIYVlYamRXaFR5bU95K2F6VjFkV05oTkpha2lPSnVCQzhVQUg0ZGRHVWFyV0d3YTgyczROa2ZqdVR0bEQzYXd3b2pBc0pwVkEyTzRJQnFmdzFCM3EraE5Vc2wwSjF0Q2tWeEpkU1hWcDMzREJJNHlWUmZRaWlKUWJkTlYyMVVFNjZPWEJDdmNwYzNrcmZTeDhWYjJuZ1RJNXA4NkRvTlRyUklydmVTQmE0bVBteHVtSEZxaFUzYzArSjQ3ZnoxYTI0MEtJSmx2aTRFSVA2Z0RSRElDYVZQK1ViYVc0ZElMVzlnN2hlODRSTitKcFhwOEFOVXRvbWlXWmNiQUVIRnBIWFkxRkIvQTdhWkprcE55WFVrNEVFVkZRR2xhLy9BTU8xYWFVRFQ0R3hjZmM5eG5lN1ZsTlY0RmdXUHozNmdVM29kS1JhbStkYkNNUkZsRWM0cUpKbkhKVytCNHFmVFRLUkVaUElMV3l1U0Z0UmVXUWFyc2hOc1pLR2dHNVkvd0F0UHRiR05WMzVVWkVtdG9jZjJzZE8xZm9ESURHRnI2MFVNVFg0bjh0U1ZQTWs3ZlFnV2JSM1VoaXR2SDdVcHN2T1FzRlFuMUxhazIvRVpOZUF3MnNNR05Na2NsbkFMbG9pOE1ZVXNpL014bGF0K2UveTFXM1BjZE9PeHVOaWM1SDNMcWV0MUdwYUtFcEdiWklnS2dCR0lLQTdkQlN1K21tQm01SUMydDlmOExxYUlTUWs4SkpESVhUL0FLY2lwWmtKWlFkdmRxZlFZMS9Ud0prSklKZTFISUtDS0dObEliWUh1TzdNM0hmNWc2YVJRQ3M2bHZpekl0bktQcUkxS3lUeEZXQlhqK2xTUWFiRUFuVXE2aTZFTEF6eEwzY2RFV2E4dUlaWkROVUhkVnFGNDdnL3A2bmZmU3V1NUtqTGNzL3VMZStOVFd0bGpyTnphMjF0SmIza0x4S1psUzNjR2ZpNUd6N2ptM3BVanJvSllkMHQrSVk4dTNSREg5dWM3Zk41TmhjQUlmOEE3cXJmcTJVaUFhVHN5WFR2TndEQmxEZHRFNHVLMDM5ZW1xODFGRHMra0Z1SzNTdmVSODhrbDhxN3d5dGtZWGx5RndUYTJFTTVrbGt2QjdicWFSRlB1b0lrV0pHQkEzOUt0ckR4MnhyMDI4T3ZrYlZsZjkxZnd3TkJaWFZqbExYSjVDNnNwTCsza2tPTnhsM0tqWElEQm80NjlwSnhCQ3BkalZYWHQ5YWpaZFNXUldVSk9IMy9BQkVpZExWc20zcXZ4NXg1Z0tUR1FYSG4rWHl0MUpJbG5heFdyTGVURXcyYzF6T3o5dHlzaUZ4QUE1a2pRMVlyN3Q2NlByYU1LU1g4L3dEVXo5czVXMkNiNVpMNlNXYU1JSm5FTVQyYVNIbmMzRERpcmhpZDRrV2pFZTFubDJCcHVMY2VpL0dnMlRYWDhQOEFvYWZGdTlqYk9kckdGcHJPZEdodjZ4aDVCQ0VkNDBxWlZhakJhdWxSVTBYY1VPckx3K3Z5S3NjcE9BeGp3TEc3dXNmbGJGNzI5Z3RYWnJtUUhzeHhSODVnR1QvbE1haCsxUnVOUng1RFlhYTJxVFRGVnc0YURjZjFsbFNCckZURHdVdUpsaWxsZ2hqZ2QyamtlTUpHVEl6N2d5QUZSdjdGOXcrMU55WFMwdFJOemtzK1E4dXVNakxjSUVrZzQyMTFLeVFFb0pwRktvc1pXbnVxc2U0SnBYK3JSV05LdElSUmR1MTVZTFhJeWdEdk85eGJ2UEZBWGhCYWVTb2xWbDVNcDQwVVY0N2dFZkhVbWtWN29OV1dqZ2htaU4zY3hSV1VnV0YrMUpGeW1NUnJWUlU4a0t5Q3JLbkducHR0T3JiN0ViUlBVU3ZKczVhZjlvWFdFdExudUxMZFJ6bFF2c1poUlJ3SjNDZ0wrbjg5RlVyNmsyQzJhMnRGY3h0U1F0K2RQNGFJS0NZcHJRL0FnRFVSd2pDYUk5Q0RUMDY5S2FWdWhhaktkeTBjUmJxV0FOT3VxNEhiQ0ZpeGU0dVhKb1IyeFFkQUFnMG00U1E5T3JKbVlCTUVQVGlvRFY2bmMxcHRxcXJsbHQrZ0ZEZHpJVjVIY0EvdzFiMktlNUp6VFV1Rm9mMUFmeTAxUjdnQUVHYVVrLzFhdTdGSGNOZUpCZjhBdUN3U2xWa2xDc3RUdUN5aW0ybGJvS3ZVdWI3YjRBNS9NM0ZoRGtUYTVIdExQRzdxb2J1cEpLUWlWVThveW5FOGhTaFBTdXNqbWNqN09QZEVvMk9GZ1dYSnRtR1orWTMrWnhtQXVNekxkemYzU3l2b1VobGxsbVpKRWlscDdJME5LbmxYM05VRHB2cGNlNnZaUjBhRzVPTjBUMTFURW5MTDl3TXBZMmVlanhGNUpqRWxtdXIySkpwNVE3cS9jZTRjRXVZWTFEQkZQUmZqWFJ0YlkwOXM2Z0Rwa2EzUm9OZmg5cm5iNjN1N1cwdWJpMjhmanEyVW1mZ2JLN21qOTEyODBrYmlRaFdZaU1LVDBGVDFwSExrVlVwTE1WVzNIWVVQdWZldzVMekhHM0tGRnM1TFN4V3NJYmdvV3lRQWRzbjJrQ2xmZFhWK05SVmpYYzJYZ1FBSVdqTHZPVEVxY29YalVOMEd3UVZCQkhJZ25vS2FidUdKS0NMQ0d0MmpXWWgzWmlKZjB1Q2hISUxYOUpPOUNLL0kvRFRsUzA2bXU4eVZ5bDF6aTR4eEZ4SE1wVUVjcUNnWDFwN2VnMytPcEpGZVRKWlBRZkxlMnU1ZkZQSDhwY1RyUkRlMmpScFJaNHd4V1lsZVFIb1NHUHBYWWFvZjdtZ3JIS29tL01ydTR1NGJET1N5U0FSRzNnVW9ReGtKQkFVVldTZ05BMytYNWlnMFFsS001MjIza21MZVRUeHhLYmVpZ0trMXpLU3NTUklGTlkxQlFDaS9xWjY5YWZEVVlMSGFldzZmYW04eDFyOXdjVk5kVEd4eHl1OEVzMXNxR1dWTG1DV1BpQVJTa2hmaHZ2djZVMnB5cDdOQXJBNnUva2VwSWx2YXl5d0dkUjIyUXpVN2NiT1pCRXFJeSswS3BaT1czSS9nUnBvQ1ZiMHpxZTV2STJGdkRCQUpHbmhDeG9rZEpGNWJLUUtIY0tUUnZUbDEwcXBpeTNxa2tEWnNwSGNlSEN3ZVFMY1dHVHRwMllsWlR4a2d1STV1SlZhOFc3VUlveG9DTnRTalVGdGJTQldqeVVrVjdGTEs3TGJQS3BMT09WZlNvNW12SWN0dm42MDFkQU45eHBoczVtSHRDT0syaW96cVkyUUJ6SEVyTVFuSDlOU1dxMVRxRzB1Kzc1SUxlTzUrNHRienNKN0xacExaakUvSm51R1YzU1FIMDNEYjFYajBvTlZYb210UTNqNXR0b1hUOVMwY3Y1UGErUVp1K3VHaE56azdpNUsyMXRGczBzaFlRS2lubFRqMjZNWEtIMzBvZXVxRlhhalh0bHJaOVBnaFR5R1hzNDRSWjRKN3FLMmFlV0x1c2hqZnNPcW8yemRCelhodDY2dVNmY0J2ZFJ0cktJTFpMRi9Wci9jclZyKzJFSXQxdHBuZUdHU2FIaXlnZGhRQ0EwbktnTmZ6MDdxK3hXc3RFM3VVb0ZaN3pOY2dxVzh0SXJHMlNTNnQ0SWdDNlR6Um9ranN6aXJBaFI3VHNCMDA2cDRGR1hrcDJsdlFUN1RLU1hNdkd6UzR1SnQxaWloUnBLVmFvb0R5SkFBTlBXdStySFNBS3Vmd2s2SysxUGkzMnN5ZmlRajh4OFp0WDhyeHp0SG1ua2pNbDIwY2lyTEJJVmxrcU9LTVVrNHFLY2E3VTN5ZWE4NmYvSFp4K2daeGE0Yko3MHBIWEwrRytCZUgzOWdtSHhGdFpZektoSXJrSkpMM1FHRE1oQzgrWVhtVTNDYjcrdWhLL3dDUnRlNnpiN0JuMnNFK212eEYvd0F5OGN4VWRoeml4SzNsdUFrMTIwT1RuaGQ1WXlWaWtpTE1DNnJ6ZGFuZFhHKzFLeXg1Y3MvdWgvQ1NGOEdLTkt5dmpCVzJSKzMzZ1dTbnpHSHM3ZTRXenNZdWEzMFYzOVJTU1JlNUdoWXhWTWxkaXU0Mk80MGJUTm1xazIwNThvQU11REVwU242bk5FMGJXOHNzRWdwSkdXallmQmxORC9ocmNtVEZKTnRJMURTbTZqWW1sZlRTRU9XTnlhUzR1S0tTZDRyakdFWEZ1NkZqeWpxTzVFeW5hcEc0K1BRNm9kZFNhWVJYS3d2RGNCRVJyZDJFOFViQVVydVZDcy9UNGJhanQxSk5oak4zVm5ObEpzbVkxK25lT09maXhZc0ZuZ0FadmNTTm1QRWY3MnJVSml0WTNTMkdJV1c2RC9WcmR0M3d6VkNJcWhnaURpZVB3M1ArR25hYkl5VDdXN3RwWWI1NGl5WEhZaGVDNVJ3SDcwVWlzekx0dDdXSTlOUVU5QnhvWHg3TzQrMXhIa2VjWDZmRDVFSkJGMkFKNG5SS2hlWVE3YjdMWHFlbXBlUWw1bmw5aDRKWWxreGRpWmJ4MldLYUdPVkJLc1VBRDhvcXFEKzRPbkxvUVFkQ2ExNnZRS1VOZVpIdnNSTGxNTGFpUC9wekpjQXlXa3FpVjRtYU5nN0hpeENBVS9TUVA1YWZIYUdObFVwTkMxZlJZckNadXpnZU1YZGdMcGttS2NBN1dxRmVMcS92QU5HZXUrcjVtWUtPakZpL3ZGdmIyVzVta2VSVEpTQkpHb1ZSVHdSUzFEMFJWV3ROVzFXaFcrb1JobW51QWp3d2puTDBjTHNPbjlSMkFCR25nZVNYTGhNZGVXM0NiSkNHNEZESGJOR2VYSUFDaGJaUjEwa016R0h3M3ZNUG9wVnVkcWxnUUFLZGFnYjBIeDA3SW9tcjRoTkV5cE8wRVpiWktNSDVHdE51WHc5ZFJrUWNUd0c3dG9qTXNEVGoyOG5pWGtQZWFBajRqOE5TbVI0TmtPTXVFcGJyYmgxUHU1dUFFQTZWK1BwNmFUZW5RYU5Ud3gvVGw0YnkwV05KZ3ZKNGxhUmdwWUhsVGtvQStSMURxUDBNeEZHamxZQVo5MkVSVktFQmp4VWZ1MFAvQU5CYjQ2bDBHWkVrdUhpaEVsM2I5dTRrZjludUNnUkIvdktvMk5EdlhVWllrakFTVCsyMXVJT04wZjM0clN2YWR4dHhLc1VvUWEvNXQ5SWVER1NHU1Iza2htUm5CSGNnbTNkU05xTXlLVjIrTmRJU2xHeHJKNXdxUU0wYnRVR1NKUkl1eHJ2dnRRZWg2NllralRiWTI1bERxanYreXFndWc1ZnEzcUFhZjRhZVJJenRwckJKaEh5WmxQUHU4bytoTlFLY3lCc1JwaFNhUXNseE1JZVJpS2h2YUZLQndGL3pFa0FtbngwaEVKWDVnY1U0Z0doWnFrZm5XbW5IYk1sdUJVcVJVSHBVY2Z6MGhtWkpMemtxQVdJRzROVzZmSWJlbW5jaU0yaldWUzBzWTdaVmdnSTRNdTN5M1A0YWFSekN5dWJ5T0I3T0tvaVFGUzQyRlZOU1Q4S2pTSU5lQjdQYVlXYVB1eXgzVVpXbktVdkdEVWcxUEZWNWJIMCtHblF4QXQwSmxLd3Z5V0lFeHVxRWtrR2dJRGZHblRUTWMyUjVLUWM0cnBDd2QvY3hRY1czNjdMWHJwREhrb3hzY2FTdy9SbWV0ZUx4c1MxZDYrNWFML2hwQ2cwenp5TDNFYU13aFNGWm95Q3JWTmFVVDBQeEIwaEVPNnkxemQ4TGU0Y3FnSUNsUndBVUNnQTZrN2FlQjVQWTdTNWFNTUVIYWNHbERFQ1BqK3NnajhkSVkyUXhHSzREejJ6eTEvUW9sVldKSUZlb0lJMHdpUmR6cFBkU3lTUkcyZ1BGVk1ESThoWXJRa25ZOU91a01TTG9ZTzhpVzJGdjN5QXJmVkFCSlFCNkhqc2ZuWFMxSkJEN1QrR2k5eXk1YkpvR2h0bGFjSzU5dnNGYXRYMEpvRHJONXZJaXUycHNjRGk3cmI3ZGpvUHk3eXl6OGR4SGRpaGtsdkZpN2thMnFLc2FSazFMTno2VUd4NDExejJIRnZ2MU9peTVGU2t3Yzc1L3pxOThnTHpUTkhHV0RNeUlPWkJQKzhhVk5PbXVneDhWWXpEeTh0NUYyQnVNV1JHczNlRXZjU0Rta2g5cUJYSkE1Q2hCclRvZFczaUdCMHRxbkVucXl6V0N5TkpISGMvV0ZvS0J3REgybURNZUo2R2xOMkhyOGRTVU1ydlpraEV1ckcxR1ZBaGEyeWF0RzhkVzc4Y2JCa1lnRFlLTi9YUzBiMmtGcFdlc2tCYlNPeXVrVzQ0TEREQ2J5V0ZTM2NYZ3Y3YXVWTkt2VUVsZHdPbXJIYVVSamFCTDlMbU95K3RlU1NIdktvaGpZTXZPT1VrdHhyMFRiMi9FYXRyRXdWMnJDa0E2dUtTU2xVakE2RTc3YWoxSkVtMWhhNXVZN2RQMXlzRlVuWVZPMWQvVFNtQkxWd05NOXpEYTJsdmpiZFVqRm1TSnBRU1RLU1BkUUpVbXA2MVB3QTBMRGJsaGVpVUFtN3l2ZmRQcGc2cWxWRVphdXgvVnhwOFR2cTJ0Q20rU1hvYjQ1Sk1uY3dXUWFTR0NkaDJ1VktzVC9VZHlhazZhTnVvdHpzNENGMWpNWmliYVY3azNVbVJsMzV1VEVqTVNWWVVYZlkvSHJxTmJPM2dPNlZxdGVwSnRsdFpiSnNsSHlndFFhUXdzNWNWUmFGMkhyVWpZYmFnMjVndHFsRW9HTDVINUhsQkZZV3l5VE1FRWFScVhjVUJOS0tvQUZOV3JIVmFsUDNHOUNWLzJ6NVJNS1hTVElHM01NRURPKysrNXBRZngwMjZ2WWFMUWVQNHpOWmxacm0ydUdjN2czSVlBbjhDQU5TVnBJbXo2UytOZjJXaVdtdy9TS2VtMm95bDBIZXBMaXNRb1Q2bVUwQS9TQ0svNEhTZHBKYk5DVTBxUVI5dTNVY0R2M0Zvb3I4L1d2cDExRVRJWmp1WlFPSnJUWUJSNm4wMnJwOUNCbEhqcEZKa3VsTVlKMm9LbGdPbzkxS0hUeVBEZzJpMHRYdDVibWU1TnFBQ1l6S0F2S2hvT0d6VnFmaHBtMk9xa0NiS3lORjJZWk9RMlFQTEdpMFNsTmh1ZjQ2bHRHbHdSWEVqcnljOGpUMi9EK0dwQ2d4aVBKMWhWV2tkdWl4aG1ZNzlBS0VuU0dETWVBZU9FVFh0VjRlK1pFTzhhdCtudUVyU3A5QlhVTnhOVjExRHNBVklFdG9KNHBMYm5Wck9SZ2s4cUQzVVVLb0pWaUJRK21vRHNLejBoaDQ0OFRZcFpFN2w0T2ZGV0k5bldRMXA3cWdEbDFKMHd4aGJSWWVHM3hpWGpYVjA4dFlwREhjRzI3TVRNZXEwYnUxQUh1cWdvZDlMVWVETEs1VEU1Q2VER1lmR1I0NVlIb2pxelhMcy9MMkZnS3h1ZmJ2UktiNlMwMUYxY0lXL0lNeERoSlA3UmpqSE5KR3hFMGhpN2NoUFUxWlN4b1Q4Q05UcldkUnJPSEFsWHNkd0xPNW11RVZIdUFvaVVVQkZYSFFFa2dVR3JWMVJDTkQzRDNrbGpjeTNEb2hrdWxhRXlTQ3ZIbXBWeUIrQjA5bEkxWEJjT0orbnZvSU1iYlJFV2NjY2wxZTNCUVJKVzVMQms0TVFXQklIRmZsWDRhQ3RwcUdyVndXTjl2Y0ZKRmtyanl6Rm9rV2ZzSjVSYW00ZGpheVJ1a2JLanhnRml6bVNSZWZwdHNRTlpuSXpiVnRmU3hvOGZFN2FycWlFTG56YnlxOUZ0ZVlLZXhUSDNGeE9jVExIRGIyODl6ZVNTU0dSbm5taUxpS0prUmVCOXdBMkFyV2piaHhxVTA1WFhWNkw2d1hxK1hKbzVTWGJvYXNwZy9LSmN4QmtSaExhVTJhS3RoYlpESldzVW5lakFMeXp3eGQ0RldrVm5DMXBYMTZhbGl5NDBucTlmQ3JKNU1XUnZwMDh3WkQ0UDl6TWhldGtydVBIM2I1UXhQRkJIa3BiVllFeDQ3UE5sS3NXQzBxR0IyOU50RVBsWUV0cW5UeThRTjhmTzNMalh6OEFzbjI3OG91VkJrOGd0VmVJdkU0c2JDNXVZcEZSbERJazBqeHFDU0F2czREYzFJNWIwUGwwN1ZmMWd2WEd1MSs1ZlFrUWZiYk9pQnBiM3k2V09Uc3pOWTJ0cGpZcUxHd1RsM3AyN2thbVVLbzRtUmpTbnhwcG56cXpDcCtmNkU2OE96NjIvTDlSQXdlSC9BTzZNamNZR3h2cnlXUEJUY1lURGNMYk9nTS9IbXF3VzRabk1qVkxWb0EyL3JyUXk1ZGxWWnJyK1BFejZZbGV6clBUOGVBMjR6N2Z1dVN2L0FLcktUdkpIRUUrbmJKU3pUenVJejNDelFzc2E4QnhpWGs1M2JvZW1xSHlYdGxMOGk3N0NUMWIrb1d0UHNqaTVNckxjelhuQmdCQUxDTzVsZUpHampxalR5R1JuZHczT2tVZnVQVUJRZFVYNTlxMC9pU3J4S3UwL2tOM2pYMks4SXVMSmJ1VzFtdTRaSVo3aTJudWc5dU82SFpBdkdVR2hDcWhOV0ZhN2ROQ1pmY01xbnNFMDRtTHdrcFBCZVBXa1BqMS9kWFZ1N01rdHhTNWhEZHRUQmNkb2lvWDNMd2FnQlllbnFkYlY4cmRra3pOcGpTVGxkeFUrNE43Wkw0dEZZVzBIWmtTNFJXY2hRMGdWcENDU3Y2aHVQd1BUYW1yc05YdmtwenVLUVZYRWFzL3IvajEwZXdCRXFGdWdIWGx2OGZYVVdTUVNoZmlHRkFReE5mNWVtb3N0UGJuWVJnVTNZSGJmNDdEVElkayt5ZWsxd0NLVjRBL0Q5Q2dhVjVSS2hMeTAxTGRCVlJVQ3ZIMUh3MVd0WEpaZm9DWVRYSXF3RlJ3QkkrV3A5aW4rNDl5NzhyenJzT241MDA5Ulc2Z1ZTUkpKWHFEcTVkQ2p1SGZEM1QvdWZGbVJ4RkgzNnZJK3loUjdpVFgwRk5SdDBaS3ZVdjM3YjNOOUQ1bmVYTmkwZjBBaGpuSzNLbHk4RXBZRUFxQXkxNW1ySVFhdDFwckY1MVU4VU5hczIrQTJzc3Byb2JQS29MZUR4OTcrVm1rWDZtMnVIU1ZsZnNGTG9Ld293NkhwUUUvRTZyNDdlOUx3SHpwYkc1Szl6L2tGeForUTVXRzROeWxqajQxZVMxa1ltR1YyUE1yTXRGTEFncXlSVTRBcnVwcWRhbGFLMVRNdGtpejhDUGRTWXE2c3N4ZHM5MWpmSDJ1b1pMckU4U0hsaGlpRWpROXh1SkJKNjhSUTFycWFsTkVIdGMrQllYanZoc0huSG1WLzVmaUpXdHZGTVJpV2FWZ2dabHQxeHZGUzRORklxUWhxMWZ6MjFUZTIya1ByL1UwZU5SV3lxeWNKZnlFQzh3bHBlU3NjZkRKemNqbFpvQVpIZ1U4aHhDYmtnQ3ZHbS96MUt0MnVvVmt3cDZwQTNJVzBtRm5NZDZ5eTN4WXhoSTVESzNjb1J5cUFOcW1pdnZVMUlycXlyM0lGeVUyUFVIWGNQYXVoQkl0YmdGZTRxb3dBVmFFa0JnQ0FCN0ZIWDg2Nm11aFJkSldoOVI3dUx0c2Y5dU1XVGJIbmM1UzhtanVHVlR5WUpFQUhGUnNPTERqVTh2WDAxUi8vQUZIcjJDcGpEMDYyS3l1Yk8xZHpKSEtEY3NzaXpJUndYbksxS1VWZDZVci9BQS9JbVRNZEVZcGVKR2dZeHRkTkNycUxabGtaVHZYa1NHQjNOZVZEdjAwNUNVaVg0ek0xcm1NWmR1NkxiTmQyMHJXN2lxQmhjbzREQnE3RWRWSjlhblRXNkVzYmh5VC9BQ2k4a2c4b3kwTm1pUVc5cmZUQzJoaWxaNG9sV1JnQUdBRzRhaWl2UWpVS3JRdHRkN21ETGllT2FaSlRQTE5LdEFpSjcvMGdnc0NkMUcxQi9IVHBFWGJXWkplSmRyeVBKWStQNmliczJ2MThNTUNnc1doa2o1aHE4d1ZDR1FtcTFvUFRmU2FGVzNWQUJyOTVybEdjcVY1a0FNUVI3YVZQSWlnNmV1cklLSGVXVDRMNjRqbG5OcGorY2FLV2Rva2tlS05hY1ZZbEJ0dWV2eDFHQi91TmRFTVBqV0d2NU0xWjVUUGxiUEd4aE9Za3EwOGlzT3NhS1ZvVFFLZmNLRFRXNlFpZU96VjFaanhmZU9lVHJMWjN0cGZ3UnE2Unh5VDJieXh6RWxpMUVaNHh6SUhyeDlhQWFwVWRJRExaY2pjeU1HV3NmdC9IYXkyalpQSXczd2RaR0Z3cVhpSVF0Sll6SEVxRWtzQTRLdnRxTlZhZXhkYSs1UkpYMXhpZkJyYTF0MGt6VjlrN2VObmthempSclZLdjdTVjdyT1IraGFrRFJEYjdBRG9sM05kdTNnTVRLV3g1bWpHM09WbmxDb3V5cUdWMUg0MXJwcFkyMnA4TW5ZUVN4M1dCRmxqcmhEU3NVRE5JQ0J4NUs3T3AzM3JwMjNPcEpWWFl5azhseVNsbi91VUgxMHhlT1dhSzM3UllQdXlsbjVWQnJ2VWFiYUxwM1BMTHpTNHRlM005MjZpU202d1JvM0pPblFFRUtQYU9tbWRXeDYzcWdldm5kTG9OYVhOd2pSRisyNk93WmVkZVZRV0tsVzZzckE2VHhydWlQM1VubzJYdjRmNUJqUEo4VGlQS3JsSUxlN3RvVnRNazBmWVRsTFpQSWthcEdDR1oyWGl3QjZENDZ3T1JSNHJ1aTc2bzFjZVJaS3F6UzAwT1dQTmNVWS9NODZockVqM2tzNnE2a1B3bll5S2FmZzJ1aXdPYVYrQmdabEYzOFNKYVlCNWFVa2NqMDR4MTYvaWRYRll6NHJEUldpU0xPa0tjaHdNa2hJWmtZVU5WNWpmNTZpMUk2UEo3WHhhR1B0U1pHUkF2NlZqa0wvcHBWU3ROcTc5RHBoOUFmTEhGZUpieDQvSVhGekdxTWpLVUNsRmhKWUN2VTA1RWc2Y1JuTmlJWTdjRzRpTXJNeUYxRnkxU0NvZHRnQXA5dXcrQjFIVVVCR3p6V0d4OE1GbGo3WnJidlBXYVZ3Qys2KzB4QmlkeFRldjZ1bW9Lcm5VbHVTMExTWHlaTDBUNGZKVzg4LzhBZDdaQ2JSQkhKRElxS3pBR0ZoR1VaVEh5Q2xpQ2EvSTZlQk5oRHgrMnMzeFYxZ3NpL08ydllqUGFsT1VjdjdUcVg3YzdxZVBjQzh1RWhJb0tFMUc4YlYzRXFXZ3grNkdHYzRUNjN4cTF1WTdld2hqZS9tN0hKcmprNENTTFBFOG9LMFkvMUFlZ3J0b1hGaXRXMm9UbHlWdFRRcGpJZUxaNTdxR1A2TjRaaklJZzBxaGFzM3Y5MjlTYWtMbzFJQ2JBdVU4ZHkxb3F6dWlsaTdJSTR5WGtMcnNRRjY3YW1tUmFOdUV3T1Z5TS9hWkp4Q29Ka1psWVJvRkZUeStINTZkc1liTEh4aFF6R0s1aklSVkxVVU1xbmZrckg1RGVtbTNNZUFoL2E3S0NSNG9vSTdtekFxOHFDa3FKdnlMQWRRS2RQaHFNa21pVWYrM1M4VjVEYmk0dFNXanNiV0pxbm5JZUlZaGw1THVBZngrV2tOQmp6bWhobHZCZWZTM1hjcUxOSjBNTG9tektUenFzaTAzRlA0YWVSK3B0dnM3ZW85czl0ZTFVd2lXNng4NVNLUlRJZmFvZFlUK3RUVWxXSDhkUExhMUdhZzBESjVpM3Q0cjZiRndMYnZJaVc4YklIakxscUJ6SXBOTnhVaGh2cE5qUVk1TElaS1Mza2tGMVoyMTdibWoyVmtzSTkvSUtxcWhWZVJxQWQycjY2VXlPa0FMbkxYUW10N2k3S0NDSm1EeDNTaVNzOVBjR1NOYWoxTy9YUzZpa254elRXYVJYK1Zack93dWxFY2JUd0ZvSkluQlpUQzZBbEF1eDQxMytXbUViRXZzV1lJMVc2aXVMVkZEVHdSQm94S0VmWXpBSzdIYitrYVdvajNHNVcxZTRvb3RybTNqY3RCYXhHV0ZlUkh0WWdSMTJwVGkxUHgwbWgwamJaNUM2bFo0NVdlZTFVbDVMWU43TjYxY05KdWxLMC9UVFRDa25OYitOeVd5MXZybXl0MmpJbTdsc0xxQU1laDV4a0VmbU50T05CaERENDVWcEY4Z3M3ZUF4amxKOU8waUtRZmFHcEdhVjZEYlRDVEFsOWpZNEpYV0RKV2t5ZHdsT0JsWnVKRmZjT0ZSVDVnYVE4a0pyV0lzR2E3VlJUbFdqZ1Y5QWZiMDA4aU1oYnFxQmttVXF3QWJoekJvZXZVRFNITlVqZ3BSU3hWQlJVY2tpZ05QMURyWFNFUlpiUkpsSFlIYnVVWXlLeWs4R2NBZGFINGFjWW1XMXpEYzJrVWx4SFc0aEhFMTVjV2FwcHRYYW5yWDh0TVFKTHZMR3hpaGllS1dRRG1JdmJzM3dMQTlmeDBvRUM3Nk43bGpGY2U1aFVqbHlEVUh4SjZrblRpQnFSWFFweFdObDNCQVVpaHIwMzlmbHB4SDBKbWdFcTlvSkFhZ3E0WnVRL0FiZmdkTUkyaTJqVzNNanljVlhjT0ZJSkIvcDl3UHJweEdQT0pvbGphVjJKMktocUt4QitKRlJ0NkhUQ01tNUlBSTdoZUFxV1BJT1ZGUFZqU2gwaEVhZkpuZU16bnVjYUYwRlMyK3dPNHBwNEVZUnpUTTIwRkZZL3VTUmdzdEQ2QVZwcE1SZXZqTWkrUDhBanJTUVNwRG1yNVVaQ2dFa2tOdSs0VVZORlkwcnQ4ZGN4bTlWNDdIWTRmVFNWMVpKZkh4WHdWc3ZldXlUeE5KSk14VldTR09oS0UxYmlyQ2grUHRvZFEzTmRFU2ROMzduSlhNR044Ymt2eFo0K0dPNldhNUQrdkVwS1NpUjhxVkNra2RLVUZUclIzNUlsZ0gyc1NlMnFrV2ptUHI4dzhXR3R1M1p4QmxTUlFIbVMxak5HSzhpUURUb1NkR3JGRmZVekp0bDlYcFdnSm5pa0Z2a2NpMGpKRzF5SUlWNWMrZnVMUDcvQUZvS1ZPcmwyUUsrcmFDVFppMGxndEY3YnhTUWhFa2c2UU5DdnhJSUxFLzQ2cTJPV09uQnJ4TTBFdC9QUERJeVhGek1zUEFrRGlKSDJvekdsZngyR3BXVGhKazYyVzc0a0x6TytlZkp5MmZNc2x0SXlrVkJXbzJYalRZQUxzQU5Td1Y5TStJc3oxandGc0NwQStPaUFjbDBxUjhQaitHb2ptL0gycHZiNk9Ma3FxVHUwaG90QnZwck9FVG90MWhnZTJ0c1kvMWNEcWswMVdXTXR5NFI5QnpDbGdPZTlGNmpycWpjM3AyTDNWTFVESGpITEZHclZJWU5LQ0tEME5EOHRFZGdVTFdkeGtFekJ5T01zeFBMQVIyVkVSa2ozcldncC84QUxWTGpiRExLNk9VTjJaczdyeVcyaXVjbXlZeUdHT2pRRXA5VExNM3VaZ2dJNGdIWmVSNmFvckZPaGJrYnRxREoxc0xka2doczNsZ1NpeFFTeWZ0OU9wQ0FWcjEzT3A2OVI5eVNOcXk1bTZaL29rV3loV2lBVzlJSTl2VGFsZjQ2VUpGVDFlaExDNUsyb1o4clBLNTZ3UXpTbmp0NmxnQWFmTFNud0hqelBycSthempqaVdFTTdVNDNVaWt6RWIvRTlEOGRNbEkvUWhMZXlvZURXOGJ5MDVMSk9YSkZQaFJnUDQ2bEJFeXVMOTJUdWR0WWVWVFJJbE1ZRzI0SkRNVFg1NlNxU2JrMlc1dHJpS1IyWnBRaEFacFpEREVXY2JBS3FEOGhYU2VnM1V4ZUVMWXZQUEkxbEU5RVJlWTRNRk5hTDZrbmJjTHB4TlFpRXVaeTBiUE5adDdpTm5rWU93OVBhdTFEK09wUWhwYklEVzkvY1MvVVhNZ2VTUWtsMmRlUkkvRTZlVVB0YlBoYjNxOFkyS3NyY2dpQ1JldnFLTFgrV25sRFF5VTJMdlJ3a3lVcTJkbTI4dkYrY3FnZEFJcThqOGhxTzVkaVVlSXpZL0hZeXo0eldwdW1CQlZiaVJTektDQ1AvYnJ4QjI2YjZwZG0rcE9FdFFqZncyZGxGOVNKNTd0WFZGVjU3ZWEzampZRForRHZ5WTdnQWtlbW1UblFrMW9hcFpqS3NkeXFtSm9vMGlSVlp1UWJrQnk1bGlSWGlLK3lnMUpFSG9ZV1llM2UxWXdYVHh4TktMaG1rUzNua2JuV2hsUldmaCtJTkIvRFRzaXlWZHlYVnhkR2UrdWVOMWRPelM5ODkxMVJmUm1DOURUaXRlTmROMjBKSkN6a2I2TER6cWtEeVMzems4aEMzYlpFcnVwcUtpdi9BTWJhbWsyUmNKbW13bnc5OWUvVTNkcW9mWnVNQzl5VjJXZzZ1eHJ2dWFqVHVVaDFEWm45eThSYzRnMk04cUtscms3VkxtMUNrR2xISUtrQUNoRlJ0VDExSEZhWDhCWlZDUXJlUDRtOHpMOTIyak53WUhRdEFHb3o4MjNXcC96VTFkYXlSVFdzalZjWHR5OXF5U1JNYjI4dGJXYVZvQ1pCSkxiU3RFRU5DRkFjdWpWci9TQlRWS1Nrdmt1LzdjUzVJZU9aZWVlZDFWeDIzWkF4WnA1MmM4YUE3RmUyaWRSOHV1c1RuTmIwb04zZ1RzYjdtL0Y0ZTl6TTF4YlBlV3N0dkJjMnM4cHNvNTN1S3lGbVFQM1hSWmZhcFhod0lVdHg1VVVuUXVYS3Nlc1B3OHZ4NWhPS2p2T3FNNHN2WXl2RGRaUE1wYlcvZnJlNDZ5V0xzVWdPNnp6Y0dEZHNIOUFCV3Z1cVRRNmRVZjdWWDRmNkRiNTFiaEJPN3puME5rNXlsd1RhQ0tLM2Q0YTNQZm5ralVxeUp5RlNLVTVPVFgwRkNEcU5jVzU2TFVmZTBuTE5ObjVqajhsZTIzMGNBeGRzN3Jad1dqS3NieW1FeFJjaXNTdWdrSzl5UlQrbWc2RFYzMldxdmRyM0IvdUxTTkNkbU14SmMzRTBkdGVvYkMrZUNmR2NWbGpaSXJhTVRzWXZhS3hzME1mYklwektuOUo1VWhqcHRVdGZqK2Y2RTNlZEYwRkQ3T3dXd3M3MjZjVzhrMlNudTV1eWs3OTU0aE9vYWFUajIyQ3F4alVJMHREVWtqYlJmTW5STHNnWGk2Ym40ajloUi9aY1hjREttNXU3dTNTS1M1bnQ0bTdNUW1qa2NHZFU0c0U3aUpSdUhNUm9xaXZMUTlySnRSSGtYUTBoZ3NaNUlvbXVjZkhGTmV4eFJNVXUrMDBndUx5TkZyeEVjaDRoU3ExSVYvYnV0QVNBcjAxaDlQSUxwWk5kQnA4ZHpHU01WemJaeUVXK1pqaVpubTdmWmh1akhDQ3JCZVI0cUR5aUpiWUViTVZJcmxabHJwYlIva2FXT3U2c3BhcjhTY3U0eSt1WVBHNGJLVzlQZW5qUzV2UW50RmJscEpXQjVQVmxxM29sTjZtbzExMTE2cFMvQ09hcGFWRFpWdm5GbFBiNFZKTGlVU01id1JLS0VNYUt6RTBKTkJUajFvZGFHRzAyK1FCblVWK1lnUmRXcC84QUc1MGF3SkV5T2dkSzdiNzZnT3VvUmdYM2JqWUZxMUhwWFR2b1dwNm1WeWRvZWxhL2dPdXExSkprdTBsZEo1VzJMR1Zlb3JVcWk2YkpxUFI5ZmlFc29Sd1ZtWlVMZE9SQUlBMzJyK09xcXN0dUJJMkQ1STl2ZENvNkdvL2xxN29pbis0eHkwOXN1UWRXbEFaUXRhZTZoL0xVcTlPaEd6MUJLTUMwaEIySnFQbnExZENudUVzQ0ZseTlna2ppT041T0x5TTNBS3JVQkpiMG9QWFRXNkNyMU9vL3R2YTRSOHBlWGN0ekRCWXBiUVF3M2R0TnlqVTI2dHlLeUpVamtCeDYvcW9LSFdGeWszVmZFM3VIdDNQd2dIZmNpOHM1ZkY3dU96OGdzMnljTXRiS0swbmdrYU9ZemdxNEtGbmFpallxb0hyOHRWOGJIYXVWVFZ4NGx2S3RXMk54WlNWdU1INU5rY2JkWEdaeGQ3OUk3UGR4eDNFU2NwUDJpV2Q1SGZseDlvUEl0V20xS2ExdDlVOUdZMzI3dFMwekdLMThUbXN4NDU1QmQzNlQzRHdCSjRZRE9rVXJLckdJU1NTRTFLcUJXaEhHbStwT3pXcUdWYXZSbDQvYXpQZlpyd3lETnhRZVp6VnpkcXRyTGlwb1k0YmFDWUlWTkdMaG1wL1V2USt1K2djdVhKRWJHYWZIKzFqY3E2RWVEd2kyeG1iZlArTjVPRElManlXeDl0TEZkUVJGM1g5c3ZQeWtVQkdMT2FHckhwcXIvTlNVWFRYMEQ2Y1hkNnF0UDYvcUlua1hndm0xeGsvcTdXMHVNcGRTY1plOWFoYmhta1VCSkdYdDhhamtwQUhwdG9qSHpjRWZ1UytJTHlPSm1WazBwRlhJL1dZeTRTMnlzRXRoazFxV3RwcVFrVlhsdUhBTzRJQVB3NlZPamFXcmRUVnlqTnlPMVhGbERKMy9BSFBiWDNoNmVPWFY1U2VHN1c5dDBxUkJ4ZEdSK1RDcDVVSHlyNjZmWkZwSXJQTk5yZmNCUFo1U3hsTUx3dkZOeFdhb295Z01mVFlnMUI5Vy9IVTRrSDNORzJQSDN0M1ZZekhIR3JlNldhV0pDekZUUUdqSGVudzBub1BMWVRYRjJCZFlMaVNCTGhtb2hpTXowQ3J2czRBNUF0ei9BRitucFhURHdlczFuTGxYeVdWaHVMNVJOSlBkeFJ5cFpwTThqOHdTWDVzZXBIekduUzAwSXQyN2hsYjd4TTJqd1JZcUN4RXJBeDNGeFBkVHljVzNaZU1WVVVOV2hJSDRhaTVrbWxvR01aZGVJeFdzdHhOZmZUM0YzYm0xK2h4MW9JaTZDc1pGWEQwSlgrcFRValVHclQwTHFxbTJXd1Y5VjQ1YUpKRE5CY0l0STBVTDI0aXZBVkcvQUVpdTVHbjFHVmFtN0xaSHhPek1XU3NjeGUzTXMxQmMyc2R4Y0QzTFUwbExCUVIwWWNTZDlKYnZBc3ZYRWxLc2VXV2F4K1J4ZVJ1N0tRdzVLd2dRbUdWVWQ1b3BYRWJTSkk0cU8yV1gyZjVkNjlkUERUMUtrMCtnbjMvbGR3ZzQyTTBxeFJ2WHVGL2VhYkE3VXBxMkNsM1p1eGYzSjhreGMvZXRybHUwNVBLRVVDYmdBa0tvQUJvTmpwblZOUVdZK1JhamxFZlArUTNXWE50ZGxXWnpHVlpuTlRzZmg2ZGZqcU5WQXN1VjNjZ1I4ck5HclJ1ZVlZVVBLZzZiaWxQaHFlMG9kMlFYdmZmekRrRVZvVk85VHFVRmNrbTJ1YnVSa1N4amxtbWRoeEFCWWxpYUFDbld1b3RwZFNhbDlOVFpUTXh1OXViWmxsVWtsV3JVRTErTzNwcGJsQW5XeWNHeVB4N3lLVlpaekdZMEE1TzdrSURYY1VyMXJUVUhscU9zVi9BNlM4Q3dkajQvOWtyTEwzeXUwbVl2TG1VM0NJWFBLSlYvYUxEZEdmaVFLZ2doYWV1dWU1ZDcyNU9uOXFOM2lxdGNHcTZsSGVYWnU0L3U5eGV5d0lMbVVMdzRBQUJJUjJhTW9ydUF2eDF2Y2VxVklNYmtXYnUyd0RKNURsZUUxdkw3RXVFNHVDQlVkQ0NLN2c2SWdHa0ZoYnk1ZmlxeVRTTlRZQm5KK0hUVGlDTnRncnVXRm5raG5qa0c0UEZRdFBXdFNDTk5JOEJuQlFmU3ptM04xSFlyT3ZHYTRrY2xvZ1NEV2tRSjlQajY3Nlpqb2NJZkYvRnA4V0lobDBrTnYwUzN1STFjcVUvU0ZrVU51OVdMZWxhYVRVQ1RNWnZHTEVFcllZMXJnVVdza2c3bzVCdW5jVmdmVGFta01aVzl2Y3kzTWtiWVdPOUFUMndSUnpOTkdRZG1ERGtGTy84QVVlbW1jRHArSVk4VzhaeXVKeTl2ZVJ5WDNqMHQyN2ZUbEE5eVNRQVdKalFFY1FkeHBTSmpmUGFTWE9TV0t6OHNTMHVSd0YxYlhkc3RzclNKSXJCSGk1LzFFOHhSUitJMGxwcUpnaktXV0xnU0tQSjVHR0c4a21CTHcreENzYkFEaVdNZ0pvT2RlUTM2MTY2bDFVakNQRmdvN0M5YTV4ZHpjMnJySTRXOG5nUjBDMUpQYjVjbE5SdUNDTlJKYUJnVytXUytreCtRYU80aEtDTko0NEdqV3FrTURJT0NySWZVc3EveDA1RSt0Rng2dkpiMjJTa1M0Y3BRVFJBeHM2aGh3RkFvNDFId08zcnFMSFdwT3h5WTQyRTArWldKb2xFa2EzMGhqZG1ldkhjU0x6VXFmMC9ENTZZbEVtcHJPeHZyOFQzYzMxc0VnTWFYcUo5UVF5QVBUZ0NhQmdLMVZsK1drTGFDSjJ4a0ZzMFUwTEhHbzdUTGFsdTFQRThxVkRWY2htVWluNmcxT21uUTBhQWk0bmh2NU8vbEhudEhVQms3ZHVzbmNFYXJUbkt2Qml6RHJYUzZESXlseXFwRGMyZU5WSjhWZGNWaVcrbHFrYlZCcUk1VW9oL0xsODlQQXBOYzczRnRMY096cGlwWVVEVExHcVhrTE55SVhnOFRBMW9hMDNJL0RTSFBiSEhYRjZ3YTJqSy9UbEdudWdvQ3M1clZTWGNCeUNhN0ZqVDVhWnVCaWJrSS9Kc1BFY1BicEgvWk1sS3N2ZWczc3pjaFFDUVFaRVUwL3dCNzh0TFFUQ3VPeDJka2I2U3d5TU1WemNvVXU0SW9ZMFpvVUhIZVdUaWhOZHVGUzNxZElTZmdmUStPTlBLSkxHU1A2cElsZElWc2k5czQ1TFJDckJhcVNEVWdIOE5JWXpnc0ZGcExIa2NoajJqcU80a2pyQkw3S1ZqVThnVnFSN2ZaWDAwa0tDYlorTVhFYzEzTmhwR0R5MjR1VGZXWTNpWHB4SzBDaWxhTlg4UnBNVUFUTEcwdUxpYUxKWEY1SGZvQVpTVnQ1SStYQVZZcUJRTHgzRzIra1BNc0RaZWF6UjRicXprN2tOM0dzZ0tjUXlQMFlNb0xCVDhCcER5REpzbGRTc3BXTmhicnNGRDhtUEhwUWdWMUlUWnJlN0ZPQmlQTWtDaGtxUUI2a25mK2VrUmt6VytXVWR1R0xqU2xhUDdlUHdPM1hTSFRJOGQwU3JwRkNHSzFJUUYvVDEyT21ISjBHUWtqU1l0YmlDZGdnVnF0UnQ2R3RDU1ZvZHhRMTBoaGhna3MvbzdOcmlGSnNsSTY4WkVMbERIVWdrSXpKc0I2RHBwbExHaEEzSWNiNlp4SmFxa1MxS0JRb2pFWU83c2ZjVFQxOXgxTG9NYVo4TERiQ09XSWdsbFZvNXdhS09WQXZIbDhhNlF4SmpzOGFJZ2Nya0pwcFpDeXRGRkEwcW93QTJMOGxGUi91NmpyMkpKSUJ5V1p1cm5zbUowV2g3Y3Jzemc4ZCtnNUFWOWZocDVJbW02dDQ0T0NvME1haGFselg5WCtXbkFVUDRuVGprRkVEc3pTSUdWRzl4SEVLOU4rbGRJWTN6elJ6OFlvRm93cW9qTUsxRlJUWXJXdW5FU0lrdUxHSVNMSmJtTnZjUWk4WkIvOVkyNjZhZFJGdFlhMCtva2x1L3FGbHQzVUJWUUFJRkMwVjBGSzhTZXRRVCtXdWN1NDBnNjZpbHlISW9ZWHVMdkRQYS8vQUhSdWJVY2JLSmlWYVNvRkcrUkI1R3A2YW9iMDNkaXhKUFR1THVlOGR3L2czak9kZU9GSjcrR0JaWThrYWN2cTdnL1R4TERSanhRYzVHQTllTmRYNDh0czJTcW5UdzhscVY1c05NR0sxbDFqODNvaXEvRWJWUmJUM0RJVEMzTkpBQXpNeXBHejE5b2FnQnAxRk5idVo5amxxSmdWTFV3U3RKY01KSXllY3ZCMVBzNWIwTzRCMUxkS0lRRkxOb0pPOWVYUTcxbGJ4MHRpMUFCVWtHbGFVMVZhVm91b1RqaUc3ZEFWMlkwaERLakczbFA3dnZvU0Ira2ZEMHJYVnFiWlRFS1FQSVEwakVkQ1RTdXJrVkhzS2xuL0FBMGhHK2pnZE91dzNycGh5ZmlvSm5kMGdqTWs4aThFSUJZcVQvd2c5ZW1vV0owY0RKWmVHM0NSL3dEM1VLV3ZJclV2SnlsWGFwb2cyQlB4WTZvZVZkaVcwTll6R2VFWVNRTmtVdmIrNlVFdExFc0xJVDhnNzhkdm1EcHQxN2RCb1NHMWMvNEJPNm9tSHk3V2FqaThiWGFSdVhOQURXRWNRdnk0blZXeXk3b3MzOWlQa0Q0ZGQxaXcrRWt0aTdnbWE2dTVaM0VaOVFxaFIvSFNVcnF4bTB5SytMeGR1STI3S3U4eExmcmRhSjZVcUtHdGY4Mm5UYkcwSVZ4Y1FFcEhieGlGQ3hxaFZhQTlLQ28rSHFEcDBoM0VHaWRMWjJhS0ZITXRDWkkrQVVjeUFCUml3NUdwMjFKQ3F0U0Q5SktPUWlTY1RyL3lveWpDVStsV0JJcFFuZlVtTTBhNGJLYTRtWmJ0emJSN01yemdSY2wvcWFnQkpwV3Y0YWVVdWhHR1NVV3h1cG9yRzIrb3ZYazlnYU9SakVSVTFPeTFBWCtHbHFLZXg1a2MvY1dNL0cxaTQzRWJOU1c0Wkx1UWtnS0tBcDZmRnE2U3FtU2NvRDNWeGQzc3B1YnhwSjVwQUdMdlZpYWtEb2RnUHcxTlFoR2prNlAyblJRS2toZWhVa2RRUXcrWHJweEdsRGNYRG0zdEVVU1ZweVppU1NQUUhZYit1azlCaHZ4dGpMWlF6U1RRR2ZLb0VlU09OQUdRU1VLOFRRbGR0eWRVV2MvQXVTZ09wYzI5NnIzUmRvYjZBam5iM0YwcDNKb1FCeElKVUQyN2JmNXRSY2trMFRMeEkvcG9aWnNrTWRiQlZtdFVDUGFOeUFJWVZVY1R1TnViZTcwWDEweWZ6RTBScnN3UjJKWGpKZVpSWVZsSVRuSUhRblorY3JxS2dFOUFBT3AxSmRTRnREMjF0TWprTHVUSVdnRUVMRmZwNUx1N1JRUXc0eWNVQklZMFZ0eWFmRFQ5Q0Vha3huaXNWZjZPek4wMC9PTzZtdUlubEVLTTVvc1E1TkUzSUtEVVZwcUk4aFB4eTUrbXVibTRsbE1Ga3FqdHh3cGJOZlRWM1R0STRZcnRUZllEVVdpYTBLczhxeDJTbHpsemMyY2NyZlZyM1pKSmdKWjI1c2FsdUFZbWgycXFqUkZMS0N1NjEwQVVWcmQybHh4dUxscllyMXFleWQ5ai93QTFrb2RXTnBrRUh2Tzh2aXNsNHpoN094a1EzRmd6c3pBMUxpWFk4U0ZBTkNnNVVKL0hWV09yVm1XWkxKMVFvMnQ5TGliZ1hFYmNHV0ZYaVhydElSUStsU0FhalY3VWxLY01mZkc3dTRseGxrOTl3WkxlK0V0eENFSElySTNJbGlTQVVWVHlXdnJvVEt0WVhnRVVlaWJMczhmYzNzbC9GaW1TeHNvbG5tWXh4c3M4Z3RiWU1pcnNLTTBrdEQ2N25mWUhXRGxVTk8ycjZmVm03aTFyNmRBQjQ5YTVHTzkrbXY0MnNzaE5hUGIzRTBjTFNMYmZWQ1FOR3JTVEx2MnZaelRkaFdtcnN1Mk5IMy9UNUVNU3M3YXFDY3VQdFo3RzJrNHJrTVpadUliTzdoN2dpdFc1a3hSbGJpT05DV1NMa3pLM29XWWxhYWdyUS9CdjgvUFFzaVYrTkFuaml1UXl0ckRjNFJjZ0xabW12ZUxXNzNFMGs2UE1vWXBFaXI3S1ZrNUVqb3RUeFZhcnRWcTJuSDFKcFRhSWtsUGVyYTV1M2hnd3R0SmxMcTRaeFpoYVJpYkhJMGZDMmpoWnBUQ1dIR1dNa0x4clhrVkducnRkWm5UK2ZqK0pJdE5PSTEva2UrV2VUNE8yaDU0eURCd1hrc3B1bzdpMmRGRUlmOW9HV1ZlUlBGU1dFYThUeUc0M0s2V0hGZHYxYm9HeTVLcGRwQVgyZHRtaXdWbmNXZkJPUGIrc3VJbkYxSzRBZDYvVHlrUmtySkpzbEdacTdDbzNJNXJlNW9wNGtLcy9VZXNaZDJzVWhHWGhrbGxpUlhOckorNUZiUlBFeVJ5VFhyMFlPam1nU09NbFMydzJHczNLNWFqOGZJMGNWVWxEWDQrSVo4V2ludVpjcGs1NGZyaUZrK2t0blpmcDQzaExsbWhsbkE1UkJwbEFkMkFjdDFhbGRRZVgrMWFSOWZ4NWRpWDJsMWZmNmZqekdDM21rWEFlUVhjelAvY2NkamJ1OHQyblhzOXdKYVBJV0c3a0x6SjdiT09ORlA2aUdPaGN0YTVNbE5KMVMwK0pMZGJIUzJ2NDhUbWJFMlVnd2VObUYwc2ZidG94ZUZvcVJraFJ3U1FGejdqKzRGYmlDYTdiYTZ1OW9zMUJoVXJOVTVFdjd0aTJpeGVNamdRbzczTWhOT1FVQkVHM0ZtWWdlNzI3L0hWL0Uxcy9nRDh4SkpRVk9zdkN0TnlUclJnelpKTnZQM0hDa1VBMDBEcGtwNzJXTWhZRlBJVjVQK0pQeC9IU2Fra3JRZlJOZVRsZTd1cW5Za2dVOWROQ2tlV3dyWW84ak8velpqNlY0L1BVTHRJbmlrMVhGbGQza3pTM053R3FCeDJJVUQ0QVYwMjVKZENicTI5VDYzeDVzM1l4emU5a0lCL1RRL0xZNmk3U0pWZ2hteWhWaVpHTEUxSkxFazEvS21yVTU2RlVJMXZFcUE4Rkh6cDYxMUtSbWlkNHhjUjIyZnh0eGNxR2dodUEwcUhjTWdJTEEvSWpTc3RCcXVHanJ0YnY3ZHdZakk0bkhZcXlzc3JrN1NNWGJ5eFIzRFFJeEcrNk4rNnlzV0ZEdlQ1YTVtNnl1NjNOd21kUlI0ZnRhSmJtdFIydThmaGNkUGJRNHkzalRGWHR0RmNYRnUwSUJXR1NNdWpValpWTW5CUGFyTDFETlVEVXJxRTkzOVNOWWxSb1ZkbVBIb2NtdDlrYk9LWnJXeUt6WGhXNFF6TkRQSTNCbWMrNWFsZCtBWldwdnNhNlpXdFJwRE9xc20yRGJMN1B4K1JRUmVOUnhQWW42djYrN3ZaSXdyTmJMQ3NmN1ZPUzhneEpLRnE3OWZoYmJsN1BWMTBCbHhWWjdlbXVwdjhBdVA4QVp2eFdIeGV6bXdJbGo4aXZJbzc3KzN3eENXZVFpSUJDMFZXY0FFT1NSNmRWOWRQeCtYZmV0M1R4SHo4T3V4N2VwU21KeHVTeHNrUDA3dkZrN1NRUVc1aEppTFNRdHNBdzNaZ1JUalNucHJTdmF0dXZRemFWdFJ5bkRSZC9sM2lHYnpkL0ZsOGxlelhFMTh5TXhlWjB0R0RNWWhIQ2xTYXNWNElvMzJMYjZ3T1BteFVtdGFwSmVXdnpOekx4NzJXNXY4ZVJXdm5HSXpIaFUySXQ4bmF3OTNLV1AxQXVWaEJQYmdrTVZDWEFKMkNrbjFyclk0V2VtWlBaL2E0TXJsNDdZN0pXNnRHckc1VzJlM3R4TXNDd2wyNXhDM1ZER0ZJNGxwQUswSUhwMFBYUnJiS2FKTStHVzhka3NZVWxSREhMTis1VkZVS0F4VVNCSlkyREthNzdnNlpweVRTckFFeUJ3TUFrQ09iaWFPVDl1NXQxRnNBdGFtbkVtdjhBdTBBL3cwNmtaMXFnWmxjMDJPdkxqR0xmRytzWXl3dHBualJuYUdVQXFTMU9wRlBYYlU2MWxBN3lRK3NnKzZ5VmxMRWdaQzdoYUIzZG1ZSDAyQUEyMUphRFdzbWdUY1pJQUlJVm82aWdhbE5TUlUyZVdHWHVyZSt0YmhXOThFOGNxQUhqN2tjTU45cWJqcnAyTW1GdkpmS2JYS1pYSjNsb3BqZ3VwV21paUJMS3JTKzUxV29VY1F4Tk50VjFwQmE4Z3VDN2xjdFNObXFPZzZBL2tOVGdxa25XTjdrcmFPVVEyNzhIUXd5VlhxSElORFhvUFg4ZFJjZUpOYnZBMHZEa2JpUXJIYkNOZ3g5b0ZEWDFHOU5MY2huV3o3RWkxd21XdWhMR29DUjhTeGtwV3RCV2lucjZhaGJKVkU2NHJNbncrRVpXNDRxR2s1c05yY3EzZE95dDdRZG0yWUVVT29Qa1ZSUC9BQjdRRnZIL0FMZFE1bTQrbGt1eERjTlZVRWpCZmRVQUZ1WFJkL3gyT3FzbkpkRk1FOGZHVnRKSERFL1o2S1hIM052M0xhYkp2REliZFZtSEx2UnlCS0N0QVY2a240VU9ncmM1N2wxZ094OEt1MXkxSmErTjhEOFN4bUF4TjE0MkVHVUZyYTVMaTh5enRiRUxFWkcyOS83ak02Z0g5STViN1UxajM1V1g3dHZ1ZEpqNG0xaHdZdnRWVlAzUkxBSG5Yak9Od0dVeGMxL05EZVpTUzN2Um5SR0JJRnU0TDBTTitxaFhaejZHbnFUclE0ZVcyUlcwaFN0dndneWVaaXJWcHpMMWtCbVczZTNuYTNzb2JpU2NMQ0VtQWJtbk1Vb2tqTUk5bXExUDZkeG9pMU5kWDBLVmVWMDFIbnhMTVJYUCtuZTh3YzhzUnZmR014Y1I1R3lySExJeWx1TVRScklTUnlrbUFaZ3JlMEdtbnpWbko4VjFKWWI3Y1gvcXloL0liR043dU8rbms0SkZKY3c4MUk0Y2xsSkhiWGl0Rld0ZXByV3VqOERVUVorZE9aWUcvc2xoSmRDU0M4allTZ0ZtbFlraDJQdUZkL1gxMFZJTkdvVnQ4ak40NnRMT3NMcWZaS2tuY1ZpS1ZQdG9OSVdxQ050bnJISVFReFg5N1oyeHFXN0JzLzNPUnJWakxSRTlmNnVWTk1PM29HYnZ3dU9MaVd4eTVneXBISjNNVjI3Mk5qSWE3eVdiY1UyMkhJMXFOUmtlSUJ0cmpjZEpTM3hYanlmM1JaRzVHK21NcThPUm9vUnEwSUd4TEhycWFUWkNCZ2JFZVM4NEljdGVHMkJVSCszMmFxSExmMHVrU29RMU52WFVaRU8rSG5ueGVLU044ZzlwT0pHU0RoQ0ozZU5XWkt5OEFySVJVbjNzUFdvNkhUejJKUnBJSXZzMzVHYnRlY2ZkRVVYRHZRL1Q4MTQxcXlPR240ajhHMzBwVUVSSHZZUmRtWnJ2SFpXWjBOWTc5MFpZeW9PKzdzb29LMTI5ZE9ta0tKTjluaTdKN1NWYmhva1J6MjE5eXF6Si9tN2dxSStKV2g0MUcvWFMzRFFSbXpWcmJwTFl4S3RyTDNLSmMyN1NYU2lNS1F4Yi9sclVqNGJhbDhoaWJOa3NmZTJRdHNoazdtYTZGVE5VTkd3TmExVm93U0FSNmFpMHlXaDdicGdvNUFGdXJkcnBuTFc2M0t5UnVWSUE5MHpyVUgxQi9ocUxUSDBDTjk0L2UyOGp4bXppZWE1ajdxeG9XdUZvL3dEWDNCV2lrSCtyVFNKcGtlVHh1NXNabzdMSmw3WlhVVFdxV2ZFdXV4NUk5U0l5S0gxQmIwR2tKTTF4K0F2ZnlTWGsxak8xaUdXTmJwM2dRbG0yb1VjTlU3ZEFOTGNPeVpKNEppYlZHUzF1cnZGbUFPWllzbEFYUjMycTN0QlFnMTRnS3RlbTJtRTRQcjM3Y3hvcU5iK1RXTFNoVmFTT2Z2aGdkOStMeHN5Y1JRYnI4TlBJMEVLRlpyZTVneEt0amJ6SDltUzZrYVZJclVSU3JRRTkxbFNSM1lpaUt0VDZhUWt5TERieTNVVnV0bmtwM3lGMUtKMXRNYXBBTWJWWU80NUZDMzZoeUtpbEtIVFRxU1pOWjdxL3VJUDc5WmpIV3VPUEJMWjRPNEo1Z3dVQXJib2FWWWNaS055UG9OSklYa1NMZnhuRlg1U3p2N2k4RnZKSTA5dmpJMDk3T0EvTUY1WTE0RlF2RmR1bXhCMHBZMEJxeXgwbUl5WGR4R0V5bDlEYXhKTmFXa2xpeTJxU2xRZVppdDVBemdOL21iM0hjZ2FhVzBOQkp5T1lrZkJ4V2QxanJxMHlxU0c4YTRsdEhobGtaZHdraTNNaFUwUDZqeEpwMDBrUzdBekJUZU5OUFBjWjJmS1kzSVNEZTZ4MWtMeU8ybFkwWWNnaUZ3UnRUa3dHbXM3ZGtLc0Jadkhmc3ZlUkNlZnp2TUllSWhtdDRzV3RrbkxlcnYzUUR1ZjFiNzZvZDh2YXFMTnRJNmlCa2ZEeWswV044VXVYemNrM2N1bmxtU0tLM0VIS2lVQklISWo5WEEwUHcwUld6N3FDdHBMb0w4K0V2YkF1MDloR0hqcWxJWjR3NE8vSWNCSWRnZXZycVl4cmd3cGxBWDZCWkptSEtNcVNFSW9XL3dBeFkxK1duR05hNDZlSjBTU3lDek1QZEFZM0ZSK1ZmeTAwaVJOT0J1bzdtSzB2TGFXMWlWdzBrOXFvazR4c0FUL3krUXJRallhVWprbWZ4dkdtTTNQT1NhUTE3U3lDVlZJRmFleU5ReW40MVA4QUhTa2RwREw0VjRqNWg1TGpidVhFeDI5emQyRndzVXNkM0xCWlNLaEFJYU1Ub0dkS0hhaDY2cnRrclY2a1lHMmY3WCtiUFdHN3M0aXNQQkd0WVpFbGw3anFTYWlJZTMyMUI5RHRwZmNxMFBzWWx5ZVBZK1MwTjdGWU8wTU12MHNrelJLZU1rUXFVNElqbFRVOGVmNWRkVGQxMEdWV1JyWEJQYlU3S0ZMT1psYTJFQ1BKRzdzQVFwL2JXckU3ZEsxNjZiZW9HalV6dnZIOHZaQzRpbXRaN29vNExHT0c1YUdnVU9BZjIxV2hyNkRrZnczMDZzbWg5c0VieUM5eGQ5RERZejN1TXRaRUFNMXZaWTJTTjZzZVZIY3FvSkE5UnAwaUxFYTlqeDlyT0pvZTNkeFVvQkdRdEhydHlWZ3cvSUhUcHlNRU1kWjVUS1hFZHJqN2V6VzdZRXdvMXlFMzRrbmlCVGZhdW1ialVkQTY1c01sYVhVa0Z6MjRMNktxenhDS1puQUh6WUFINUVhZE5NUmNXTnU4UGlvNXJmSlhoaGl1Q0lVRnh1dklqMjhCL1R2UTcrblhYTzJyYTNRNnF0bFZhaGZGWk1MZlM1UEpUU2R5MHRtaWNCRmJ1UndvR1p4U25KaUNLY2ZqcWkxZElYY0p4NnR0OWwrR0ovM0h1V3lHSWl4RnFlN2RaRkh5OG5lNFc3dzJOaXJDSlpGTkFHWTl4Z2dQVStwT2pPSFhiYVgvQUc2Zk5nZnVGcHJGZjd0Zmt2RXJlL3lWeFllTVdsZ2tndHplU1BLOE1EZTlvMTJIZUkzRlRRaGE2MTFXYnM1dHlsOFFOYmlHU09NWFg3YXdvOHRKQ2VNakRjS0JUWW5WajhpS04xaksxNWpyaXg3U0JJU0p5d0ZYYmlLS2cvRW5UV1VXVEpWY3FDSkRGYzVHOGdzYThPWlZVV01jd0FSVHArV3A5RTJNNWVneVdQZ3F5TXdkMmxsSC90a01pMEFydVIvNDZwZWJ5SDJrNkMwd3RoU0Y3VzNra3JSdUJsbDMvRlRTdnA2Nm5XMW1oOUViSlpyVnlmb01YRkV1Nm84eTgzcjZrZzZqVlducUkrRStVdWxFTm9RaG9RVWloMjI2MEM4ZWdIV3VtaXRYcU9TYlRBWDhyRDZrUnErd0VrcXlDaFlrRFpDUVB6MUcxMEtBdGIrUFF3T2swbkdncXdtYXJDb3JSdUxCcWpWTHUyU1ZYMURNV0t5RjZCYldPS215RHFBSE52RWZieTJWalJlbjRhaktIanlOSXgyUnMyLzY2MHVMT0dFdUpwUjNJMUtBOGFCNHdwVUU3ZGZscVV5SkkwOEljbGo3dHNmYnJhd1dyQjVyaDdxNG1SWXQ5Z2t6S056L0FMdjRhZnAxRkNCTnUxeHhhenRBeWxxOXQxaXF6VU5lbXpiaitHcGpKNlFUY2Jha1B4dlpiaTB1WmhXSXJES1NnQUlJQzlwZ1MxTnZkdHBtL0FhUEVrMlhpT1JTSmJzSkZiU3hTOTIzdWVYL0FGY3FFbXBZY21CclgrcitHazdva3FzajVpRE9ZNUpyaXNDV0xxUjlmY3lkNXlXNnhvb1duSWdBRUJkaDFJMHF3eFdUNmdlOGt1czZzZDVJbjBzUWlXRmJZRWhCUURkVHZUbDFhcmI2czZDMnRtMkt5dElnYVE4eTdEOXRpeisybENBdzQxM0hwVFRTU1NoYW1Sc3JENmxIdWJmaGJyR3BXTnVWV0ZTU3pBRTFvQjArR2xMSlFwQmQ3SWwzZkMxc1k0bDdocEhNNUVZL1VQUWsvRVU5ZFNXaFc5WG9OT0d0TFRDUk85eGlsekR2V1IrM2RTUnd3Z1U1anRvb2R5T085R1dwMjFVM0xKcFIyQ3MrU3RJSTQ0LzdJbUlnbTRpRVczZGVVdTFTR1BlZVJpQ2Rpb1VIVmJtZkVtbnBxU2U3ZHgyS1pxNmUxTTF5R2pRdkdKQ3NQSXF6TkZHcEtzZjFjdjRldXBRdWhGMllLdUpuaWNsbWx2eEk2M1ljb0VCRUlDeGlQOXhUMFB5cDZqVWtOMVJKdHBNZVpiZHN4UGJKZHNFSTV3QzduVkhMR29JYmlyYjhkeURUNGFacndIVWRXYnByYkRwRXkyMFYzYzR1UXV6M3p0RkNDNkRkRVZSSVR1eWppYTdiVjBsUGNqYU94OWJQYjQ2UnJxN2k3c2hKN2FyVGdLOWU0aXNoQUJwN0VBSDQ2UThwSU5uSlkyUEI1dTd4ZDdGaWM1ZndMRGpib0dXRjRtRW5LU1VBTTdMeUZWR3crR29RNVhnU1VOTXBEeUkzRU15Qzg4aXVjdExJU1pGWHVVMzlSM1hxZC9pdWpLUjJVQTF2aUM0emh3dkk0MjRuYW9DdmNYU3hMWDFxcUlwcC93Q3JVOVNPZ3oyK0x3dVl3bDdiMlNRcGswUXlSMjhMelM4QWhERnVUc3c0bjhhNnBkbW1XUW1oV3hjVnRmUy8vZFp5dHZhUnlTdWlBYzI3TVpaVjM5R0lwcTV2d0trR3NZdVF6MlRteFNGaDlVMzdzc1RCMDdhaFZUY1VVaEFHWGIxMVhhS3FTeE9YQjBQOW81ck80dzE5UGZxWWxqTTc1TXJJSkwxRVlLM0lJM0VjR3FIU2pBMTJxdXVhOXdUVjYvaEhSY0cwNHJmaG1GLzVMWlhOeGVXMk9OWGppRFEyY01NbmRXMW9GVVN6MjZyeGNsenR4UW90VHRYU1dMbzJ0SkpidFhWUFg1L0kzM2lYRHcyMGpRM1p4czhBbEtrd1J4dERDdktVTTdodmJMeFJkdVczSlVadjA2aFd5VTlKL0g2ZmhGbGszQzdHTXM4bU50b3JPZnQyOXpjWER6elNYRXRHUVRCb2xZTVhqSHRlTXV5bGtHNEI2QmRLcjNPVnJBelczUjZOc3p4SG1HQndsNWVYMDJTaHRKYmhKcmFTNHVIREpjeVJ0eEVpeWhsSlhhcE1iVUoyOU5Tdmh5WFNTWDlCVXlZNk42cnc2bGNlUjUzN2Uza0Y2Wk1vc3Q3RGJxdU1ndGJXTzREM2FLUjNwV1JqdXcyOXZKYTcxNmEwY2VMTFdJWGZXWDJNekxreFduWHQ0ZHlSNGI1eGFlSnc0Ni9rd2VVYTN0VjUzR1lzRnVMYWNwREFxaUlzNVZBT0pJcW02L3FyNmFiTGdlU3o5UytHaExIbXJTcWUxdnpDc3YzeHRzZUxuRndZL0l0anNqRDNKUi8wNnpQeWlEUnVpeXJ5b05xdDdSeEFLZ0hmUTc5dGRvZTVTbVhMM0ZKNjFibEJyR2ZjN3lpK3hzZVJ3dmk5dFk0dThqU08wbHY1YjJhU1VOS2tLczdCREVRV1B0VDlURUxRL0doOEhIV3pWcnR2eWdKWE95WFNkYUpMNWt6TjNYM2V1ZkhNbjR4bHhpOGRoc3k3UjNid1IzRTF3bjFDMUVRa0VoUUVwR1NGWVVwVTdMcHNWdUtycTFXMjZqWmNmSjJ0V1NXNFJyVHczelM1eGlYVFpHS0NISFA5RmFMSGF4d3p5U01yczBuY0tPZVFDZjhBTUlxQWE3VTBaazV1RldpSmJLY1BBejNyTXdsb0lYM2lzTGJFNUd3c0k4dkxsYjFCT2I4dTZTUlJ5TEx4SEFvaTFMYnMxZmo4YTZQNE9WNUU3YmRxMGd6K2ZpV04xVzdjKzVYU2NldEs2MFRMTjZtZzI2YVlramFyMU82MVBwcDRGT2hNaWl2SnRvWVhJUFRpcE5hZmxwcEpJSlcyTnlDeFBXSjBkcFNvTGxGSHU2QWwyR291R1NxOW9RT0x2dVFpZVcyVmwyY200amJqVC84QVo4eFQ4TlJoRm01dm9TVDQ4MGlmVVBmeHZHaTFkYmVLZVlxYUQ5Ukt4Z1YvSFVWQkY3aWZZZUUvWGxsdG9jamRvb0JkeGJKYlJnbXBwM0pYWUQ4OVBiSWtPcTJaUGsrM1VkcGFpOHVjY3NNQUJrZWEreWNTRGl0QlRqRndJSnJRYjcrbW8vZlQwSmZadEVzTTRPMThWeDdkeWF3eG5aREtFdUxVeTNjalRCeElJMVppMVFkcWtqajg5UmQ1SHJqTFc4SzhJd09mOG1zY29VdVAvdWdKQ3F6UXgydHJjeHd0eWFZSGtTdmIvd0NXT0tldTI5RG9USmJzZzdIU0hJeWZkTEplUDJkeGRZWHlTZGJhVEZwRk5mM0NYUml0Z3NxSHRvWWdGTWtrYXIrMEZCb1RYYmZWZUtqc3BYVW5teXFyRmp4WE1HLzhTelYzaDdzMldNamhFMGR6SUdMeXRDakV3TFJqN21xZVA2ZmJ6SDlPcXI0bXJwUHFYNDg2ZEdidkhzOTVieGFYQnJMSWtsbkxGanByc3JCREkxd3NMOFFUUmFxemNsUFFjbHI2blZHYkdwaUI4VjIxSTgrYzRxMnNKTVA1SmpKWmg1REZhMjhWNE1kSUhrbmxzUkRPNEtrZ3FYQ3VnUDhBVTIzclEwckcyNDdQc3dpOTRyNFIvckJ6YjVsZE5aWis3eUdRdXc2M29iTVk2NjVxVm5ndTVPNGlYS1JBSXJBdWRnYSsybTJ0UEFwcENYVFIvd0JETHplbTh0OWRWOEg0bC81anlqQnhMWVl5L1JrakZ3cnVSRTZKMmxqV2lja0pLQ1FuaVNBQWErNmxSWGo2WU1uM0xOZHZ4M09ydGVpcFdlaktKLzFIK1EyYzExNGcrSkRpMHM3SzlzNHB1MFlZcEZXNXFRaGIzT3FtcTFJM3BycHZaTVZxVnVyZFpYNmR6bS9kckoyclplREtIYkwzQmFwbFkxcHkzNjAxME1HRnVQWmN2SS82UlFVQUorUTZEOE5MYVNlUm1qNjY0a3FGcXgrSFgrV2xCSGMyWjlySlhFcUtJR01yRGdsRk5TRUhwK1dtM0pEeFo5Zy9aK0MrVVhJZzVSdEN0MG5jaTVWM1hpV1UwV3AzcHQrWHgwTGJsNDFQZUF1bkR5V2p0SktoKzJ1Y3VGbGQxYmxGeTJGR0xLckJRVjMzQlkwR29XNXRFV1U0RjdUNUJYR2ZhRE5TU2hycU12RXlxMElRTWVmT1JJeFFBVjNMN1YxVmYzQ25ZdXI3Wms3bHFlQi9abng5c1hhWGVXWkV5WmxtZ3VZSlZEeVF5d3lzaW9ZNjFMTVVaZHg2RTlOWS9NOXd5S3pWT21uNkdudytIaFNUdDEvcVBjLzJvOGF4c0FTT3d0cmg1eE5iMnJvL05ITUtHYXA0cUNXQ2dlbE9QSnY4bzFtVTUrUzdlclcwMHY4QUd4VldpUlZ2M084WWh3L2tXUnhzQ0xETDlOYW1FMEZ2Q1dqaEFZMElKNXZ4MlZhRHFkYjNCeTc4U2ZhWCtwZzh5cVdScGVDK0FuQ3p0N3VTM2Q0bTdGeEt5UXNRaU03RktIaUtxS0tlSlppVFRScW1zd0ROcXoxR3Z4bUxHMjg4R051ZU1kcGIyNGFkcGtFaWllMmttcktIQTNIN3daYS83TlU1SmRaWGlXNDRWb2ZaQkhNWm0yc1BJTHk1bGhudGxzMWhBWVJvQ3R2TkdmZ0FIY3FPNTBCb0srbXFzZU4yb3ZPU1dYTEYzSmhCbEwxUjlSaUpCd0U0UzJ1cEFza2tBZUlLNnRLd3JKKzB3V3BVVW9mNmpYVnlWZWxsL1VxZG1sb3dndmt5WjNGd1hNUC9BRXJCRGJ5VzBqT0RQemlqSElSSjc2cFRrekNpaFk5VVBBNldmZjhBZ0VmNUcrb0Q4Y3krUXhiUGM0L0ljVytuanhxcGNxSDRwQzhnVm1XTWl2QkVYald0VzI2YUt5NDYzVU5lWUxpeVdvNXEvSUorUzVuRFpUeDdIWldTTjF6WXVMaTFXeWlvSFNDZFRMSXhKWGlBMGdWbDk1Wm1aaWRxYW93WXJWdTEyanIraGJueTF2VlB1SnNqUFpoQTBoV1JKWm9aMUx5Tk55WlBjelVBQzd0d3JTcEEyNjZPU2tEbUREeEc5aXUvSU0zaXdoUzZ1ekpkMnpoT1o1UnFzcmdjU3ZweXBwOGxQU2hzVmx1YThROTU1NCs5L3dDTGVPWVhCVzV2Y3M5ek5jemZTbHU2b05VUExreDJxRHljK282Nmh4NnRYdFprK1JaT2xhcnNLY24ydnprRXl4RytpdDVDb1lUUGN4UEVxa0hkMkJvdlFqYXZUV2lwZXBuRSsyKzIrYXNtUzd1YzVqY2pESTZ4L1J3VC9VVHlkd2UwS0VWdDl2alFlcDBvOGhHNksxd0tTc2wxWnBQZElyZG0ybnVIREx4STRxNnJ2UnFVMk8ya25vSmo4Ykg3T0cwL3VrcjNXQ3ZJMWphUzR0elJSUHlBSUNweEpROVYvYzVDaHIwMHJkUE1kUkkyM21LeGVadGtpc2NuWlppVmtYNmQydTArdEN1YU5HR3VuMzYvcFZ5MVQwcHFwdEpkQzFKc0ZYL2h1UnY1ZnFibkMzMGx6RXBsYUNSUUU3S0FDclNsbFJlbE9uejMxQlhYaVMyd3BGR1REd1hEdGNVT0xMUTl4SlpaNENxbVAzRXBVb3U0OVRRbFJVSFZqc3l2YWlIa00zWjJjd2xoa2grb25IdnZicUVYQUtjekczYmlIT01ucXczWXN1K25samFBT1B5WHlHSzZ1Yjk3bEhFcU1MaDRpa0JlS3ZMYUp3cFZhZkJTTk0wbU9tVFlwb01yREJjWlBIeTNQZDRiU1dyZDNneFBCUzBRNUt0S0FHb3FOTlBnSkk5dThiNC9hRnpkWTFMcTZqQWtaTGE0bWlsUEUxZEc0eVRGYUxVVUlIVFRxelkyMkNIa3J2Q3kycjNPTjhhbWduYVRpYmpKNUNWMGhmWndnamo3UW9RT2toLzJhZlh4SXRvZ1grVnVRR3NKN2V4c0xkRjdxMzlyYmlPdFZwVHVRdHlKSk94NS9sOFhGSWF3V1o4MWhnamVHd0YxaTIvY2htbFZ2NktxU080dEtpdENLZGE2Wm9kTmpwYU5tUHFvamR3MmVReDBjaGxsS1R5eElaeW9LUkFwRVVXVGNqNUVldE5SaGRTVXRuMlYrNUdEdDhQZVErUldNK0p5S3VVSDAxN1dVcUR6alZrUGNCTzI1Q0FldlhiVEtyRTJWVGRmY1hJM1Z6MjhEWXo1UjBSVVo1ZS9OSWhGQVhWb3lLbGh0VmxvUGh2cXlQRWhJUHQvSFBOTW1xejVDWjhYRVE5SjVJcERMMjZjbTdqeHJXaEozTG5jNlVvYUdXSmd2dFpZQzJ0TGhzYmRaaS9FaVBMZVgxeVlMSm9uQjRPdk5RQnYvUzIrb094S0MxL0c4Yko0NHNDWW5NMnR4RE0xSlliV3dTVlluWlFTZTZGY01XYU5SeEt0MXJ2cURVNndTUmpsOGxEZEt6Vzl2SFBmUUs4aGFEbWpNNmVzMGEvVEF2SHRzUlRUSkNGTDZITlhkeEJNMWxDWjR6M3pKUGJ4ZHg2a1NlM2pLVktBSFplSlB6T3JFbkl4UGpnOHJmQ2xaNEV0b2xWbHZaSkZNVVFralBKQTBieGlpT20zdWRldjU2ajNnZVRSYzNac3lMcUdSNDdPVjJaekhGQk5ER0ZvUUJ6VktoalVrVk8vcjExSnBFWkFzV0l5ZDlmS1lydU9ldks2aHMzU0pnNnNTdkV3OTRHUU0zNmVKUDRhamF5WFVsRGZROHZQSGJPd24vOEF1eEw5TkdTSG50R3g5ejJ3alZZS25HVGlxa2ppQnZ2V3Vsdm5SRFFUSWMzZFdtTmhzN1V3UzJjc2xTaVdrOHBLZ0NzZFpnNFFBMGFnWWIrdW9xcUhuUUFqSTNVbHliNmFCNE8yN21HVjdSWFFNaEZhRHR2eHFwNmJjdFdFSkJWMWpyV05VbFc0YWRYbExJSW9EMnlhZ2tNb0hRRTh0LzU2Y1FRc283YTlqbXQ3M0puRndXNTdjY2JXMGx3LzdZNTh1N0hIeG9mUkQ4eHFwMjhOU2UwOHh0M2hMN04vMnUxaWU4dmc0aWl1U24wVVZUdXowbFV4aGFEcXpyMUExYnVhVTlDRUQ5WVlXK3hiSkRmdmIyUGozSitPVHViNndZSTBxOG8xQmltamtZS0JRYit0ZFUydWl4VWJFNlBJMjk1WVhDNUNLekszTWtrY01rMThqdXJDdENhelNGVnFmYWVmWDh0VGxUM0l3VEh4L2tNbUl2c3ppbzJ1VGpZaXQ5Y1dXVFdTMkhaSTVkdHpKN2luVmh4b3Y0MDBsZFRBME05dFBJTE9USHZsY25OZndTM00zYWJCeHoyMTh4YU9pSzdqdGc4YWphbFQ4ZE05WEF1eExHY3Nacml3eFZyZDVWRVIxSWdrbGdVZGpjR0ZFcEhJS2x0enZ4MDlyTkRBYkwrTldmOEFiTGlmRTIyUWhra21kWVpVYTVuRXZJaE9pdHg1S3hLazAyMDZZZ0JsUEhtdGZGTFhJMy85dXY4QUlRbFVGbi95TWpHemRQcURUZ1F0UFZxN2pUMXRMRUxTaTR2SWpqRFoyNWx1QVhGdHpSWStUVjZTaDJERDVsdXZvTlRJbnRsaHI3eDNJMkVua0Z6SGFSM0VYMXVMdjQ1NDJFa0N0d2VKSlZxRmtRa3F3UHFLYWltcmRCeHdieTd3MjR4OS9odkoyRXl6bnQyR1J0bkQzWVFnampQY1F4S2RnRjl2QWc2cisyMDVRODZBdklJSnJteE0waVhpZnRYZDBRSkVqUmxxb1FDb1p2aVRzTnVueHpGcE1mQTZEVnBTTk5wYzJrYUpGR3lxbHVXVzNtTHNpcXppbENSK3RlTzlENjAwTGFyY3NLcFphSXJmN2kzRm5mM2x6T2tpUkpad1EydG9CeTV6dkd4RE1SVWdBN3RRNzE2bldqdzA2cVBGeVp2UHNydWVrS1BpSTluYndMdmVLNVVrQlFvRmFtaEJxZGFObjRHVFZMdVNMaTBtdVJITkdHa1JqMlVMRWwyZXRCVmZRYWluQXJFckY0SE9aTlhzckN5b2dBNzEyL3RqUHdISTdkZlFhYTFxOVd4bEl3V3VCc3NCTEc1bGUveThpTXNpY1NJWXdSNjAzSitXbTNibDVFa2o3SUxlM29XYTZ1cEY0Z0lMZU1GVlZWOWFGZ09tb1ZTUStwQ2dnTE9vV1dRcXZ1QUZGcVI4cTZzM1FOQVZzOEZjWHk5MlB1L1NGeVptSlFENGtMNjErUG9OVnUybzhEYWxwWmlLVzNzK01Gd0FnRS9JOUcyQXFWQU5mV2xOVXF6VGtsQjYvYnNvRnRIV0dhM1Z5OTBVSTVodDltYU10UUVBKzFtcjhCcE55NUhtQ0hGbDVMbHpCWjJvK25nb0NxQjJqUlgyRkNPTmFWcjZldGRQRWRTZGJUQ0NOdEUxNGtxLzNTV0Y0WFBlbGhMa1NLNDJpVkVjc1QxUHdHK29OK1ErMmZnUjhqQmRYYnBCWkpOY1FRRVNPSkkraTBOZUVaSUZmVWdqZlVsb1YyNjZHRnM5emQzelI0MjZ1TGFsUHFsVzBIT09KVm9Dem1PbFZOQjh0UzZMVWI0QmRlNnNFT1Z2WmJxOUVhMWdrdXpHa2tJVWtWb1FPUUorTyt3NmFoT3NFMG1sSU5peTFtd1N5a3VaSUxhV0RrM2ZETklDem1vQWhCTkdyVUEvQ3BQeG5ESXR5OVRENm14amY2cTR2SkxkMWpCaXNyYUhqUGNHdFc1RzVSakd2b1R5cDhCNmFTVEVsTEJGMmJ6SkdJWk1scG9HbStsV1NRTW9qWnVSTHFxamVsQlhiOE5UNmRDU1I1R0pZb3pJdDBpRUJsM1JqU01kUXBaaU56dFQ0NlQxSFNhTUhlV2RLTTRZY2dJU3NJQXFPdGFiYmRkSVRNYjdtOE0zMVV6UXFVNW9wNGdNS2dWQTQ5QURwSVRtTlNSZ2NWTWpSWDdzSkhucEpaVzBxOTFPTlRTUm9sSXFHM0NiamZmVFd0MkdTWTRISXBKRzMxRm5ZV0U1QmljcGJoUkNnRkNvU1JTbklBbnB5SUo2NnAyL0V0YlBvWllMU2VPOGVlM0VYWmpnanQrNURLOGpsdHBDaXFRT081Wmo4cWROUzE2RWVtc24wYzlpMTQ0dG9MZVcwYU1SVC9SSjI1S01hdFY2Y0tIanZ0WDFBMHcyN3dJTnEyT3h0eThCdTVZcks0TE4yWGFOMERiOFN6UnJHMjUyb3BBb054cWZVak1HSUZ0UGNyZUNDTkluN2JzclFLcEVoTlc0MVkwcUs4YWVucjZhVWkwQ0dha2hzM3RtbXR2cHFGWjF0Z3hTcUUrOGx4M09DamJjKzQxMjB5SldoZGdibTVzUzlxTGtvYkZWQkgwdGtKNTJlUUgyTVpMaGdXWnlha3F0QnR0NjZraUZrUmJLNCtudFl4TGJXNnBJd3JOZVJTeXlVOUZkZ0NLZ2Vpci9BTE5PME1JL2xFa0VrMGNiUUNIdVNQTFN6NEFHdEJUWWtpbE5oVFZ0Q3RpNlpiUjY5aXdVbU1lNXBwWGxkaWZnRjRhdElsaGVHNUsveHRzWHVWZ3NzWGNmODlBb2dMSjBvUXRXZmM3VnJxaTZUQ01iaENrYmVUSmVUWFZnN2hJNWk2eEZ4UThWaFlScDZuWlNLL2hxMWFWS1grNEorSFhWM2FaM0dKallqZFR4SXNLUnFCd2VSbkRjU1FDS2NTYTErR3FzcVRxNUpZNVRVRjRlQ2VONXpQV0Y0djhBY284Tms4VmFOYXlYaGhabzBzM241eXh5UnFGYm5WUTBiYmtIWS9xMWhjak5XbGxwdVRON2o0YjJvNGNQK0J0c3NCZTQyNHU3dk0rVDM2NVNaaFZybkcyZHgyeVMwYVJpUjFkVlloUFpHamJWOUs2SHZ5SzNoVm9vL3dEWmw5T0s2TjJ0Wno4UHgxRnZ5ekdaUCt4NXJNWGVYeVU5eGpHNHJiNUM2anRXYUV6SkE1V09KVVlzdGVKNE5RZEIwT2k4TjY3MVZWV3ZncEJjOUhzZHR6MDhmNkN6aE1XdVp4NlpMS1d5M05nNnVZMFV6M0VyR011QVhlU1YrUzBUMFg0Z2FMeTVOcmhPSDlBZkRUZXBlcS9IbU9GcjRwZ1p1eXNXT3R4WUYyUzVSVkMzVG1na1BFUnhsbFVmcEJkaU5qdnZvUythMnN2VUlyaHE0aGFHKzU4SjhjaHRyUytreDdRTkZiYzNrZzVzWEMrODkwUElEUXNBaElIdUg0aWtLOGpJMjFQVW0rUFR3TVlZcmFHRXh5aUhNMkR3ODd0TzRZNDRaQ25hS0NOK1JwR3hDRUJONk1LR29PcDJibndaQkpOUjFSYkZsNFppTUxCSm5iZTJqaVI4YkRjUnBOV2E2dUxjV0xkNFN0RVpaVlZlYWV5TjJXbnQ0Z1VwbFpNMTd2YTNPdjAxRHFVVlBWSGI1bGRlRjNONWMvYitDTzVkYkczL0FMZkJMYVhjbHFVZDQwdVpCR3ZlWWtuakVLUm1teGFxN0sycmVaVmZmbGF1Zkh5OEMzaFd2OW1PelhoNWhUNit3OGZ4NnJOZkJiVVhMMnRnOTdCSWJxVU1FYVVoR1YzRU1iVVNqUkU4ZllBS0U2bzJQSmFOdmFYRDBYaDgzOGZNTFYvdFVUM05KNmFycjQvTDVBbkplVnlaL0syMkNlNytqV0JuZVc2dkFydWpSSVNZeWk5b0htd1pqRzBZL0FiRFZtTGk3VTdSTDh2dy9xTm01bFhGSmlPclpSLzNHdElzamw3TmNkY1hON3hXU04rN2JmU3h4L3VFeHh4bHFNL3NJTEZoc1Q2OVQwM0RUclZ5a3ZuSnlITXNyVzBjaTFhK1BUeWcxN2NkUDFkeWFOS2ZpT1ZSbzEzUUVxTUlXZUJTNG1GdEJQYXZPUjhXWVVBcVR6STRnQWRkOVJlU05TZGNjbTlzYkRieENXQzRTNWtBNU1rRWJBS0Irb2xuQ2oyK3VtM2krMkdNYU1PZjBXZDNjeW9LM0N5M0t3UlVVTXpMN0kyTzRXZzMxQjJaWldxQ1VNbGxCWnc1R0xDV1I3amNQcGJ5VzRtWWN0MS9USWdZMEgrWFVIZHpFc3NWRnRtREdMelcrbGpsQ1dsaFp1cmRoT3pqYmZpVllHcXJJNFpsWWcvaUI4OTlTZENPOHhsa3ltWWlpSnlMUlFseENJSTJjT0lDYU1PSXBXdFB4T29QUW1xdTNjWXJIeCtQR3RDOTdieTVhd2VSWWJTMEhjWjV5Z2FSSFpXQklCMjl2b0tjdERQSTdhTFIrSVhYRERXa3I5UjZ1cDhQZlcwMWlFT0VTQkxjejJpUlVSMmlqSEFNR0o5dkltdlgwMW1xdDYybjkzek5TOThkNnd2VEg1Z093OFJ0TDdJWTBRUU5GYjNTcGRUdEorekRMUnVJN1IyNEtOaUJ1eFBSZmladmNOVHFnSllsSzdKbHlZS2Z3N3d6RzIwa1Z4QmJzNEQ1TEpHVThEY3VRQTBTN0ZneFJtb0swcFg4UlZYSmV5RDE5dkhWK1pVWDNtZk5lZGZkdVNid3JGM2VheEsybHBISzlyQzkvQUxtM0pWWGNxckFiQWUzNTcxMXFjZUswY3VOVEN6K3ErbXFnbWVQL2F6N3gyR0V2Y1hpL0dibTZ0TDhOSnd2eEJaUVF5dkhMSCszRkk5T0k3cmZxQy9DbE5XTzFiTWdxMnF0RFo0ZDQ5OThmdDU1Vlo1SEwrTFNacTNTTll4Yk5KSEpEYndVVk8yZTJaU1kxb2xLVUpBTzFOUGI3YjA2RWEvY3EvRVl2dUo1bmVXdUh2c1JjV0V1S3ZwNFVreDF4UEMwTWNLaDBLSjlTdkJXVlZTcEVpMDVLYWRkRC9acnVucUdYNURhYUtCeU9UblBqTWRwazFlUlRQYm14aTRvVkZpOERWUXkwVWx2YXJFa0hwdnZxK3FXK1YrR0J1ejI2bHgrWHoyZDVQajBnbmtZdGo4Zk9zVUR0Vkk1YlpDSDQ4eFZ5emtWcDA1TU9tdVl3SzFiVzhOek9yeVdyZkhWZDlxS08rNitidDh6SGhiUkZkTG5FZlZXTG9HSnQrRFM5NWUwaEI0MExzQ2VUY3V0ZGRId2NXemMvd0RkRC9INDBPYjUrVGR0WGV1aFg5dFltWjFVYnN4QUMrdS9yK0d0RjJnekVwRDl2Z1lUT2ljQ1dxcE1kZjZTeWcxUHgzMjBPOGpDYTQwWFA0bjl1TUhkNUN6bnRrRXNZalY1SW1SbzVDeVN5SklzZ0NNeVZLcUZQQTFydDhkWXVYbFhTYXNiR0hqVXMwMGcrUENvOGY1Ukhjenh4d1drVndxdk1KaHlkcG9IZDQ0aVYvbzJTcGIwNmJhRysvdnhOZDQvaUZyRnN5cDlwL2dUcFdzUmRuTVN4bUtDTVF1MWttMVhFbEkwTEFndnk0OHlGcHNPbldsRmF2YkhqT3Y2L0F2dGtXNXQ2ZFB4NW0yOHNiYTR4UnZJWXpESE1xaWU1ZzVKSk5KQXBSRTVBS3NhOGtwK210T200cnBVYjNSNGZRamxhMnl1L2NrWXZJM3FXbHRZQ0tGRmx1YmExak1hRFpnd0xGbVVna3VBdkhnRjZpbEtrNm5rd1YxZmZxUng4bTBwZklOWVc2bThhelYvaTVsRWxubU12ZFdzcXdsU2tNUE5ibCs0eDlwWWQxRjVJYTBZZ2REcW5MaldhbFgwZGFwNi9RbGlzOGQydXMyYTArbzU0eTh0TEdhMG5ubDdrVjZZL3dCeEFaSC9BSEk2dEdYS0tGcVdxcXFpazBBTEVrRFdYYkM3K251Zzc3cXBEN01vdjd6WFZ0ay9LNGJPQ1lmM0dPM1FaRzFsWndZM01zbEJJZUlCUGJrVUx1Zm5UWFRlM1UyNFcrMDZHRHpyemxYakFvM1dKdWpaVy82TGRwWTVSQkRVTnhDQU16RWdnZ0QzQWs3Zkxwb3Y3aVRCM1MwSm1qRC9BRTAxNWs4VEs3eFk2VEd6TldnRy9PSWdjS3NTRDJCVjZiZkFkZFcyVDJwK1pRbzNOZE5BeGZYZUN4VmhqMm54OHR6azd0VUJqb0pnYXhjVWthUjNrWmlTeHJYMnFBS0RiUTZya3RaNndnaTFzZGFyU1dCY2crSXNiaERlUzNDUXJHc01LMmpMUjZCVVpwWm5WZmJVbGxSZDk2c2VtaUtxelhpRFhoZkF4a3VzYkM4aWxWTVVzU3dMMm5NY1Vab2UyaFdSbTVuZmp5SFhWcVRzaXR0SWl3cG04bk5QSkZqTGhtWVNDS1MwZ2ttak16eHF0ZWExcUZrVXRVOVBTbXJJVUZidHJxYmNYNDlsSHVzZGEzTno5TG1WbEFDWGZQY3VUR1FBZjZtRGdrRTlLK3RkVFZWcjRFWlphYS9hbkFxOWIzTG5JVE5Fc2tzVmlZcldPS1NNSXpyTTZOUEp4NGtqOHVtb3BRVGNOYWh2RmVLL2EvQ3l4WDAvaUUyUW1pZFZqdUxXWjczbGN1V0JBY3lRczNRTDdodjZDbWxaTjZUQTFkdGRRbEptc1llL25zSGg0Y0pQYlFTTEZjVzFxdHJjUEN6cXZia0x5U2txUXZGd28zL1BVc2RWWHJxTTdONndWTjViOVJleTltNStveXpNM0tTRzA3VWhXUnh6aktJbTlDRCtsVm9OOVd5MGltRHl5OEZ2cjJaRGV3WkhHbDRtYVdhOXRtTU1vSVZLTzlFVmR0NnFLbjhkOVEzaWd6Ynhtd2EwYTJ0TTFncDU1WXpGY3lHWnByaFNHNHNPeXlvMUJzUGMyMUs3NmZmUFZNZllUTFh3ZkQ0OVpyZktYYlh3dVNzc2NOcEZ3UTlzRXNJNUFKTzJDUnhZTVBkMDFIZkpMWWs5Umt4L2kvaTRzN2U1OGNXUEh6cks0dVd1d0pyZ0lUeTVENmxlSzhkL2FsUHgxQjI4U2UzcEJHdjdQUFhtUXVJWWN1ODFwTHlsTXN0ck83RnoxVmpDN3FvWGFucC9EU3JkUHNSMnQ5elF2ajAwMlQraWx6ZGhjenhxenUxNWtsVkVSL2F3TVJhU1FrVkZBd0ZCcDFadm9tSnFBYko0NTRMaGIwdDVGTFBDNWRJQTluQlBKQXpTL3BWSk5xQThxaDYvejFaTElzMXorWi9aekJMMmJmQTMrVHZJR3BITGZQU0NxdHhCQ21wSy9pbStrazJobXdZL21tYnpNNlhWcGhjUmpySzNkU3NWckFKcmdJd3FGUEVGM2FqQmZ3MDdTUTB0aFRHZmJiejdQSjM3VHgwNCt6aUlGdklpQzJqRk5nOHNjNGN0VHFlQ0hicHF0NWE5SkVxc1ljVjRoNFM5dkpkWnk0dk1oNUZhUElKNHNWTkZCWlJNbnVEVFN6eHhPUFdwNE5wOXpKYlYzQkdmOGorMWZqcXkyZU53OHNubS9FdkcxMjBXVnRYTkNRclBJMFlOUzM2bFhwNmFlRzBNNFRFREJ6K2VYdmtQOTVUeDJXNXNNaWpSM3NQY01OcTBiMElFTXg0aUNteFVxZjQ2bHZTMGtiYXlmbWZHUHVONU5leldkbE8rTndTeWQyM3g3M2JYRDJ3SUMwTG9BS21td0RVOU5Ncm9mWXpYYmZadUNLMWtlOHVZTG00RTZSUExkVDhCVUtYSUFESXkxLzNxNmI3bW82b0g0OGZZNE8zanQ3ZThTZFJWTG1KTzJMWkNwcFJ4QzVNZ0g2alNnK0dtVGxrb1NISHhlOHhXYVNZbTFGL0thbzg4RVVGckVzcm5paW9aT1ZWVVZyeVBRVkkwemNEYlJubHdua1YvWUM3T2N5RmhaUzNBN2xwYXNxY280Z3Fnb0xkV1lNM1J2WnQ2OU5VL2VxV0tucEJWeDQ1NU5EZEg2SnUxYjJxa1N5b2lESWhGQlFGbUVXd05BUThhYmI2bXNpZ2c2UHFBWHkrU2N5NGEreVdObnZYaldTT09TNWhhNVh0bml5MW1XT2hyU25jWThmMUVIcHFUdnA1RWRyUFQ1VEJnN0sxdmZvcjAydHZDWUwremxoK3JTU1FOUXlNL2U3Zkd2TC9sRGY0RFNvM1BVUWFoenVSc1BHcHIvRHlZL3dDb0NkK0hFcUpKWkVoWmFNendRWE14akhIZWhVYmZQVFNwMUhTMEZUSFhUK1FwUEJrRGVJTWpKKzJZSkxtTW1lbGYrVTd5TXlML0FKT1d3MzA3dEJGYWdaYmZ5QnIxYldHNVcveHR1bEVuVjVTamtsbTROM0hEY3VQdFBIYi9BQjA4b2FISWFsaWFiRk05cmlPM2Uydk9HRzBobUVjVEl3NWptTzQvS29WcUZhMStXbzcwdTVQYTJhS1hXUEtYbjlrc1VqdGgvd0JYY1FHQkpXNW1yS2pGNGw1am9IS3R1UGlOTnVsOVJrUmZJY2hidEpOa3J2RnltenVDc2N5RzZqTXhsQ2lraXBBeUlDYURjTlEvTFYxVWlGZ1BhWmJFMkVjVjNiNDc2RnBDWUk3cTcvZWxQTGxHd0hLU1hxQnV0ZXZUcHBva1VoRzBuRitsdEhETkxiUlcwcjl0U1dnZDM0OUFWQTRrOGZhS24rWjAwSkRwaHJHNDIybFluRy9VMnNFRHIvY1p2cUhmbU9WVzRxV2pCSTRqWWo4enBuS0V0UTdtUEdNYmYyTjVlVFM1RzZ4TG1VTmlwSVpsUXlBRWhDeVNTRDJrVkxIL0FNdE1uYnVKaXZoOEZ4eEUyUnk5dWttSFI1SXJlOHgxc3Q3R2dpcFdSbVVWY0FqaXlrK25RZGRKdEswSVM4d05lWG1QdzFyQXRyZjMxcG1nZ2t0K3hZbXpNNlBWL1lpengwVTlQWVB4cnFhY2pkRFhaK1ZaRE1wTkxnYm1WOG9JeTE3SmYyUmtFZFdKcVhrZVVzU0NmMEx2c0tldWxDUTJvenc0YksrVTRkVGZYRFN3S25GcmZIMjBFRXNvSjVLL0VkdVFra2o5UjlOOVJoSmprZE1YbnNkYU5nN2U3dUxTM3FVZ2hTQ0NHczBncXdkSFE3bXBKNHR1ZjQ2ZVV0UlFMZDM0TG1ZcEEzZmdreDhqcXR5VmhzMnR3UW9KQUJRRlRVaXA0MHJwdnVwRFFZeWZiRzRsbm1lUlk1MHRpR2xEckRER1ZKQUN4bFVIUGZxVkhwVFRmZFJMYUtQay9qV1orbGFLN3lrTHg0dXYwRmlpajJSOGlLUlVIVGtEVWZIYzZzVnZJakI1NHRrUERyMlJvdko4ZFBjekxHSkduam5hTjZSN2YwamJmci9ocXlDREJEK1JwTkJLa3BrZHBtSmtlTTBJWFlLQUcyOXROdEIvWmhxRFRlZmNvWnRnOHZ5TTZSMk1VZ2pqaFZpcnNTWktLT25MNG1tK210Z3IxWTlNOW5wNEMxUGRLN1AzWXEzRXU1a2YwSk5hL1AxMFVxd0EydEwxSkZwY0NaWTRybGU3QWpzMFVLRDl4cFNLZW05UDVhYTFlNkk3dXhZZml2aHEzOC85dzhsYjZmSHN2Tk1mWGhVMDlyTnY4QjE5ZEQydkNoZFMzWjNZWnY4QU4yOWxJTEhCd1F6V2ExN2pxU1krZjlQQlFSV25Ua2RWS3M5U2RVbUxqWDEzRVdFYXFYa2N5R05WZHlhMDJHNTlOV2JVTkczdWFIVElPRDlSQlFFQ2pOQ2VKL053ZmpUVmpTUTZldW9XeG5pMTdQYlIzMTdMSGJXSUlSWW1sU0puWWIrMk1WY3FQalNudzFXN2lkWlNHYkpKYlkrYUdLR1FpMWpSQUxhTkdJQklGU1FSczN4cjhkVXB0anZRMDNHY3d3TnhqbW1sdXBKWm8xTHdpWmFUVjQ4VDJsbzIzLzV6YjAxUGF4UGI0a0c3U2VPNnVMQzBySHdaaEdqMnovdHN0YXB5ZHRoVTFKTEg1Nmt2TWoxTXJXUzR0b21aeWxwYUVxWldraUU0YVVWYXBVT29GRjM2TlhTYVFsMGtnNVhKK1FHN2tsYU9TNHNlNHJ4T0xhVlBiU3Z3MnI4dFNyVkpETzdiTU1Sa2tsblpiaUtQSUtYTGlPNmxkVVU3bGdsdkgyMlkxQkcrbmFJaHFWSnJoMmJIVFIyTVY5QjIzdHJFTkpjU2dNU3FORnpxR0grNE5xZGRRK0pLR0FvTDNJNHp0VzhodURFWm43TU56YXh3d295ays0aVYxOXhJMjMvbnF4cVNLbEUrNzhzelp1MHM0SWtqdTFaR2thVjFFQkZDd0xLRURNVy95cSttVkZCS1pZdnJmWmZKM3I1VzV2azcxMDVhYWJzQW12SGlnQ0VqaUtDZ0ZkUzBTSFNZV2dlVnU0MTNkR1ZBb0t0RENpS1Y2VTJKM3FPb09vTkluMWVwc2pibkoyM1Zwd0NRMHhLd3JXZ2IwSTJBK1hYU2dVbjBzOG9nZUZkcmJpcUJsa1VKeExiZTVoVCtCMDY2ak53Yk1MaG84L2t6RE5mckZhd0FGd3hERW40R3Z0QUc1UHA4anFObTB0RVNTbDZzZTdJWWUxRU9HbnpxR3drakphSEd3SXZjRWRHV3JHS3JzS1Yvd3BxcVhIUWVQQWlYRnBqNWNwSkcxMHJMWHROSmNSdGNrS3c1MWQrM3hMQWRBdW5UY0VuRW1uS3JQREJNdHBieDNFSEFTUTNNYTdLZ3F4VkVrQzdBMUFvVFRTV3JHczQwTnFYdVVhQ1A2MTRJclM2SGNBaW9XaVFnQlFXV2pLcWpmM0FrOUthZUVKdnhBMTFqaTk1MnJ1OGl2WUtLTzJzYlZkRm95eHJKSUZVbmVuRk9vOWRUa3FmVVlwWWI0WEZ2SmR3OXVGZVVqMmlxaXFPUFNFY0tCQWFnN3JwbEFvWU1ndm5zYmRvbWxrbXhseWpJOWpFbmNGYWsxRFJzbnVBSjlwUDg5S0IreHF0UmtaNENjYmF0RGhGWXZjU1RJck8wS01BYWxVa2RDQitnTHQ2NmRqS1lEV0t2TVBhSkZrYlRBM2wxWlc2eWlXNWhsbDdVanpWVUFsNGl3SUhYakdOUmp6RW9rcVR5eWV5TXlFUnpKa0dZdWtidCsyc0wvd0JKRDBINWlueE9pS0ZkNEUyVzdoY1VScGUwQ1FrYUJVVUFtdENha244eHE2Q29kUHR2ZnhQa0d4czl2RzBFNXB6bFBJcVdCUUVCcUxzVzVkTlZaRnBKYlJxVER5VHhxNDhienhOMHp4WGtqODBraUlWbGppRGMybzFmMUxXbEQ2YVZiU2g3MWhrdjdlWHNrZDdkcmFwRTF5aWhvVWxCVllvbGl1R2tVU1ViaTNEY21ueXJxamtwYmRTN2p2MWwyV0hrV1E4WHNNNWw0MENYRXpXa2VSbFQ5MkpGdlkzblBFY2xiL21ncUZyWGY0SFhPMm9zdGxYdHI1ZERvbTNqcTdlYW52MUZ2TVowK1FXOW5aelpCRGNUckhQTkJMREsxdzhVRDFRd29ZeFJuWTdxM0lmMUNpamV6RmdXSnV5WDUrUGl5Rjg3eXBWYjE2L1R3Szc4b3lqWE9OYy9YL1QyT1J2b2xtc2tKN1BiakRFTnhGZDFwWHJzcEZONjYxY0dLTExTV2wxTW5QazNWOEUzME9uTUhKNDJuamVNUVcwUXRFc2JlM2lsalNGR1NRb2ljcU00Q2lqTVNXTlN4RmZkMTUvTlhKdmNlTE5uRHMrMmhSeXVUalRNUTROaWd3VnhPODBOdmFzVmFhZm5UazVRRmpVVXF1NEh4cXdwZmpwNmQzOXk4U0Y3TlBhM29MbmsxbGxWdUhGejM0OFhaTzZ4dEpFMGFSeEFtUmpKOU55QzFiMktuSmpTcFA2YWd2RTFIbitPa2xHUk5QWG9OWDJ1OFh5OWozWmx0aGZOZU5aeHhKZTJyc1pLaHBIS0kwYklaQXJCZ2pGbFU4ZVh1T2grVGxWMmw4ZWpId1lvVGEvTXNMN3E1ZkdlT2ZianltOGtjV3ozZU91L3BJcitSVGRtNHZLd0JBc3FqMmdGZUtoU2dGRmpHM0xWUEd4SytTdmZYOGgrUmQxeHY0SEwxbG5Nclk0bFBHM2lqdGIwUUpESEhQTzBLeHBHamJQM0ZFUU5RcmtiaWxSK3B0YWQ4VmJYZCtxbncvREo0c3RsalZGQ2NlTWYwUGZIUElvN3pKd1htZFBPT0puVnlsd0xVU3h1Q2FoK1JjSldnUERpT1BMMU9ueTRJcTFYdjVFTWZJZG5OdTNtYjVNemhMKzJ4dVBuZ1cxanZMbUFJWTE3a0FvWjNtWktvQXl2STN1cHR0U3A5SjRjVmxadnJCVHlNdFhSTHBMK1htS2w3aUliWEhMR0ZOM0U4MHFMY0t4S3EwWUJrNExUclRpU0NmOEFEUlZjamJBSGpTV21wQy9zZG9ZQkFqOXNTcXo4QlR1YkNrZk1VQUJiZHRqc091cnQ3S3RpNkRCaHNMSEk2M2xsUERjVzBWdElyQ1VWWU15aFdvbkVIWWYxRDE2VjFSZTc2TkZ0YUpQUm0yMXdOeVpXczRJWjdtN1h1L1N2RHdsWjQ1VmJpVVFkQ2VvTHRwdDZhSnFtMXdGTGF5dC9GN1dkY2RiUlhGemYyd2dhTzhjd2hDUThidUZKRE9GNTEzSW9kOTZhV3QrdllqcFRvTCtReC8xY01DNHJJUjNGcEZLSkZzSVNydkhMT2dFbnNnTXJFVlQ0NnZyUGRGVm9mUm0vRmVOeVd6RTMyUHl1Unh0cVhralRzL1RKMzM5cXZ6bUtjYWtEM0d2U21tdTIxbzBtS3FWZXphR0cydGN6Sk5JcTJHT3NJWm93cVFOZHB6NFVVaFJ3RWpGMkk5d0crKzJxL3RyeFpOWGE3SVljajVNeGdSTGlmR3JleFFDQWR2Nm1VaFNxSTlGQmdDZXlQaWFrOWRWcmpyeFpmYmsyOHBJQjhsVllPTjlrSjRvZUN0RWx2YjJscTVLTXBBSGU3cnNEVGM4dDZmTFUvc1Y3SXIrOWJ4SFhEWXkreWVPL3ZXTUNaT3l0SGlTVzZ5dVFlZTNqa1lncEVJSXpER2pBbmx1bTNYVk4zVEcra1Q0SUt4MHZsV212ekprMmFrOFZ0b1puOGZ3dVJoV1VSTkxaV2tRN1BJYy9mSlB5cjA5Sy9IcHFtdWV0bkNiUmZialdvcGFVRWl6OHdUT0pIaW10c2pIUGNJaFRIMmt4anRWVmtEZHd4cWVQQ29DZ2o5WHk5STVNanFwVUU4ZUN0OUhQUTE0SDdneldYbGNtQXNFdjJWNHhGQkNyaFdFc2o4QXpFMHJ4QkRqZ0tlbS9YVldUTGtlUGNta1c0Y2VOWmRzTmx0V1hrV1p4Y050bE1rMHM0V1VpSzBUdVNQY0M1ckRER3FramthN3MxYWIxb2R0WnRPVloyaHZzR1pzRktxVXZvVmw5Njg5bmJ6eHlmSlo3TExkMjFwbDdlYXh4TU1mYmdpaWhZMjhrVHRJU1pDUVdQdEJYZmM2Mk9QbGQ3L0xVeHVUajJLWDRuTkYzRmRaVzF1cnd5R3hhOGFXK2xpU3BqY3c4aWhZQUJVVUY2RFliazlkSDFzcXVPc2FHZmFrcWVrbGhrV1hrT010SHVPMVlYRVdHc2hjVEl2Y01pTEFvSEVNb0o1QkkwOXBIcjdxYXczYTJQSTQxVzUvcWRDdnQyeFZsUTl2VXFmenkwTU0wY2dqS1dva1JJVUlYa1AyUTdFRlFSdVR5Mk5QWFc5eExTdk01L20wYXQ1Qy9aeUczNHNrWm5EclFxb0lIdW9DQ2FFbW82ZW1pMnBBazRDbG5MZlN6eVhiUlB3UkpMbFFhVm9wUEhnMjM2ZjhBNTZyYVhRc3EyWFZpUEpuczF0c3ZGSExEWnMwMTBnZ2hkb2kxeEh5Wm1WbGtma0EyeDQ5ZDY4UU5ZVjhLdFoxZXJOM0hsdFZLM1JmQXl6ZWZHVThyd3VjeUVza041YVh0dGJwYXhtVlo0b25XVVJrMFppc2pEaXJVRkZxYWFuaXg3S090ZWpUSVpycTkxWjZRMStZUW51N0N5N0VTWEp1UkdESmQ4cEppQlJ1S0pHa3BVRjJLN1VxU3Y0YXFxbSswRXJ0Vjd5VEkvSkVndDAvdDRWN3BKbzVKYmxQM1FGalIrQlJLc2hWWS9lOGpEcWVud2c4Y3ViZENlK0VvL0M4ankzdmJ0OGhCbU1yTU1mUGkwZDRhbU51ZHl5a3lnVktnUnhnR01CUXgyRzVhbXBPRW9yclA2RWxMOVZ0SURYaTJaeDNrRCtRWFdEWnJ0Rm10NWJhem0vNmRaSTU3Q0NHUkhabGJ0MGZadUpXdENhbW1xYytLMk5VM2VjL1VuZ3lLN3ZzOHYwZ3g4eXlpb2NmaWJ2dTNHZlNRTmJUdExHalN6WFFWcG5rTkFBZzdiZ0dsRjVBVUZOV2NYRkxkMTBaVHlzelVWZlZDVm1iM0taREpXME9idnJSSkV0cERNNklsc1pIamUwbGRaSHBJZmlvUEd2OEF1NzYwYTQ2MHEyaytvQmJKYTkwck5kQ1ZZWHVQbHhsbXNlUWlXMWxtbHRjcEVpbGUzQWl5TUpHYWhMSzdDUGZrVFhZdHFsNEczTWZqOFNFTGtKVmhrRElZaTJremlqdzJFWHN6V1V0ak5CS3BqbFBMazhmYlgzUHhZVlVrRWUwNk9wUjdZdDRnRjdyZE5mQVZMN3hmSzRlNVdUSVhWTHlTTTk0QlhReHlGdUhBbCtGSzEzWU1CdjBJcm92WW1EUzB3NWIvQUd5c1hXMnZzemxvYjJDWW82SkRLcHRtRW9xNnU4SzhnOWVOV0tnZlAxMUZlUTdYaXhoZzhSOGJ4NWhpdzlwWjNqeUZ6TGIzZ21XV1o0S3RSR1Z4d1Z3NnFQZWE4YWpycVVDVWRob3QvSXJKb0xqQVRYOGVQYStUNktZMmRvRlMwUSt5dFk1SHJXdXhZaW9Hb1dxK3c4b2ovUjJkaEZURVpmOEF2R0JncW91WThWQTAvd0JTbEJHc2prTVdSaHV2dEJwMFBYVXRSbkF5UjNFZHBaM0l4VnZqNHIrNVJPY3R4LzhBY2lTV1RyeU1idFRxTnoydzNUMDB5K285dFZvVjFlNUM2dGNsTGJTekd6dWpILzFVT09nTnhielM4aFJuZTRKVXR4cFFoZXRmeW1pbnFiN1BLNFczREprclNhNnNVSWxiaGVKRGNFSWExTVlTT2grSUo5eEhUU2E4Q2FmWWg1bnpQRzIxeERINDVtcjNGSWhBNFIySVpveElTemp2UnU3bHQ5L2JTbW9xdXNqM2FmUUhZdkgzZm10eGNDUytsemJBdEs0a21sdE9aZjJSaGpKRUZwVUNsSHEybFo3VU50a0tZejdLK1NUckpDTVBERXBjajZ0WkdLSTFPWEVsMUtrY2FDb3JUYzEwKzhiYTROdHY5azhwRGVYUnlRdTRiU051Y0xZaUJiaHBRdEtLcmR4Q09sRnFQNTZaM1FsVVpjMUxnL0g4WUlyYkdlUlN6MnJVSDkyc1pwbDNJQnJLOVVvQWExM0czU3UycTRuV1NUc3dIUExnL0xKUG92TFpMdnRJQkRiT1lyZ1BCUUFxRDJGVkdCL3lzQ282VTFZbEdxSXpJcGVjL2JYQmVHM1VOMUJjMkx4WkJ1NUZZM1VSdFpJbzBBWXM0WmlhZE53UnZ0MTIxSldraTZ3RHJieWk1bHNFczRzdmNMYUNWZXlGZDFzbzBCcVZLU2tyc2FGZDYvTFNqVWx1MEplQzg1OFh3SW5UTzRmQzVlR1dWbzdlU1F5QzRqNVViazR0MjRtUDh1UlB5R28ybzMwY0RxNlhZc3o3V2ZlM3h2TTVkc2FNUmI0ODJjY2t0bzlqampOSTBleWlKR2hBZFdwL1U2MFBxUnFqTGllM3FUcmVyZmdYZEQ1eDRZbDNITFpYTmpZM055eGFhWEpNNnlKSUFDU3FxREdmYU92Y1VWME02VzdsM3A3RkUvY2J4enhUeVB6bDg3NVQ1UW1LK3JqV2E2U0dPSzZoa0NLSXZkOU01SnFoVGtkeC9qb21tNVYwMUtySk55RzdMN1hlQStLcjlkaGNyYlpESTloWklZb3JJVHVzTVFVbDFhUm43ZjZodVNCVTZpM2V3a2ttQUVOdDVCRElsN2tubXRYWXozdUttRFc1ZmtTbzR6eHR4WnFyMUFPMnBLaldxRTJMUGtsdU1Ra0tZb1phWEd1U29oaXZIbGhSeUtoU2p4S2Z4L3gxTlQzSVNKR1Q4eHZvNDVaN2dUM0U1RlJiM1VOQVpCN0JSNmIrMzFGRHFhUkZzZzJPVDhsek54RjlQZ3JPUzVjcklsQWJkZ0Via0tqdWNtVVUzMjA3aGR4cGJMQ01ON0cxck5kR1BIM25FU3JiM012L0FFN01UU1NXS0xtcDl2cHlaalgrR3FscVdESGJ4MzFyYlhONWhacnFIRjNBWkxtVzFjUnRLKzRra1F2eTdhZ2plZ0hyMTBuV3ZjZVgyRHQ5NVQ0NU5BclhWMW5ZK0VzVXIzVnBCRE9YbWhVS3BlUlhGSzc3N1YzcnFEeGtuWWdIeTN4TEtMTkF0N2xWUE4yTmxOaldpbWMwb3dqbmhNcEErWWJiMXJxWDIvQXIzRUhIVFdDelNUS2w2ZkhvVEs2dmNmU1hybVNOQUNlTTBjYmhmY1BjV09rNmVlcEp2eUF1VHlXSHlnZ3lXTXhwc1dSamlycTBqa3QwbG5sWnVJZFFaQzFRcEhzTEtyZkhVcXl1cklkZXhKanRzRkJBRnVROEZoYU9rY1dSa3RvME1MYm9RUmF5eXhseXdvZjZpTnpxemN1bmNpaytvdlgzaWVRdjhtbDRQS3NwMjNrN1VkczR1RU5DVDdveVl6R0VwdlQwR25jSmRCa3BmVWdFeVlPWW1iekRKV1VrY3FxNE04VW83Zkxab3d5cUhHM3dyOHRSaWY3U1NiWGNZdjduRm5NWW5jbnR2N1BIRHdNOTVPNWZnQ1FTYmVCb1FSejNQdEJIb2FhaFhSanlEc2JoNzV6Wll5M3ViUzlzTG9naTNwR3NhZHhxOG1Na3M4K3dveXFxbGZYVXJXWFVnUDhBZWVIV21hdHJ6RzNlS2V3akE0NCtXUzNuK2phUkNBN002UlY0TXRTT0kyYmY4S1ZmYnIxTEluUTNEeGkydzlsTGhXR01td2tIQnk5M0xjeGlTcWxtTUxNQ0F3QTlvQlBUZnJzLzN1NUY0elBBNHUweEdQdVJiNWIrNjIxeVdsaXhWbTYyTTBFU3Z4RDdjMmxvRHk1Rmd0TlBiTTIrZzlha0ROWlFIQmkweGF0azhkY0Zadjdia1ltbWFlVXFFWXl6T3pkdER2eTdYRWo0YWF0OWRSb0JGMTl6L0o1TVdscm4vSEx6RzJPTmpQWm54MXljWmFkbGFnOGVMb3o3Q2czUHhwcVcxVG8rbzZmaVoyRXR6NVNsbGZCbnMydFAzTEZMeWExeVV4Qi9yREZnUnNLVVpoWDU2Zy9Ub0p3ekh5VEJISjJrRUQyaGppaUZiY3dxWWJkWkRROGc2cklGWnFibHlkNkFIVXEySXVyZ1JMZkdYbHROSmR3ejNrczFvWFNXUEp0YnhCT1lxamhuOXJDblQzVjI2YjZ1MytJMEJLUWVkVDJ0dTExQ21UdzZiWERXRjdCYnlOeUZRV2FnQllocURrdjU2WldRMEJQRjVDMHNNaW1OOG1zM2hzSGgvYWh2TWlzU2tSa0RpSllYSTVMeUIzWGZUcjFQUVJsbEx2dzlMMlc3dHJiSnpTMTdheVc5OGt0ckdyVmRGUjVFM3F0QnUxZCt1blNZMFFMRjZ2aTBsd0xzVFpsTCthUGxCQUd0V0I1TC9WKzhHQ2dlcDlOUEF4VytjaWxzc21jbGlDOElIdkVoWWR6bFdoSjQvUDAxWWhILzJRPT1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3RleHR1cmUuanBnXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vc3R5bGUuc2Nzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9zdHlsZS5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9zdHlsZS5zY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc3R5bGUuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiYm9keSB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwOyB9XFxuXFxuI3Jvb3Qge1xcbiAgZm9udC1zaXplOiAwOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vc3JjL3N0eWxlLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8gKyBcIiBcIiArIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzJyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLypcbiBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiovXG4ndXNlIHN0cmljdCc7dmFyIGFhPXJlcXVpcmUoXCJyZWFjdFwiKSxsPXJlcXVpcmUoXCJmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKSxCPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLEM9cmVxdWlyZShcImZianMvbGliL2VtcHR5RnVuY3Rpb25cIiksYmE9cmVxdWlyZShcImZianMvbGliL0V2ZW50TGlzdGVuZXJcIiksZGE9cmVxdWlyZShcImZianMvbGliL2dldEFjdGl2ZUVsZW1lbnRcIiksZWE9cmVxdWlyZShcImZianMvbGliL3NoYWxsb3dFcXVhbFwiKSxmYT1yZXF1aXJlKFwiZmJqcy9saWIvY29udGFpbnNOb2RlXCIpLGlhPXJlcXVpcmUoXCJmYmpzL2xpYi9mb2N1c05vZGVcIiksRD1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlPYmplY3RcIik7XG5mdW5jdGlvbiBFKGEpe2Zvcih2YXIgYj1hcmd1bWVudHMubGVuZ3RoLTEsYz1cIk1pbmlmaWVkIFJlYWN0IGVycm9yICNcIithK1wiOyB2aXNpdCBodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudFxceDNkXCIrYSxkPTA7ZDxiO2QrKyljKz1cIlxceDI2YXJnc1tdXFx4M2RcIitlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2QrMV0pO2I9RXJyb3IoYytcIiBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuXCIpO2IubmFtZT1cIkludmFyaWFudCBWaW9sYXRpb25cIjtiLmZyYW1lc1RvUG9wPTE7dGhyb3cgYjt9YWE/dm9pZCAwOkUoXCIyMjdcIik7XG52YXIgb2E9e2NoaWxkcmVuOiEwLGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiEwLGRlZmF1bHRWYWx1ZTohMCxkZWZhdWx0Q2hlY2tlZDohMCxpbm5lckhUTUw6ITAsc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiEwLHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzohMCxzdHlsZTohMH07ZnVuY3Rpb24gcGEoYSxiKXtyZXR1cm4oYSZiKT09PWJ9XG52YXIgdGE9e01VU1RfVVNFX1BST1BFUlRZOjEsSEFTX0JPT0xFQU5fVkFMVUU6NCxIQVNfTlVNRVJJQ19WQUxVRTo4LEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOjI0LEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU6MzIsSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFOjY0LGluamVjdERPTVByb3BlcnR5Q29uZmlnOmZ1bmN0aW9uKGEpe3ZhciBiPXRhLGM9YS5Qcm9wZXJ0aWVzfHx7fSxkPWEuRE9NQXR0cmlidXRlTmFtZXNwYWNlc3x8e30sZT1hLkRPTUF0dHJpYnV0ZU5hbWVzfHx7fTthPWEuRE9NTXV0YXRpb25NZXRob2RzfHx7fTtmb3IodmFyIGYgaW4gYyl7dWEuaGFzT3duUHJvcGVydHkoZik/RShcIjQ4XCIsZik6dm9pZCAwO3ZhciBnPWYudG9Mb3dlckNhc2UoKSxoPWNbZl07Zz17YXR0cmlidXRlTmFtZTpnLGF0dHJpYnV0ZU5hbWVzcGFjZTpudWxsLHByb3BlcnR5TmFtZTpmLG11dGF0aW9uTWV0aG9kOm51bGwsbXVzdFVzZVByb3BlcnR5OnBhKGgsYi5NVVNUX1VTRV9QUk9QRVJUWSksXG5oYXNCb29sZWFuVmFsdWU6cGEoaCxiLkhBU19CT09MRUFOX1ZBTFVFKSxoYXNOdW1lcmljVmFsdWU6cGEoaCxiLkhBU19OVU1FUklDX1ZBTFVFKSxoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpwYShoLGIuSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpLGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6cGEoaCxiLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpLGhhc1N0cmluZ0Jvb2xlYW5WYWx1ZTpwYShoLGIuSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFKX07MT49Zy5oYXNCb29sZWFuVmFsdWUrZy5oYXNOdW1lcmljVmFsdWUrZy5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlP3ZvaWQgMDpFKFwiNTBcIixmKTtlLmhhc093blByb3BlcnR5KGYpJiYoZy5hdHRyaWJ1dGVOYW1lPWVbZl0pO2QuaGFzT3duUHJvcGVydHkoZikmJihnLmF0dHJpYnV0ZU5hbWVzcGFjZT1kW2ZdKTthLmhhc093blByb3BlcnR5KGYpJiYoZy5tdXRhdGlvbk1ldGhvZD1hW2ZdKTt1YVtmXT1nfX19LHVhPXt9O1xuZnVuY3Rpb24gdmEoYSxiKXtpZihvYS5oYXNPd25Qcm9wZXJ0eShhKXx8MjxhLmxlbmd0aCYmKFwib1wiPT09YVswXXx8XCJPXCI9PT1hWzBdKSYmKFwiblwiPT09YVsxXXx8XCJOXCI9PT1hWzFdKSlyZXR1cm4hMTtpZihudWxsPT09YilyZXR1cm4hMDtzd2l0Y2godHlwZW9mIGIpe2Nhc2UgXCJib29sZWFuXCI6cmV0dXJuIG9hLmhhc093blByb3BlcnR5KGEpP2E9ITA6KGI9d2EoYSkpP2E9Yi5oYXNCb29sZWFuVmFsdWV8fGIuaGFzU3RyaW5nQm9vbGVhblZhbHVlfHxiLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6KGE9YS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsNSksYT1cImRhdGEtXCI9PT1hfHxcImFyaWEtXCI9PT1hKSxhO2Nhc2UgXCJ1bmRlZmluZWRcIjpjYXNlIFwibnVtYmVyXCI6Y2FzZSBcInN0cmluZ1wiOmNhc2UgXCJvYmplY3RcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiB3YShhKXtyZXR1cm4gdWEuaGFzT3duUHJvcGVydHkoYSk/dWFbYV06bnVsbH1cbnZhciB4YT10YSx5YT14YS5NVVNUX1VTRV9QUk9QRVJUWSxLPXhhLkhBU19CT09MRUFOX1ZBTFVFLHphPXhhLkhBU19OVU1FUklDX1ZBTFVFLEFhPXhhLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLEJhPXhhLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsQ2E9eGEuSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLERhPXtQcm9wZXJ0aWVzOnthbGxvd0Z1bGxTY3JlZW46Syxhc3luYzpLLGF1dG9Gb2N1czpLLGF1dG9QbGF5OkssY2FwdHVyZTpCYSxjaGVja2VkOnlhfEssY29sczpBYSxjb250ZW50RWRpdGFibGU6Q2EsY29udHJvbHM6SyxcImRlZmF1bHRcIjpLLGRlZmVyOkssZGlzYWJsZWQ6Syxkb3dubG9hZDpCYSxkcmFnZ2FibGU6Q2EsZm9ybU5vVmFsaWRhdGU6SyxoaWRkZW46Syxsb29wOkssbXVsdGlwbGU6eWF8SyxtdXRlZDp5YXxLLG5vVmFsaWRhdGU6SyxvcGVuOksscGxheXNJbmxpbmU6SyxyZWFkT25seTpLLHJlcXVpcmVkOksscmV2ZXJzZWQ6Syxyb3dzOkFhLHJvd1NwYW46emEsXG5zY29wZWQ6SyxzZWFtbGVzczpLLHNlbGVjdGVkOnlhfEssc2l6ZTpBYSxzdGFydDp6YSxzcGFuOkFhLHNwZWxsQ2hlY2s6Q2Esc3R5bGU6MCx0YWJJbmRleDowLGl0ZW1TY29wZTpLLGFjY2VwdENoYXJzZXQ6MCxjbGFzc05hbWU6MCxodG1sRm9yOjAsaHR0cEVxdWl2OjAsdmFsdWU6Q2F9LERPTUF0dHJpYnV0ZU5hbWVzOnthY2NlcHRDaGFyc2V0OlwiYWNjZXB0LWNoYXJzZXRcIixjbGFzc05hbWU6XCJjbGFzc1wiLGh0bWxGb3I6XCJmb3JcIixodHRwRXF1aXY6XCJodHRwLWVxdWl2XCJ9LERPTU11dGF0aW9uTWV0aG9kczp7dmFsdWU6ZnVuY3Rpb24oYSxiKXtpZihudWxsPT1iKXJldHVybiBhLnJlbW92ZUF0dHJpYnV0ZShcInZhbHVlXCIpO1wibnVtYmVyXCIhPT1hLnR5cGV8fCExPT09YS5oYXNBdHRyaWJ1dGUoXCJ2YWx1ZVwiKT9hLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIitiKTphLnZhbGlkaXR5JiYhYS52YWxpZGl0eS5iYWRJbnB1dCYmYS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQhPT1hJiZcbmEuc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiK2IpfX19LEVhPXhhLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxNPXt4bGluazpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIix4bWw6XCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIn0sR2E9e1Byb3BlcnRpZXM6e2F1dG9SZXZlcnNlOkVhLGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6RWEscHJlc2VydmVBbHBoYTpFYX0sRE9NQXR0cmlidXRlTmFtZXM6e2F1dG9SZXZlcnNlOlwiYXV0b1JldmVyc2VcIixleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOlwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiLHByZXNlcnZlQWxwaGE6XCJwcmVzZXJ2ZUFscGhhXCJ9LERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6e3hsaW5rQWN0dWF0ZTpNLnhsaW5rLHhsaW5rQXJjcm9sZTpNLnhsaW5rLHhsaW5rSHJlZjpNLnhsaW5rLHhsaW5rUm9sZTpNLnhsaW5rLHhsaW5rU2hvdzpNLnhsaW5rLHhsaW5rVGl0bGU6TS54bGluayx4bGlua1R5cGU6TS54bGluayxcbnhtbEJhc2U6TS54bWwseG1sTGFuZzpNLnhtbCx4bWxTcGFjZTpNLnhtbH19LEhhPS9bXFwtXFw6XShbYS16XSkvZztmdW5jdGlvbiBJYShhKXtyZXR1cm4gYVsxXS50b1VwcGVyQ2FzZSgpfVxuXCJhY2NlbnQtaGVpZ2h0IGFsaWdubWVudC1iYXNlbGluZSBhcmFiaWMtZm9ybSBiYXNlbGluZS1zaGlmdCBjYXAtaGVpZ2h0IGNsaXAtcGF0aCBjbGlwLXJ1bGUgY29sb3ItaW50ZXJwb2xhdGlvbiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMgY29sb3ItcHJvZmlsZSBjb2xvci1yZW5kZXJpbmcgZG9taW5hbnQtYmFzZWxpbmUgZW5hYmxlLWJhY2tncm91bmQgZmlsbC1vcGFjaXR5IGZpbGwtcnVsZSBmbG9vZC1jb2xvciBmbG9vZC1vcGFjaXR5IGZvbnQtZmFtaWx5IGZvbnQtc2l6ZSBmb250LXNpemUtYWRqdXN0IGZvbnQtc3RyZXRjaCBmb250LXN0eWxlIGZvbnQtdmFyaWFudCBmb250LXdlaWdodCBnbHlwaC1uYW1lIGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwgZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwgaG9yaXotYWR2LXggaG9yaXotb3JpZ2luLXggaW1hZ2UtcmVuZGVyaW5nIGxldHRlci1zcGFjaW5nIGxpZ2h0aW5nLWNvbG9yIG1hcmtlci1lbmQgbWFya2VyLW1pZCBtYXJrZXItc3RhcnQgb3ZlcmxpbmUtcG9zaXRpb24gb3ZlcmxpbmUtdGhpY2tuZXNzIHBhaW50LW9yZGVyIHBhbm9zZS0xIHBvaW50ZXItZXZlbnRzIHJlbmRlcmluZy1pbnRlbnQgc2hhcGUtcmVuZGVyaW5nIHN0b3AtY29sb3Igc3RvcC1vcGFjaXR5IHN0cmlrZXRocm91Z2gtcG9zaXRpb24gc3RyaWtldGhyb3VnaC10aGlja25lc3Mgc3Ryb2tlLWRhc2hhcnJheSBzdHJva2UtZGFzaG9mZnNldCBzdHJva2UtbGluZWNhcCBzdHJva2UtbGluZWpvaW4gc3Ryb2tlLW1pdGVybGltaXQgc3Ryb2tlLW9wYWNpdHkgc3Ryb2tlLXdpZHRoIHRleHQtYW5jaG9yIHRleHQtZGVjb3JhdGlvbiB0ZXh0LXJlbmRlcmluZyB1bmRlcmxpbmUtcG9zaXRpb24gdW5kZXJsaW5lLXRoaWNrbmVzcyB1bmljb2RlLWJpZGkgdW5pY29kZS1yYW5nZSB1bml0cy1wZXItZW0gdi1hbHBoYWJldGljIHYtaGFuZ2luZyB2LWlkZW9ncmFwaGljIHYtbWF0aGVtYXRpY2FsIHZlY3Rvci1lZmZlY3QgdmVydC1hZHYteSB2ZXJ0LW9yaWdpbi14IHZlcnQtb3JpZ2luLXkgd29yZC1zcGFjaW5nIHdyaXRpbmctbW9kZSB4LWhlaWdodCB4bGluazphY3R1YXRlIHhsaW5rOmFyY3JvbGUgeGxpbms6aHJlZiB4bGluazpyb2xlIHhsaW5rOnNob3cgeGxpbms6dGl0bGUgeGxpbms6dHlwZSB4bWw6YmFzZSB4bWxuczp4bGluayB4bWw6bGFuZyB4bWw6c3BhY2VcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgYj1hLnJlcGxhY2UoSGEsXG5JYSk7R2EuUHJvcGVydGllc1tiXT0wO0dhLkRPTUF0dHJpYnV0ZU5hbWVzW2JdPWF9KTt4YS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhEYSk7eGEuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoR2EpO1xudmFyIFA9e19jYXVnaHRFcnJvcjpudWxsLF9oYXNDYXVnaHRFcnJvcjohMSxfcmV0aHJvd0Vycm9yOm51bGwsX2hhc1JldGhyb3dFcnJvcjohMSxpbmplY3Rpb246e2luamVjdEVycm9yVXRpbHM6ZnVuY3Rpb24oYSl7XCJmdW5jdGlvblwiIT09dHlwZW9mIGEuaW52b2tlR3VhcmRlZENhbGxiYWNrP0UoXCIxOTdcIik6dm9pZCAwO0phPWEuaW52b2tlR3VhcmRlZENhbGxiYWNrfX0saW52b2tlR3VhcmRlZENhbGxiYWNrOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxrKXtKYS5hcHBseShQLGFyZ3VtZW50cyl9LGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcjpmdW5jdGlvbihhLGIsYyxkLGUsZixnLGgsayl7UC5pbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKFAuaGFzQ2F1Z2h0RXJyb3IoKSl7dmFyIHE9UC5jbGVhckNhdWdodEVycm9yKCk7UC5faGFzUmV0aHJvd0Vycm9yfHwoUC5faGFzUmV0aHJvd0Vycm9yPSEwLFAuX3JldGhyb3dFcnJvcj1cbnEpfX0scmV0aHJvd0NhdWdodEVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIEthLmFwcGx5KFAsYXJndW1lbnRzKX0saGFzQ2F1Z2h0RXJyb3I6ZnVuY3Rpb24oKXtyZXR1cm4gUC5faGFzQ2F1Z2h0RXJyb3J9LGNsZWFyQ2F1Z2h0RXJyb3I6ZnVuY3Rpb24oKXtpZihQLl9oYXNDYXVnaHRFcnJvcil7dmFyIGE9UC5fY2F1Z2h0RXJyb3I7UC5fY2F1Z2h0RXJyb3I9bnVsbDtQLl9oYXNDYXVnaHRFcnJvcj0hMTtyZXR1cm4gYX1FKFwiMTk4XCIpfX07ZnVuY3Rpb24gSmEoYSxiLGMsZCxlLGYsZyxoLGspe1AuX2hhc0NhdWdodEVycm9yPSExO1AuX2NhdWdodEVycm9yPW51bGw7dmFyIHE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDMpO3RyeXtiLmFwcGx5KGMscSl9Y2F0Y2godil7UC5fY2F1Z2h0RXJyb3I9dixQLl9oYXNDYXVnaHRFcnJvcj0hMH19XG5mdW5jdGlvbiBLYSgpe2lmKFAuX2hhc1JldGhyb3dFcnJvcil7dmFyIGE9UC5fcmV0aHJvd0Vycm9yO1AuX3JldGhyb3dFcnJvcj1udWxsO1AuX2hhc1JldGhyb3dFcnJvcj0hMTt0aHJvdyBhO319dmFyIExhPW51bGwsTWE9e307XG5mdW5jdGlvbiBOYSgpe2lmKExhKWZvcih2YXIgYSBpbiBNYSl7dmFyIGI9TWFbYV0sYz1MYS5pbmRleE9mKGEpOy0xPGM/dm9pZCAwOkUoXCI5NlwiLGEpO2lmKCFPYVtjXSl7Yi5leHRyYWN0RXZlbnRzP3ZvaWQgMDpFKFwiOTdcIixhKTtPYVtjXT1iO2M9Yi5ldmVudFR5cGVzO2Zvcih2YXIgZCBpbiBjKXt2YXIgZT12b2lkIDA7dmFyIGY9Y1tkXSxnPWIsaD1kO1BhLmhhc093blByb3BlcnR5KGgpP0UoXCI5OVwiLGgpOnZvaWQgMDtQYVtoXT1mO3ZhciBrPWYucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7aWYoayl7Zm9yKGUgaW4gaylrLmhhc093blByb3BlcnR5KGUpJiZRYShrW2VdLGcsaCk7ZT0hMH1lbHNlIGYucmVnaXN0cmF0aW9uTmFtZT8oUWEoZi5yZWdpc3RyYXRpb25OYW1lLGcsaCksZT0hMCk6ZT0hMTtlP3ZvaWQgMDpFKFwiOThcIixkLGEpfX19fVxuZnVuY3Rpb24gUWEoYSxiLGMpe1JhW2FdP0UoXCIxMDBcIixhKTp2b2lkIDA7UmFbYV09YjtTYVthXT1iLmV2ZW50VHlwZXNbY10uZGVwZW5kZW5jaWVzfXZhciBPYT1bXSxQYT17fSxSYT17fSxTYT17fTtmdW5jdGlvbiBUYShhKXtMYT9FKFwiMTAxXCIpOnZvaWQgMDtMYT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhKTtOYSgpfWZ1bmN0aW9uIFVhKGEpe3ZhciBiPSExLGM7Zm9yKGMgaW4gYSlpZihhLmhhc093blByb3BlcnR5KGMpKXt2YXIgZD1hW2NdO01hLmhhc093blByb3BlcnR5KGMpJiZNYVtjXT09PWR8fChNYVtjXT9FKFwiMTAyXCIsYyk6dm9pZCAwLE1hW2NdPWQsYj0hMCl9YiYmTmEoKX1cbnZhciBWYT1PYmplY3QuZnJlZXplKHtwbHVnaW5zOk9hLGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczpQYSxyZWdpc3RyYXRpb25OYW1lTW9kdWxlczpSYSxyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOlNhLHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6bnVsbCxpbmplY3RFdmVudFBsdWdpbk9yZGVyOlRhLGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTpVYX0pLFdhPW51bGwsWGE9bnVsbCxZYT1udWxsO2Z1bmN0aW9uIFphKGEsYixjLGQpe2I9YS50eXBlfHxcInVua25vd24tZXZlbnRcIjthLmN1cnJlbnRUYXJnZXQ9WWEoZCk7UC5pbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IoYixjLHZvaWQgMCxhKTthLmN1cnJlbnRUYXJnZXQ9bnVsbH1cbmZ1bmN0aW9uICRhKGEsYil7bnVsbD09Yj9FKFwiMzBcIik6dm9pZCAwO2lmKG51bGw9PWEpcmV0dXJuIGI7aWYoQXJyYXkuaXNBcnJheShhKSl7aWYoQXJyYXkuaXNBcnJheShiKSlyZXR1cm4gYS5wdXNoLmFwcGx5KGEsYiksYTthLnB1c2goYik7cmV0dXJuIGF9cmV0dXJuIEFycmF5LmlzQXJyYXkoYik/W2FdLmNvbmNhdChiKTpbYSxiXX1mdW5jdGlvbiBhYihhLGIsYyl7QXJyYXkuaXNBcnJheShhKT9hLmZvckVhY2goYixjKTphJiZiLmNhbGwoYyxhKX12YXIgYmI9bnVsbDtcbmZ1bmN0aW9uIGNiKGEsYil7aWYoYSl7dmFyIGM9YS5fZGlzcGF0Y2hMaXN0ZW5lcnMsZD1hLl9kaXNwYXRjaEluc3RhbmNlcztpZihBcnJheS5pc0FycmF5KGMpKWZvcih2YXIgZT0wO2U8Yy5sZW5ndGgmJiFhLmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7ZSsrKVphKGEsYixjW2VdLGRbZV0pO2Vsc2UgYyYmWmEoYSxiLGMsZCk7YS5fZGlzcGF0Y2hMaXN0ZW5lcnM9bnVsbDthLl9kaXNwYXRjaEluc3RhbmNlcz1udWxsO2EuaXNQZXJzaXN0ZW50KCl8fGEuY29uc3RydWN0b3IucmVsZWFzZShhKX19ZnVuY3Rpb24gZGIoYSl7cmV0dXJuIGNiKGEsITApfWZ1bmN0aW9uIGdiKGEpe3JldHVybiBjYihhLCExKX12YXIgaGI9e2luamVjdEV2ZW50UGx1Z2luT3JkZXI6VGEsaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOlVhfTtcbmZ1bmN0aW9uIGliKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7aWYoIWMpcmV0dXJuIG51bGw7dmFyIGQ9V2EoYyk7aWYoIWQpcmV0dXJuIG51bGw7Yz1kW2JdO2E6c3dpdGNoKGIpe2Nhc2UgXCJvbkNsaWNrXCI6Y2FzZSBcIm9uQ2xpY2tDYXB0dXJlXCI6Y2FzZSBcIm9uRG91YmxlQ2xpY2tcIjpjYXNlIFwib25Eb3VibGVDbGlja0NhcHR1cmVcIjpjYXNlIFwib25Nb3VzZURvd25cIjpjYXNlIFwib25Nb3VzZURvd25DYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlVXBcIjpjYXNlIFwib25Nb3VzZVVwQ2FwdHVyZVwiOihkPSFkLmRpc2FibGVkKXx8KGE9YS50eXBlLGQ9IShcImJ1dHRvblwiPT09YXx8XCJpbnB1dFwiPT09YXx8XCJzZWxlY3RcIj09PWF8fFwidGV4dGFyZWFcIj09PWEpKTthPSFkO2JyZWFrIGE7ZGVmYXVsdDphPSExfWlmKGEpcmV0dXJuIG51bGw7YyYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGM/RShcIjIzMVwiLGIsdHlwZW9mIGMpOnZvaWQgMDtcbnJldHVybiBjfWZ1bmN0aW9uIGpiKGEsYixjLGQpe2Zvcih2YXIgZSxmPTA7ZjxPYS5sZW5ndGg7ZisrKXt2YXIgZz1PYVtmXTtnJiYoZz1nLmV4dHJhY3RFdmVudHMoYSxiLGMsZCkpJiYoZT0kYShlLGcpKX1yZXR1cm4gZX1mdW5jdGlvbiBrYihhKXthJiYoYmI9JGEoYmIsYSkpfWZ1bmN0aW9uIGxiKGEpe3ZhciBiPWJiO2JiPW51bGw7YiYmKGE/YWIoYixkYik6YWIoYixnYiksYmI/RShcIjk1XCIpOnZvaWQgMCxQLnJldGhyb3dDYXVnaHRFcnJvcigpKX12YXIgbWI9T2JqZWN0LmZyZWV6ZSh7aW5qZWN0aW9uOmhiLGdldExpc3RlbmVyOmliLGV4dHJhY3RFdmVudHM6amIsZW5xdWV1ZUV2ZW50czprYixwcm9jZXNzRXZlbnRRdWV1ZTpsYn0pLG5iPU1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLFE9XCJfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSRcIituYixvYj1cIl9fcmVhY3RFdmVudEhhbmRsZXJzJFwiK25iO1xuZnVuY3Rpb24gcGIoYSl7aWYoYVtRXSlyZXR1cm4gYVtRXTtmb3IodmFyIGI9W107IWFbUV07KWlmKGIucHVzaChhKSxhLnBhcmVudE5vZGUpYT1hLnBhcmVudE5vZGU7ZWxzZSByZXR1cm4gbnVsbDt2YXIgYz12b2lkIDAsZD1hW1FdO2lmKDU9PT1kLnRhZ3x8Nj09PWQudGFnKXJldHVybiBkO2Zvcig7YSYmKGQ9YVtRXSk7YT1iLnBvcCgpKWM9ZDtyZXR1cm4gY31mdW5jdGlvbiBxYihhKXtpZig1PT09YS50YWd8fDY9PT1hLnRhZylyZXR1cm4gYS5zdGF0ZU5vZGU7RShcIjMzXCIpfWZ1bmN0aW9uIHJiKGEpe3JldHVybiBhW29iXXx8bnVsbH1cbnZhciBzYj1PYmplY3QuZnJlZXplKHtwcmVjYWNoZUZpYmVyTm9kZTpmdW5jdGlvbihhLGIpe2JbUV09YX0sZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6cGIsZ2V0SW5zdGFuY2VGcm9tTm9kZTpmdW5jdGlvbihhKXthPWFbUV07cmV0dXJuIWF8fDUhPT1hLnRhZyYmNiE9PWEudGFnP251bGw6YX0sZ2V0Tm9kZUZyb21JbnN0YW5jZTpxYixnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlOnJiLHVwZGF0ZUZpYmVyUHJvcHM6ZnVuY3Rpb24oYSxiKXthW29iXT1ifX0pO2Z1bmN0aW9uIHRiKGEpe2RvIGE9YVtcInJldHVyblwiXTt3aGlsZShhJiY1IT09YS50YWcpO3JldHVybiBhP2E6bnVsbH1mdW5jdGlvbiB1YihhLGIsYyl7Zm9yKHZhciBkPVtdO2E7KWQucHVzaChhKSxhPXRiKGEpO2ZvcihhPWQubGVuZ3RoOzA8YS0tOyliKGRbYV0sXCJjYXB0dXJlZFwiLGMpO2ZvcihhPTA7YTxkLmxlbmd0aDthKyspYihkW2FdLFwiYnViYmxlZFwiLGMpfVxuZnVuY3Rpb24gdmIoYSxiLGMpe2lmKGI9aWIoYSxjLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW2JdKSljLl9kaXNwYXRjaExpc3RlbmVycz0kYShjLl9kaXNwYXRjaExpc3RlbmVycyxiKSxjLl9kaXNwYXRjaEluc3RhbmNlcz0kYShjLl9kaXNwYXRjaEluc3RhbmNlcyxhKX1mdW5jdGlvbiB3YihhKXthJiZhLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzJiZ1YihhLl90YXJnZXRJbnN0LHZiLGEpfWZ1bmN0aW9uIHhiKGEpe2lmKGEmJmEuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpe3ZhciBiPWEuX3RhcmdldEluc3Q7Yj1iP3RiKGIpOm51bGw7dWIoYix2YixhKX19XG5mdW5jdGlvbiB5YihhLGIsYyl7YSYmYyYmYy5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lJiYoYj1pYihhLGMuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkpJiYoYy5fZGlzcGF0Y2hMaXN0ZW5lcnM9JGEoYy5fZGlzcGF0Y2hMaXN0ZW5lcnMsYiksYy5fZGlzcGF0Y2hJbnN0YW5jZXM9JGEoYy5fZGlzcGF0Y2hJbnN0YW5jZXMsYSkpfWZ1bmN0aW9uIHpiKGEpe2EmJmEuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSYmeWIoYS5fdGFyZ2V0SW5zdCxudWxsLGEpfWZ1bmN0aW9uIEFiKGEpe2FiKGEsd2IpfVxuZnVuY3Rpb24gQmIoYSxiLGMsZCl7aWYoYyYmZClhOnt2YXIgZT1jO2Zvcih2YXIgZj1kLGc9MCxoPWU7aDtoPXRiKGgpKWcrKztoPTA7Zm9yKHZhciBrPWY7aztrPXRiKGspKWgrKztmb3IoOzA8Zy1oOyllPXRiKGUpLGctLTtmb3IoOzA8aC1nOylmPXRiKGYpLGgtLTtmb3IoO2ctLTspe2lmKGU9PT1mfHxlPT09Zi5hbHRlcm5hdGUpYnJlYWsgYTtlPXRiKGUpO2Y9dGIoZil9ZT1udWxsfWVsc2UgZT1udWxsO2Y9ZTtmb3IoZT1bXTtjJiZjIT09Zjspe2c9Yy5hbHRlcm5hdGU7aWYobnVsbCE9PWcmJmc9PT1mKWJyZWFrO2UucHVzaChjKTtjPXRiKGMpfWZvcihjPVtdO2QmJmQhPT1mOyl7Zz1kLmFsdGVybmF0ZTtpZihudWxsIT09ZyYmZz09PWYpYnJlYWs7Yy5wdXNoKGQpO2Q9dGIoZCl9Zm9yKGQ9MDtkPGUubGVuZ3RoO2QrKyl5YihlW2RdLFwiYnViYmxlZFwiLGEpO2ZvcihhPWMubGVuZ3RoOzA8YS0tOyl5YihjW2FdLFwiY2FwdHVyZWRcIixiKX1cbnZhciBDYj1PYmplY3QuZnJlZXplKHthY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOkFiLGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OmZ1bmN0aW9uKGEpe2FiKGEseGIpfSxhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6QmIsYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6ZnVuY3Rpb24oYSl7YWIoYSx6Yil9fSksRGI9bnVsbDtmdW5jdGlvbiBFYigpeyFEYiYmbC5jYW5Vc2VET00mJihEYj1cInRleHRDb250ZW50XCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ/XCJ0ZXh0Q29udGVudFwiOlwiaW5uZXJUZXh0XCIpO3JldHVybiBEYn12YXIgUz17X3Jvb3Q6bnVsbCxfc3RhcnRUZXh0Om51bGwsX2ZhbGxiYWNrVGV4dDpudWxsfTtcbmZ1bmN0aW9uIEZiKCl7aWYoUy5fZmFsbGJhY2tUZXh0KXJldHVybiBTLl9mYWxsYmFja1RleHQ7dmFyIGEsYj1TLl9zdGFydFRleHQsYz1iLmxlbmd0aCxkLGU9R2IoKSxmPWUubGVuZ3RoO2ZvcihhPTA7YTxjJiZiW2FdPT09ZVthXTthKyspO3ZhciBnPWMtYTtmb3IoZD0xO2Q8PWcmJmJbYy1kXT09PWVbZi1kXTtkKyspO1MuX2ZhbGxiYWNrVGV4dD1lLnNsaWNlKGEsMTxkPzEtZDp2b2lkIDApO3JldHVybiBTLl9mYWxsYmFja1RleHR9ZnVuY3Rpb24gR2IoKXtyZXR1cm5cInZhbHVlXCJpbiBTLl9yb290P1MuX3Jvb3QudmFsdWU6Uy5fcm9vdFtFYigpXX1cbnZhciBIYj1cImRpc3BhdGNoQ29uZmlnIF90YXJnZXRJbnN0IG5hdGl2ZUV2ZW50IGlzRGVmYXVsdFByZXZlbnRlZCBpc1Byb3BhZ2F0aW9uU3RvcHBlZCBfZGlzcGF0Y2hMaXN0ZW5lcnMgX2Rpc3BhdGNoSW5zdGFuY2VzXCIuc3BsaXQoXCIgXCIpLEliPXt0eXBlOm51bGwsdGFyZ2V0Om51bGwsY3VycmVudFRhcmdldDpDLnRoYXRSZXR1cm5zTnVsbCxldmVudFBoYXNlOm51bGwsYnViYmxlczpudWxsLGNhbmNlbGFibGU6bnVsbCx0aW1lU3RhbXA6ZnVuY3Rpb24oYSl7cmV0dXJuIGEudGltZVN0YW1wfHxEYXRlLm5vdygpfSxkZWZhdWx0UHJldmVudGVkOm51bGwsaXNUcnVzdGVkOm51bGx9O1xuZnVuY3Rpb24gVChhLGIsYyxkKXt0aGlzLmRpc3BhdGNoQ29uZmlnPWE7dGhpcy5fdGFyZ2V0SW5zdD1iO3RoaXMubmF0aXZlRXZlbnQ9YzthPXRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO2Zvcih2YXIgZSBpbiBhKWEuaGFzT3duUHJvcGVydHkoZSkmJigoYj1hW2VdKT90aGlzW2VdPWIoYyk6XCJ0YXJnZXRcIj09PWU/dGhpcy50YXJnZXQ9ZDp0aGlzW2VdPWNbZV0pO3RoaXMuaXNEZWZhdWx0UHJldmVudGVkPShudWxsIT1jLmRlZmF1bHRQcmV2ZW50ZWQ/Yy5kZWZhdWx0UHJldmVudGVkOiExPT09Yy5yZXR1cm5WYWx1ZSk/Qy50aGF0UmV0dXJuc1RydWU6Qy50aGF0UmV0dXJuc0ZhbHNlO3RoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9Qy50aGF0UmV0dXJuc0ZhbHNlO3JldHVybiB0aGlzfVxuQihULnByb3RvdHlwZSx7cHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ9ITA7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5wcmV2ZW50RGVmYXVsdD9hLnByZXZlbnREZWZhdWx0KCk6XCJ1bmtub3duXCIhPT10eXBlb2YgYS5yZXR1cm5WYWx1ZSYmKGEucmV0dXJuVmFsdWU9ITEpLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPUMudGhhdFJldHVybnNUcnVlKX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5zdG9wUHJvcGFnYXRpb24/YS5zdG9wUHJvcGFnYXRpb24oKTpcInVua25vd25cIiE9PXR5cGVvZiBhLmNhbmNlbEJ1YmJsZSYmKGEuY2FuY2VsQnViYmxlPSEwKSx0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPUMudGhhdFJldHVybnNUcnVlKX0scGVyc2lzdDpmdW5jdGlvbigpe3RoaXMuaXNQZXJzaXN0ZW50PUMudGhhdFJldHVybnNUcnVlfSxpc1BlcnNpc3RlbnQ6Qy50aGF0UmV0dXJuc0ZhbHNlLFxuZGVzdHJ1Y3RvcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlLGI7Zm9yKGIgaW4gYSl0aGlzW2JdPW51bGw7Zm9yKGE9MDthPEhiLmxlbmd0aDthKyspdGhpc1tIYlthXV09bnVsbH19KTtULkludGVyZmFjZT1JYjtULmF1Z21lbnRDbGFzcz1mdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt9Yy5wcm90b3R5cGU9dGhpcy5wcm90b3R5cGU7dmFyIGQ9bmV3IGM7QihkLGEucHJvdG90eXBlKTthLnByb3RvdHlwZT1kO2EucHJvdG90eXBlLmNvbnN0cnVjdG9yPWE7YS5JbnRlcmZhY2U9Qih7fSx0aGlzLkludGVyZmFjZSxiKTthLmF1Z21lbnRDbGFzcz10aGlzLmF1Z21lbnRDbGFzcztKYihhKX07SmIoVCk7ZnVuY3Rpb24gS2IoYSxiLGMsZCl7aWYodGhpcy5ldmVudFBvb2wubGVuZ3RoKXt2YXIgZT10aGlzLmV2ZW50UG9vbC5wb3AoKTt0aGlzLmNhbGwoZSxhLGIsYyxkKTtyZXR1cm4gZX1yZXR1cm4gbmV3IHRoaXMoYSxiLGMsZCl9XG5mdW5jdGlvbiBMYihhKXthIGluc3RhbmNlb2YgdGhpcz92b2lkIDA6RShcIjIyM1wiKTthLmRlc3RydWN0b3IoKTsxMD50aGlzLmV2ZW50UG9vbC5sZW5ndGgmJnRoaXMuZXZlbnRQb29sLnB1c2goYSl9ZnVuY3Rpb24gSmIoYSl7YS5ldmVudFBvb2w9W107YS5nZXRQb29sZWQ9S2I7YS5yZWxlYXNlPUxifWZ1bmN0aW9uIE1iKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhNYix7ZGF0YTpudWxsfSk7ZnVuY3Rpb24gTmIoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKE5iLHtkYXRhOm51bGx9KTt2YXIgUGI9WzksMTMsMjcsMzJdLFZiPWwuY2FuVXNlRE9NJiZcIkNvbXBvc2l0aW9uRXZlbnRcImluIHdpbmRvdyxXYj1udWxsO2wuY2FuVXNlRE9NJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJihXYj1kb2N1bWVudC5kb2N1bWVudE1vZGUpO3ZhciBYYjtcbmlmKFhiPWwuY2FuVXNlRE9NJiZcIlRleHRFdmVudFwiaW4gd2luZG93JiYhV2Ipe3ZhciBZYj13aW5kb3cub3BlcmE7WGI9IShcIm9iamVjdFwiPT09dHlwZW9mIFliJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgWWIudmVyc2lvbiYmMTI+PXBhcnNlSW50KFliLnZlcnNpb24oKSwxMCkpfVxudmFyIFpiPVhiLCRiPWwuY2FuVXNlRE9NJiYoIVZifHxXYiYmODxXYiYmMTE+PVdiKSxhYz1TdHJpbmcuZnJvbUNoYXJDb2RlKDMyKSxiYz17YmVmb3JlSW5wdXQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25CZWZvcmVJbnB1dFwiLGNhcHR1cmVkOlwib25CZWZvcmVJbnB1dENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOltcInRvcENvbXBvc2l0aW9uRW5kXCIsXCJ0b3BLZXlQcmVzc1wiLFwidG9wVGV4dElucHV0XCIsXCJ0b3BQYXN0ZVwiXX0sY29tcG9zaXRpb25FbmQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25Db21wb3NpdGlvbkVuZFwiLGNhcHR1cmVkOlwib25Db21wb3NpdGlvbkVuZENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDb21wb3NpdGlvbkVuZCB0b3BLZXlEb3duIHRvcEtleVByZXNzIHRvcEtleVVwIHRvcE1vdXNlRG93blwiLnNwbGl0KFwiIFwiKX0sY29tcG9zaXRpb25TdGFydDp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNvbXBvc2l0aW9uU3RhcnRcIixcbmNhcHR1cmVkOlwib25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENvbXBvc2l0aW9uU3RhcnQgdG9wS2V5RG93biB0b3BLZXlQcmVzcyB0b3BLZXlVcCB0b3BNb3VzZURvd25cIi5zcGxpdChcIiBcIil9LGNvbXBvc2l0aW9uVXBkYXRlOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ29tcG9zaXRpb25VcGRhdGVcIixjYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ29tcG9zaXRpb25VcGRhdGUgdG9wS2V5RG93biB0b3BLZXlQcmVzcyB0b3BLZXlVcCB0b3BNb3VzZURvd25cIi5zcGxpdChcIiBcIil9fSxjYz0hMTtcbmZ1bmN0aW9uIGRjKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BLZXlVcFwiOnJldHVybi0xIT09UGIuaW5kZXhPZihiLmtleUNvZGUpO2Nhc2UgXCJ0b3BLZXlEb3duXCI6cmV0dXJuIDIyOSE9PWIua2V5Q29kZTtjYXNlIFwidG9wS2V5UHJlc3NcIjpjYXNlIFwidG9wTW91c2VEb3duXCI6Y2FzZSBcInRvcEJsdXJcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBlYyhhKXthPWEuZGV0YWlsO3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmXCJkYXRhXCJpbiBhP2EuZGF0YTpudWxsfXZhciBmYz0hMTtmdW5jdGlvbiBnYyhhLGIpe3N3aXRjaChhKXtjYXNlIFwidG9wQ29tcG9zaXRpb25FbmRcIjpyZXR1cm4gZWMoYik7Y2FzZSBcInRvcEtleVByZXNzXCI6aWYoMzIhPT1iLndoaWNoKXJldHVybiBudWxsO2NjPSEwO3JldHVybiBhYztjYXNlIFwidG9wVGV4dElucHV0XCI6cmV0dXJuIGE9Yi5kYXRhLGE9PT1hYyYmY2M/bnVsbDphO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxuZnVuY3Rpb24gaGMoYSxiKXtpZihmYylyZXR1cm5cInRvcENvbXBvc2l0aW9uRW5kXCI9PT1hfHwhVmImJmRjKGEsYik/KGE9RmIoKSxTLl9yb290PW51bGwsUy5fc3RhcnRUZXh0PW51bGwsUy5fZmFsbGJhY2tUZXh0PW51bGwsZmM9ITEsYSk6bnVsbDtzd2l0Y2goYSl7Y2FzZSBcInRvcFBhc3RlXCI6cmV0dXJuIG51bGw7Y2FzZSBcInRvcEtleVByZXNzXCI6aWYoIShiLmN0cmxLZXl8fGIuYWx0S2V5fHxiLm1ldGFLZXkpfHxiLmN0cmxLZXkmJmIuYWx0S2V5KXtpZihiLmNoYXImJjE8Yi5jaGFyLmxlbmd0aClyZXR1cm4gYi5jaGFyO2lmKGIud2hpY2gpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYi53aGljaCl9cmV0dXJuIG51bGw7Y2FzZSBcInRvcENvbXBvc2l0aW9uRW5kXCI6cmV0dXJuICRiP251bGw6Yi5kYXRhO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxudmFyIGljPXtldmVudFR5cGVzOmJjLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU7aWYoVmIpYjp7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BDb21wb3NpdGlvblN0YXJ0XCI6dmFyIGY9YmMuY29tcG9zaXRpb25TdGFydDticmVhayBiO2Nhc2UgXCJ0b3BDb21wb3NpdGlvbkVuZFwiOmY9YmMuY29tcG9zaXRpb25FbmQ7YnJlYWsgYjtjYXNlIFwidG9wQ29tcG9zaXRpb25VcGRhdGVcIjpmPWJjLmNvbXBvc2l0aW9uVXBkYXRlO2JyZWFrIGJ9Zj12b2lkIDB9ZWxzZSBmYz9kYyhhLGMpJiYoZj1iYy5jb21wb3NpdGlvbkVuZCk6XCJ0b3BLZXlEb3duXCI9PT1hJiYyMjk9PT1jLmtleUNvZGUmJihmPWJjLmNvbXBvc2l0aW9uU3RhcnQpO2Y/KCRiJiYoZmN8fGYhPT1iYy5jb21wb3NpdGlvblN0YXJ0P2Y9PT1iYy5jb21wb3NpdGlvbkVuZCYmZmMmJihlPUZiKCkpOihTLl9yb290PWQsUy5fc3RhcnRUZXh0PUdiKCksZmM9ITApKSxmPU1iLmdldFBvb2xlZChmLGIsYyxkKSxlP2YuZGF0YT1cbmU6KGU9ZWMoYyksbnVsbCE9PWUmJihmLmRhdGE9ZSkpLEFiKGYpLGU9Zik6ZT1udWxsOyhhPVpiP2djKGEsYyk6aGMoYSxjKSk/KGI9TmIuZ2V0UG9vbGVkKGJjLmJlZm9yZUlucHV0LGIsYyxkKSxiLmRhdGE9YSxBYihiKSk6Yj1udWxsO3JldHVybltlLGJdfX0samM9bnVsbCxrYz1udWxsLGxjPW51bGw7ZnVuY3Rpb24gbWMoYSl7aWYoYT1YYShhKSl7amMmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBqYy5yZXN0b3JlQ29udHJvbGxlZFN0YXRlP3ZvaWQgMDpFKFwiMTk0XCIpO3ZhciBiPVdhKGEuc3RhdGVOb2RlKTtqYy5yZXN0b3JlQ29udHJvbGxlZFN0YXRlKGEuc3RhdGVOb2RlLGEudHlwZSxiKX19dmFyIG5jPXtpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50OmZ1bmN0aW9uKGEpe2pjPWF9fTtmdW5jdGlvbiBvYyhhKXtrYz9sYz9sYy5wdXNoKGEpOmxjPVthXTprYz1hfVxuZnVuY3Rpb24gcGMoKXtpZihrYyl7dmFyIGE9a2MsYj1sYztsYz1rYz1udWxsO21jKGEpO2lmKGIpZm9yKGE9MDthPGIubGVuZ3RoO2ErKyltYyhiW2FdKX19dmFyIHFjPU9iamVjdC5mcmVlemUoe2luamVjdGlvbjpuYyxlbnF1ZXVlU3RhdGVSZXN0b3JlOm9jLHJlc3RvcmVTdGF0ZUlmTmVlZGVkOnBjfSk7ZnVuY3Rpb24gcmMoYSxiKXtyZXR1cm4gYShiKX12YXIgc2M9ITE7ZnVuY3Rpb24gdGMoYSxiKXtpZihzYylyZXR1cm4gcmMoYSxiKTtzYz0hMDt0cnl7cmV0dXJuIHJjKGEsYil9ZmluYWxseXtzYz0hMSxwYygpfX12YXIgdWM9e2NvbG9yOiEwLGRhdGU6ITAsZGF0ZXRpbWU6ITAsXCJkYXRldGltZS1sb2NhbFwiOiEwLGVtYWlsOiEwLG1vbnRoOiEwLG51bWJlcjohMCxwYXNzd29yZDohMCxyYW5nZTohMCxzZWFyY2g6ITAsdGVsOiEwLHRleHQ6ITAsdGltZTohMCx1cmw6ITAsd2VlazohMH07XG5mdW5jdGlvbiB2YyhhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09Yj8hIXVjW2EudHlwZV06XCJ0ZXh0YXJlYVwiPT09Yj8hMDohMX1mdW5jdGlvbiB3YyhhKXthPWEudGFyZ2V0fHxhLnNyY0VsZW1lbnR8fHdpbmRvdzthLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50JiYoYT1hLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KTtyZXR1cm4gMz09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlOmF9dmFyIHhjO2wuY2FuVXNlRE9NJiYoeGM9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24mJmRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUmJiEwIT09ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcIlwiLFwiXCIpKTtcbmZ1bmN0aW9uIHljKGEsYil7aWYoIWwuY2FuVXNlRE9NfHxiJiYhKFwiYWRkRXZlbnRMaXN0ZW5lclwiaW4gZG9jdW1lbnQpKXJldHVybiExO2I9XCJvblwiK2E7dmFyIGM9YiBpbiBkb2N1bWVudDtjfHwoYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGMuc2V0QXR0cmlidXRlKGIsXCJyZXR1cm47XCIpLGM9XCJmdW5jdGlvblwiPT09dHlwZW9mIGNbYl0pOyFjJiZ4YyYmXCJ3aGVlbFwiPT09YSYmKGM9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcIkV2ZW50cy53aGVlbFwiLFwiMy4wXCIpKTtyZXR1cm4gY31mdW5jdGlvbiB6YyhhKXt2YXIgYj1hLnR5cGU7cmV0dXJuKGE9YS5ub2RlTmFtZSkmJlwiaW5wdXRcIj09PWEudG9Mb3dlckNhc2UoKSYmKFwiY2hlY2tib3hcIj09PWJ8fFwicmFkaW9cIj09PWIpfVxuZnVuY3Rpb24gQWMoYSl7dmFyIGI9emMoYSk/XCJjaGVja2VkXCI6XCJ2YWx1ZVwiLGM9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLmNvbnN0cnVjdG9yLnByb3RvdHlwZSxiKSxkPVwiXCIrYVtiXTtpZighYS5oYXNPd25Qcm9wZXJ0eShiKSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuZ2V0JiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5zZXQpcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGIse2VudW1lcmFibGU6Yy5lbnVtZXJhYmxlLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5nZXQuY2FsbCh0aGlzKX0sc2V0OmZ1bmN0aW9uKGEpe2Q9XCJcIithO2Muc2V0LmNhbGwodGhpcyxhKX19KSx7Z2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gZH0sc2V0VmFsdWU6ZnVuY3Rpb24oYSl7ZD1cIlwiK2F9LHN0b3BUcmFja2luZzpmdW5jdGlvbigpe2EuX3ZhbHVlVHJhY2tlcj1udWxsO2RlbGV0ZSBhW2JdfX19XG5mdW5jdGlvbiBCYyhhKXthLl92YWx1ZVRyYWNrZXJ8fChhLl92YWx1ZVRyYWNrZXI9QWMoYSkpfWZ1bmN0aW9uIENjKGEpe2lmKCFhKXJldHVybiExO3ZhciBiPWEuX3ZhbHVlVHJhY2tlcjtpZighYilyZXR1cm4hMDt2YXIgYz1iLmdldFZhbHVlKCk7dmFyIGQ9XCJcIjthJiYoZD16YyhhKT9hLmNoZWNrZWQ/XCJ0cnVlXCI6XCJmYWxzZVwiOmEudmFsdWUpO2E9ZDtyZXR1cm4gYSE9PWM/KGIuc2V0VmFsdWUoYSksITApOiExfXZhciBEYz17Y2hhbmdlOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ2hhbmdlXCIsY2FwdHVyZWQ6XCJvbkNoYW5nZUNhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDaGFuZ2UgdG9wQ2xpY2sgdG9wRm9jdXMgdG9wSW5wdXQgdG9wS2V5RG93biB0b3BLZXlVcCB0b3BTZWxlY3Rpb25DaGFuZ2VcIi5zcGxpdChcIiBcIil9fTtcbmZ1bmN0aW9uIEVjKGEsYixjKXthPVQuZ2V0UG9vbGVkKERjLmNoYW5nZSxhLGIsYyk7YS50eXBlPVwiY2hhbmdlXCI7b2MoYyk7QWIoYSk7cmV0dXJuIGF9dmFyIEZjPW51bGwsR2M9bnVsbDtmdW5jdGlvbiBIYyhhKXtrYihhKTtsYighMSl9ZnVuY3Rpb24gSWMoYSl7dmFyIGI9cWIoYSk7aWYoQ2MoYikpcmV0dXJuIGF9ZnVuY3Rpb24gSmMoYSxiKXtpZihcInRvcENoYW5nZVwiPT09YSlyZXR1cm4gYn12YXIgS2M9ITE7bC5jYW5Vc2VET00mJihLYz15YyhcImlucHV0XCIpJiYoIWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OTxkb2N1bWVudC5kb2N1bWVudE1vZGUpKTtmdW5jdGlvbiBMYygpe0ZjJiYoRmMuZGV0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsTWMpLEdjPUZjPW51bGwpfWZ1bmN0aW9uIE1jKGEpe1widmFsdWVcIj09PWEucHJvcGVydHlOYW1lJiZJYyhHYykmJihhPUVjKEdjLGEsd2MoYSkpLHRjKEhjLGEpKX1cbmZ1bmN0aW9uIE5jKGEsYixjKXtcInRvcEZvY3VzXCI9PT1hPyhMYygpLEZjPWIsR2M9YyxGYy5hdHRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIixNYykpOlwidG9wQmx1clwiPT09YSYmTGMoKX1mdW5jdGlvbiBPYyhhKXtpZihcInRvcFNlbGVjdGlvbkNoYW5nZVwiPT09YXx8XCJ0b3BLZXlVcFwiPT09YXx8XCJ0b3BLZXlEb3duXCI9PT1hKXJldHVybiBJYyhHYyl9ZnVuY3Rpb24gUGMoYSxiKXtpZihcInRvcENsaWNrXCI9PT1hKXJldHVybiBJYyhiKX1mdW5jdGlvbiAkYyhhLGIpe2lmKFwidG9wSW5wdXRcIj09PWF8fFwidG9wQ2hhbmdlXCI9PT1hKXJldHVybiBJYyhiKX1cbnZhciBhZD17ZXZlbnRUeXBlczpEYyxfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOktjLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9Yj9xYihiKTp3aW5kb3csZj1lLm5vZGVOYW1lJiZlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYoXCJzZWxlY3RcIj09PWZ8fFwiaW5wdXRcIj09PWYmJlwiZmlsZVwiPT09ZS50eXBlKXZhciBnPUpjO2Vsc2UgaWYodmMoZSkpaWYoS2MpZz0kYztlbHNle2c9T2M7dmFyIGg9TmN9ZWxzZSBmPWUubm9kZU5hbWUsIWZ8fFwiaW5wdXRcIiE9PWYudG9Mb3dlckNhc2UoKXx8XCJjaGVja2JveFwiIT09ZS50eXBlJiZcInJhZGlvXCIhPT1lLnR5cGV8fChnPVBjKTtpZihnJiYoZz1nKGEsYikpKXJldHVybiBFYyhnLGMsZCk7aCYmaChhLGUsYik7XCJ0b3BCbHVyXCI9PT1hJiZudWxsIT1iJiYoYT1iLl93cmFwcGVyU3RhdGV8fGUuX3dyYXBwZXJTdGF0ZSkmJmEuY29udHJvbGxlZCYmXCJudW1iZXJcIj09PWUudHlwZSYmKGE9XCJcIitlLnZhbHVlLGUuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikhPT1cbmEmJmUuc2V0QXR0cmlidXRlKFwidmFsdWVcIixhKSl9fTtmdW5jdGlvbiBiZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoYmQse3ZpZXc6bnVsbCxkZXRhaWw6bnVsbH0pO3ZhciBjZD17QWx0OlwiYWx0S2V5XCIsQ29udHJvbDpcImN0cmxLZXlcIixNZXRhOlwibWV0YUtleVwiLFNoaWZ0Olwic2hpZnRLZXlcIn07ZnVuY3Rpb24gZGQoYSl7dmFyIGI9dGhpcy5uYXRpdmVFdmVudDtyZXR1cm4gYi5nZXRNb2RpZmllclN0YXRlP2IuZ2V0TW9kaWZpZXJTdGF0ZShhKTooYT1jZFthXSk/ISFiW2FdOiExfWZ1bmN0aW9uIGVkKCl7cmV0dXJuIGRkfWZ1bmN0aW9uIGZkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1cbmJkLmF1Z21lbnRDbGFzcyhmZCx7c2NyZWVuWDpudWxsLHNjcmVlblk6bnVsbCxjbGllbnRYOm51bGwsY2xpZW50WTpudWxsLHBhZ2VYOm51bGwscGFnZVk6bnVsbCxjdHJsS2V5Om51bGwsc2hpZnRLZXk6bnVsbCxhbHRLZXk6bnVsbCxtZXRhS2V5Om51bGwsZ2V0TW9kaWZpZXJTdGF0ZTplZCxidXR0b246bnVsbCxidXR0b25zOm51bGwscmVsYXRlZFRhcmdldDpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZWxhdGVkVGFyZ2V0fHwoYS5mcm9tRWxlbWVudD09PWEuc3JjRWxlbWVudD9hLnRvRWxlbWVudDphLmZyb21FbGVtZW50KX19KTtcbnZhciBnZD17bW91c2VFbnRlcjp7cmVnaXN0cmF0aW9uTmFtZTpcIm9uTW91c2VFbnRlclwiLGRlcGVuZGVuY2llczpbXCJ0b3BNb3VzZU91dFwiLFwidG9wTW91c2VPdmVyXCJdfSxtb3VzZUxlYXZlOntyZWdpc3RyYXRpb25OYW1lOlwib25Nb3VzZUxlYXZlXCIsZGVwZW5kZW5jaWVzOltcInRvcE1vdXNlT3V0XCIsXCJ0b3BNb3VzZU92ZXJcIl19fSxoZD17ZXZlbnRUeXBlczpnZCxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe2lmKFwidG9wTW91c2VPdmVyXCI9PT1hJiYoYy5yZWxhdGVkVGFyZ2V0fHxjLmZyb21FbGVtZW50KXx8XCJ0b3BNb3VzZU91dFwiIT09YSYmXCJ0b3BNb3VzZU92ZXJcIiE9PWEpcmV0dXJuIG51bGw7dmFyIGU9ZC53aW5kb3c9PT1kP2Q6KGU9ZC5vd25lckRvY3VtZW50KT9lLmRlZmF1bHRWaWV3fHxlLnBhcmVudFdpbmRvdzp3aW5kb3c7XCJ0b3BNb3VzZU91dFwiPT09YT8oYT1iLGI9KGI9Yy5yZWxhdGVkVGFyZ2V0fHxjLnRvRWxlbWVudCk/cGIoYik6bnVsbCk6YT1udWxsO2lmKGE9PT1cbmIpcmV0dXJuIG51bGw7dmFyIGY9bnVsbD09YT9lOnFiKGEpO2U9bnVsbD09Yj9lOnFiKGIpO3ZhciBnPWZkLmdldFBvb2xlZChnZC5tb3VzZUxlYXZlLGEsYyxkKTtnLnR5cGU9XCJtb3VzZWxlYXZlXCI7Zy50YXJnZXQ9ZjtnLnJlbGF0ZWRUYXJnZXQ9ZTtjPWZkLmdldFBvb2xlZChnZC5tb3VzZUVudGVyLGIsYyxkKTtjLnR5cGU9XCJtb3VzZWVudGVyXCI7Yy50YXJnZXQ9ZTtjLnJlbGF0ZWRUYXJnZXQ9ZjtCYihnLGMsYSxiKTtyZXR1cm5bZyxjXX19LGlkPWFhLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyO2Z1bmN0aW9uIGpkKGEpe2E9YS50eXBlO3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYT9hOlwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2EuZGlzcGxheU5hbWV8fGEubmFtZTpudWxsfVxuZnVuY3Rpb24ga2QoYSl7dmFyIGI9YTtpZihhLmFsdGVybmF0ZSlmb3IoO2JbXCJyZXR1cm5cIl07KWI9YltcInJldHVyblwiXTtlbHNle2lmKDAhPT0oYi5lZmZlY3RUYWcmMikpcmV0dXJuIDE7Zm9yKDtiW1wicmV0dXJuXCJdOylpZihiPWJbXCJyZXR1cm5cIl0sMCE9PShiLmVmZmVjdFRhZyYyKSlyZXR1cm4gMX1yZXR1cm4gMz09PWIudGFnPzI6M31mdW5jdGlvbiBsZChhKXtyZXR1cm4oYT1hLl9yZWFjdEludGVybmFsRmliZXIpPzI9PT1rZChhKTohMX1mdW5jdGlvbiBtZChhKXsyIT09a2QoYSk/RShcIjE4OFwiKTp2b2lkIDB9XG5mdW5jdGlvbiBuZChhKXt2YXIgYj1hLmFsdGVybmF0ZTtpZighYilyZXR1cm4gYj1rZChhKSwzPT09Yj9FKFwiMTg4XCIpOnZvaWQgMCwxPT09Yj9udWxsOmE7Zm9yKHZhciBjPWEsZD1iOzspe3ZhciBlPWNbXCJyZXR1cm5cIl0sZj1lP2UuYWx0ZXJuYXRlOm51bGw7aWYoIWV8fCFmKWJyZWFrO2lmKGUuY2hpbGQ9PT1mLmNoaWxkKXtmb3IodmFyIGc9ZS5jaGlsZDtnOyl7aWYoZz09PWMpcmV0dXJuIG1kKGUpLGE7aWYoZz09PWQpcmV0dXJuIG1kKGUpLGI7Zz1nLnNpYmxpbmd9RShcIjE4OFwiKX1pZihjW1wicmV0dXJuXCJdIT09ZFtcInJldHVyblwiXSljPWUsZD1mO2Vsc2V7Zz0hMTtmb3IodmFyIGg9ZS5jaGlsZDtoOyl7aWYoaD09PWMpe2c9ITA7Yz1lO2Q9ZjticmVha31pZihoPT09ZCl7Zz0hMDtkPWU7Yz1mO2JyZWFrfWg9aC5zaWJsaW5nfWlmKCFnKXtmb3IoaD1mLmNoaWxkO2g7KXtpZihoPT09Yyl7Zz0hMDtjPWY7ZD1lO2JyZWFrfWlmKGg9PT1kKXtnPSEwO2Q9ZjtjPWU7YnJlYWt9aD1oLnNpYmxpbmd9Zz9cbnZvaWQgMDpFKFwiMTg5XCIpfX1jLmFsdGVybmF0ZSE9PWQ/RShcIjE5MFwiKTp2b2lkIDB9MyE9PWMudGFnP0UoXCIxODhcIik6dm9pZCAwO3JldHVybiBjLnN0YXRlTm9kZS5jdXJyZW50PT09Yz9hOmJ9ZnVuY3Rpb24gb2QoYSl7YT1uZChhKTtpZighYSlyZXR1cm4gbnVsbDtmb3IodmFyIGI9YTs7KXtpZig1PT09Yi50YWd8fDY9PT1iLnRhZylyZXR1cm4gYjtpZihiLmNoaWxkKWIuY2hpbGRbXCJyZXR1cm5cIl09YixiPWIuY2hpbGQ7ZWxzZXtpZihiPT09YSlicmVhaztmb3IoOyFiLnNpYmxpbmc7KXtpZighYltcInJldHVyblwiXXx8YltcInJldHVyblwiXT09PWEpcmV0dXJuIG51bGw7Yj1iW1wicmV0dXJuXCJdfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfX1yZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIHBkKGEpe2E9bmQoYSk7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKHZhciBiPWE7Oyl7aWYoNT09PWIudGFnfHw2PT09Yi50YWcpcmV0dXJuIGI7aWYoYi5jaGlsZCYmNCE9PWIudGFnKWIuY2hpbGRbXCJyZXR1cm5cIl09YixiPWIuY2hpbGQ7ZWxzZXtpZihiPT09YSlicmVhaztmb3IoOyFiLnNpYmxpbmc7KXtpZighYltcInJldHVyblwiXXx8YltcInJldHVyblwiXT09PWEpcmV0dXJuIG51bGw7Yj1iW1wicmV0dXJuXCJdfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfX1yZXR1cm4gbnVsbH12YXIgcWQ9W107XG5mdW5jdGlvbiByZChhKXt2YXIgYj1hLnRhcmdldEluc3Q7ZG97aWYoIWIpe2EuYW5jZXN0b3JzLnB1c2goYik7YnJlYWt9dmFyIGM7Zm9yKGM9YjtjW1wicmV0dXJuXCJdOyljPWNbXCJyZXR1cm5cIl07Yz0zIT09Yy50YWc/bnVsbDpjLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2lmKCFjKWJyZWFrO2EuYW5jZXN0b3JzLnB1c2goYik7Yj1wYihjKX13aGlsZShiKTtmb3IoYz0wO2M8YS5hbmNlc3RvcnMubGVuZ3RoO2MrKyliPWEuYW5jZXN0b3JzW2NdLHNkKGEudG9wTGV2ZWxUeXBlLGIsYS5uYXRpdmVFdmVudCx3YyhhLm5hdGl2ZUV2ZW50KSl9dmFyIHRkPSEwLHNkPXZvaWQgMDtmdW5jdGlvbiB1ZChhKXt0ZD0hIWF9ZnVuY3Rpb24gVShhLGIsYyl7cmV0dXJuIGM/YmEubGlzdGVuKGMsYix2ZC5iaW5kKG51bGwsYSkpOm51bGx9ZnVuY3Rpb24gd2QoYSxiLGMpe3JldHVybiBjP2JhLmNhcHR1cmUoYyxiLHZkLmJpbmQobnVsbCxhKSk6bnVsbH1cbmZ1bmN0aW9uIHZkKGEsYil7aWYodGQpe3ZhciBjPXdjKGIpO2M9cGIoYyk7bnVsbD09PWN8fFwibnVtYmVyXCIhPT10eXBlb2YgYy50YWd8fDI9PT1rZChjKXx8KGM9bnVsbCk7aWYocWQubGVuZ3RoKXt2YXIgZD1xZC5wb3AoKTtkLnRvcExldmVsVHlwZT1hO2QubmF0aXZlRXZlbnQ9YjtkLnRhcmdldEluc3Q9YzthPWR9ZWxzZSBhPXt0b3BMZXZlbFR5cGU6YSxuYXRpdmVFdmVudDpiLHRhcmdldEluc3Q6YyxhbmNlc3RvcnM6W119O3RyeXt0YyhyZCxhKX1maW5hbGx5e2EudG9wTGV2ZWxUeXBlPW51bGwsYS5uYXRpdmVFdmVudD1udWxsLGEudGFyZ2V0SW5zdD1udWxsLGEuYW5jZXN0b3JzLmxlbmd0aD0wLDEwPnFkLmxlbmd0aCYmcWQucHVzaChhKX19fVxudmFyIHhkPU9iamVjdC5mcmVlemUoe2dldCBfZW5hYmxlZCgpe3JldHVybiB0ZH0sZ2V0IF9oYW5kbGVUb3BMZXZlbCgpe3JldHVybiBzZH0sc2V0SGFuZGxlVG9wTGV2ZWw6ZnVuY3Rpb24oYSl7c2Q9YX0sc2V0RW5hYmxlZDp1ZCxpc0VuYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGR9LHRyYXBCdWJibGVkRXZlbnQ6VSx0cmFwQ2FwdHVyZWRFdmVudDp3ZCxkaXNwYXRjaEV2ZW50OnZkfSk7ZnVuY3Rpb24geWQoYSxiKXt2YXIgYz17fTtjW2EudG9Mb3dlckNhc2UoKV09Yi50b0xvd2VyQ2FzZSgpO2NbXCJXZWJraXRcIithXT1cIndlYmtpdFwiK2I7Y1tcIk1velwiK2FdPVwibW96XCIrYjtjW1wibXNcIithXT1cIk1TXCIrYjtjW1wiT1wiK2FdPVwib1wiK2IudG9Mb3dlckNhc2UoKTtyZXR1cm4gY31cbnZhciB6ZD17YW5pbWF0aW9uZW5kOnlkKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25FbmRcIiksYW5pbWF0aW9uaXRlcmF0aW9uOnlkKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25JdGVyYXRpb25cIiksYW5pbWF0aW9uc3RhcnQ6eWQoXCJBbmltYXRpb25cIixcIkFuaW1hdGlvblN0YXJ0XCIpLHRyYW5zaXRpb25lbmQ6eWQoXCJUcmFuc2l0aW9uXCIsXCJUcmFuc2l0aW9uRW5kXCIpfSxBZD17fSxCZD17fTtsLmNhblVzZURPTSYmKEJkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUsXCJBbmltYXRpb25FdmVudFwiaW4gd2luZG93fHwoZGVsZXRlIHpkLmFuaW1hdGlvbmVuZC5hbmltYXRpb24sZGVsZXRlIHpkLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb24sZGVsZXRlIHpkLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbiksXCJUcmFuc2l0aW9uRXZlbnRcImluIHdpbmRvd3x8ZGVsZXRlIHpkLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbik7XG5mdW5jdGlvbiBDZChhKXtpZihBZFthXSlyZXR1cm4gQWRbYV07aWYoIXpkW2FdKXJldHVybiBhO3ZhciBiPXpkW2FdLGM7Zm9yKGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpJiZjIGluIEJkKXJldHVybiBBZFthXT1iW2NdO3JldHVyblwiXCJ9XG52YXIgRGQ9e3RvcEFib3J0OlwiYWJvcnRcIix0b3BBbmltYXRpb25FbmQ6Q2QoXCJhbmltYXRpb25lbmRcIil8fFwiYW5pbWF0aW9uZW5kXCIsdG9wQW5pbWF0aW9uSXRlcmF0aW9uOkNkKFwiYW5pbWF0aW9uaXRlcmF0aW9uXCIpfHxcImFuaW1hdGlvbml0ZXJhdGlvblwiLHRvcEFuaW1hdGlvblN0YXJ0OkNkKFwiYW5pbWF0aW9uc3RhcnRcIil8fFwiYW5pbWF0aW9uc3RhcnRcIix0b3BCbHVyOlwiYmx1clwiLHRvcENhbmNlbDpcImNhbmNlbFwiLHRvcENhblBsYXk6XCJjYW5wbGF5XCIsdG9wQ2FuUGxheVRocm91Z2g6XCJjYW5wbGF5dGhyb3VnaFwiLHRvcENoYW5nZTpcImNoYW5nZVwiLHRvcENsaWNrOlwiY2xpY2tcIix0b3BDbG9zZTpcImNsb3NlXCIsdG9wQ29tcG9zaXRpb25FbmQ6XCJjb21wb3NpdGlvbmVuZFwiLHRvcENvbXBvc2l0aW9uU3RhcnQ6XCJjb21wb3NpdGlvbnN0YXJ0XCIsdG9wQ29tcG9zaXRpb25VcGRhdGU6XCJjb21wb3NpdGlvbnVwZGF0ZVwiLHRvcENvbnRleHRNZW51OlwiY29udGV4dG1lbnVcIix0b3BDb3B5OlwiY29weVwiLFxudG9wQ3V0OlwiY3V0XCIsdG9wRG91YmxlQ2xpY2s6XCJkYmxjbGlja1wiLHRvcERyYWc6XCJkcmFnXCIsdG9wRHJhZ0VuZDpcImRyYWdlbmRcIix0b3BEcmFnRW50ZXI6XCJkcmFnZW50ZXJcIix0b3BEcmFnRXhpdDpcImRyYWdleGl0XCIsdG9wRHJhZ0xlYXZlOlwiZHJhZ2xlYXZlXCIsdG9wRHJhZ092ZXI6XCJkcmFnb3ZlclwiLHRvcERyYWdTdGFydDpcImRyYWdzdGFydFwiLHRvcERyb3A6XCJkcm9wXCIsdG9wRHVyYXRpb25DaGFuZ2U6XCJkdXJhdGlvbmNoYW5nZVwiLHRvcEVtcHRpZWQ6XCJlbXB0aWVkXCIsdG9wRW5jcnlwdGVkOlwiZW5jcnlwdGVkXCIsdG9wRW5kZWQ6XCJlbmRlZFwiLHRvcEVycm9yOlwiZXJyb3JcIix0b3BGb2N1czpcImZvY3VzXCIsdG9wSW5wdXQ6XCJpbnB1dFwiLHRvcEtleURvd246XCJrZXlkb3duXCIsdG9wS2V5UHJlc3M6XCJrZXlwcmVzc1wiLHRvcEtleVVwOlwia2V5dXBcIix0b3BMb2FkZWREYXRhOlwibG9hZGVkZGF0YVwiLHRvcExvYWQ6XCJsb2FkXCIsdG9wTG9hZGVkTWV0YWRhdGE6XCJsb2FkZWRtZXRhZGF0YVwiLHRvcExvYWRTdGFydDpcImxvYWRzdGFydFwiLFxudG9wTW91c2VEb3duOlwibW91c2Vkb3duXCIsdG9wTW91c2VNb3ZlOlwibW91c2Vtb3ZlXCIsdG9wTW91c2VPdXQ6XCJtb3VzZW91dFwiLHRvcE1vdXNlT3ZlcjpcIm1vdXNlb3ZlclwiLHRvcE1vdXNlVXA6XCJtb3VzZXVwXCIsdG9wUGFzdGU6XCJwYXN0ZVwiLHRvcFBhdXNlOlwicGF1c2VcIix0b3BQbGF5OlwicGxheVwiLHRvcFBsYXlpbmc6XCJwbGF5aW5nXCIsdG9wUHJvZ3Jlc3M6XCJwcm9ncmVzc1wiLHRvcFJhdGVDaGFuZ2U6XCJyYXRlY2hhbmdlXCIsdG9wU2Nyb2xsOlwic2Nyb2xsXCIsdG9wU2Vla2VkOlwic2Vla2VkXCIsdG9wU2Vla2luZzpcInNlZWtpbmdcIix0b3BTZWxlY3Rpb25DaGFuZ2U6XCJzZWxlY3Rpb25jaGFuZ2VcIix0b3BTdGFsbGVkOlwic3RhbGxlZFwiLHRvcFN1c3BlbmQ6XCJzdXNwZW5kXCIsdG9wVGV4dElucHV0OlwidGV4dElucHV0XCIsdG9wVGltZVVwZGF0ZTpcInRpbWV1cGRhdGVcIix0b3BUb2dnbGU6XCJ0b2dnbGVcIix0b3BUb3VjaENhbmNlbDpcInRvdWNoY2FuY2VsXCIsdG9wVG91Y2hFbmQ6XCJ0b3VjaGVuZFwiLHRvcFRvdWNoTW92ZTpcInRvdWNobW92ZVwiLFxudG9wVG91Y2hTdGFydDpcInRvdWNoc3RhcnRcIix0b3BUcmFuc2l0aW9uRW5kOkNkKFwidHJhbnNpdGlvbmVuZFwiKXx8XCJ0cmFuc2l0aW9uZW5kXCIsdG9wVm9sdW1lQ2hhbmdlOlwidm9sdW1lY2hhbmdlXCIsdG9wV2FpdGluZzpcIndhaXRpbmdcIix0b3BXaGVlbDpcIndoZWVsXCJ9LEVkPXt9LEZkPTAsR2Q9XCJfcmVhY3RMaXN0ZW5lcnNJRFwiKyhcIlwiK01hdGgucmFuZG9tKCkpLnNsaWNlKDIpO2Z1bmN0aW9uIEhkKGEpe09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLEdkKXx8KGFbR2RdPUZkKyssRWRbYVtHZF1dPXt9KTtyZXR1cm4gRWRbYVtHZF1dfWZ1bmN0aW9uIElkKGEpe2Zvcig7YSYmYS5maXJzdENoaWxkOylhPWEuZmlyc3RDaGlsZDtyZXR1cm4gYX1cbmZ1bmN0aW9uIEpkKGEsYil7dmFyIGM9SWQoYSk7YT0wO2Zvcih2YXIgZDtjOyl7aWYoMz09PWMubm9kZVR5cGUpe2Q9YStjLnRleHRDb250ZW50Lmxlbmd0aDtpZihhPD1iJiZkPj1iKXJldHVybntub2RlOmMsb2Zmc2V0OmItYX07YT1kfWE6e2Zvcig7Yzspe2lmKGMubmV4dFNpYmxpbmcpe2M9Yy5uZXh0U2libGluZzticmVhayBhfWM9Yy5wYXJlbnROb2RlfWM9dm9pZCAwfWM9SWQoYyl9fWZ1bmN0aW9uIEtkKGEpe3ZhciBiPWEmJmEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gYiYmKFwiaW5wdXRcIj09PWImJlwidGV4dFwiPT09YS50eXBlfHxcInRleHRhcmVhXCI9PT1ifHxcInRydWVcIj09PWEuY29udGVudEVkaXRhYmxlKX1cbnZhciBMZD1sLmNhblVzZURPTSYmXCJkb2N1bWVudE1vZGVcImluIGRvY3VtZW50JiYxMT49ZG9jdW1lbnQuZG9jdW1lbnRNb2RlLE1kPXtzZWxlY3Q6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25TZWxlY3RcIixjYXB0dXJlZDpcIm9uU2VsZWN0Q2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENvbnRleHRNZW51IHRvcEZvY3VzIHRvcEtleURvd24gdG9wS2V5VXAgdG9wTW91c2VEb3duIHRvcE1vdXNlVXAgdG9wU2VsZWN0aW9uQ2hhbmdlXCIuc3BsaXQoXCIgXCIpfX0sTmQ9bnVsbCxPZD1udWxsLFBkPW51bGwsUWQ9ITE7XG5mdW5jdGlvbiBSZChhLGIpe2lmKFFkfHxudWxsPT1OZHx8TmQhPT1kYSgpKXJldHVybiBudWxsO3ZhciBjPU5kO1wic2VsZWN0aW9uU3RhcnRcImluIGMmJktkKGMpP2M9e3N0YXJ0OmMuc2VsZWN0aW9uU3RhcnQsZW5kOmMuc2VsZWN0aW9uRW5kfTp3aW5kb3cuZ2V0U2VsZWN0aW9uPyhjPXdpbmRvdy5nZXRTZWxlY3Rpb24oKSxjPXthbmNob3JOb2RlOmMuYW5jaG9yTm9kZSxhbmNob3JPZmZzZXQ6Yy5hbmNob3JPZmZzZXQsZm9jdXNOb2RlOmMuZm9jdXNOb2RlLGZvY3VzT2Zmc2V0OmMuZm9jdXNPZmZzZXR9KTpjPXZvaWQgMDtyZXR1cm4gUGQmJmVhKFBkLGMpP251bGw6KFBkPWMsYT1ULmdldFBvb2xlZChNZC5zZWxlY3QsT2QsYSxiKSxhLnR5cGU9XCJzZWxlY3RcIixhLnRhcmdldD1OZCxBYihhKSxhKX1cbnZhciBTZD17ZXZlbnRUeXBlczpNZCxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWQud2luZG93PT09ZD9kLmRvY3VtZW50Ojk9PT1kLm5vZGVUeXBlP2Q6ZC5vd25lckRvY3VtZW50LGY7aWYoIShmPSFlKSl7YTp7ZT1IZChlKTtmPVNhLm9uU2VsZWN0O2Zvcih2YXIgZz0wO2c8Zi5sZW5ndGg7ZysrKXt2YXIgaD1mW2ddO2lmKCFlLmhhc093blByb3BlcnR5KGgpfHwhZVtoXSl7ZT0hMTticmVhayBhfX1lPSEwfWY9IWV9aWYoZilyZXR1cm4gbnVsbDtlPWI/cWIoYik6d2luZG93O3N3aXRjaChhKXtjYXNlIFwidG9wRm9jdXNcIjppZih2YyhlKXx8XCJ0cnVlXCI9PT1lLmNvbnRlbnRFZGl0YWJsZSlOZD1lLE9kPWIsUGQ9bnVsbDticmVhaztjYXNlIFwidG9wQmx1clwiOlBkPU9kPU5kPW51bGw7YnJlYWs7Y2FzZSBcInRvcE1vdXNlRG93blwiOlFkPSEwO2JyZWFrO2Nhc2UgXCJ0b3BDb250ZXh0TWVudVwiOmNhc2UgXCJ0b3BNb3VzZVVwXCI6cmV0dXJuIFFkPSExLFJkKGMsZCk7Y2FzZSBcInRvcFNlbGVjdGlvbkNoYW5nZVwiOmlmKExkKWJyZWFrO1xuY2FzZSBcInRvcEtleURvd25cIjpjYXNlIFwidG9wS2V5VXBcIjpyZXR1cm4gUmQoYyxkKX1yZXR1cm4gbnVsbH19O2Z1bmN0aW9uIFRkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhUZCx7YW5pbWF0aW9uTmFtZTpudWxsLGVsYXBzZWRUaW1lOm51bGwscHNldWRvRWxlbWVudDpudWxsfSk7ZnVuY3Rpb24gVWQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKFVkLHtjbGlwYm9hcmREYXRhOmZ1bmN0aW9uKGEpe3JldHVyblwiY2xpcGJvYXJkRGF0YVwiaW4gYT9hLmNsaXBib2FyZERhdGE6d2luZG93LmNsaXBib2FyZERhdGF9fSk7ZnVuY3Rpb24gVmQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfWJkLmF1Z21lbnRDbGFzcyhWZCx7cmVsYXRlZFRhcmdldDpudWxsfSk7XG5mdW5jdGlvbiBXZChhKXt2YXIgYj1hLmtleUNvZGU7XCJjaGFyQ29kZVwiaW4gYT8oYT1hLmNoYXJDb2RlLDA9PT1hJiYxMz09PWImJihhPTEzKSk6YT1iO3JldHVybiAzMjw9YXx8MTM9PT1hP2E6MH1cbnZhciBYZD17RXNjOlwiRXNjYXBlXCIsU3BhY2ViYXI6XCIgXCIsTGVmdDpcIkFycm93TGVmdFwiLFVwOlwiQXJyb3dVcFwiLFJpZ2h0OlwiQXJyb3dSaWdodFwiLERvd246XCJBcnJvd0Rvd25cIixEZWw6XCJEZWxldGVcIixXaW46XCJPU1wiLE1lbnU6XCJDb250ZXh0TWVudVwiLEFwcHM6XCJDb250ZXh0TWVudVwiLFNjcm9sbDpcIlNjcm9sbExvY2tcIixNb3pQcmludGFibGVLZXk6XCJVbmlkZW50aWZpZWRcIn0sWWQ9ezg6XCJCYWNrc3BhY2VcIiw5OlwiVGFiXCIsMTI6XCJDbGVhclwiLDEzOlwiRW50ZXJcIiwxNjpcIlNoaWZ0XCIsMTc6XCJDb250cm9sXCIsMTg6XCJBbHRcIiwxOTpcIlBhdXNlXCIsMjA6XCJDYXBzTG9ja1wiLDI3OlwiRXNjYXBlXCIsMzI6XCIgXCIsMzM6XCJQYWdlVXBcIiwzNDpcIlBhZ2VEb3duXCIsMzU6XCJFbmRcIiwzNjpcIkhvbWVcIiwzNzpcIkFycm93TGVmdFwiLDM4OlwiQXJyb3dVcFwiLDM5OlwiQXJyb3dSaWdodFwiLDQwOlwiQXJyb3dEb3duXCIsNDU6XCJJbnNlcnRcIiw0NjpcIkRlbGV0ZVwiLDExMjpcIkYxXCIsMTEzOlwiRjJcIiwxMTQ6XCJGM1wiLDExNTpcIkY0XCIsXG4xMTY6XCJGNVwiLDExNzpcIkY2XCIsMTE4OlwiRjdcIiwxMTk6XCJGOFwiLDEyMDpcIkY5XCIsMTIxOlwiRjEwXCIsMTIyOlwiRjExXCIsMTIzOlwiRjEyXCIsMTQ0OlwiTnVtTG9ja1wiLDE0NTpcIlNjcm9sbExvY2tcIiwyMjQ6XCJNZXRhXCJ9O2Z1bmN0aW9uIFpkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1cbmJkLmF1Z21lbnRDbGFzcyhaZCx7a2V5OmZ1bmN0aW9uKGEpe2lmKGEua2V5KXt2YXIgYj1YZFthLmtleV18fGEua2V5O2lmKFwiVW5pZGVudGlmaWVkXCIhPT1iKXJldHVybiBifXJldHVyblwia2V5cHJlc3NcIj09PWEudHlwZT8oYT1XZChhKSwxMz09PWE/XCJFbnRlclwiOlN0cmluZy5mcm9tQ2hhckNvZGUoYSkpOlwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/WWRbYS5rZXlDb2RlXXx8XCJVbmlkZW50aWZpZWRcIjpcIlwifSxsb2NhdGlvbjpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGFsdEtleTpudWxsLG1ldGFLZXk6bnVsbCxyZXBlYXQ6bnVsbCxsb2NhbGU6bnVsbCxnZXRNb2RpZmllclN0YXRlOmVkLGNoYXJDb2RlOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5cHJlc3NcIj09PWEudHlwZT9XZChhKTowfSxrZXlDb2RlOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/YS5rZXlDb2RlOjB9LHdoaWNoOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5cHJlc3NcIj09PVxuYS50eXBlP1dkKGEpOlwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/YS5rZXlDb2RlOjB9fSk7ZnVuY3Rpb24gJGQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfWZkLmF1Z21lbnRDbGFzcygkZCx7ZGF0YVRyYW5zZmVyOm51bGx9KTtmdW5jdGlvbiBhZShhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9YmQuYXVnbWVudENsYXNzKGFlLHt0b3VjaGVzOm51bGwsdGFyZ2V0VG91Y2hlczpudWxsLGNoYW5nZWRUb3VjaGVzOm51bGwsYWx0S2V5Om51bGwsbWV0YUtleTpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGdldE1vZGlmaWVyU3RhdGU6ZWR9KTtmdW5jdGlvbiBiZShhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoYmUse3Byb3BlcnR5TmFtZTpudWxsLGVsYXBzZWRUaW1lOm51bGwscHNldWRvRWxlbWVudDpudWxsfSk7XG5mdW5jdGlvbiBjZShhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9ZmQuYXVnbWVudENsYXNzKGNlLHtkZWx0YVg6ZnVuY3Rpb24oYSl7cmV0dXJuXCJkZWx0YVhcImluIGE/YS5kZWx0YVg6XCJ3aGVlbERlbHRhWFwiaW4gYT8tYS53aGVlbERlbHRhWDowfSxkZWx0YVk6ZnVuY3Rpb24oYSl7cmV0dXJuXCJkZWx0YVlcImluIGE/YS5kZWx0YVk6XCJ3aGVlbERlbHRhWVwiaW4gYT8tYS53aGVlbERlbHRhWTpcIndoZWVsRGVsdGFcImluIGE/LWEud2hlZWxEZWx0YTowfSxkZWx0YVo6bnVsbCxkZWx0YU1vZGU6bnVsbH0pO3ZhciBkZT17fSxlZT17fTtcblwiYWJvcnQgYW5pbWF0aW9uRW5kIGFuaW1hdGlvbkl0ZXJhdGlvbiBhbmltYXRpb25TdGFydCBibHVyIGNhbmNlbCBjYW5QbGF5IGNhblBsYXlUaHJvdWdoIGNsaWNrIGNsb3NlIGNvbnRleHRNZW51IGNvcHkgY3V0IGRvdWJsZUNsaWNrIGRyYWcgZHJhZ0VuZCBkcmFnRW50ZXIgZHJhZ0V4aXQgZHJhZ0xlYXZlIGRyYWdPdmVyIGRyYWdTdGFydCBkcm9wIGR1cmF0aW9uQ2hhbmdlIGVtcHRpZWQgZW5jcnlwdGVkIGVuZGVkIGVycm9yIGZvY3VzIGlucHV0IGludmFsaWQga2V5RG93biBrZXlQcmVzcyBrZXlVcCBsb2FkIGxvYWRlZERhdGEgbG9hZGVkTWV0YWRhdGEgbG9hZFN0YXJ0IG1vdXNlRG93biBtb3VzZU1vdmUgbW91c2VPdXQgbW91c2VPdmVyIG1vdXNlVXAgcGFzdGUgcGF1c2UgcGxheSBwbGF5aW5nIHByb2dyZXNzIHJhdGVDaGFuZ2UgcmVzZXQgc2Nyb2xsIHNlZWtlZCBzZWVraW5nIHN0YWxsZWQgc3VibWl0IHN1c3BlbmQgdGltZVVwZGF0ZSB0b2dnbGUgdG91Y2hDYW5jZWwgdG91Y2hFbmQgdG91Y2hNb3ZlIHRvdWNoU3RhcnQgdHJhbnNpdGlvbkVuZCB2b2x1bWVDaGFuZ2Ugd2FpdGluZyB3aGVlbFwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWFbMF0udG9VcHBlckNhc2UoKStcbmEuc2xpY2UoMSksYz1cIm9uXCIrYjtiPVwidG9wXCIrYjtjPXtwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpjLGNhcHR1cmVkOmMrXCJDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpbYl19O2RlW2FdPWM7ZWVbYl09Y30pO1xudmFyIGZlPXtldmVudFR5cGVzOmRlLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ZWVbYV07aWYoIWUpcmV0dXJuIG51bGw7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BLZXlQcmVzc1wiOmlmKDA9PT1XZChjKSlyZXR1cm4gbnVsbDtjYXNlIFwidG9wS2V5RG93blwiOmNhc2UgXCJ0b3BLZXlVcFwiOmE9WmQ7YnJlYWs7Y2FzZSBcInRvcEJsdXJcIjpjYXNlIFwidG9wRm9jdXNcIjphPVZkO2JyZWFrO2Nhc2UgXCJ0b3BDbGlja1wiOmlmKDI9PT1jLmJ1dHRvbilyZXR1cm4gbnVsbDtjYXNlIFwidG9wRG91YmxlQ2xpY2tcIjpjYXNlIFwidG9wTW91c2VEb3duXCI6Y2FzZSBcInRvcE1vdXNlTW92ZVwiOmNhc2UgXCJ0b3BNb3VzZVVwXCI6Y2FzZSBcInRvcE1vdXNlT3V0XCI6Y2FzZSBcInRvcE1vdXNlT3ZlclwiOmNhc2UgXCJ0b3BDb250ZXh0TWVudVwiOmE9ZmQ7YnJlYWs7Y2FzZSBcInRvcERyYWdcIjpjYXNlIFwidG9wRHJhZ0VuZFwiOmNhc2UgXCJ0b3BEcmFnRW50ZXJcIjpjYXNlIFwidG9wRHJhZ0V4aXRcIjpjYXNlIFwidG9wRHJhZ0xlYXZlXCI6Y2FzZSBcInRvcERyYWdPdmVyXCI6Y2FzZSBcInRvcERyYWdTdGFydFwiOmNhc2UgXCJ0b3BEcm9wXCI6YT1cbiRkO2JyZWFrO2Nhc2UgXCJ0b3BUb3VjaENhbmNlbFwiOmNhc2UgXCJ0b3BUb3VjaEVuZFwiOmNhc2UgXCJ0b3BUb3VjaE1vdmVcIjpjYXNlIFwidG9wVG91Y2hTdGFydFwiOmE9YWU7YnJlYWs7Y2FzZSBcInRvcEFuaW1hdGlvbkVuZFwiOmNhc2UgXCJ0b3BBbmltYXRpb25JdGVyYXRpb25cIjpjYXNlIFwidG9wQW5pbWF0aW9uU3RhcnRcIjphPVRkO2JyZWFrO2Nhc2UgXCJ0b3BUcmFuc2l0aW9uRW5kXCI6YT1iZTticmVhaztjYXNlIFwidG9wU2Nyb2xsXCI6YT1iZDticmVhaztjYXNlIFwidG9wV2hlZWxcIjphPWNlO2JyZWFrO2Nhc2UgXCJ0b3BDb3B5XCI6Y2FzZSBcInRvcEN1dFwiOmNhc2UgXCJ0b3BQYXN0ZVwiOmE9VWQ7YnJlYWs7ZGVmYXVsdDphPVR9Yj1hLmdldFBvb2xlZChlLGIsYyxkKTtBYihiKTtyZXR1cm4gYn19O3NkPWZ1bmN0aW9uKGEsYixjLGQpe2E9amIoYSxiLGMsZCk7a2IoYSk7bGIoITEpfTtoYi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKFwiUmVzcG9uZGVyRXZlbnRQbHVnaW4gU2ltcGxlRXZlbnRQbHVnaW4gVGFwRXZlbnRQbHVnaW4gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luIENoYW5nZUV2ZW50UGx1Z2luIFNlbGVjdEV2ZW50UGx1Z2luIEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cIi5zcGxpdChcIiBcIikpO1xuV2E9c2IuZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTtYYT1zYi5nZXRJbnN0YW5jZUZyb21Ob2RlO1lhPXNiLmdldE5vZGVGcm9tSW5zdGFuY2U7aGIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtTaW1wbGVFdmVudFBsdWdpbjpmZSxFbnRlckxlYXZlRXZlbnRQbHVnaW46aGQsQ2hhbmdlRXZlbnRQbHVnaW46YWQsU2VsZWN0RXZlbnRQbHVnaW46U2QsQmVmb3JlSW5wdXRFdmVudFBsdWdpbjppY30pO3ZhciBnZT1bXSxoZT0tMTtmdW5jdGlvbiBWKGEpezA+aGV8fChhLmN1cnJlbnQ9Z2VbaGVdLGdlW2hlXT1udWxsLGhlLS0pfWZ1bmN0aW9uIFcoYSxiKXtoZSsrO2dlW2hlXT1hLmN1cnJlbnQ7YS5jdXJyZW50PWJ9bmV3IFNldDt2YXIgaWU9e2N1cnJlbnQ6RH0sWD17Y3VycmVudDohMX0samU9RDtmdW5jdGlvbiBrZShhKXtyZXR1cm4gbGUoYSk/amU6aWUuY3VycmVudH1cbmZ1bmN0aW9uIG1lKGEsYil7dmFyIGM9YS50eXBlLmNvbnRleHRUeXBlcztpZighYylyZXR1cm4gRDt2YXIgZD1hLnN0YXRlTm9kZTtpZihkJiZkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9PT1iKXJldHVybiBkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O3ZhciBlPXt9LGY7Zm9yKGYgaW4gYyllW2ZdPWJbZl07ZCYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWIsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1lKTtyZXR1cm4gZX1mdW5jdGlvbiBsZShhKXtyZXR1cm4gMj09PWEudGFnJiZudWxsIT1hLnR5cGUuY2hpbGRDb250ZXh0VHlwZXN9ZnVuY3Rpb24gbmUoYSl7bGUoYSkmJihWKFgsYSksVihpZSxhKSl9XG5mdW5jdGlvbiBvZShhLGIsYyl7bnVsbCE9aWUuY3Vyc29yP0UoXCIxNjhcIik6dm9pZCAwO1coaWUsYixhKTtXKFgsYyxhKX1mdW5jdGlvbiBwZShhLGIpe3ZhciBjPWEuc3RhdGVOb2RlLGQ9YS50eXBlLmNoaWxkQ29udGV4dFR5cGVzO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjLmdldENoaWxkQ29udGV4dClyZXR1cm4gYjtjPWMuZ2V0Q2hpbGRDb250ZXh0KCk7Zm9yKHZhciBlIGluIGMpZSBpbiBkP3ZvaWQgMDpFKFwiMTA4XCIsamQoYSl8fFwiVW5rbm93blwiLGUpO3JldHVybiBCKHt9LGIsYyl9ZnVuY3Rpb24gcWUoYSl7aWYoIWxlKGEpKXJldHVybiExO3ZhciBiPWEuc3RhdGVOb2RlO2I9YiYmYi5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dHx8RDtqZT1pZS5jdXJyZW50O1coaWUsYixhKTtXKFgsWC5jdXJyZW50LGEpO3JldHVybiEwfVxuZnVuY3Rpb24gcmUoYSxiKXt2YXIgYz1hLnN0YXRlTm9kZTtjP3ZvaWQgMDpFKFwiMTY5XCIpO2lmKGIpe3ZhciBkPXBlKGEsamUpO2MuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ9ZDtWKFgsYSk7VihpZSxhKTtXKGllLGQsYSl9ZWxzZSBWKFgsYSk7VyhYLGIsYSl9XG5mdW5jdGlvbiBZKGEsYixjKXt0aGlzLnRhZz1hO3RoaXMua2V5PWI7dGhpcy5zdGF0ZU5vZGU9dGhpcy50eXBlPW51bGw7dGhpcy5zaWJsaW5nPXRoaXMuY2hpbGQ9dGhpc1tcInJldHVyblwiXT1udWxsO3RoaXMuaW5kZXg9MDt0aGlzLm1lbW9pemVkU3RhdGU9dGhpcy51cGRhdGVRdWV1ZT10aGlzLm1lbW9pemVkUHJvcHM9dGhpcy5wZW5kaW5nUHJvcHM9dGhpcy5yZWY9bnVsbDt0aGlzLmludGVybmFsQ29udGV4dFRhZz1jO3RoaXMuZWZmZWN0VGFnPTA7dGhpcy5sYXN0RWZmZWN0PXRoaXMuZmlyc3RFZmZlY3Q9dGhpcy5uZXh0RWZmZWN0PW51bGw7dGhpcy5leHBpcmF0aW9uVGltZT0wO3RoaXMuYWx0ZXJuYXRlPW51bGx9XG5mdW5jdGlvbiBzZShhLGIsYyl7dmFyIGQ9YS5hbHRlcm5hdGU7bnVsbD09PWQ/KGQ9bmV3IFkoYS50YWcsYS5rZXksYS5pbnRlcm5hbENvbnRleHRUYWcpLGQudHlwZT1hLnR5cGUsZC5zdGF0ZU5vZGU9YS5zdGF0ZU5vZGUsZC5hbHRlcm5hdGU9YSxhLmFsdGVybmF0ZT1kKTooZC5lZmZlY3RUYWc9MCxkLm5leHRFZmZlY3Q9bnVsbCxkLmZpcnN0RWZmZWN0PW51bGwsZC5sYXN0RWZmZWN0PW51bGwpO2QuZXhwaXJhdGlvblRpbWU9YztkLnBlbmRpbmdQcm9wcz1iO2QuY2hpbGQ9YS5jaGlsZDtkLm1lbW9pemVkUHJvcHM9YS5tZW1vaXplZFByb3BzO2QubWVtb2l6ZWRTdGF0ZT1hLm1lbW9pemVkU3RhdGU7ZC51cGRhdGVRdWV1ZT1hLnVwZGF0ZVF1ZXVlO2Quc2libGluZz1hLnNpYmxpbmc7ZC5pbmRleD1hLmluZGV4O2QucmVmPWEucmVmO3JldHVybiBkfVxuZnVuY3Rpb24gdGUoYSxiLGMpe3ZhciBkPXZvaWQgMCxlPWEudHlwZSxmPWEua2V5O1wiZnVuY3Rpb25cIj09PXR5cGVvZiBlPyhkPWUucHJvdG90eXBlJiZlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50P25ldyBZKDIsZixiKTpuZXcgWSgwLGYsYiksZC50eXBlPWUsZC5wZW5kaW5nUHJvcHM9YS5wcm9wcyk6XCJzdHJpbmdcIj09PXR5cGVvZiBlPyhkPW5ldyBZKDUsZixiKSxkLnR5cGU9ZSxkLnBlbmRpbmdQcm9wcz1hLnByb3BzKTpcIm9iamVjdFwiPT09dHlwZW9mIGUmJm51bGwhPT1lJiZcIm51bWJlclwiPT09dHlwZW9mIGUudGFnPyhkPWUsZC5wZW5kaW5nUHJvcHM9YS5wcm9wcyk6RShcIjEzMFwiLG51bGw9PWU/ZTp0eXBlb2YgZSxcIlwiKTtkLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGR9ZnVuY3Rpb24gdWUoYSxiLGMsZCl7Yj1uZXcgWSgxMCxkLGIpO2IucGVuZGluZ1Byb3BzPWE7Yi5leHBpcmF0aW9uVGltZT1jO3JldHVybiBifVxuZnVuY3Rpb24gdmUoYSxiLGMpe2I9bmV3IFkoNixudWxsLGIpO2IucGVuZGluZ1Byb3BzPWE7Yi5leHBpcmF0aW9uVGltZT1jO3JldHVybiBifWZ1bmN0aW9uIHdlKGEsYixjKXtiPW5ldyBZKDcsYS5rZXksYik7Yi50eXBlPWEuaGFuZGxlcjtiLnBlbmRpbmdQcm9wcz1hO2IuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYn1mdW5jdGlvbiB4ZShhLGIsYyl7YT1uZXcgWSg5LG51bGwsYik7YS5leHBpcmF0aW9uVGltZT1jO3JldHVybiBhfWZ1bmN0aW9uIHllKGEsYixjKXtiPW5ldyBZKDQsYS5rZXksYik7Yi5wZW5kaW5nUHJvcHM9YS5jaGlsZHJlbnx8W107Yi5leHBpcmF0aW9uVGltZT1jO2Iuc3RhdGVOb2RlPXtjb250YWluZXJJbmZvOmEuY29udGFpbmVySW5mbyxwZW5kaW5nQ2hpbGRyZW46bnVsbCxpbXBsZW1lbnRhdGlvbjphLmltcGxlbWVudGF0aW9ufTtyZXR1cm4gYn12YXIgemU9bnVsbCxBZT1udWxsO1xuZnVuY3Rpb24gQmUoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3RyeXtyZXR1cm4gYShiKX1jYXRjaChjKXt9fX1mdW5jdGlvbiBDZShhKXtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXylyZXR1cm4hMTt2YXIgYj1fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187aWYoYi5pc0Rpc2FibGVkfHwhYi5zdXBwb3J0c0ZpYmVyKXJldHVybiEwO3RyeXt2YXIgYz1iLmluamVjdChhKTt6ZT1CZShmdW5jdGlvbihhKXtyZXR1cm4gYi5vbkNvbW1pdEZpYmVyUm9vdChjLGEpfSk7QWU9QmUoZnVuY3Rpb24oYSl7cmV0dXJuIGIub25Db21taXRGaWJlclVubW91bnQoYyxhKX0pfWNhdGNoKGQpe31yZXR1cm4hMH1mdW5jdGlvbiBEZShhKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgemUmJnplKGEpfWZ1bmN0aW9uIEVlKGEpe1wiZnVuY3Rpb25cIj09PXR5cGVvZiBBZSYmQWUoYSl9XG5mdW5jdGlvbiBGZShhKXtyZXR1cm57YmFzZVN0YXRlOmEsZXhwaXJhdGlvblRpbWU6MCxmaXJzdDpudWxsLGxhc3Q6bnVsbCxjYWxsYmFja0xpc3Q6bnVsbCxoYXNGb3JjZVVwZGF0ZTohMSxpc0luaXRpYWxpemVkOiExfX1mdW5jdGlvbiBHZShhLGIpe251bGw9PT1hLmxhc3Q/YS5maXJzdD1hLmxhc3Q9YjooYS5sYXN0Lm5leHQ9YixhLmxhc3Q9Yik7aWYoMD09PWEuZXhwaXJhdGlvblRpbWV8fGEuZXhwaXJhdGlvblRpbWU+Yi5leHBpcmF0aW9uVGltZSlhLmV4cGlyYXRpb25UaW1lPWIuZXhwaXJhdGlvblRpbWV9XG5mdW5jdGlvbiBIZShhLGIpe3ZhciBjPWEuYWx0ZXJuYXRlLGQ9YS51cGRhdGVRdWV1ZTtudWxsPT09ZCYmKGQ9YS51cGRhdGVRdWV1ZT1GZShudWxsKSk7bnVsbCE9PWM/KGE9Yy51cGRhdGVRdWV1ZSxudWxsPT09YSYmKGE9Yy51cGRhdGVRdWV1ZT1GZShudWxsKSkpOmE9bnVsbDthPWEhPT1kP2E6bnVsbDtudWxsPT09YT9HZShkLGIpOm51bGw9PT1kLmxhc3R8fG51bGw9PT1hLmxhc3Q/KEdlKGQsYiksR2UoYSxiKSk6KEdlKGQsYiksYS5sYXN0PWIpfWZ1bmN0aW9uIEllKGEsYixjLGQpe2E9YS5wYXJ0aWFsU3RhdGU7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YS5jYWxsKGIsYyxkKTphfVxuZnVuY3Rpb24gSmUoYSxiLGMsZCxlLGYpe251bGwhPT1hJiZhLnVwZGF0ZVF1ZXVlPT09YyYmKGM9Yi51cGRhdGVRdWV1ZT17YmFzZVN0YXRlOmMuYmFzZVN0YXRlLGV4cGlyYXRpb25UaW1lOmMuZXhwaXJhdGlvblRpbWUsZmlyc3Q6Yy5maXJzdCxsYXN0OmMubGFzdCxpc0luaXRpYWxpemVkOmMuaXNJbml0aWFsaXplZCxjYWxsYmFja0xpc3Q6bnVsbCxoYXNGb3JjZVVwZGF0ZTohMX0pO2MuZXhwaXJhdGlvblRpbWU9MDtjLmlzSW5pdGlhbGl6ZWQ/YT1jLmJhc2VTdGF0ZTooYT1jLmJhc2VTdGF0ZT1iLm1lbW9pemVkU3RhdGUsYy5pc0luaXRpYWxpemVkPSEwKTtmb3IodmFyIGc9ITAsaD1jLmZpcnN0LGs9ITE7bnVsbCE9PWg7KXt2YXIgcT1oLmV4cGlyYXRpb25UaW1lO2lmKHE+Zil7dmFyIHY9Yy5leHBpcmF0aW9uVGltZTtpZigwPT09dnx8dj5xKWMuZXhwaXJhdGlvblRpbWU9cTtrfHwoaz0hMCxjLmJhc2VTdGF0ZT1hKX1lbHNle2t8fChjLmZpcnN0PWgubmV4dCxudWxsPT09XG5jLmZpcnN0JiYoYy5sYXN0PW51bGwpKTtpZihoLmlzUmVwbGFjZSlhPUllKGgsZCxhLGUpLGc9ITA7ZWxzZSBpZihxPUllKGgsZCxhLGUpKWE9Zz9CKHt9LGEscSk6QihhLHEpLGc9ITE7aC5pc0ZvcmNlZCYmKGMuaGFzRm9yY2VVcGRhdGU9ITApO251bGwhPT1oLmNhbGxiYWNrJiYocT1jLmNhbGxiYWNrTGlzdCxudWxsPT09cSYmKHE9Yy5jYWxsYmFja0xpc3Q9W10pLHEucHVzaChoKSl9aD1oLm5leHR9bnVsbCE9PWMuY2FsbGJhY2tMaXN0P2IuZWZmZWN0VGFnfD0zMjpudWxsIT09Yy5maXJzdHx8Yy5oYXNGb3JjZVVwZGF0ZXx8KGIudXBkYXRlUXVldWU9bnVsbCk7a3x8KGMuYmFzZVN0YXRlPWEpO3JldHVybiBhfVxuZnVuY3Rpb24gS2UoYSxiKXt2YXIgYz1hLmNhbGxiYWNrTGlzdDtpZihudWxsIT09Yylmb3IoYS5jYWxsYmFja0xpc3Q9bnVsbCxhPTA7YTxjLmxlbmd0aDthKyspe3ZhciBkPWNbYV0sZT1kLmNhbGxiYWNrO2QuY2FsbGJhY2s9bnVsbDtcImZ1bmN0aW9uXCIhPT10eXBlb2YgZT9FKFwiMTkxXCIsZSk6dm9pZCAwO2UuY2FsbChiKX19XG5mdW5jdGlvbiBMZShhLGIsYyxkKXtmdW5jdGlvbiBlKGEsYil7Yi51cGRhdGVyPWY7YS5zdGF0ZU5vZGU9YjtiLl9yZWFjdEludGVybmFsRmliZXI9YX12YXIgZj17aXNNb3VudGVkOmxkLGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbihjLGQsZSl7Yz1jLl9yZWFjdEludGVybmFsRmliZXI7ZT12b2lkIDA9PT1lP251bGw6ZTt2YXIgZz1iKGMpO0hlKGMse2V4cGlyYXRpb25UaW1lOmcscGFydGlhbFN0YXRlOmQsY2FsbGJhY2s6ZSxpc1JlcGxhY2U6ITEsaXNGb3JjZWQ6ITEsbmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7YShjLGcpfSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKGMsZCxlKXtjPWMuX3JlYWN0SW50ZXJuYWxGaWJlcjtlPXZvaWQgMD09PWU/bnVsbDplO3ZhciBnPWIoYyk7SGUoYyx7ZXhwaXJhdGlvblRpbWU6ZyxwYXJ0aWFsU3RhdGU6ZCxjYWxsYmFjazplLGlzUmVwbGFjZTohMCxpc0ZvcmNlZDohMSxuZXh0Q2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9KTtcbmEoYyxnKX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKGMsZCl7Yz1jLl9yZWFjdEludGVybmFsRmliZXI7ZD12b2lkIDA9PT1kP251bGw6ZDt2YXIgZT1iKGMpO0hlKGMse2V4cGlyYXRpb25UaW1lOmUscGFydGlhbFN0YXRlOm51bGwsY2FsbGJhY2s6ZCxpc1JlcGxhY2U6ITEsaXNGb3JjZWQ6ITAsbmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7YShjLGUpfX07cmV0dXJue2Fkb3B0Q2xhc3NJbnN0YW5jZTplLGNvbnN0cnVjdENsYXNzSW5zdGFuY2U6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnR5cGUsZD1rZShhKSxmPTI9PT1hLnRhZyYmbnVsbCE9YS50eXBlLmNvbnRleHRUeXBlcyxnPWY/bWUoYSxkKTpEO2I9bmV3IGMoYixnKTtlKGEsYik7ZiYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWQsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1nKTtyZXR1cm4gYn0sbW91bnRDbGFzc0luc3RhbmNlOmZ1bmN0aW9uKGEsXG5iKXt2YXIgYz1hLmFsdGVybmF0ZSxkPWEuc3RhdGVOb2RlLGU9ZC5zdGF0ZXx8bnVsbCxnPWEucGVuZGluZ1Byb3BzO2c/dm9pZCAwOkUoXCIxNThcIik7dmFyIGg9a2UoYSk7ZC5wcm9wcz1nO2Quc3RhdGU9YS5tZW1vaXplZFN0YXRlPWU7ZC5yZWZzPUQ7ZC5jb250ZXh0PW1lKGEsaCk7bnVsbCE9YS50eXBlJiZudWxsIT1hLnR5cGUucHJvdG90eXBlJiYhMD09PWEudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50JiYoYS5pbnRlcm5hbENvbnRleHRUYWd8PTEpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudFdpbGxNb3VudCYmKGU9ZC5zdGF0ZSxkLmNvbXBvbmVudFdpbGxNb3VudCgpLGUhPT1kLnN0YXRlJiZmLmVucXVldWVSZXBsYWNlU3RhdGUoZCxkLnN0YXRlLG51bGwpLGU9YS51cGRhdGVRdWV1ZSxudWxsIT09ZSYmKGQuc3RhdGU9SmUoYyxhLGUsZCxnLGIpKSk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50RGlkTW91bnQmJihhLmVmZmVjdFRhZ3w9XG40KX0sdXBkYXRlQ2xhc3NJbnN0YW5jZTpmdW5jdGlvbihhLGIsZSl7dmFyIGc9Yi5zdGF0ZU5vZGU7Zy5wcm9wcz1iLm1lbW9pemVkUHJvcHM7Zy5zdGF0ZT1iLm1lbW9pemVkU3RhdGU7dmFyIGg9Yi5tZW1vaXplZFByb3BzLGs9Yi5wZW5kaW5nUHJvcHM7a3x8KGs9aCxudWxsPT1rP0UoXCIxNTlcIik6dm9pZCAwKTt2YXIgdT1nLmNvbnRleHQsej1rZShiKTt6PW1lKGIseik7XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc3x8aD09PWsmJnU9PT16fHwodT1nLnN0YXRlLGcuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhrLHopLGcuc3RhdGUhPT11JiZmLmVucXVldWVSZXBsYWNlU3RhdGUoZyxnLnN0YXRlLG51bGwpKTt1PWIubWVtb2l6ZWRTdGF0ZTtlPW51bGwhPT1iLnVwZGF0ZVF1ZXVlP0plKGEsYixiLnVwZGF0ZVF1ZXVlLGcsayxlKTp1O2lmKCEoaCE9PWt8fHUhPT1lfHxYLmN1cnJlbnR8fG51bGwhPT1iLnVwZGF0ZVF1ZXVlJiZiLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSlyZXR1cm5cImZ1bmN0aW9uXCIhPT1cbnR5cGVvZiBnLmNvbXBvbmVudERpZFVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmdT09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZWZmZWN0VGFnfD00KSwhMTt2YXIgRz1rO2lmKG51bGw9PT1ofHxudWxsIT09Yi51cGRhdGVRdWV1ZSYmYi51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSlHPSEwO2Vsc2V7dmFyIEk9Yi5zdGF0ZU5vZGUsTD1iLnR5cGU7Rz1cImZ1bmN0aW9uXCI9PT10eXBlb2YgSS5zaG91bGRDb21wb25lbnRVcGRhdGU/SS5zaG91bGRDb21wb25lbnRVcGRhdGUoRyxlLHopOkwucHJvdG90eXBlJiZMLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudD8hZWEoaCxHKXx8IWVhKHUsZSk6ITB9Rz8oXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFVwZGF0ZSYmZy5jb21wb25lbnRXaWxsVXBkYXRlKGssZSx6KSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGUmJihiLmVmZmVjdFRhZ3w9NCkpOihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fFxuaD09PWEubWVtb2l6ZWRQcm9wcyYmdT09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZWZmZWN0VGFnfD00KSxjKGIsayksZChiLGUpKTtnLnByb3BzPWs7Zy5zdGF0ZT1lO2cuY29udGV4dD16O3JldHVybiBHfX19dmFyIFFlPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbFtcImZvclwiXSxSZT1RZT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5lbGVtZW50XCIpOjYwMTAzLFNlPVFlP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmNhbGxcIik6NjAxMDQsVGU9UWU/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucmV0dXJuXCIpOjYwMTA1LFVlPVFlP1N5bWJvbFtcImZvclwiXShcInJlYWN0LnBvcnRhbFwiKTo2MDEwNixWZT1RZT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5mcmFnbWVudFwiKTo2MDEwNyxXZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3I7XG5mdW5jdGlvbiBYZShhKXtpZihudWxsPT09YXx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhKXJldHVybiBudWxsO2E9V2UmJmFbV2VdfHxhW1wiQEBpdGVyYXRvclwiXTtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hOm51bGx9dmFyIFllPUFycmF5LmlzQXJyYXk7XG5mdW5jdGlvbiBaZShhLGIpe3ZhciBjPWIucmVmO2lmKG51bGwhPT1jJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYyl7aWYoYi5fb3duZXIpe2I9Yi5fb3duZXI7dmFyIGQ9dm9pZCAwO2ImJigyIT09Yi50YWc/RShcIjExMFwiKTp2b2lkIDAsZD1iLnN0YXRlTm9kZSk7ZD92b2lkIDA6RShcIjE0N1wiLGMpO3ZhciBlPVwiXCIrYztpZihudWxsIT09YSYmbnVsbCE9PWEucmVmJiZhLnJlZi5fc3RyaW5nUmVmPT09ZSlyZXR1cm4gYS5yZWY7YT1mdW5jdGlvbihhKXt2YXIgYj1kLnJlZnM9PT1EP2QucmVmcz17fTpkLnJlZnM7bnVsbD09PWE/ZGVsZXRlIGJbZV06YltlXT1hfTthLl9zdHJpbmdSZWY9ZTtyZXR1cm4gYX1cInN0cmluZ1wiIT09dHlwZW9mIGM/RShcIjE0OFwiKTp2b2lkIDA7Yi5fb3duZXI/dm9pZCAwOkUoXCIxNDlcIixjKX1yZXR1cm4gY31cbmZ1bmN0aW9uICRlKGEsYil7XCJ0ZXh0YXJlYVwiIT09YS50eXBlJiZFKFwiMzFcIixcIltvYmplY3QgT2JqZWN0XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYikuam9pbihcIiwgXCIpK1wifVwiOmIsXCJcIil9XG5mdW5jdGlvbiBhZihhKXtmdW5jdGlvbiBiKGIsYyl7aWYoYSl7dmFyIGQ9Yi5sYXN0RWZmZWN0O251bGwhPT1kPyhkLm5leHRFZmZlY3Q9YyxiLmxhc3RFZmZlY3Q9Yyk6Yi5maXJzdEVmZmVjdD1iLmxhc3RFZmZlY3Q9YztjLm5leHRFZmZlY3Q9bnVsbDtjLmVmZmVjdFRhZz04fX1mdW5jdGlvbiBjKGMsZCl7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKDtudWxsIT09ZDspYihjLGQpLGQ9ZC5zaWJsaW5nO3JldHVybiBudWxsfWZ1bmN0aW9uIGQoYSxiKXtmb3IoYT1uZXcgTWFwO251bGwhPT1iOyludWxsIT09Yi5rZXk/YS5zZXQoYi5rZXksYik6YS5zZXQoYi5pbmRleCxiKSxiPWIuc2libGluZztyZXR1cm4gYX1mdW5jdGlvbiBlKGEsYixjKXthPXNlKGEsYixjKTthLmluZGV4PTA7YS5zaWJsaW5nPW51bGw7cmV0dXJuIGF9ZnVuY3Rpb24gZihiLGMsZCl7Yi5pbmRleD1kO2lmKCFhKXJldHVybiBjO2Q9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWQpcmV0dXJuIGQ9ZC5pbmRleCxkPGM/KGIuZWZmZWN0VGFnPVxuMixjKTpkO2IuZWZmZWN0VGFnPTI7cmV0dXJuIGN9ZnVuY3Rpb24gZyhiKXthJiZudWxsPT09Yi5hbHRlcm5hdGUmJihiLmVmZmVjdFRhZz0yKTtyZXR1cm4gYn1mdW5jdGlvbiBoKGEsYixjLGQpe2lmKG51bGw9PT1ifHw2IT09Yi50YWcpcmV0dXJuIGI9dmUoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixjLGQpO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiBrKGEsYixjLGQpe2lmKG51bGwhPT1iJiZiLnR5cGU9PT1jLnR5cGUpcmV0dXJuIGQ9ZShiLGMucHJvcHMsZCksZC5yZWY9WmUoYixjKSxkW1wicmV0dXJuXCJdPWEsZDtkPXRlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCk7ZC5yZWY9WmUoYixjKTtkW1wicmV0dXJuXCJdPWE7cmV0dXJuIGR9ZnVuY3Rpb24gcShhLGIsYyxkKXtpZihudWxsPT09Ynx8NyE9PWIudGFnKXJldHVybiBiPXdlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCksYltcInJldHVyblwiXT1hLGI7Yj1lKGIsYyxkKTtcbmJbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB2KGEsYixjLGQpe2lmKG51bGw9PT1ifHw5IT09Yi50YWcpcmV0dXJuIGI9eGUoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKSxiLnR5cGU9Yy52YWx1ZSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixudWxsLGQpO2IudHlwZT1jLnZhbHVlO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB5KGEsYixjLGQpe2lmKG51bGw9PT1ifHw0IT09Yi50YWd8fGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8hPT1jLmNvbnRhaW5lckluZm98fGIuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uIT09Yy5pbXBsZW1lbnRhdGlvbilyZXR1cm4gYj15ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLGQpLGJbXCJyZXR1cm5cIl09YSxiO2I9ZShiLGMuY2hpbGRyZW58fFtdLGQpO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB1KGEsYixjLGQsZil7aWYobnVsbD09PWJ8fDEwIT09Yi50YWcpcmV0dXJuIGI9dWUoYyxhLmludGVybmFsQ29udGV4dFRhZyxcbmQsZiksYltcInJldHVyblwiXT1hLGI7Yj1lKGIsYyxkKTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24geihhLGIsYyl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBifHxcIm51bWJlclwiPT09dHlwZW9mIGIpcmV0dXJuIGI9dmUoXCJcIitiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpLGJbXCJyZXR1cm5cIl09YSxiO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYiYmbnVsbCE9PWIpe3N3aXRjaChiLiQkdHlwZW9mKXtjYXNlIFJlOmlmKGIudHlwZT09PVZlKXJldHVybiBiPXVlKGIucHJvcHMuY2hpbGRyZW4sYS5pbnRlcm5hbENvbnRleHRUYWcsYyxiLmtleSksYltcInJldHVyblwiXT1hLGI7Yz10ZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpO2MucmVmPVplKG51bGwsYik7Y1tcInJldHVyblwiXT1hO3JldHVybiBjO2Nhc2UgU2U6cmV0dXJuIGI9d2UoYixhLmludGVybmFsQ29udGV4dFRhZyxjKSxiW1wicmV0dXJuXCJdPWEsYjtjYXNlIFRlOnJldHVybiBjPXhlKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsXG5jKSxjLnR5cGU9Yi52YWx1ZSxjW1wicmV0dXJuXCJdPWEsYztjYXNlIFVlOnJldHVybiBiPXllKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsYyksYltcInJldHVyblwiXT1hLGJ9aWYoWWUoYil8fFhlKGIpKXJldHVybiBiPXVlKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsYyxudWxsKSxiW1wicmV0dXJuXCJdPWEsYjskZShhLGIpfXJldHVybiBudWxsfWZ1bmN0aW9uIEcoYSxiLGMsZCl7dmFyIGU9bnVsbCE9PWI/Yi5rZXk6bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGN8fFwibnVtYmVyXCI9PT10eXBlb2YgYylyZXR1cm4gbnVsbCE9PWU/bnVsbDpoKGEsYixcIlwiK2MsZCk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yyl7c3dpdGNoKGMuJCR0eXBlb2Ype2Nhc2UgUmU6cmV0dXJuIGMua2V5PT09ZT9jLnR5cGU9PT1WZT91KGEsYixjLnByb3BzLmNoaWxkcmVuLGQsZSk6ayhhLGIsYyxkKTpudWxsO2Nhc2UgU2U6cmV0dXJuIGMua2V5PT09ZT9xKGEsYixjLGQpOm51bGw7Y2FzZSBUZTpyZXR1cm4gbnVsbD09PVxuZT92KGEsYixjLGQpOm51bGw7Y2FzZSBVZTpyZXR1cm4gYy5rZXk9PT1lP3koYSxiLGMsZCk6bnVsbH1pZihZZShjKXx8WGUoYykpcmV0dXJuIG51bGwhPT1lP251bGw6dShhLGIsYyxkLG51bGwpOyRlKGEsYyl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gSShhLGIsYyxkLGUpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgZHx8XCJudW1iZXJcIj09PXR5cGVvZiBkKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLGgoYixhLFwiXCIrZCxlKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kKXtzd2l0Y2goZC4kJHR5cGVvZil7Y2FzZSBSZTpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwsZC50eXBlPT09VmU/dShiLGEsZC5wcm9wcy5jaGlsZHJlbixlLGQua2V5KTprKGIsYSxkLGUpO2Nhc2UgU2U6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLHEoYixhLGQsZSk7Y2FzZSBUZTpyZXR1cm4gYT1hLmdldChjKXx8bnVsbCx2KGIsYSxkLGUpO2Nhc2UgVWU6cmV0dXJuIGE9XG5hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwseShiLGEsZCxlKX1pZihZZShkKXx8WGUoZCkpcmV0dXJuIGE9YS5nZXQoYyl8fG51bGwsdShiLGEsZCxlLG51bGwpOyRlKGIsZCl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gTChlLGcsbSxBKXtmb3IodmFyIGg9bnVsbCxyPW51bGwsbj1nLHc9Zz0wLGs9bnVsbDtudWxsIT09biYmdzxtLmxlbmd0aDt3Kyspe24uaW5kZXg+dz8oaz1uLG49bnVsbCk6az1uLnNpYmxpbmc7dmFyIHg9RyhlLG4sbVt3XSxBKTtpZihudWxsPT09eCl7bnVsbD09PW4mJihuPWspO2JyZWFrfWEmJm4mJm51bGw9PT14LmFsdGVybmF0ZSYmYihlLG4pO2c9Zih4LGcsdyk7bnVsbD09PXI/aD14OnIuc2libGluZz14O3I9eDtuPWt9aWYodz09PW0ubGVuZ3RoKXJldHVybiBjKGUsbiksaDtpZihudWxsPT09bil7Zm9yKDt3PG0ubGVuZ3RoO3crKylpZihuPXooZSxtW3ddLEEpKWc9ZihuLGcsdyksbnVsbD09PXI/aD1uOnIuc2libGluZz1uLHI9bjtyZXR1cm4gaH1mb3Iobj1cbmQoZSxuKTt3PG0ubGVuZ3RoO3crKylpZihrPUkobixlLHcsbVt3XSxBKSl7aWYoYSYmbnVsbCE9PWsuYWx0ZXJuYXRlKW5bXCJkZWxldGVcIl0obnVsbD09PWsua2V5P3c6ay5rZXkpO2c9ZihrLGcsdyk7bnVsbD09PXI/aD1rOnIuc2libGluZz1rO3I9a31hJiZuLmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGIoZSxhKX0pO3JldHVybiBofWZ1bmN0aW9uIE4oZSxnLG0sQSl7dmFyIGg9WGUobSk7XCJmdW5jdGlvblwiIT09dHlwZW9mIGg/RShcIjE1MFwiKTp2b2lkIDA7bT1oLmNhbGwobSk7bnVsbD09bT9FKFwiMTUxXCIpOnZvaWQgMDtmb3IodmFyIHI9aD1udWxsLG49Zyx3PWc9MCxrPW51bGwseD1tLm5leHQoKTtudWxsIT09biYmIXguZG9uZTt3KysseD1tLm5leHQoKSl7bi5pbmRleD53PyhrPW4sbj1udWxsKTprPW4uc2libGluZzt2YXIgSj1HKGUsbix4LnZhbHVlLEEpO2lmKG51bGw9PT1KKXtufHwobj1rKTticmVha31hJiZuJiZudWxsPT09Si5hbHRlcm5hdGUmJmIoZSxuKTtnPWYoSixcbmcsdyk7bnVsbD09PXI/aD1KOnIuc2libGluZz1KO3I9SjtuPWt9aWYoeC5kb25lKXJldHVybiBjKGUsbiksaDtpZihudWxsPT09bil7Zm9yKDsheC5kb25lO3crKyx4PW0ubmV4dCgpKXg9eihlLHgudmFsdWUsQSksbnVsbCE9PXgmJihnPWYoeCxnLHcpLG51bGw9PT1yP2g9eDpyLnNpYmxpbmc9eCxyPXgpO3JldHVybiBofWZvcihuPWQoZSxuKTsheC5kb25lO3crKyx4PW0ubmV4dCgpKWlmKHg9SShuLGUsdyx4LnZhbHVlLEEpLG51bGwhPT14KXtpZihhJiZudWxsIT09eC5hbHRlcm5hdGUpbltcImRlbGV0ZVwiXShudWxsPT09eC5rZXk/dzp4LmtleSk7Zz1mKHgsZyx3KTtudWxsPT09cj9oPXg6ci5zaWJsaW5nPXg7cj14fWEmJm4uZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYihlLGEpfSk7cmV0dXJuIGh9cmV0dXJuIGZ1bmN0aW9uKGEsZCxmLGgpe1wib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWYmJmYudHlwZT09PVZlJiZudWxsPT09Zi5rZXkmJihmPWYucHJvcHMuY2hpbGRyZW4pO1xudmFyIG09XCJvYmplY3RcIj09PXR5cGVvZiBmJiZudWxsIT09ZjtpZihtKXN3aXRjaChmLiQkdHlwZW9mKXtjYXNlIFJlOmE6e3ZhciByPWYua2V5O2ZvcihtPWQ7bnVsbCE9PW07KXtpZihtLmtleT09PXIpaWYoMTA9PT1tLnRhZz9mLnR5cGU9PT1WZTptLnR5cGU9PT1mLnR5cGUpe2MoYSxtLnNpYmxpbmcpO2Q9ZShtLGYudHlwZT09PVZlP2YucHJvcHMuY2hpbGRyZW46Zi5wcm9wcyxoKTtkLnJlZj1aZShtLGYpO2RbXCJyZXR1cm5cIl09YTthPWQ7YnJlYWsgYX1lbHNle2MoYSxtKTticmVha31lbHNlIGIoYSxtKTttPW0uc2libGluZ31mLnR5cGU9PT1WZT8oZD11ZShmLnByb3BzLmNoaWxkcmVuLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgsZi5rZXkpLGRbXCJyZXR1cm5cIl09YSxhPWQpOihoPXRlKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCksaC5yZWY9WmUoZCxmKSxoW1wicmV0dXJuXCJdPWEsYT1oKX1yZXR1cm4gZyhhKTtjYXNlIFNlOmE6e2ZvcihtPWYua2V5O251bGwhPT1kOyl7aWYoZC5rZXk9PT1cbm0paWYoNz09PWQudGFnKXtjKGEsZC5zaWJsaW5nKTtkPWUoZCxmLGgpO2RbXCJyZXR1cm5cIl09YTthPWQ7YnJlYWsgYX1lbHNle2MoYSxkKTticmVha31lbHNlIGIoYSxkKTtkPWQuc2libGluZ31kPXdlKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCk7ZFtcInJldHVyblwiXT1hO2E9ZH1yZXR1cm4gZyhhKTtjYXNlIFRlOmE6e2lmKG51bGwhPT1kKWlmKDk9PT1kLnRhZyl7YyhhLGQuc2libGluZyk7ZD1lKGQsbnVsbCxoKTtkLnR5cGU9Zi52YWx1ZTtkW1wicmV0dXJuXCJdPWE7YT1kO2JyZWFrIGF9ZWxzZSBjKGEsZCk7ZD14ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpO2QudHlwZT1mLnZhbHVlO2RbXCJyZXR1cm5cIl09YTthPWR9cmV0dXJuIGcoYSk7Y2FzZSBVZTphOntmb3IobT1mLmtleTtudWxsIT09ZDspe2lmKGQua2V5PT09bSlpZig0PT09ZC50YWcmJmQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm89PT1mLmNvbnRhaW5lckluZm8mJmQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uPT09XG5mLmltcGxlbWVudGF0aW9uKXtjKGEsZC5zaWJsaW5nKTtkPWUoZCxmLmNoaWxkcmVufHxbXSxoKTtkW1wicmV0dXJuXCJdPWE7YT1kO2JyZWFrIGF9ZWxzZXtjKGEsZCk7YnJlYWt9ZWxzZSBiKGEsZCk7ZD1kLnNpYmxpbmd9ZD15ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpO2RbXCJyZXR1cm5cIl09YTthPWR9cmV0dXJuIGcoYSl9aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBmfHxcIm51bWJlclwiPT09dHlwZW9mIGYpcmV0dXJuIGY9XCJcIitmLG51bGwhPT1kJiY2PT09ZC50YWc/KGMoYSxkLnNpYmxpbmcpLGQ9ZShkLGYsaCkpOihjKGEsZCksZD12ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpKSxkW1wicmV0dXJuXCJdPWEsYT1kLGcoYSk7aWYoWWUoZikpcmV0dXJuIEwoYSxkLGYsaCk7aWYoWGUoZikpcmV0dXJuIE4oYSxkLGYsaCk7bSYmJGUoYSxmKTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGYpc3dpdGNoKGEudGFnKXtjYXNlIDI6Y2FzZSAxOmg9YS50eXBlLEUoXCIxNTJcIixoLmRpc3BsYXlOYW1lfHxcbmgubmFtZXx8XCJDb21wb25lbnRcIil9cmV0dXJuIGMoYSxkKX19dmFyIGJmPWFmKCEwKSxjZj1hZighMSk7XG5mdW5jdGlvbiBkZihhLGIsYyxkLGUpe2Z1bmN0aW9uIGYoYSxiLGMpe3ZhciBkPWIuZXhwaXJhdGlvblRpbWU7Yi5jaGlsZD1udWxsPT09YT9jZihiLG51bGwsYyxkKTpiZihiLGEuY2hpbGQsYyxkKX1mdW5jdGlvbiBnKGEsYil7dmFyIGM9Yi5yZWY7bnVsbD09PWN8fGEmJmEucmVmPT09Y3x8KGIuZWZmZWN0VGFnfD0xMjgpfWZ1bmN0aW9uIGgoYSxiLGMsZCl7ZyhhLGIpO2lmKCFjKXJldHVybiBkJiZyZShiLCExKSxxKGEsYik7Yz1iLnN0YXRlTm9kZTtpZC5jdXJyZW50PWI7dmFyIGU9Yy5yZW5kZXIoKTtiLmVmZmVjdFRhZ3w9MTtmKGEsYixlKTtiLm1lbW9pemVkU3RhdGU9Yy5zdGF0ZTtiLm1lbW9pemVkUHJvcHM9Yy5wcm9wcztkJiZyZShiLCEwKTtyZXR1cm4gYi5jaGlsZH1mdW5jdGlvbiBrKGEpe3ZhciBiPWEuc3RhdGVOb2RlO2IucGVuZGluZ0NvbnRleHQ/b2UoYSxiLnBlbmRpbmdDb250ZXh0LGIucGVuZGluZ0NvbnRleHQhPT1iLmNvbnRleHQpOmIuY29udGV4dCYmb2UoYSxcbmIuY29udGV4dCwhMSk7SShhLGIuY29udGFpbmVySW5mbyl9ZnVuY3Rpb24gcShhLGIpe251bGwhPT1hJiZiLmNoaWxkIT09YS5jaGlsZD9FKFwiMTUzXCIpOnZvaWQgMDtpZihudWxsIT09Yi5jaGlsZCl7YT1iLmNoaWxkO3ZhciBjPXNlKGEsYS5wZW5kaW5nUHJvcHMsYS5leHBpcmF0aW9uVGltZSk7Yi5jaGlsZD1jO2ZvcihjW1wicmV0dXJuXCJdPWI7bnVsbCE9PWEuc2libGluZzspYT1hLnNpYmxpbmcsYz1jLnNpYmxpbmc9c2UoYSxhLnBlbmRpbmdQcm9wcyxhLmV4cGlyYXRpb25UaW1lKSxjW1wicmV0dXJuXCJdPWI7Yy5zaWJsaW5nPW51bGx9cmV0dXJuIGIuY2hpbGR9ZnVuY3Rpb24gdihhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAzOmsoYik7YnJlYWs7Y2FzZSAyOnFlKGIpO2JyZWFrO2Nhc2UgNDpJKGIsYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyl9cmV0dXJuIG51bGx9dmFyIHk9YS5zaG91bGRTZXRUZXh0Q29udGVudCx1PWEudXNlU3luY1NjaGVkdWxpbmcsej1hLnNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUsXG5HPWIucHVzaEhvc3RDb250ZXh0LEk9Yi5wdXNoSG9zdENvbnRhaW5lcixMPWMuZW50ZXJIeWRyYXRpb25TdGF0ZSxOPWMucmVzZXRIeWRyYXRpb25TdGF0ZSxKPWMudHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U7YT1MZShkLGUsZnVuY3Rpb24oYSxiKXthLm1lbW9pemVkUHJvcHM9Yn0sZnVuY3Rpb24oYSxiKXthLm1lbW9pemVkU3RhdGU9Yn0pO3ZhciB3PWEuYWRvcHRDbGFzc0luc3RhbmNlLG09YS5jb25zdHJ1Y3RDbGFzc0luc3RhbmNlLEE9YS5tb3VudENsYXNzSW5zdGFuY2UsT2I9YS51cGRhdGVDbGFzc0luc3RhbmNlO3JldHVybntiZWdpbldvcms6ZnVuY3Rpb24oYSxiLGMpe2lmKDA9PT1iLmV4cGlyYXRpb25UaW1lfHxiLmV4cGlyYXRpb25UaW1lPmMpcmV0dXJuIHYoYSxiKTtzd2l0Y2goYi50YWcpe2Nhc2UgMDpudWxsIT09YT9FKFwiMTU1XCIpOnZvaWQgMDt2YXIgZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxyPWtlKGIpO3I9bWUoYixyKTtkPWQoZSxyKTtiLmVmZmVjdFRhZ3w9XG4xO1wib2JqZWN0XCI9PT10eXBlb2YgZCYmbnVsbCE9PWQmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLnJlbmRlcj8oYi50YWc9MixlPXFlKGIpLHcoYixkKSxBKGIsYyksYj1oKGEsYiwhMCxlKSk6KGIudGFnPTEsZihhLGIsZCksYi5tZW1vaXplZFByb3BzPWUsYj1iLmNoaWxkKTtyZXR1cm4gYjtjYXNlIDE6YTp7ZT1iLnR5cGU7Yz1iLnBlbmRpbmdQcm9wcztkPWIubWVtb2l6ZWRQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWMmJihjPWQpO2Vsc2UgaWYobnVsbD09PWN8fGQ9PT1jKXtiPXEoYSxiKTticmVhayBhfWQ9a2UoYik7ZD1tZShiLGQpO2U9ZShjLGQpO2IuZWZmZWN0VGFnfD0xO2YoYSxiLGUpO2IubWVtb2l6ZWRQcm9wcz1jO2I9Yi5jaGlsZH1yZXR1cm4gYjtjYXNlIDI6cmV0dXJuIGU9cWUoYiksZD12b2lkIDAsbnVsbD09PWE/Yi5zdGF0ZU5vZGU/RShcIjE1M1wiKToobShiLGIucGVuZGluZ1Byb3BzKSxBKGIsYyksZD0hMCk6ZD1PYihhLGIsYyksaChhLGIsZCxlKTtjYXNlIDM6cmV0dXJuIGsoYiksXG5lPWIudXBkYXRlUXVldWUsbnVsbCE9PWU/KGQ9Yi5tZW1vaXplZFN0YXRlLGU9SmUoYSxiLGUsbnVsbCxudWxsLGMpLGQ9PT1lPyhOKCksYj1xKGEsYikpOihkPWUuZWxlbWVudCxyPWIuc3RhdGVOb2RlLChudWxsPT09YXx8bnVsbD09PWEuY2hpbGQpJiZyLmh5ZHJhdGUmJkwoYik/KGIuZWZmZWN0VGFnfD0yLGIuY2hpbGQ9Y2YoYixudWxsLGQsYykpOihOKCksZihhLGIsZCkpLGIubWVtb2l6ZWRTdGF0ZT1lLGI9Yi5jaGlsZCkpOihOKCksYj1xKGEsYikpLGI7Y2FzZSA1OkcoYik7bnVsbD09PWEmJkooYik7ZT1iLnR5cGU7dmFyIG49Yi5tZW1vaXplZFByb3BzO2Q9Yi5wZW5kaW5nUHJvcHM7bnVsbD09PWQmJihkPW4sbnVsbD09PWQ/RShcIjE1NFwiKTp2b2lkIDApO3I9bnVsbCE9PWE/YS5tZW1vaXplZFByb3BzOm51bGw7WC5jdXJyZW50fHxudWxsIT09ZCYmbiE9PWQ/KG49ZC5jaGlsZHJlbix5KGUsZCk/bj1udWxsOnImJnkoZSxyKSYmKGIuZWZmZWN0VGFnfD0xNiksZyhhLGIpLFxuMjE0NzQ4MzY0NyE9PWMmJiF1JiZ6KGUsZCk/KGIuZXhwaXJhdGlvblRpbWU9MjE0NzQ4MzY0NyxiPW51bGwpOihmKGEsYixuKSxiLm1lbW9pemVkUHJvcHM9ZCxiPWIuY2hpbGQpKTpiPXEoYSxiKTtyZXR1cm4gYjtjYXNlIDY6cmV0dXJuIG51bGw9PT1hJiZKKGIpLGE9Yi5wZW5kaW5nUHJvcHMsbnVsbD09PWEmJihhPWIubWVtb2l6ZWRQcm9wcyksYi5tZW1vaXplZFByb3BzPWEsbnVsbDtjYXNlIDg6Yi50YWc9NztjYXNlIDc6ZT1iLnBlbmRpbmdQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWUmJihlPWEmJmEubWVtb2l6ZWRQcm9wcyxudWxsPT09ZT9FKFwiMTU0XCIpOnZvaWQgMCk7ZWxzZSBpZihudWxsPT09ZXx8Yi5tZW1vaXplZFByb3BzPT09ZSllPWIubWVtb2l6ZWRQcm9wcztkPWUuY2hpbGRyZW47Yi5zdGF0ZU5vZGU9bnVsbD09PWE/Y2YoYixiLnN0YXRlTm9kZSxkLGMpOmJmKGIsYi5zdGF0ZU5vZGUsZCxjKTtiLm1lbW9pemVkUHJvcHM9ZTtyZXR1cm4gYi5zdGF0ZU5vZGU7XG5jYXNlIDk6cmV0dXJuIG51bGw7Y2FzZSA0OmE6e0koYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtlPWIucGVuZGluZ1Byb3BzO2lmKFguY3VycmVudCludWxsPT09ZSYmKGU9YSYmYS5tZW1vaXplZFByb3BzLG51bGw9PWU/RShcIjE1NFwiKTp2b2lkIDApO2Vsc2UgaWYobnVsbD09PWV8fGIubWVtb2l6ZWRQcm9wcz09PWUpe2I9cShhLGIpO2JyZWFrIGF9bnVsbD09PWE/Yi5jaGlsZD1iZihiLG51bGwsZSxjKTpmKGEsYixlKTtiLm1lbW9pemVkUHJvcHM9ZTtiPWIuY2hpbGR9cmV0dXJuIGI7Y2FzZSAxMDphOntjPWIucGVuZGluZ1Byb3BzO2lmKFguY3VycmVudCludWxsPT09YyYmKGM9Yi5tZW1vaXplZFByb3BzKTtlbHNlIGlmKG51bGw9PT1jfHxiLm1lbW9pemVkUHJvcHM9PT1jKXtiPXEoYSxiKTticmVhayBhfWYoYSxiLGMpO2IubWVtb2l6ZWRQcm9wcz1jO2I9Yi5jaGlsZH1yZXR1cm4gYjtkZWZhdWx0OkUoXCIxNTZcIil9fSxiZWdpbkZhaWxlZFdvcms6ZnVuY3Rpb24oYSxiLFxuYyl7c3dpdGNoKGIudGFnKXtjYXNlIDI6cWUoYik7YnJlYWs7Y2FzZSAzOmsoYik7YnJlYWs7ZGVmYXVsdDpFKFwiMTU3XCIpfWIuZWZmZWN0VGFnfD02NDtudWxsPT09YT9iLmNoaWxkPW51bGw6Yi5jaGlsZCE9PWEuY2hpbGQmJihiLmNoaWxkPWEuY2hpbGQpO2lmKDA9PT1iLmV4cGlyYXRpb25UaW1lfHxiLmV4cGlyYXRpb25UaW1lPmMpcmV0dXJuIHYoYSxiKTtiLmZpcnN0RWZmZWN0PW51bGw7Yi5sYXN0RWZmZWN0PW51bGw7Yi5jaGlsZD1udWxsPT09YT9jZihiLG51bGwsbnVsbCxjKTpiZihiLGEuY2hpbGQsbnVsbCxjKTsyPT09Yi50YWcmJihhPWIuc3RhdGVOb2RlLGIubWVtb2l6ZWRQcm9wcz1hLnByb3BzLGIubWVtb2l6ZWRTdGF0ZT1hLnN0YXRlKTtyZXR1cm4gYi5jaGlsZH19fVxuZnVuY3Rpb24gZWYoYSxiLGMpe2Z1bmN0aW9uIGQoYSl7YS5lZmZlY3RUYWd8PTR9dmFyIGU9YS5jcmVhdGVJbnN0YW5jZSxmPWEuY3JlYXRlVGV4dEluc3RhbmNlLGc9YS5hcHBlbmRJbml0aWFsQ2hpbGQsaD1hLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuLGs9YS5wcmVwYXJlVXBkYXRlLHE9YS5wZXJzaXN0ZW5jZSx2PWIuZ2V0Um9vdEhvc3RDb250YWluZXIseT1iLnBvcEhvc3RDb250ZXh0LHU9Yi5nZXRIb3N0Q29udGV4dCx6PWIucG9wSG9zdENvbnRhaW5lcixHPWMucHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxJPWMucHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UsTD1jLnBvcEh5ZHJhdGlvblN0YXRlLE49dm9pZCAwLEo9dm9pZCAwLHc9dm9pZCAwO2EubXV0YXRpb24/KE49ZnVuY3Rpb24oKXt9LEo9ZnVuY3Rpb24oYSxiLGMpeyhiLnVwZGF0ZVF1ZXVlPWMpJiZkKGIpfSx3PWZ1bmN0aW9uKGEsYixjLGUpe2MhPT1lJiZkKGIpfSk6cT9FKFwiMjM1XCIpOkUoXCIyMzZcIik7XG5yZXR1cm57Y29tcGxldGVXb3JrOmZ1bmN0aW9uKGEsYixjKXt2YXIgbT1iLnBlbmRpbmdQcm9wcztpZihudWxsPT09bSltPWIubWVtb2l6ZWRQcm9wcztlbHNlIGlmKDIxNDc0ODM2NDchPT1iLmV4cGlyYXRpb25UaW1lfHwyMTQ3NDgzNjQ3PT09YyliLnBlbmRpbmdQcm9wcz1udWxsO3N3aXRjaChiLnRhZyl7Y2FzZSAxOnJldHVybiBudWxsO2Nhc2UgMjpyZXR1cm4gbmUoYiksbnVsbDtjYXNlIDM6eihiKTtWKFgsYik7VihpZSxiKTttPWIuc3RhdGVOb2RlO20ucGVuZGluZ0NvbnRleHQmJihtLmNvbnRleHQ9bS5wZW5kaW5nQ29udGV4dCxtLnBlbmRpbmdDb250ZXh0PW51bGwpO2lmKG51bGw9PT1hfHxudWxsPT09YS5jaGlsZClMKGIpLGIuZWZmZWN0VGFnJj0tMztOKGIpO3JldHVybiBudWxsO2Nhc2UgNTp5KGIpO2M9digpO3ZhciBBPWIudHlwZTtpZihudWxsIT09YSYmbnVsbCE9Yi5zdGF0ZU5vZGUpe3ZhciBwPWEubWVtb2l6ZWRQcm9wcyxxPWIuc3RhdGVOb2RlLHg9dSgpO3E9XG5rKHEsQSxwLG0sYyx4KTtKKGEsYixxLEEscCxtLGMpO2EucmVmIT09Yi5yZWYmJihiLmVmZmVjdFRhZ3w9MTI4KX1lbHNle2lmKCFtKXJldHVybiBudWxsPT09Yi5zdGF0ZU5vZGU/RShcIjE2NlwiKTp2b2lkIDAsbnVsbDthPXUoKTtpZihMKGIpKUcoYixjLGEpJiZkKGIpO2Vsc2V7YT1lKEEsbSxjLGEsYik7YTpmb3IocD1iLmNoaWxkO251bGwhPT1wOyl7aWYoNT09PXAudGFnfHw2PT09cC50YWcpZyhhLHAuc3RhdGVOb2RlKTtlbHNlIGlmKDQhPT1wLnRhZyYmbnVsbCE9PXAuY2hpbGQpe3AuY2hpbGRbXCJyZXR1cm5cIl09cDtwPXAuY2hpbGQ7Y29udGludWV9aWYocD09PWIpYnJlYWs7Zm9yKDtudWxsPT09cC5zaWJsaW5nOyl7aWYobnVsbD09PXBbXCJyZXR1cm5cIl18fHBbXCJyZXR1cm5cIl09PT1iKWJyZWFrIGE7cD1wW1wicmV0dXJuXCJdfXAuc2libGluZ1tcInJldHVyblwiXT1wW1wicmV0dXJuXCJdO3A9cC5zaWJsaW5nfWgoYSxBLG0sYykmJmQoYik7Yi5zdGF0ZU5vZGU9YX1udWxsIT09Yi5yZWYmJlxuKGIuZWZmZWN0VGFnfD0xMjgpfXJldHVybiBudWxsO2Nhc2UgNjppZihhJiZudWxsIT1iLnN0YXRlTm9kZSl3KGEsYixhLm1lbW9pemVkUHJvcHMsbSk7ZWxzZXtpZihcInN0cmluZ1wiIT09dHlwZW9mIG0pcmV0dXJuIG51bGw9PT1iLnN0YXRlTm9kZT9FKFwiMTY2XCIpOnZvaWQgMCxudWxsO2E9digpO2M9dSgpO0woYik/SShiKSYmZChiKTpiLnN0YXRlTm9kZT1mKG0sYSxjLGIpfXJldHVybiBudWxsO2Nhc2UgNzoobT1iLm1lbW9pemVkUHJvcHMpP3ZvaWQgMDpFKFwiMTY1XCIpO2IudGFnPTg7QT1bXTthOmZvcigocD1iLnN0YXRlTm9kZSkmJihwW1wicmV0dXJuXCJdPWIpO251bGwhPT1wOyl7aWYoNT09PXAudGFnfHw2PT09cC50YWd8fDQ9PT1wLnRhZylFKFwiMjQ3XCIpO2Vsc2UgaWYoOT09PXAudGFnKUEucHVzaChwLnR5cGUpO2Vsc2UgaWYobnVsbCE9PXAuY2hpbGQpe3AuY2hpbGRbXCJyZXR1cm5cIl09cDtwPXAuY2hpbGQ7Y29udGludWV9Zm9yKDtudWxsPT09cC5zaWJsaW5nOyl7aWYobnVsbD09PVxucFtcInJldHVyblwiXXx8cFtcInJldHVyblwiXT09PWIpYnJlYWsgYTtwPXBbXCJyZXR1cm5cIl19cC5zaWJsaW5nW1wicmV0dXJuXCJdPXBbXCJyZXR1cm5cIl07cD1wLnNpYmxpbmd9cD1tLmhhbmRsZXI7bT1wKG0ucHJvcHMsQSk7Yi5jaGlsZD1iZihiLG51bGwhPT1hP2EuY2hpbGQ6bnVsbCxtLGMpO3JldHVybiBiLmNoaWxkO2Nhc2UgODpyZXR1cm4gYi50YWc9NyxudWxsO2Nhc2UgOTpyZXR1cm4gbnVsbDtjYXNlIDEwOnJldHVybiBudWxsO2Nhc2UgNDpyZXR1cm4geihiKSxOKGIpLG51bGw7Y2FzZSAwOkUoXCIxNjdcIik7ZGVmYXVsdDpFKFwiMTU2XCIpfX19fVxuZnVuY3Rpb24gZmYoYSxiKXtmdW5jdGlvbiBjKGEpe3ZhciBjPWEucmVmO2lmKG51bGwhPT1jKXRyeXtjKG51bGwpfWNhdGNoKEEpe2IoYSxBKX19ZnVuY3Rpb24gZChhKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgRWUmJkVlKGEpO3N3aXRjaChhLnRhZyl7Y2FzZSAyOmMoYSk7dmFyIGQ9YS5zdGF0ZU5vZGU7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50V2lsbFVubW91bnQpdHJ5e2QucHJvcHM9YS5tZW1vaXplZFByb3BzLGQuc3RhdGU9YS5tZW1vaXplZFN0YXRlLGQuY29tcG9uZW50V2lsbFVubW91bnQoKX1jYXRjaChBKXtiKGEsQSl9YnJlYWs7Y2FzZSA1OmMoYSk7YnJlYWs7Y2FzZSA3OmUoYS5zdGF0ZU5vZGUpO2JyZWFrO2Nhc2UgNDprJiZnKGEpfX1mdW5jdGlvbiBlKGEpe2Zvcih2YXIgYj1hOzspaWYoZChiKSxudWxsPT09Yi5jaGlsZHx8ayYmND09PWIudGFnKXtpZihiPT09YSlicmVhaztmb3IoO251bGw9PT1iLnNpYmxpbmc7KXtpZihudWxsPT09YltcInJldHVyblwiXXx8XG5iW1wicmV0dXJuXCJdPT09YSlyZXR1cm47Yj1iW1wicmV0dXJuXCJdfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfWVsc2UgYi5jaGlsZFtcInJldHVyblwiXT1iLGI9Yi5jaGlsZH1mdW5jdGlvbiBmKGEpe3JldHVybiA1PT09YS50YWd8fDM9PT1hLnRhZ3x8ND09PWEudGFnfWZ1bmN0aW9uIGcoYSl7Zm9yKHZhciBiPWEsYz0hMSxmPXZvaWQgMCxnPXZvaWQgMDs7KXtpZighYyl7Yz1iW1wicmV0dXJuXCJdO2E6Zm9yKDs7KXtudWxsPT09Yz9FKFwiMTYwXCIpOnZvaWQgMDtzd2l0Y2goYy50YWcpe2Nhc2UgNTpmPWMuc3RhdGVOb2RlO2c9ITE7YnJlYWsgYTtjYXNlIDM6Zj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2c9ITA7YnJlYWsgYTtjYXNlIDQ6Zj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2c9ITA7YnJlYWsgYX1jPWNbXCJyZXR1cm5cIl19Yz0hMH1pZig1PT09Yi50YWd8fDY9PT1iLnRhZyllKGIpLGc/SihmLGIuc3RhdGVOb2RlKTpOKGYsYi5zdGF0ZU5vZGUpO1xuZWxzZSBpZig0PT09Yi50YWc/Zj1iLnN0YXRlTm9kZS5jb250YWluZXJJbmZvOmQoYiksbnVsbCE9PWIuY2hpbGQpe2IuY2hpbGRbXCJyZXR1cm5cIl09YjtiPWIuY2hpbGQ7Y29udGludWV9aWYoYj09PWEpYnJlYWs7Zm9yKDtudWxsPT09Yi5zaWJsaW5nOyl7aWYobnVsbD09PWJbXCJyZXR1cm5cIl18fGJbXCJyZXR1cm5cIl09PT1hKXJldHVybjtiPWJbXCJyZXR1cm5cIl07ND09PWIudGFnJiYoYz0hMSl9Yi5zaWJsaW5nW1wicmV0dXJuXCJdPWJbXCJyZXR1cm5cIl07Yj1iLnNpYmxpbmd9fXZhciBoPWEuZ2V0UHVibGljSW5zdGFuY2Usaz1hLm11dGF0aW9uO2E9YS5wZXJzaXN0ZW5jZTtrfHwoYT9FKFwiMjM1XCIpOkUoXCIyMzZcIikpO3ZhciBxPWsuY29tbWl0TW91bnQsdj1rLmNvbW1pdFVwZGF0ZSx5PWsucmVzZXRUZXh0Q29udGVudCx1PWsuY29tbWl0VGV4dFVwZGF0ZSx6PWsuYXBwZW5kQ2hpbGQsRz1rLmFwcGVuZENoaWxkVG9Db250YWluZXIsST1rLmluc2VydEJlZm9yZSxMPWsuaW5zZXJ0SW5Db250YWluZXJCZWZvcmUsXG5OPWsucmVtb3ZlQ2hpbGQsSj1rLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtyZXR1cm57Y29tbWl0UmVzZXRUZXh0Q29udGVudDpmdW5jdGlvbihhKXt5KGEuc3RhdGVOb2RlKX0sY29tbWl0UGxhY2VtZW50OmZ1bmN0aW9uKGEpe2E6e2Zvcih2YXIgYj1hW1wicmV0dXJuXCJdO251bGwhPT1iOyl7aWYoZihiKSl7dmFyIGM9YjticmVhayBhfWI9YltcInJldHVyblwiXX1FKFwiMTYwXCIpO2M9dm9pZCAwfXZhciBkPWI9dm9pZCAwO3N3aXRjaChjLnRhZyl7Y2FzZSA1OmI9Yy5zdGF0ZU5vZGU7ZD0hMTticmVhaztjYXNlIDM6Yj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2Q9ITA7YnJlYWs7Y2FzZSA0OmI9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2RlZmF1bHQ6RShcIjE2MVwiKX1jLmVmZmVjdFRhZyYxNiYmKHkoYiksYy5lZmZlY3RUYWcmPS0xNyk7YTpiOmZvcihjPWE7Oyl7Zm9yKDtudWxsPT09Yy5zaWJsaW5nOyl7aWYobnVsbD09PWNbXCJyZXR1cm5cIl18fGYoY1tcInJldHVyblwiXSkpe2M9XG5udWxsO2JyZWFrIGF9Yz1jW1wicmV0dXJuXCJdfWMuc2libGluZ1tcInJldHVyblwiXT1jW1wicmV0dXJuXCJdO2ZvcihjPWMuc2libGluZzs1IT09Yy50YWcmJjYhPT1jLnRhZzspe2lmKGMuZWZmZWN0VGFnJjIpY29udGludWUgYjtpZihudWxsPT09Yy5jaGlsZHx8ND09PWMudGFnKWNvbnRpbnVlIGI7ZWxzZSBjLmNoaWxkW1wicmV0dXJuXCJdPWMsYz1jLmNoaWxkfWlmKCEoYy5lZmZlY3RUYWcmMikpe2M9Yy5zdGF0ZU5vZGU7YnJlYWsgYX19Zm9yKHZhciBlPWE7Oyl7aWYoNT09PWUudGFnfHw2PT09ZS50YWcpYz9kP0woYixlLnN0YXRlTm9kZSxjKTpJKGIsZS5zdGF0ZU5vZGUsYyk6ZD9HKGIsZS5zdGF0ZU5vZGUpOnooYixlLnN0YXRlTm9kZSk7ZWxzZSBpZig0IT09ZS50YWcmJm51bGwhPT1lLmNoaWxkKXtlLmNoaWxkW1wicmV0dXJuXCJdPWU7ZT1lLmNoaWxkO2NvbnRpbnVlfWlmKGU9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWUuc2libGluZzspe2lmKG51bGw9PT1lW1wicmV0dXJuXCJdfHxlW1wicmV0dXJuXCJdPT09XG5hKXJldHVybjtlPWVbXCJyZXR1cm5cIl19ZS5zaWJsaW5nW1wicmV0dXJuXCJdPWVbXCJyZXR1cm5cIl07ZT1lLnNpYmxpbmd9fSxjb21taXREZWxldGlvbjpmdW5jdGlvbihhKXtnKGEpO2FbXCJyZXR1cm5cIl09bnVsbDthLmNoaWxkPW51bGw7YS5hbHRlcm5hdGUmJihhLmFsdGVybmF0ZS5jaGlsZD1udWxsLGEuYWx0ZXJuYXRlW1wicmV0dXJuXCJdPW51bGwpfSxjb21taXRXb3JrOmZ1bmN0aW9uKGEsYil7c3dpdGNoKGIudGFnKXtjYXNlIDI6YnJlYWs7Y2FzZSA1OnZhciBjPWIuc3RhdGVOb2RlO2lmKG51bGwhPWMpe3ZhciBkPWIubWVtb2l6ZWRQcm9wczthPW51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpkO3ZhciBlPWIudHlwZSxmPWIudXBkYXRlUXVldWU7Yi51cGRhdGVRdWV1ZT1udWxsO251bGwhPT1mJiZ2KGMsZixlLGEsZCxiKX1icmVhaztjYXNlIDY6bnVsbD09PWIuc3RhdGVOb2RlP0UoXCIxNjJcIik6dm9pZCAwO2M9Yi5tZW1vaXplZFByb3BzO3UoYi5zdGF0ZU5vZGUsbnVsbCE9PWE/YS5tZW1vaXplZFByb3BzOlxuYyxjKTticmVhaztjYXNlIDM6YnJlYWs7ZGVmYXVsdDpFKFwiMTYzXCIpfX0sY29tbWl0TGlmZUN5Y2xlczpmdW5jdGlvbihhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAyOnZhciBjPWIuc3RhdGVOb2RlO2lmKGIuZWZmZWN0VGFnJjQpaWYobnVsbD09PWEpYy5wcm9wcz1iLm1lbW9pemVkUHJvcHMsYy5zdGF0ZT1iLm1lbW9pemVkU3RhdGUsYy5jb21wb25lbnREaWRNb3VudCgpO2Vsc2V7dmFyIGQ9YS5tZW1vaXplZFByb3BzO2E9YS5tZW1vaXplZFN0YXRlO2MucHJvcHM9Yi5tZW1vaXplZFByb3BzO2Muc3RhdGU9Yi5tZW1vaXplZFN0YXRlO2MuY29tcG9uZW50RGlkVXBkYXRlKGQsYSl9Yj1iLnVwZGF0ZVF1ZXVlO251bGwhPT1iJiZLZShiLGMpO2JyZWFrO2Nhc2UgMzpjPWIudXBkYXRlUXVldWU7bnVsbCE9PWMmJktlKGMsbnVsbCE9PWIuY2hpbGQ/Yi5jaGlsZC5zdGF0ZU5vZGU6bnVsbCk7YnJlYWs7Y2FzZSA1OmM9Yi5zdGF0ZU5vZGU7bnVsbD09PWEmJmIuZWZmZWN0VGFnJjQmJnEoYyxcbmIudHlwZSxiLm1lbW9pemVkUHJvcHMsYik7YnJlYWs7Y2FzZSA2OmJyZWFrO2Nhc2UgNDpicmVhaztkZWZhdWx0OkUoXCIxNjNcIil9fSxjb21taXRBdHRhY2hSZWY6ZnVuY3Rpb24oYSl7dmFyIGI9YS5yZWY7aWYobnVsbCE9PWIpe3ZhciBjPWEuc3RhdGVOb2RlO3N3aXRjaChhLnRhZyl7Y2FzZSA1OmIoaChjKSk7YnJlYWs7ZGVmYXVsdDpiKGMpfX19LGNvbW1pdERldGFjaFJlZjpmdW5jdGlvbihhKXthPWEucmVmO251bGwhPT1hJiZhKG51bGwpfX19dmFyIGdmPXt9O1xuZnVuY3Rpb24gaGYoYSl7ZnVuY3Rpb24gYihhKXthPT09Z2Y/RShcIjE3NFwiKTp2b2lkIDA7cmV0dXJuIGF9dmFyIGM9YS5nZXRDaGlsZEhvc3RDb250ZXh0LGQ9YS5nZXRSb290SG9zdENvbnRleHQsZT17Y3VycmVudDpnZn0sZj17Y3VycmVudDpnZn0sZz17Y3VycmVudDpnZn07cmV0dXJue2dldEhvc3RDb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIGIoZS5jdXJyZW50KX0sZ2V0Um9vdEhvc3RDb250YWluZXI6ZnVuY3Rpb24oKXtyZXR1cm4gYihnLmN1cnJlbnQpfSxwb3BIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKGEpe1YoZSxhKTtWKGYsYSk7VihnLGEpfSxwb3BIb3N0Q29udGV4dDpmdW5jdGlvbihhKXtmLmN1cnJlbnQ9PT1hJiYoVihlLGEpLFYoZixhKSl9LHB1c2hIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKGEsYil7VyhnLGIsYSk7Yj1kKGIpO1coZixhLGEpO1coZSxiLGEpfSxwdXNoSG9zdENvbnRleHQ6ZnVuY3Rpb24oYSl7dmFyIGQ9YihnLmN1cnJlbnQpLGg9YihlLmN1cnJlbnQpO1xuZD1jKGgsYS50eXBlLGQpO2ghPT1kJiYoVyhmLGEsYSksVyhlLGQsYSkpfSxyZXNldEhvc3RDb250YWluZXI6ZnVuY3Rpb24oKXtlLmN1cnJlbnQ9Z2Y7Zy5jdXJyZW50PWdmfX19XG5mdW5jdGlvbiBqZihhKXtmdW5jdGlvbiBiKGEsYil7dmFyIGM9bmV3IFkoNSxudWxsLDApO2MudHlwZT1cIkRFTEVURURcIjtjLnN0YXRlTm9kZT1iO2NbXCJyZXR1cm5cIl09YTtjLmVmZmVjdFRhZz04O251bGwhPT1hLmxhc3RFZmZlY3Q/KGEubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWMsYS5sYXN0RWZmZWN0PWMpOmEuZmlyc3RFZmZlY3Q9YS5sYXN0RWZmZWN0PWN9ZnVuY3Rpb24gYyhhLGIpe3N3aXRjaChhLnRhZyl7Y2FzZSA1OnJldHVybiBiPWYoYixhLnR5cGUsYS5wZW5kaW5nUHJvcHMpLG51bGwhPT1iPyhhLnN0YXRlTm9kZT1iLCEwKTohMTtjYXNlIDY6cmV0dXJuIGI9ZyhiLGEucGVuZGluZ1Byb3BzKSxudWxsIT09Yj8oYS5zdGF0ZU5vZGU9YiwhMCk6ITE7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gZChhKXtmb3IoYT1hW1wicmV0dXJuXCJdO251bGwhPT1hJiY1IT09YS50YWcmJjMhPT1hLnRhZzspYT1hW1wicmV0dXJuXCJdO3k9YX12YXIgZT1hLnNob3VsZFNldFRleHRDb250ZW50O1xuYT1hLmh5ZHJhdGlvbjtpZighYSlyZXR1cm57ZW50ZXJIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe3JldHVybiExfSxyZXNldEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKCl7fSx0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTpmdW5jdGlvbigpe30scHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTpmdW5jdGlvbigpe0UoXCIxNzVcIil9LHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7RShcIjE3NlwiKX0scG9wSHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4hMX19O3ZhciBmPWEuY2FuSHlkcmF0ZUluc3RhbmNlLGc9YS5jYW5IeWRyYXRlVGV4dEluc3RhbmNlLGg9YS5nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcsaz1hLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkLHE9YS5oeWRyYXRlSW5zdGFuY2Usdj1hLmh5ZHJhdGVUZXh0SW5zdGFuY2UseT1udWxsLHU9bnVsbCx6PSExO3JldHVybntlbnRlckh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKGEpe3U9XG5rKGEuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO3k9YTtyZXR1cm4gej0hMH0scmVzZXRIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe3U9eT1udWxsO3o9ITF9LHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOmZ1bmN0aW9uKGEpe2lmKHope3ZhciBkPXU7aWYoZCl7aWYoIWMoYSxkKSl7ZD1oKGQpO2lmKCFkfHwhYyhhLGQpKXthLmVmZmVjdFRhZ3w9Mjt6PSExO3k9YTtyZXR1cm59Yih5LHUpfXk9YTt1PWsoZCl9ZWxzZSBhLmVmZmVjdFRhZ3w9Mix6PSExLHk9YX19LHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMpe2I9cShhLnN0YXRlTm9kZSxhLnR5cGUsYS5tZW1vaXplZFByb3BzLGIsYyxhKTthLnVwZGF0ZVF1ZXVlPWI7cmV0dXJuIG51bGwhPT1iPyEwOiExfSxwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTpmdW5jdGlvbihhKXtyZXR1cm4gdihhLnN0YXRlTm9kZSxhLm1lbW9pemVkUHJvcHMsYSl9LHBvcEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKGEpe2lmKGEhPT1cbnkpcmV0dXJuITE7aWYoIXopcmV0dXJuIGQoYSksej0hMCwhMTt2YXIgYz1hLnR5cGU7aWYoNSE9PWEudGFnfHxcImhlYWRcIiE9PWMmJlwiYm9keVwiIT09YyYmIWUoYyxhLm1lbW9pemVkUHJvcHMpKWZvcihjPXU7YzspYihhLGMpLGM9aChjKTtkKGEpO3U9eT9oKGEuc3RhdGVOb2RlKTpudWxsO3JldHVybiEwfX19XG5mdW5jdGlvbiBrZihhKXtmdW5jdGlvbiBiKGEpe1FiPWphPSEwO3ZhciBiPWEuc3RhdGVOb2RlO2IuY3VycmVudD09PWE/RShcIjE3N1wiKTp2b2lkIDA7Yi5pc1JlYWR5Rm9yQ29tbWl0PSExO2lkLmN1cnJlbnQ9bnVsbDtpZigxPGEuZWZmZWN0VGFnKWlmKG51bGwhPT1hLmxhc3RFZmZlY3Qpe2EubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWE7dmFyIGM9YS5maXJzdEVmZmVjdH1lbHNlIGM9YTtlbHNlIGM9YS5maXJzdEVmZmVjdDt5ZygpO2Zvcih0PWM7bnVsbCE9PXQ7KXt2YXIgZD0hMSxlPXZvaWQgMDt0cnl7Zm9yKDtudWxsIT09dDspe3ZhciBmPXQuZWZmZWN0VGFnO2YmMTYmJnpnKHQpO2lmKGYmMTI4KXt2YXIgZz10LmFsdGVybmF0ZTtudWxsIT09ZyYmQWcoZyl9c3dpdGNoKGYmLTI0Mil7Y2FzZSAyOk5lKHQpO3QuZWZmZWN0VGFnJj0tMzticmVhaztjYXNlIDY6TmUodCk7dC5lZmZlY3RUYWcmPS0zO09lKHQuYWx0ZXJuYXRlLHQpO2JyZWFrO2Nhc2UgNDpPZSh0LmFsdGVybmF0ZSxcbnQpO2JyZWFrO2Nhc2UgODpTYz0hMCxCZyh0KSxTYz0hMX10PXQubmV4dEVmZmVjdH19Y2F0Y2goVGMpe2Q9ITAsZT1UY31kJiYobnVsbD09PXQ/RShcIjE3OFwiKTp2b2lkIDAsaCh0LGUpLG51bGwhPT10JiYodD10Lm5leHRFZmZlY3QpKX1DZygpO2IuY3VycmVudD1hO2Zvcih0PWM7bnVsbCE9PXQ7KXtjPSExO2Q9dm9pZCAwO3RyeXtmb3IoO251bGwhPT10Oyl7dmFyIGs9dC5lZmZlY3RUYWc7ayYzNiYmRGcodC5hbHRlcm5hdGUsdCk7ayYxMjgmJkVnKHQpO2lmKGsmNjQpc3dpdGNoKGU9dCxmPXZvaWQgMCxudWxsIT09UiYmKGY9Ui5nZXQoZSksUltcImRlbGV0ZVwiXShlKSxudWxsPT1mJiZudWxsIT09ZS5hbHRlcm5hdGUmJihlPWUuYWx0ZXJuYXRlLGY9Ui5nZXQoZSksUltcImRlbGV0ZVwiXShlKSkpLG51bGw9PWY/RShcIjE4NFwiKTp2b2lkIDAsZS50YWcpe2Nhc2UgMjplLnN0YXRlTm9kZS5jb21wb25lbnREaWRDYXRjaChmLmVycm9yLHtjb21wb25lbnRTdGFjazpmLmNvbXBvbmVudFN0YWNrfSk7XG5icmVhaztjYXNlIDM6bnVsbD09PWNhJiYoY2E9Zi5lcnJvcik7YnJlYWs7ZGVmYXVsdDpFKFwiMTU3XCIpfXZhciBRYz10Lm5leHRFZmZlY3Q7dC5uZXh0RWZmZWN0PW51bGw7dD1RY319Y2F0Y2goVGMpe2M9ITAsZD1UY31jJiYobnVsbD09PXQ/RShcIjE3OFwiKTp2b2lkIDAsaCh0LGQpLG51bGwhPT10JiYodD10Lm5leHRFZmZlY3QpKX1qYT1RYj0hMTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgRGUmJkRlKGEuc3RhdGVOb2RlKTtoYSYmKGhhLmZvckVhY2goRyksaGE9bnVsbCk7bnVsbCE9PWNhJiYoYT1jYSxjYT1udWxsLE9iKGEpKTtiPWIuY3VycmVudC5leHBpcmF0aW9uVGltZTswPT09YiYmKHFhPVI9bnVsbCk7cmV0dXJuIGJ9ZnVuY3Rpb24gYyhhKXtmb3IoOzspe3ZhciBiPUZnKGEuYWx0ZXJuYXRlLGEsSCksYz1hW1wicmV0dXJuXCJdLGQ9YS5zaWJsaW5nO3ZhciBlPWE7aWYoMjE0NzQ4MzY0Nz09PUh8fDIxNDc0ODM2NDchPT1lLmV4cGlyYXRpb25UaW1lKXtpZigyIT09ZS50YWcmJjMhPT1cbmUudGFnKXZhciBmPTA7ZWxzZSBmPWUudXBkYXRlUXVldWUsZj1udWxsPT09Zj8wOmYuZXhwaXJhdGlvblRpbWU7Zm9yKHZhciBnPWUuY2hpbGQ7bnVsbCE9PWc7KTAhPT1nLmV4cGlyYXRpb25UaW1lJiYoMD09PWZ8fGY+Zy5leHBpcmF0aW9uVGltZSkmJihmPWcuZXhwaXJhdGlvblRpbWUpLGc9Zy5zaWJsaW5nO2UuZXhwaXJhdGlvblRpbWU9Zn1pZihudWxsIT09YilyZXR1cm4gYjtudWxsIT09YyYmKG51bGw9PT1jLmZpcnN0RWZmZWN0JiYoYy5maXJzdEVmZmVjdD1hLmZpcnN0RWZmZWN0KSxudWxsIT09YS5sYXN0RWZmZWN0JiYobnVsbCE9PWMubGFzdEVmZmVjdCYmKGMubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWEuZmlyc3RFZmZlY3QpLGMubGFzdEVmZmVjdD1hLmxhc3RFZmZlY3QpLDE8YS5lZmZlY3RUYWcmJihudWxsIT09Yy5sYXN0RWZmZWN0P2MubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWE6Yy5maXJzdEVmZmVjdD1hLGMubGFzdEVmZmVjdD1hKSk7aWYobnVsbCE9PWQpcmV0dXJuIGQ7XG5pZihudWxsIT09YylhPWM7ZWxzZXthLnN0YXRlTm9kZS5pc1JlYWR5Rm9yQ29tbWl0PSEwO2JyZWFrfX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBkKGEpe3ZhciBiPXJnKGEuYWx0ZXJuYXRlLGEsSCk7bnVsbD09PWImJihiPWMoYSkpO2lkLmN1cnJlbnQ9bnVsbDtyZXR1cm4gYn1mdW5jdGlvbiBlKGEpe3ZhciBiPUdnKGEuYWx0ZXJuYXRlLGEsSCk7bnVsbD09PWImJihiPWMoYSkpO2lkLmN1cnJlbnQ9bnVsbDtyZXR1cm4gYn1mdW5jdGlvbiBmKGEpe2lmKG51bGwhPT1SKXtpZighKDA9PT1IfHxIPmEpKWlmKEg8PVVjKWZvcig7bnVsbCE9PUY7KUY9ayhGKT9lKEYpOmQoRik7ZWxzZSBmb3IoO251bGwhPT1GJiYhQSgpOylGPWsoRik/ZShGKTpkKEYpfWVsc2UgaWYoISgwPT09SHx8SD5hKSlpZihIPD1VYylmb3IoO251bGwhPT1GOylGPWQoRik7ZWxzZSBmb3IoO251bGwhPT1GJiYhQSgpOylGPWQoRil9ZnVuY3Rpb24gZyhhLGIpe2phP0UoXCIyNDNcIik6dm9pZCAwO2phPSEwO2EuaXNSZWFkeUZvckNvbW1pdD1cbiExO2lmKGEhPT1yYXx8YiE9PUh8fG51bGw9PT1GKXtmb3IoOy0xPGhlOylnZVtoZV09bnVsbCxoZS0tO2plPUQ7aWUuY3VycmVudD1EO1guY3VycmVudD0hMTt4KCk7cmE9YTtIPWI7Rj1zZShyYS5jdXJyZW50LG51bGwsYil9dmFyIGM9ITEsZD1udWxsO3RyeXtmKGIpfWNhdGNoKFJjKXtjPSEwLGQ9UmN9Zm9yKDtjOyl7aWYoZWIpe2NhPWQ7YnJlYWt9dmFyIGc9RjtpZihudWxsPT09ZyllYj0hMDtlbHNle3ZhciBrPWgoZyxkKTtudWxsPT09az9FKFwiMTgzXCIpOnZvaWQgMDtpZighZWIpe3RyeXtjPWs7ZD1iO2ZvcihrPWM7bnVsbCE9PWc7KXtzd2l0Y2goZy50YWcpe2Nhc2UgMjpuZShnKTticmVhaztjYXNlIDU6cWcoZyk7YnJlYWs7Y2FzZSAzOnAoZyk7YnJlYWs7Y2FzZSA0OnAoZyl9aWYoZz09PWt8fGcuYWx0ZXJuYXRlPT09aylicmVhaztnPWdbXCJyZXR1cm5cIl19Rj1lKGMpO2YoZCl9Y2F0Y2goUmMpe2M9ITA7ZD1SYztjb250aW51ZX1icmVha319fWI9Y2E7ZWI9amE9ITE7Y2E9XG5udWxsO251bGwhPT1iJiZPYihiKTtyZXR1cm4gYS5pc1JlYWR5Rm9yQ29tbWl0P2EuY3VycmVudC5hbHRlcm5hdGU6bnVsbH1mdW5jdGlvbiBoKGEsYil7dmFyIGM9aWQuY3VycmVudD1udWxsLGQ9ITEsZT0hMSxmPW51bGw7aWYoMz09PWEudGFnKWM9YSxxKGEpJiYoZWI9ITApO2Vsc2UgZm9yKHZhciBnPWFbXCJyZXR1cm5cIl07bnVsbCE9PWcmJm51bGw9PT1jOyl7Mj09PWcudGFnP1wiZnVuY3Rpb25cIj09PXR5cGVvZiBnLnN0YXRlTm9kZS5jb21wb25lbnREaWRDYXRjaCYmKGQ9ITAsZj1qZChnKSxjPWcsZT0hMCk6Mz09PWcudGFnJiYoYz1nKTtpZihxKGcpKXtpZihTY3x8bnVsbCE9PWhhJiYoaGEuaGFzKGcpfHxudWxsIT09Zy5hbHRlcm5hdGUmJmhhLmhhcyhnLmFsdGVybmF0ZSkpKXJldHVybiBudWxsO2M9bnVsbDtlPSExfWc9Z1tcInJldHVyblwiXX1pZihudWxsIT09Yyl7bnVsbD09PXFhJiYocWE9bmV3IFNldCk7cWEuYWRkKGMpO3ZhciBoPVwiXCI7Zz1hO2Rve2E6c3dpdGNoKGcudGFnKXtjYXNlIDA6Y2FzZSAxOmNhc2UgMjpjYXNlIDU6dmFyIGs9XG5nLl9kZWJ1Z093bmVyLFFjPWcuX2RlYnVnU291cmNlO3ZhciBtPWpkKGcpO3ZhciBuPW51bGw7ayYmKG49amQoaykpO2s9UWM7bT1cIlxcbiAgICBpbiBcIisobXx8XCJVbmtub3duXCIpKyhrP1wiIChhdCBcIitrLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sXCJcIikrXCI6XCIray5saW5lTnVtYmVyK1wiKVwiOm4/XCIgKGNyZWF0ZWQgYnkgXCIrbitcIilcIjpcIlwiKTticmVhayBhO2RlZmF1bHQ6bT1cIlwifWgrPW07Zz1nW1wicmV0dXJuXCJdfXdoaWxlKGcpO2c9aDthPWpkKGEpO251bGw9PT1SJiYoUj1uZXcgTWFwKTtiPXtjb21wb25lbnROYW1lOmEsY29tcG9uZW50U3RhY2s6ZyxlcnJvcjpiLGVycm9yQm91bmRhcnk6ZD9jLnN0YXRlTm9kZTpudWxsLGVycm9yQm91bmRhcnlGb3VuZDpkLGVycm9yQm91bmRhcnlOYW1lOmYsd2lsbFJldHJ5OmV9O1Iuc2V0KGMsYik7dHJ5e3ZhciBwPWIuZXJyb3I7cCYmcC5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nfHxjb25zb2xlLmVycm9yKHApfWNhdGNoKFZjKXtWYyYmXG5WYy5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nfHxjb25zb2xlLmVycm9yKFZjKX1RYj8obnVsbD09PWhhJiYoaGE9bmV3IFNldCksaGEuYWRkKGMpKTpHKGMpO3JldHVybiBjfW51bGw9PT1jYSYmKGNhPWIpO3JldHVybiBudWxsfWZ1bmN0aW9uIGsoYSl7cmV0dXJuIG51bGwhPT1SJiYoUi5oYXMoYSl8fG51bGwhPT1hLmFsdGVybmF0ZSYmUi5oYXMoYS5hbHRlcm5hdGUpKX1mdW5jdGlvbiBxKGEpe3JldHVybiBudWxsIT09cWEmJihxYS5oYXMoYSl8fG51bGwhPT1hLmFsdGVybmF0ZSYmcWEuaGFzKGEuYWx0ZXJuYXRlKSl9ZnVuY3Rpb24gdigpe3JldHVybiAyMCooKChJKCkrMTAwKS8yMHwwKSsxKX1mdW5jdGlvbiB5KGEpe3JldHVybiAwIT09a2E/a2E6amE/UWI/MTpIOiFIZ3x8YS5pbnRlcm5hbENvbnRleHRUYWcmMT92KCk6MX1mdW5jdGlvbiB1KGEsYil7cmV0dXJuIHooYSxiLCExKX1mdW5jdGlvbiB6KGEsYil7Zm9yKDtudWxsIT09YTspe2lmKDA9PT1hLmV4cGlyYXRpb25UaW1lfHxcbmEuZXhwaXJhdGlvblRpbWU+YilhLmV4cGlyYXRpb25UaW1lPWI7bnVsbCE9PWEuYWx0ZXJuYXRlJiYoMD09PWEuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lfHxhLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZT5iKSYmKGEuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lPWIpO2lmKG51bGw9PT1hW1wicmV0dXJuXCJdKWlmKDM9PT1hLnRhZyl7dmFyIGM9YS5zdGF0ZU5vZGU7IWphJiZjPT09cmEmJmI8SCYmKEY9cmE9bnVsbCxIPTApO3ZhciBkPWMsZT1iO1JiPklnJiZFKFwiMTg1XCIpO2lmKG51bGw9PT1kLm5leHRTY2hlZHVsZWRSb290KWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9ZSxudWxsPT09Tz8oc2E9Tz1kLGQubmV4dFNjaGVkdWxlZFJvb3Q9ZCk6KE89Ty5uZXh0U2NoZWR1bGVkUm9vdD1kLE8ubmV4dFNjaGVkdWxlZFJvb3Q9c2EpO2Vsc2V7dmFyIGY9ZC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtpZigwPT09Znx8ZTxmKWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9ZX1GYXx8KGxhP1xuU2ImJihtYT1kLG5hPTEsbShtYSxuYSkpOjE9PT1lP3coMSxudWxsKTpMKGUpKTshamEmJmM9PT1yYSYmYjxIJiYoRj1yYT1udWxsLEg9MCl9ZWxzZSBicmVhazthPWFbXCJyZXR1cm5cIl19fWZ1bmN0aW9uIEcoYSl7eihhLDEsITApfWZ1bmN0aW9uIEkoKXtyZXR1cm4gVWM9KChXYygpLVBlKS8xMHwwKSsyfWZ1bmN0aW9uIEwoYSl7aWYoMCE9PVRiKXtpZihhPlRiKXJldHVybjtKZyhYYyl9dmFyIGI9V2MoKS1QZTtUYj1hO1hjPUtnKEose3RpbWVvdXQ6MTAqKGEtMiktYn0pfWZ1bmN0aW9uIE4oKXt2YXIgYT0wLGI9bnVsbDtpZihudWxsIT09Tylmb3IodmFyIGM9TyxkPXNhO251bGwhPT1kOyl7dmFyIGU9ZC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtpZigwPT09ZSl7bnVsbD09PWN8fG51bGw9PT1PP0UoXCIyNDRcIik6dm9pZCAwO2lmKGQ9PT1kLm5leHRTY2hlZHVsZWRSb290KXtzYT1PPWQubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDticmVha31lbHNlIGlmKGQ9PT1zYSlzYT1lPWQubmV4dFNjaGVkdWxlZFJvb3QsXG5PLm5leHRTY2hlZHVsZWRSb290PWUsZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2Vsc2UgaWYoZD09PU8pe089YztPLm5leHRTY2hlZHVsZWRSb290PXNhO2QubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDticmVha31lbHNlIGMubmV4dFNjaGVkdWxlZFJvb3Q9ZC5uZXh0U2NoZWR1bGVkUm9vdCxkLm5leHRTY2hlZHVsZWRSb290PW51bGw7ZD1jLm5leHRTY2hlZHVsZWRSb290fWVsc2V7aWYoMD09PWF8fGU8YSlhPWUsYj1kO2lmKGQ9PT1PKWJyZWFrO2M9ZDtkPWQubmV4dFNjaGVkdWxlZFJvb3R9fWM9bWE7bnVsbCE9PWMmJmM9PT1iP1JiKys6UmI9MDttYT1iO25hPWF9ZnVuY3Rpb24gSihhKXt3KDAsYSl9ZnVuY3Rpb24gdyhhLGIpe2ZiPWI7Zm9yKE4oKTtudWxsIT09bWEmJjAhPT1uYSYmKDA9PT1hfHxuYTw9YSkmJiFZYzspbShtYSxuYSksTigpO251bGwhPT1mYiYmKFRiPTAsWGM9LTEpOzAhPT1uYSYmTChuYSk7ZmI9bnVsbDtZYz0hMTtSYj0wO2lmKFViKXRocm93IGE9WmMsWmM9XG5udWxsLFViPSExLGE7fWZ1bmN0aW9uIG0oYSxjKXtGYT9FKFwiMjQ1XCIpOnZvaWQgMDtGYT0hMDtpZihjPD1JKCkpe3ZhciBkPWEuZmluaXNoZWRXb3JrO251bGwhPT1kPyhhLmZpbmlzaGVkV29yaz1udWxsLGEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSk6KGEuZmluaXNoZWRXb3JrPW51bGwsZD1nKGEsYyksbnVsbCE9PWQmJihhLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWIoZCkpKX1lbHNlIGQ9YS5maW5pc2hlZFdvcmssbnVsbCE9PWQ/KGEuZmluaXNoZWRXb3JrPW51bGwsYS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1iKGQpKTooYS5maW5pc2hlZFdvcms9bnVsbCxkPWcoYSxjKSxudWxsIT09ZCYmKEEoKT9hLmZpbmlzaGVkV29yaz1kOmEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSkpO0ZhPSExfWZ1bmN0aW9uIEEoKXtyZXR1cm4gbnVsbD09PWZifHxmYi50aW1lUmVtYWluaW5nKCk+TGc/ITE6WWM9ITB9ZnVuY3Rpb24gT2IoYSl7bnVsbD09PW1hP0UoXCIyNDZcIik6XG52b2lkIDA7bWEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9MDtVYnx8KFViPSEwLFpjPWEpfXZhciByPWhmKGEpLG49amYoYSkscD1yLnBvcEhvc3RDb250YWluZXIscWc9ci5wb3BIb3N0Q29udGV4dCx4PXIucmVzZXRIb3N0Q29udGFpbmVyLE1lPWRmKGEscixuLHUseSkscmc9TWUuYmVnaW5Xb3JrLEdnPU1lLmJlZ2luRmFpbGVkV29yayxGZz1lZihhLHIsbikuY29tcGxldGVXb3JrO3I9ZmYoYSxoKTt2YXIgemc9ci5jb21taXRSZXNldFRleHRDb250ZW50LE5lPXIuY29tbWl0UGxhY2VtZW50LEJnPXIuY29tbWl0RGVsZXRpb24sT2U9ci5jb21taXRXb3JrLERnPXIuY29tbWl0TGlmZUN5Y2xlcyxFZz1yLmNvbW1pdEF0dGFjaFJlZixBZz1yLmNvbW1pdERldGFjaFJlZixXYz1hLm5vdyxLZz1hLnNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayxKZz1hLmNhbmNlbERlZmVycmVkQ2FsbGJhY2ssSGc9YS51c2VTeW5jU2NoZWR1bGluZyx5Zz1hLnByZXBhcmVGb3JDb21taXQsQ2c9YS5yZXNldEFmdGVyQ29tbWl0LFxuUGU9V2MoKSxVYz0yLGthPTAsamE9ITEsRj1udWxsLHJhPW51bGwsSD0wLHQ9bnVsbCxSPW51bGwscWE9bnVsbCxoYT1udWxsLGNhPW51bGwsZWI9ITEsUWI9ITEsU2M9ITEsc2E9bnVsbCxPPW51bGwsVGI9MCxYYz0tMSxGYT0hMSxtYT1udWxsLG5hPTAsWWM9ITEsVWI9ITEsWmM9bnVsbCxmYj1udWxsLGxhPSExLFNiPSExLElnPTFFMyxSYj0wLExnPTE7cmV0dXJue2NvbXB1dGVBc3luY0V4cGlyYXRpb246dixjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyOnksc2NoZWR1bGVXb3JrOnUsYmF0Y2hlZFVwZGF0ZXM6ZnVuY3Rpb24oYSxiKXt2YXIgYz1sYTtsYT0hMDt0cnl7cmV0dXJuIGEoYil9ZmluYWxseXsobGE9Yyl8fEZhfHx3KDEsbnVsbCl9fSx1bmJhdGNoZWRVcGRhdGVzOmZ1bmN0aW9uKGEpe2lmKGxhJiYhU2Ipe1NiPSEwO3RyeXtyZXR1cm4gYSgpfWZpbmFsbHl7U2I9ITF9fXJldHVybiBhKCl9LGZsdXNoU3luYzpmdW5jdGlvbihhKXt2YXIgYj1sYTtsYT0hMDt0cnl7YTp7dmFyIGM9XG5rYTtrYT0xO3RyeXt2YXIgZD1hKCk7YnJlYWsgYX1maW5hbGx5e2thPWN9ZD12b2lkIDB9cmV0dXJuIGR9ZmluYWxseXtsYT1iLEZhP0UoXCIxODdcIik6dm9pZCAwLHcoMSxudWxsKX19LGRlZmVycmVkVXBkYXRlczpmdW5jdGlvbihhKXt2YXIgYj1rYTtrYT12KCk7dHJ5e3JldHVybiBhKCl9ZmluYWxseXtrYT1ifX19fVxuZnVuY3Rpb24gbGYoYSl7ZnVuY3Rpb24gYihhKXthPW9kKGEpO3JldHVybiBudWxsPT09YT9udWxsOmEuc3RhdGVOb2RlfXZhciBjPWEuZ2V0UHVibGljSW5zdGFuY2U7YT1rZihhKTt2YXIgZD1hLmNvbXB1dGVBc3luY0V4cGlyYXRpb24sZT1hLmNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsZj1hLnNjaGVkdWxlV29yaztyZXR1cm57Y3JlYXRlQ29udGFpbmVyOmZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IFkoMyxudWxsLDApO2E9e2N1cnJlbnQ6Yyxjb250YWluZXJJbmZvOmEscGVuZGluZ0NoaWxkcmVuOm51bGwscmVtYWluaW5nRXhwaXJhdGlvblRpbWU6MCxpc1JlYWR5Rm9yQ29tbWl0OiExLGZpbmlzaGVkV29yazpudWxsLGNvbnRleHQ6bnVsbCxwZW5kaW5nQ29udGV4dDpudWxsLGh5ZHJhdGU6YixuZXh0U2NoZWR1bGVkUm9vdDpudWxsfTtyZXR1cm4gYy5zdGF0ZU5vZGU9YX0sdXBkYXRlQ29udGFpbmVyOmZ1bmN0aW9uKGEsYixjLHEpe3ZhciBnPWIuY3VycmVudDtpZihjKXtjPVxuYy5fcmVhY3RJbnRlcm5hbEZpYmVyO3ZhciBoO2I6ezI9PT1rZChjKSYmMj09PWMudGFnP3ZvaWQgMDpFKFwiMTcwXCIpO2ZvcihoPWM7MyE9PWgudGFnOyl7aWYobGUoaCkpe2g9aC5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7YnJlYWsgYn0oaD1oW1wicmV0dXJuXCJdKT92b2lkIDA6RShcIjE3MVwiKX1oPWguc3RhdGVOb2RlLmNvbnRleHR9Yz1sZShjKT9wZShjLGgpOmh9ZWxzZSBjPUQ7bnVsbD09PWIuY29udGV4dD9iLmNvbnRleHQ9YzpiLnBlbmRpbmdDb250ZXh0PWM7Yj1xO2I9dm9pZCAwPT09Yj9udWxsOmI7cT1udWxsIT1hJiZudWxsIT1hLnR5cGUmJm51bGwhPWEudHlwZS5wcm90b3R5cGUmJiEwPT09YS50eXBlLnByb3RvdHlwZS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQ/ZCgpOmUoZyk7SGUoZyx7ZXhwaXJhdGlvblRpbWU6cSxwYXJ0aWFsU3RhdGU6e2VsZW1lbnQ6YX0sY2FsbGJhY2s6Yixpc1JlcGxhY2U6ITEsaXNGb3JjZWQ6ITEsXG5uZXh0Q2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9KTtmKGcscSl9LGJhdGNoZWRVcGRhdGVzOmEuYmF0Y2hlZFVwZGF0ZXMsdW5iYXRjaGVkVXBkYXRlczphLnVuYmF0Y2hlZFVwZGF0ZXMsZGVmZXJyZWRVcGRhdGVzOmEuZGVmZXJyZWRVcGRhdGVzLGZsdXNoU3luYzphLmZsdXNoU3luYyxnZXRQdWJsaWNSb290SW5zdGFuY2U6ZnVuY3Rpb24oYSl7YT1hLmN1cnJlbnQ7aWYoIWEuY2hpbGQpcmV0dXJuIG51bGw7c3dpdGNoKGEuY2hpbGQudGFnKXtjYXNlIDU6cmV0dXJuIGMoYS5jaGlsZC5zdGF0ZU5vZGUpO2RlZmF1bHQ6cmV0dXJuIGEuY2hpbGQuc3RhdGVOb2RlfX0sZmluZEhvc3RJbnN0YW5jZTpiLGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzOmZ1bmN0aW9uKGEpe2E9cGQoYSk7cmV0dXJuIG51bGw9PT1hP251bGw6YS5zdGF0ZU5vZGV9LGluamVjdEludG9EZXZUb29sczpmdW5jdGlvbihhKXt2YXIgYz1hLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO3JldHVybiBDZShCKHt9LFxuYSx7ZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGIoYSl9LGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOmZ1bmN0aW9uKGEpe3JldHVybiBjP2MoYSk6bnVsbH19KSl9fX12YXIgbWY9T2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDpsZn0pLG5mPW1mJiZsZnx8bWYsb2Y9bmZbXCJkZWZhdWx0XCJdP25mW1wiZGVmYXVsdFwiXTpuZjtmdW5jdGlvbiBwZihhLGIsYyl7dmFyIGQ9Mzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOm51bGw7cmV0dXJueyQkdHlwZW9mOlVlLGtleTpudWxsPT1kP251bGw6XCJcIitkLGNoaWxkcmVuOmEsY29udGFpbmVySW5mbzpiLGltcGxlbWVudGF0aW9uOmN9fXZhciBxZj1cIm9iamVjdFwiPT09dHlwZW9mIHBlcmZvcm1hbmNlJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgcGVyZm9ybWFuY2Uubm93LHJmPXZvaWQgMDtyZj1xZj9mdW5jdGlvbigpe3JldHVybiBwZXJmb3JtYW5jZS5ub3coKX06ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX07XG52YXIgc2Y9dm9pZCAwLHRmPXZvaWQgMDtcbmlmKGwuY2FuVXNlRE9NKWlmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgY2FuY2VsSWRsZUNhbGxiYWNrKXt2YXIgdWY9bnVsbCx2Zj0hMSx3Zj0tMSx4Zj0hMSx5Zj0wLHpmPTMzLEFmPTMzLEJmO0JmPXFmP3tkaWRUaW1lb3V0OiExLHRpbWVSZW1haW5pbmc6ZnVuY3Rpb24oKXt2YXIgYT15Zi1wZXJmb3JtYW5jZS5ub3coKTtyZXR1cm4gMDxhP2E6MH19OntkaWRUaW1lb3V0OiExLHRpbWVSZW1haW5pbmc6ZnVuY3Rpb24oKXt2YXIgYT15Zi1EYXRlLm5vdygpO3JldHVybiAwPGE/YTowfX07dmFyIENmPVwiX19yZWFjdElkbGVDYWxsYmFjayRcIitNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixmdW5jdGlvbihhKXtpZihhLnNvdXJjZT09PXdpbmRvdyYmYS5kYXRhPT09Q2Ype3ZmPSExO2E9cmYoKTtpZigwPj15Zi1hKWlmKC0xIT09d2YmJndmPD1cbmEpQmYuZGlkVGltZW91dD0hMDtlbHNle3hmfHwoeGY9ITAscmVxdWVzdEFuaW1hdGlvbkZyYW1lKERmKSk7cmV0dXJufWVsc2UgQmYuZGlkVGltZW91dD0hMTt3Zj0tMTthPXVmO3VmPW51bGw7bnVsbCE9PWEmJmEoQmYpfX0sITEpO3ZhciBEZj1mdW5jdGlvbihhKXt4Zj0hMTt2YXIgYj1hLXlmK0FmO2I8QWYmJnpmPEFmPyg4PmImJihiPTgpLEFmPWI8emY/emY6Yik6emY9Yjt5Zj1hK0FmO3ZmfHwodmY9ITAsd2luZG93LnBvc3RNZXNzYWdlKENmLFwiKlwiKSl9O3NmPWZ1bmN0aW9uKGEsYil7dWY9YTtudWxsIT1iJiZcIm51bWJlclwiPT09dHlwZW9mIGIudGltZW91dCYmKHdmPXJmKCkrYi50aW1lb3V0KTt4Znx8KHhmPSEwLHJlcXVlc3RBbmltYXRpb25GcmFtZShEZikpO3JldHVybiAwfTt0Zj1mdW5jdGlvbigpe3VmPW51bGw7dmY9ITE7d2Y9LTF9fWVsc2Ugc2Y9d2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2ssdGY9d2luZG93LmNhbmNlbElkbGVDYWxsYmFjaztlbHNlIHNmPWZ1bmN0aW9uKGEpe3JldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YSh7dGltZVJlbWFpbmluZzpmdW5jdGlvbigpe3JldHVybiBJbmZpbml0eX19KX0pfSxcbnRmPWZ1bmN0aW9uKGEpe2NsZWFyVGltZW91dChhKX07dmFyIEVmPS9eWzpBLVpfYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXVs6QS1aX2EtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcLS4wLTlcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwXSokLyxGZj17fSxHZj17fTtcbmZ1bmN0aW9uIEhmKGEpe2lmKEdmLmhhc093blByb3BlcnR5KGEpKXJldHVybiEwO2lmKEZmLmhhc093blByb3BlcnR5KGEpKXJldHVybiExO2lmKEVmLnRlc3QoYSkpcmV0dXJuIEdmW2FdPSEwO0ZmW2FdPSEwO3JldHVybiExfVxuZnVuY3Rpb24gSWYoYSxiLGMpe3ZhciBkPXdhKGIpO2lmKGQmJnZhKGIsYykpe3ZhciBlPWQubXV0YXRpb25NZXRob2Q7ZT9lKGEsYyk6bnVsbD09Y3x8ZC5oYXNCb29sZWFuVmFsdWUmJiFjfHxkLmhhc051bWVyaWNWYWx1ZSYmaXNOYU4oYyl8fGQuaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUmJjE+Y3x8ZC5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlJiYhMT09PWM/SmYoYSxiKTpkLm11c3RVc2VQcm9wZXJ0eT9hW2QucHJvcGVydHlOYW1lXT1jOihiPWQuYXR0cmlidXRlTmFtZSwoZT1kLmF0dHJpYnV0ZU5hbWVzcGFjZSk/YS5zZXRBdHRyaWJ1dGVOUyhlLGIsXCJcIitjKTpkLmhhc0Jvb2xlYW5WYWx1ZXx8ZC5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlJiYhMD09PWM/YS5zZXRBdHRyaWJ1dGUoYixcIlwiKTphLnNldEF0dHJpYnV0ZShiLFwiXCIrYykpfWVsc2UgS2YoYSxiLHZhKGIsYyk/YzpudWxsKX1cbmZ1bmN0aW9uIEtmKGEsYixjKXtIZihiKSYmKG51bGw9PWM/YS5yZW1vdmVBdHRyaWJ1dGUoYik6YS5zZXRBdHRyaWJ1dGUoYixcIlwiK2MpKX1mdW5jdGlvbiBKZihhLGIpe3ZhciBjPXdhKGIpO2M/KGI9Yy5tdXRhdGlvbk1ldGhvZCk/YihhLHZvaWQgMCk6Yy5tdXN0VXNlUHJvcGVydHk/YVtjLnByb3BlcnR5TmFtZV09Yy5oYXNCb29sZWFuVmFsdWU/ITE6XCJcIjphLnJlbW92ZUF0dHJpYnV0ZShjLmF0dHJpYnV0ZU5hbWUpOmEucmVtb3ZlQXR0cmlidXRlKGIpfVxuZnVuY3Rpb24gTGYoYSxiKXt2YXIgYz1iLnZhbHVlLGQ9Yi5jaGVja2VkO3JldHVybiBCKHt0eXBlOnZvaWQgMCxzdGVwOnZvaWQgMCxtaW46dm9pZCAwLG1heDp2b2lkIDB9LGIse2RlZmF1bHRDaGVja2VkOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLHZhbHVlOm51bGwhPWM/YzphLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLGNoZWNrZWQ6bnVsbCE9ZD9kOmEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZH0pfWZ1bmN0aW9uIE1mKGEsYil7dmFyIGM9Yi5kZWZhdWx0VmFsdWU7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsQ2hlY2tlZDpudWxsIT1iLmNoZWNrZWQ/Yi5jaGVja2VkOmIuZGVmYXVsdENoZWNrZWQsaW5pdGlhbFZhbHVlOm51bGwhPWIudmFsdWU/Yi52YWx1ZTpjLGNvbnRyb2xsZWQ6XCJjaGVja2JveFwiPT09Yi50eXBlfHxcInJhZGlvXCI9PT1iLnR5cGU/bnVsbCE9Yi5jaGVja2VkOm51bGwhPWIudmFsdWV9fVxuZnVuY3Rpb24gTmYoYSxiKXtiPWIuY2hlY2tlZDtudWxsIT1iJiZJZihhLFwiY2hlY2tlZFwiLGIpfWZ1bmN0aW9uIE9mKGEsYil7TmYoYSxiKTt2YXIgYz1iLnZhbHVlO2lmKG51bGwhPWMpaWYoMD09PWMmJlwiXCI9PT1hLnZhbHVlKWEudmFsdWU9XCIwXCI7ZWxzZSBpZihcIm51bWJlclwiPT09Yi50eXBlKXtpZihiPXBhcnNlRmxvYXQoYS52YWx1ZSl8fDAsYyE9Ynx8Yz09YiYmYS52YWx1ZSE9YylhLnZhbHVlPVwiXCIrY31lbHNlIGEudmFsdWUhPT1cIlwiK2MmJihhLnZhbHVlPVwiXCIrYyk7ZWxzZSBudWxsPT1iLnZhbHVlJiZudWxsIT1iLmRlZmF1bHRWYWx1ZSYmYS5kZWZhdWx0VmFsdWUhPT1cIlwiK2IuZGVmYXVsdFZhbHVlJiYoYS5kZWZhdWx0VmFsdWU9XCJcIitiLmRlZmF1bHRWYWx1ZSksbnVsbD09Yi5jaGVja2VkJiZudWxsIT1iLmRlZmF1bHRDaGVja2VkJiYoYS5kZWZhdWx0Q2hlY2tlZD0hIWIuZGVmYXVsdENoZWNrZWQpfVxuZnVuY3Rpb24gUGYoYSxiKXtzd2l0Y2goYi50eXBlKXtjYXNlIFwic3VibWl0XCI6Y2FzZSBcInJlc2V0XCI6YnJlYWs7Y2FzZSBcImNvbG9yXCI6Y2FzZSBcImRhdGVcIjpjYXNlIFwiZGF0ZXRpbWVcIjpjYXNlIFwiZGF0ZXRpbWUtbG9jYWxcIjpjYXNlIFwibW9udGhcIjpjYXNlIFwidGltZVwiOmNhc2UgXCJ3ZWVrXCI6YS52YWx1ZT1cIlwiO2EudmFsdWU9YS5kZWZhdWx0VmFsdWU7YnJlYWs7ZGVmYXVsdDphLnZhbHVlPWEudmFsdWV9Yj1hLm5hbWU7XCJcIiE9PWImJihhLm5hbWU9XCJcIik7YS5kZWZhdWx0Q2hlY2tlZD0hYS5kZWZhdWx0Q2hlY2tlZDthLmRlZmF1bHRDaGVja2VkPSFhLmRlZmF1bHRDaGVja2VkO1wiXCIhPT1iJiYoYS5uYW1lPWIpfWZ1bmN0aW9uIFFmKGEpe3ZhciBiPVwiXCI7YWEuQ2hpbGRyZW4uZm9yRWFjaChhLGZ1bmN0aW9uKGEpe251bGw9PWF8fFwic3RyaW5nXCIhPT10eXBlb2YgYSYmXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwoYis9YSl9KTtyZXR1cm4gYn1cbmZ1bmN0aW9uIFJmKGEsYil7YT1CKHtjaGlsZHJlbjp2b2lkIDB9LGIpO2lmKGI9UWYoYi5jaGlsZHJlbikpYS5jaGlsZHJlbj1iO3JldHVybiBhfWZ1bmN0aW9uIFNmKGEsYixjLGQpe2E9YS5vcHRpb25zO2lmKGIpe2I9e307Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspYltcIiRcIitjW2VdXT0hMDtmb3IoYz0wO2M8YS5sZW5ndGg7YysrKWU9Yi5oYXNPd25Qcm9wZXJ0eShcIiRcIithW2NdLnZhbHVlKSxhW2NdLnNlbGVjdGVkIT09ZSYmKGFbY10uc2VsZWN0ZWQ9ZSksZSYmZCYmKGFbY10uZGVmYXVsdFNlbGVjdGVkPSEwKX1lbHNle2M9XCJcIitjO2I9bnVsbDtmb3IoZT0wO2U8YS5sZW5ndGg7ZSsrKXtpZihhW2VdLnZhbHVlPT09Yyl7YVtlXS5zZWxlY3RlZD0hMDtkJiYoYVtlXS5kZWZhdWx0U2VsZWN0ZWQ9ITApO3JldHVybn1udWxsIT09Ynx8YVtlXS5kaXNhYmxlZHx8KGI9YVtlXSl9bnVsbCE9PWImJihiLnNlbGVjdGVkPSEwKX19XG5mdW5jdGlvbiBUZihhLGIpe3ZhciBjPWIudmFsdWU7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsVmFsdWU6bnVsbCE9Yz9jOmIuZGVmYXVsdFZhbHVlLHdhc011bHRpcGxlOiEhYi5tdWx0aXBsZX19ZnVuY3Rpb24gVWYoYSxiKXtudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MP0UoXCI5MVwiKTp2b2lkIDA7cmV0dXJuIEIoe30sYix7dmFsdWU6dm9pZCAwLGRlZmF1bHRWYWx1ZTp2b2lkIDAsY2hpbGRyZW46XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlfSl9ZnVuY3Rpb24gVmYoYSxiKXt2YXIgYz1iLnZhbHVlO251bGw9PWMmJihjPWIuZGVmYXVsdFZhbHVlLGI9Yi5jaGlsZHJlbixudWxsIT1iJiYobnVsbCE9Yz9FKFwiOTJcIik6dm9pZCAwLEFycmF5LmlzQXJyYXkoYikmJigxPj1iLmxlbmd0aD92b2lkIDA6RShcIjkzXCIpLGI9YlswXSksYz1cIlwiK2IpLG51bGw9PWMmJihjPVwiXCIpKTthLl93cmFwcGVyU3RhdGU9e2luaXRpYWxWYWx1ZTpcIlwiK2N9fVxuZnVuY3Rpb24gV2YoYSxiKXt2YXIgYz1iLnZhbHVlO251bGwhPWMmJihjPVwiXCIrYyxjIT09YS52YWx1ZSYmKGEudmFsdWU9YyksbnVsbD09Yi5kZWZhdWx0VmFsdWUmJihhLmRlZmF1bHRWYWx1ZT1jKSk7bnVsbCE9Yi5kZWZhdWx0VmFsdWUmJihhLmRlZmF1bHRWYWx1ZT1iLmRlZmF1bHRWYWx1ZSl9ZnVuY3Rpb24gWGYoYSl7dmFyIGI9YS50ZXh0Q29udGVudDtiPT09YS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSYmKGEudmFsdWU9Yil9dmFyIFlmPXtodG1sOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLG1hdGhtbDpcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIixzdmc6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifTtcbmZ1bmN0aW9uIFpmKGEpe3N3aXRjaChhKXtjYXNlIFwic3ZnXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO2Nhc2UgXCJtYXRoXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7ZGVmYXVsdDpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIn19ZnVuY3Rpb24gJGYoYSxiKXtyZXR1cm4gbnVsbD09YXx8XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI9PT1hP1pmKGIpOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj09PWEmJlwiZm9yZWlnbk9iamVjdFwiPT09Yj9cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjphfVxudmFyIGFnPXZvaWQgMCxiZz1mdW5jdGlvbihhKXtyZXR1cm5cInVuZGVmaW5lZFwiIT09dHlwZW9mIE1TQXBwJiZNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbj9mdW5jdGlvbihiLGMsZCxlKXtNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbigpe3JldHVybiBhKGIsYyxkLGUpfSl9OmF9KGZ1bmN0aW9uKGEsYil7aWYoYS5uYW1lc3BhY2VVUkkhPT1ZZi5zdmd8fFwiaW5uZXJIVE1MXCJpbiBhKWEuaW5uZXJIVE1MPWI7ZWxzZXthZz1hZ3x8ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTthZy5pbm5lckhUTUw9XCJcXHgzY3N2Z1xceDNlXCIrYitcIlxceDNjL3N2Z1xceDNlXCI7Zm9yKGI9YWcuZmlyc3RDaGlsZDthLmZpcnN0Q2hpbGQ7KWEucmVtb3ZlQ2hpbGQoYS5maXJzdENoaWxkKTtmb3IoO2IuZmlyc3RDaGlsZDspYS5hcHBlbmRDaGlsZChiLmZpcnN0Q2hpbGQpfX0pO1xuZnVuY3Rpb24gY2coYSxiKXtpZihiKXt2YXIgYz1hLmZpcnN0Q2hpbGQ7aWYoYyYmYz09PWEubGFzdENoaWxkJiYzPT09Yy5ub2RlVHlwZSl7Yy5ub2RlVmFsdWU9YjtyZXR1cm59fWEudGV4dENvbnRlbnQ9Yn1cbnZhciBkZz17YW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ITAsYm9yZGVySW1hZ2VPdXRzZXQ6ITAsYm9yZGVySW1hZ2VTbGljZTohMCxib3JkZXJJbWFnZVdpZHRoOiEwLGJveEZsZXg6ITAsYm94RmxleEdyb3VwOiEwLGJveE9yZGluYWxHcm91cDohMCxjb2x1bW5Db3VudDohMCxjb2x1bW5zOiEwLGZsZXg6ITAsZmxleEdyb3c6ITAsZmxleFBvc2l0aXZlOiEwLGZsZXhTaHJpbms6ITAsZmxleE5lZ2F0aXZlOiEwLGZsZXhPcmRlcjohMCxncmlkUm93OiEwLGdyaWRSb3dFbmQ6ITAsZ3JpZFJvd1NwYW46ITAsZ3JpZFJvd1N0YXJ0OiEwLGdyaWRDb2x1bW46ITAsZ3JpZENvbHVtbkVuZDohMCxncmlkQ29sdW1uU3BhbjohMCxncmlkQ29sdW1uU3RhcnQ6ITAsZm9udFdlaWdodDohMCxsaW5lQ2xhbXA6ITAsbGluZUhlaWdodDohMCxvcGFjaXR5OiEwLG9yZGVyOiEwLG9ycGhhbnM6ITAsdGFiU2l6ZTohMCx3aWRvd3M6ITAsekluZGV4OiEwLHpvb206ITAsZmlsbE9wYWNpdHk6ITAsZmxvb2RPcGFjaXR5OiEwLFxuc3RvcE9wYWNpdHk6ITAsc3Ryb2tlRGFzaGFycmF5OiEwLHN0cm9rZURhc2hvZmZzZXQ6ITAsc3Ryb2tlTWl0ZXJsaW1pdDohMCxzdHJva2VPcGFjaXR5OiEwLHN0cm9rZVdpZHRoOiEwfSxlZz1bXCJXZWJraXRcIixcIm1zXCIsXCJNb3pcIixcIk9cIl07T2JqZWN0LmtleXMoZGcpLmZvckVhY2goZnVuY3Rpb24oYSl7ZWcuZm9yRWFjaChmdW5jdGlvbihiKXtiPWIrYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSthLnN1YnN0cmluZygxKTtkZ1tiXT1kZ1thXX0pfSk7XG5mdW5jdGlvbiBmZyhhLGIpe2E9YS5zdHlsZTtmb3IodmFyIGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpKXt2YXIgZD0wPT09Yy5pbmRleE9mKFwiLS1cIik7dmFyIGU9Yzt2YXIgZj1iW2NdO2U9bnVsbD09Znx8XCJib29sZWFuXCI9PT10eXBlb2YgZnx8XCJcIj09PWY/XCJcIjpkfHxcIm51bWJlclwiIT09dHlwZW9mIGZ8fDA9PT1mfHxkZy5oYXNPd25Qcm9wZXJ0eShlKSYmZGdbZV0/KFwiXCIrZikudHJpbSgpOmYrXCJweFwiO1wiZmxvYXRcIj09PWMmJihjPVwiY3NzRmxvYXRcIik7ZD9hLnNldFByb3BlcnR5KGMsZSk6YVtjXT1lfX12YXIgZ2c9Qih7bWVudWl0ZW06ITB9LHthcmVhOiEwLGJhc2U6ITAsYnI6ITAsY29sOiEwLGVtYmVkOiEwLGhyOiEwLGltZzohMCxpbnB1dDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9KTtcbmZ1bmN0aW9uIGhnKGEsYixjKXtiJiYoZ2dbYV0mJihudWxsIT1iLmNoaWxkcmVufHxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MP0UoXCIxMzdcIixhLGMoKSk6dm9pZCAwKSxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiYobnVsbCE9Yi5jaGlsZHJlbj9FKFwiNjBcIik6dm9pZCAwLFwib2JqZWN0XCI9PT10eXBlb2YgYi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmXCJfX2h0bWxcImluIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw/dm9pZCAwOkUoXCI2MVwiKSksbnVsbCE9Yi5zdHlsZSYmXCJvYmplY3RcIiE9PXR5cGVvZiBiLnN0eWxlP0UoXCI2MlwiLGMoKSk6dm9pZCAwKX1cbmZ1bmN0aW9uIGlnKGEsYil7aWYoLTE9PT1hLmluZGV4T2YoXCItXCIpKXJldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYi5pcztzd2l0Y2goYSl7Y2FzZSBcImFubm90YXRpb24teG1sXCI6Y2FzZSBcImNvbG9yLXByb2ZpbGVcIjpjYXNlIFwiZm9udC1mYWNlXCI6Y2FzZSBcImZvbnQtZmFjZS1zcmNcIjpjYXNlIFwiZm9udC1mYWNlLXVyaVwiOmNhc2UgXCJmb250LWZhY2UtZm9ybWF0XCI6Y2FzZSBcImZvbnQtZmFjZS1uYW1lXCI6Y2FzZSBcIm1pc3NpbmctZ2x5cGhcIjpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiEwfX12YXIgamc9WWYuaHRtbCxrZz1DLnRoYXRSZXR1cm5zKFwiXCIpO1xuZnVuY3Rpb24gbGcoYSxiKXthPTk9PT1hLm5vZGVUeXBlfHwxMT09PWEubm9kZVR5cGU/YTphLm93bmVyRG9jdW1lbnQ7dmFyIGM9SGQoYSk7Yj1TYVtiXTtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGU9YltkXTtjLmhhc093blByb3BlcnR5KGUpJiZjW2VdfHwoXCJ0b3BTY3JvbGxcIj09PWU/d2QoXCJ0b3BTY3JvbGxcIixcInNjcm9sbFwiLGEpOlwidG9wRm9jdXNcIj09PWV8fFwidG9wQmx1clwiPT09ZT8od2QoXCJ0b3BGb2N1c1wiLFwiZm9jdXNcIixhKSx3ZChcInRvcEJsdXJcIixcImJsdXJcIixhKSxjLnRvcEJsdXI9ITAsYy50b3BGb2N1cz0hMCk6XCJ0b3BDYW5jZWxcIj09PWU/KHljKFwiY2FuY2VsXCIsITApJiZ3ZChcInRvcENhbmNlbFwiLFwiY2FuY2VsXCIsYSksYy50b3BDYW5jZWw9ITApOlwidG9wQ2xvc2VcIj09PWU/KHljKFwiY2xvc2VcIiwhMCkmJndkKFwidG9wQ2xvc2VcIixcImNsb3NlXCIsYSksYy50b3BDbG9zZT0hMCk6RGQuaGFzT3duUHJvcGVydHkoZSkmJlUoZSxEZFtlXSxhKSxjW2VdPSEwKX19XG52YXIgbWc9e3RvcEFib3J0OlwiYWJvcnRcIix0b3BDYW5QbGF5OlwiY2FucGxheVwiLHRvcENhblBsYXlUaHJvdWdoOlwiY2FucGxheXRocm91Z2hcIix0b3BEdXJhdGlvbkNoYW5nZTpcImR1cmF0aW9uY2hhbmdlXCIsdG9wRW1wdGllZDpcImVtcHRpZWRcIix0b3BFbmNyeXB0ZWQ6XCJlbmNyeXB0ZWRcIix0b3BFbmRlZDpcImVuZGVkXCIsdG9wRXJyb3I6XCJlcnJvclwiLHRvcExvYWRlZERhdGE6XCJsb2FkZWRkYXRhXCIsdG9wTG9hZGVkTWV0YWRhdGE6XCJsb2FkZWRtZXRhZGF0YVwiLHRvcExvYWRTdGFydDpcImxvYWRzdGFydFwiLHRvcFBhdXNlOlwicGF1c2VcIix0b3BQbGF5OlwicGxheVwiLHRvcFBsYXlpbmc6XCJwbGF5aW5nXCIsdG9wUHJvZ3Jlc3M6XCJwcm9ncmVzc1wiLHRvcFJhdGVDaGFuZ2U6XCJyYXRlY2hhbmdlXCIsdG9wU2Vla2VkOlwic2Vla2VkXCIsdG9wU2Vla2luZzpcInNlZWtpbmdcIix0b3BTdGFsbGVkOlwic3RhbGxlZFwiLHRvcFN1c3BlbmQ6XCJzdXNwZW5kXCIsdG9wVGltZVVwZGF0ZTpcInRpbWV1cGRhdGVcIix0b3BWb2x1bWVDaGFuZ2U6XCJ2b2x1bWVjaGFuZ2VcIixcbnRvcFdhaXRpbmc6XCJ3YWl0aW5nXCJ9O2Z1bmN0aW9uIG5nKGEsYixjLGQpe2M9OT09PWMubm9kZVR5cGU/YzpjLm93bmVyRG9jdW1lbnQ7ZD09PWpnJiYoZD1aZihhKSk7ZD09PWpnP1wic2NyaXB0XCI9PT1hPyhhPWMuY3JlYXRlRWxlbWVudChcImRpdlwiKSxhLmlubmVySFRNTD1cIlxceDNjc2NyaXB0XFx4M2VcXHgzYy9zY3JpcHRcXHgzZVwiLGE9YS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpKTphPVwic3RyaW5nXCI9PT10eXBlb2YgYi5pcz9jLmNyZWF0ZUVsZW1lbnQoYSx7aXM6Yi5pc30pOmMuY3JlYXRlRWxlbWVudChhKTphPWMuY3JlYXRlRWxlbWVudE5TKGQsYSk7cmV0dXJuIGF9ZnVuY3Rpb24gb2coYSxiKXtyZXR1cm4oOT09PWIubm9kZVR5cGU/YjpiLm93bmVyRG9jdW1lbnQpLmNyZWF0ZVRleHROb2RlKGEpfVxuZnVuY3Rpb24gcGcoYSxiLGMsZCl7dmFyIGU9aWcoYixjKTtzd2l0Y2goYil7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpVKFwidG9wTG9hZFwiLFwibG9hZFwiLGEpO3ZhciBmPWM7YnJlYWs7Y2FzZSBcInZpZGVvXCI6Y2FzZSBcImF1ZGlvXCI6Zm9yKGYgaW4gbWcpbWcuaGFzT3duUHJvcGVydHkoZikmJlUoZixtZ1tmXSxhKTtmPWM7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImltZ1wiOmNhc2UgXCJpbWFnZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTtVKFwidG9wTG9hZFwiLFwibG9hZFwiLGEpO2Y9YzticmVhaztjYXNlIFwiZm9ybVwiOlUoXCJ0b3BSZXNldFwiLFwicmVzZXRcIixhKTtVKFwidG9wU3VibWl0XCIsXCJzdWJtaXRcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpVKFwidG9wVG9nZ2xlXCIsXCJ0b2dnbGVcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImlucHV0XCI6TWYoYSxjKTtmPUxmKGEsYyk7VShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtcbmxnKGQsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwib3B0aW9uXCI6Zj1SZihhLGMpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpUZihhLGMpO2Y9Qih7fSxjLHt2YWx1ZTp2b2lkIDB9KTtVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO2xnKGQsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpWZihhLGMpO2Y9VWYoYSxjKTtVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO2xnKGQsXCJvbkNoYW5nZVwiKTticmVhaztkZWZhdWx0OmY9Y31oZyhiLGYsa2cpO3ZhciBnPWYsaDtmb3IoaCBpbiBnKWlmKGcuaGFzT3duUHJvcGVydHkoaCkpe3ZhciBrPWdbaF07XCJzdHlsZVwiPT09aD9mZyhhLGssa2cpOlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWg/KGs9az9rLl9faHRtbDp2b2lkIDAsbnVsbCE9ayYmYmcoYSxrKSk6XCJjaGlsZHJlblwiPT09aD9cInN0cmluZ1wiPT09dHlwZW9mIGs/KFwidGV4dGFyZWFcIiE9PWJ8fFwiXCIhPT1rKSYmY2coYSxrKTpcIm51bWJlclwiPT09dHlwZW9mIGsmJmNnKGEsXG5cIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1oJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09aCYmXCJhdXRvRm9jdXNcIiE9PWgmJihSYS5oYXNPd25Qcm9wZXJ0eShoKT9udWxsIT1rJiZsZyhkLGgpOmU/S2YoYSxoLGspOm51bGwhPWsmJklmKGEsaCxrKSl9c3dpdGNoKGIpe2Nhc2UgXCJpbnB1dFwiOkJjKGEpO1BmKGEsYyk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6QmMoYSk7WGYoYSxjKTticmVhaztjYXNlIFwib3B0aW9uXCI6bnVsbCE9Yy52YWx1ZSYmYS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLGMudmFsdWUpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjphLm11bHRpcGxlPSEhYy5tdWx0aXBsZTtiPWMudmFsdWU7bnVsbCE9Yj9TZihhLCEhYy5tdWx0aXBsZSxiLCExKTpudWxsIT1jLmRlZmF1bHRWYWx1ZSYmU2YoYSwhIWMubXVsdGlwbGUsYy5kZWZhdWx0VmFsdWUsITApO2JyZWFrO2RlZmF1bHQ6XCJmdW5jdGlvblwiPT09dHlwZW9mIGYub25DbGljayYmKGEub25jbGljaz1cbkMpfX1cbmZ1bmN0aW9uIHNnKGEsYixjLGQsZSl7dmFyIGY9bnVsbDtzd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6Yz1MZihhLGMpO2Q9TGYoYSxkKTtmPVtdO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjpjPVJmKGEsYyk7ZD1SZihhLGQpO2Y9W107YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmM9Qih7fSxjLHt2YWx1ZTp2b2lkIDB9KTtkPUIoe30sZCx7dmFsdWU6dm9pZCAwfSk7Zj1bXTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpjPVVmKGEsYyk7ZD1VZihhLGQpO2Y9W107YnJlYWs7ZGVmYXVsdDpcImZ1bmN0aW9uXCIhPT10eXBlb2YgYy5vbkNsaWNrJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5vbkNsaWNrJiYoYS5vbmNsaWNrPUMpfWhnKGIsZCxrZyk7dmFyIGcsaDthPW51bGw7Zm9yKGcgaW4gYylpZighZC5oYXNPd25Qcm9wZXJ0eShnKSYmYy5oYXNPd25Qcm9wZXJ0eShnKSYmbnVsbCE9Y1tnXSlpZihcInN0eWxlXCI9PT1nKWZvcihoIGluIGI9Y1tnXSxiKWIuaGFzT3duUHJvcGVydHkoaCkmJihhfHwoYT17fSksYVtoXT1cblwiXCIpO2Vsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1nJiZcImNoaWxkcmVuXCIhPT1nJiZcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09ZyYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWcmJlwiYXV0b0ZvY3VzXCIhPT1nJiYoUmEuaGFzT3duUHJvcGVydHkoZyk/Znx8KGY9W10pOihmPWZ8fFtdKS5wdXNoKGcsbnVsbCkpO2ZvcihnIGluIGQpe3ZhciBrPWRbZ107Yj1udWxsIT1jP2NbZ106dm9pZCAwO2lmKGQuaGFzT3duUHJvcGVydHkoZykmJmshPT1iJiYobnVsbCE9a3x8bnVsbCE9YikpaWYoXCJzdHlsZVwiPT09ZylpZihiKXtmb3IoaCBpbiBiKSFiLmhhc093blByb3BlcnR5KGgpfHxrJiZrLmhhc093blByb3BlcnR5KGgpfHwoYXx8KGE9e30pLGFbaF09XCJcIik7Zm9yKGggaW4gaylrLmhhc093blByb3BlcnR5KGgpJiZiW2hdIT09a1toXSYmKGF8fChhPXt9KSxhW2hdPWtbaF0pfWVsc2UgYXx8KGZ8fChmPVtdKSxmLnB1c2goZyxhKSksYT1rO2Vsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1cbmc/KGs9az9rLl9faHRtbDp2b2lkIDAsYj1iP2IuX19odG1sOnZvaWQgMCxudWxsIT1rJiZiIT09ayYmKGY9Znx8W10pLnB1c2goZyxcIlwiK2spKTpcImNoaWxkcmVuXCI9PT1nP2I9PT1rfHxcInN0cmluZ1wiIT09dHlwZW9mIGsmJlwibnVtYmVyXCIhPT10eXBlb2Yga3x8KGY9Znx8W10pLnB1c2goZyxcIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1nJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09ZyYmKFJhLmhhc093blByb3BlcnR5KGcpPyhudWxsIT1rJiZsZyhlLGcpLGZ8fGI9PT1rfHwoZj1bXSkpOihmPWZ8fFtdKS5wdXNoKGcsaykpfWEmJihmPWZ8fFtdKS5wdXNoKFwic3R5bGVcIixhKTtyZXR1cm4gZn1cbmZ1bmN0aW9uIHRnKGEsYixjLGQsZSl7XCJpbnB1dFwiPT09YyYmXCJyYWRpb1wiPT09ZS50eXBlJiZudWxsIT1lLm5hbWUmJk5mKGEsZSk7aWcoYyxkKTtkPWlnKGMsZSk7Zm9yKHZhciBmPTA7ZjxiLmxlbmd0aDtmKz0yKXt2YXIgZz1iW2ZdLGg9YltmKzFdO1wic3R5bGVcIj09PWc/ZmcoYSxoLGtnKTpcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1nP2JnKGEsaCk6XCJjaGlsZHJlblwiPT09Zz9jZyhhLGgpOmQ/bnVsbCE9aD9LZihhLGcsaCk6YS5yZW1vdmVBdHRyaWJ1dGUoZyk6bnVsbCE9aD9JZihhLGcsaCk6SmYoYSxnKX1zd2l0Y2goYyl7Y2FzZSBcImlucHV0XCI6T2YoYSxlKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpXZihhLGUpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjphLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlPXZvaWQgMCxiPWEuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSxhLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU9ISFlLm11bHRpcGxlLGM9ZS52YWx1ZSxudWxsIT1jP1NmKGEsXG4hIWUubXVsdGlwbGUsYywhMSk6YiE9PSEhZS5tdWx0aXBsZSYmKG51bGwhPWUuZGVmYXVsdFZhbHVlP1NmKGEsISFlLm11bHRpcGxlLGUuZGVmYXVsdFZhbHVlLCEwKTpTZihhLCEhZS5tdWx0aXBsZSxlLm11bHRpcGxlP1tdOlwiXCIsITEpKX19XG5mdW5jdGlvbiB1ZyhhLGIsYyxkLGUpe3N3aXRjaChiKXtjYXNlIFwiaWZyYW1lXCI6Y2FzZSBcIm9iamVjdFwiOlUoXCJ0b3BMb2FkXCIsXCJsb2FkXCIsYSk7YnJlYWs7Y2FzZSBcInZpZGVvXCI6Y2FzZSBcImF1ZGlvXCI6Zm9yKHZhciBmIGluIG1nKW1nLmhhc093blByb3BlcnR5KGYpJiZVKGYsbWdbZl0sYSk7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTticmVhaztjYXNlIFwiaW1nXCI6Y2FzZSBcImltYWdlXCI6VShcInRvcEVycm9yXCIsXCJlcnJvclwiLGEpO1UoXCJ0b3BMb2FkXCIsXCJsb2FkXCIsYSk7YnJlYWs7Y2FzZSBcImZvcm1cIjpVKFwidG9wUmVzZXRcIixcInJlc2V0XCIsYSk7VShcInRvcFN1Ym1pdFwiLFwic3VibWl0XCIsYSk7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpVKFwidG9wVG9nZ2xlXCIsXCJ0b2dnbGVcIixhKTticmVhaztjYXNlIFwiaW5wdXRcIjpNZihhLGMpO1UoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7bGcoZSxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpUZihhLGMpO1xuVShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtsZyhlLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VmYoYSxjKSxVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpLGxnKGUsXCJvbkNoYW5nZVwiKX1oZyhiLGMsa2cpO2Q9bnVsbDtmb3IodmFyIGcgaW4gYyljLmhhc093blByb3BlcnR5KGcpJiYoZj1jW2ddLFwiY2hpbGRyZW5cIj09PWc/XCJzdHJpbmdcIj09PXR5cGVvZiBmP2EudGV4dENvbnRlbnQhPT1mJiYoZD1bXCJjaGlsZHJlblwiLGZdKTpcIm51bWJlclwiPT09dHlwZW9mIGYmJmEudGV4dENvbnRlbnQhPT1cIlwiK2YmJihkPVtcImNoaWxkcmVuXCIsXCJcIitmXSk6UmEuaGFzT3duUHJvcGVydHkoZykmJm51bGwhPWYmJmxnKGUsZykpO3N3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpCYyhhKTtQZihhLGMpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOkJjKGEpO1hmKGEsYyk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmNhc2UgXCJvcHRpb25cIjpicmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjLm9uQ2xpY2smJlxuKGEub25jbGljaz1DKX1yZXR1cm4gZH1mdW5jdGlvbiB2ZyhhLGIpe3JldHVybiBhLm5vZGVWYWx1ZSE9PWJ9XG52YXIgd2c9T2JqZWN0LmZyZWV6ZSh7Y3JlYXRlRWxlbWVudDpuZyxjcmVhdGVUZXh0Tm9kZTpvZyxzZXRJbml0aWFsUHJvcGVydGllczpwZyxkaWZmUHJvcGVydGllczpzZyx1cGRhdGVQcm9wZXJ0aWVzOnRnLGRpZmZIeWRyYXRlZFByb3BlcnRpZXM6dWcsZGlmZkh5ZHJhdGVkVGV4dDp2Zyx3YXJuRm9yVW5tYXRjaGVkVGV4dDpmdW5jdGlvbigpe30sd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudDpmdW5jdGlvbigpe30sd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dDpmdW5jdGlvbigpe30sd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50OmZ1bmN0aW9uKCl7fSx3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQ6ZnVuY3Rpb24oKXt9LHJlc3RvcmVDb250cm9sbGVkU3RhdGU6ZnVuY3Rpb24oYSxiLGMpe3N3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpPZihhLGMpO2I9Yy5uYW1lO2lmKFwicmFkaW9cIj09PWMudHlwZSYmbnVsbCE9Yil7Zm9yKGM9YTtjLnBhcmVudE5vZGU7KWM9XG5jLnBhcmVudE5vZGU7Yz1jLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFtuYW1lXFx4M2RcIitKU09OLnN0cmluZ2lmeShcIlwiK2IpKyddW3R5cGVcXHgzZFwicmFkaW9cIl0nKTtmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKXt2YXIgZD1jW2JdO2lmKGQhPT1hJiZkLmZvcm09PT1hLmZvcm0pe3ZhciBlPXJiKGQpO2U/dm9pZCAwOkUoXCI5MFwiKTtDYyhkKTtPZihkLGUpfX19YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6V2YoYSxjKTticmVhaztjYXNlIFwic2VsZWN0XCI6Yj1jLnZhbHVlLG51bGwhPWImJlNmKGEsISFjLm11bHRpcGxlLGIsITEpfX19KTtuYy5pbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50KHdnKTt2YXIgeGc9bnVsbCxNZz1udWxsO2Z1bmN0aW9uIE5nKGEpe3JldHVybiEoIWF8fDEhPT1hLm5vZGVUeXBlJiY5IT09YS5ub2RlVHlwZSYmMTEhPT1hLm5vZGVUeXBlJiYoOCE9PWEubm9kZVR5cGV8fFwiIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlIFwiIT09YS5ub2RlVmFsdWUpKX1cbmZ1bmN0aW9uIE9nKGEpe2E9YT85PT09YS5ub2RlVHlwZT9hLmRvY3VtZW50RWxlbWVudDphLmZpcnN0Q2hpbGQ6bnVsbDtyZXR1cm4hKCFhfHwxIT09YS5ub2RlVHlwZXx8IWEuaGFzQXR0cmlidXRlKFwiZGF0YS1yZWFjdHJvb3RcIikpfVxudmFyIFo9b2Yoe2dldFJvb3RIb3N0Q29udGV4dDpmdW5jdGlvbihhKXt2YXIgYj1hLm5vZGVUeXBlO3N3aXRjaChiKXtjYXNlIDk6Y2FzZSAxMTphPShhPWEuZG9jdW1lbnRFbGVtZW50KT9hLm5hbWVzcGFjZVVSSTokZihudWxsLFwiXCIpO2JyZWFrO2RlZmF1bHQ6Yj04PT09Yj9hLnBhcmVudE5vZGU6YSxhPWIubmFtZXNwYWNlVVJJfHxudWxsLGI9Yi50YWdOYW1lLGE9JGYoYSxiKX1yZXR1cm4gYX0sZ2V0Q2hpbGRIb3N0Q29udGV4dDpmdW5jdGlvbihhLGIpe3JldHVybiAkZihhLGIpfSxnZXRQdWJsaWNJbnN0YW5jZTpmdW5jdGlvbihhKXtyZXR1cm4gYX0scHJlcGFyZUZvckNvbW1pdDpmdW5jdGlvbigpe3hnPXRkO3ZhciBhPWRhKCk7aWYoS2QoYSkpe2lmKFwic2VsZWN0aW9uU3RhcnRcImluIGEpdmFyIGI9e3N0YXJ0OmEuc2VsZWN0aW9uU3RhcnQsZW5kOmEuc2VsZWN0aW9uRW5kfTtlbHNlIGE6e3ZhciBjPXdpbmRvdy5nZXRTZWxlY3Rpb24mJndpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbmlmKGMmJjAhPT1jLnJhbmdlQ291bnQpe2I9Yy5hbmNob3JOb2RlO3ZhciBkPWMuYW5jaG9yT2Zmc2V0LGU9Yy5mb2N1c05vZGU7Yz1jLmZvY3VzT2Zmc2V0O3RyeXtiLm5vZGVUeXBlLGUubm9kZVR5cGV9Y2F0Y2goeil7Yj1udWxsO2JyZWFrIGF9dmFyIGY9MCxnPS0xLGg9LTEsaz0wLHE9MCx2PWEseT1udWxsO2I6Zm9yKDs7KXtmb3IodmFyIHU7Oyl7diE9PWJ8fDAhPT1kJiYzIT09di5ub2RlVHlwZXx8KGc9ZitkKTt2IT09ZXx8MCE9PWMmJjMhPT12Lm5vZGVUeXBlfHwoaD1mK2MpOzM9PT12Lm5vZGVUeXBlJiYoZis9di5ub2RlVmFsdWUubGVuZ3RoKTtpZihudWxsPT09KHU9di5maXJzdENoaWxkKSlicmVhazt5PXY7dj11fWZvcig7Oyl7aWYodj09PWEpYnJlYWsgYjt5PT09YiYmKytrPT09ZCYmKGc9Zik7eT09PWUmJisrcT09PWMmJihoPWYpO2lmKG51bGwhPT0odT12Lm5leHRTaWJsaW5nKSlicmVhazt2PXk7eT12LnBhcmVudE5vZGV9dj11fWI9LTE9PT1nfHwtMT09PWg/bnVsbDpcbntzdGFydDpnLGVuZDpofX1lbHNlIGI9bnVsbH1iPWJ8fHtzdGFydDowLGVuZDowfX1lbHNlIGI9bnVsbDtNZz17Zm9jdXNlZEVsZW06YSxzZWxlY3Rpb25SYW5nZTpifTt1ZCghMSl9LHJlc2V0QWZ0ZXJDb21taXQ6ZnVuY3Rpb24oKXt2YXIgYT1NZyxiPWRhKCksYz1hLmZvY3VzZWRFbGVtLGQ9YS5zZWxlY3Rpb25SYW5nZTtpZihiIT09YyYmZmEoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGMpKXtpZihLZChjKSlpZihiPWQuc3RhcnQsYT1kLmVuZCx2b2lkIDA9PT1hJiYoYT1iKSxcInNlbGVjdGlvblN0YXJ0XCJpbiBjKWMuc2VsZWN0aW9uU3RhcnQ9YixjLnNlbGVjdGlvbkVuZD1NYXRoLm1pbihhLGMudmFsdWUubGVuZ3RoKTtlbHNlIGlmKHdpbmRvdy5nZXRTZWxlY3Rpb24pe2I9d2luZG93LmdldFNlbGVjdGlvbigpO3ZhciBlPWNbRWIoKV0ubGVuZ3RoO2E9TWF0aC5taW4oZC5zdGFydCxlKTtkPXZvaWQgMD09PWQuZW5kP2E6TWF0aC5taW4oZC5lbmQsZSk7IWIuZXh0ZW5kJiZhPlxuZCYmKGU9ZCxkPWEsYT1lKTtlPUpkKGMsYSk7dmFyIGY9SmQoYyxkKTtpZihlJiZmJiYoMSE9PWIucmFuZ2VDb3VudHx8Yi5hbmNob3JOb2RlIT09ZS5ub2RlfHxiLmFuY2hvck9mZnNldCE9PWUub2Zmc2V0fHxiLmZvY3VzTm9kZSE9PWYubm9kZXx8Yi5mb2N1c09mZnNldCE9PWYub2Zmc2V0KSl7dmFyIGc9ZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtnLnNldFN0YXJ0KGUubm9kZSxlLm9mZnNldCk7Yi5yZW1vdmVBbGxSYW5nZXMoKTthPmQ/KGIuYWRkUmFuZ2UoZyksYi5leHRlbmQoZi5ub2RlLGYub2Zmc2V0KSk6KGcuc2V0RW5kKGYubm9kZSxmLm9mZnNldCksYi5hZGRSYW5nZShnKSl9fWI9W107Zm9yKGE9YzthPWEucGFyZW50Tm9kZTspMT09PWEubm9kZVR5cGUmJmIucHVzaCh7ZWxlbWVudDphLGxlZnQ6YS5zY3JvbGxMZWZ0LHRvcDphLnNjcm9sbFRvcH0pO2lhKGMpO2ZvcihjPTA7YzxiLmxlbmd0aDtjKyspYT1iW2NdLGEuZWxlbWVudC5zY3JvbGxMZWZ0PWEubGVmdCxhLmVsZW1lbnQuc2Nyb2xsVG9wPVxuYS50b3B9TWc9bnVsbDt1ZCh4Zyk7eGc9bnVsbH0sY3JlYXRlSW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMsZCxlKXthPW5nKGEsYixjLGQpO2FbUV09ZTthW29iXT1iO3JldHVybiBhfSxhcHBlbmRJbml0aWFsQ2hpbGQ6ZnVuY3Rpb24oYSxiKXthLmFwcGVuZENoaWxkKGIpfSxmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbjpmdW5jdGlvbihhLGIsYyxkKXtwZyhhLGIsYyxkKTthOntzd2l0Y2goYil7Y2FzZSBcImJ1dHRvblwiOmNhc2UgXCJpbnB1dFwiOmNhc2UgXCJzZWxlY3RcIjpjYXNlIFwidGV4dGFyZWFcIjphPSEhYy5hdXRvRm9jdXM7YnJlYWsgYX1hPSExfXJldHVybiBhfSxwcmVwYXJlVXBkYXRlOmZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIHNnKGEsYixjLGQsZSl9LHNob3VsZFNldFRleHRDb250ZW50OmZ1bmN0aW9uKGEsYil7cmV0dXJuXCJ0ZXh0YXJlYVwiPT09YXx8XCJzdHJpbmdcIj09PXR5cGVvZiBiLmNoaWxkcmVufHxcIm51bWJlclwiPT09dHlwZW9mIGIuY2hpbGRyZW58fFwib2JqZWN0XCI9PT1cbnR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZudWxsIT09Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmXCJzdHJpbmdcIj09PXR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbH0sc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTpmdW5jdGlvbihhLGIpe3JldHVybiEhYi5oaWRkZW59LGNyZWF0ZVRleHRJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyxkKXthPW9nKGEsYik7YVtRXT1kO3JldHVybiBhfSxub3c6cmYsbXV0YXRpb246e2NvbW1pdE1vdW50OmZ1bmN0aW9uKGEpe2EuZm9jdXMoKX0sY29tbWl0VXBkYXRlOmZ1bmN0aW9uKGEsYixjLGQsZSl7YVtvYl09ZTt0ZyhhLGIsYyxkLGUpfSxyZXNldFRleHRDb250ZW50OmZ1bmN0aW9uKGEpe2EudGV4dENvbnRlbnQ9XCJcIn0sY29tbWl0VGV4dFVwZGF0ZTpmdW5jdGlvbihhLGIsYyl7YS5ub2RlVmFsdWU9Y30sYXBwZW5kQ2hpbGQ6ZnVuY3Rpb24oYSxiKXthLmFwcGVuZENoaWxkKGIpfSxhcHBlbmRDaGlsZFRvQ29udGFpbmVyOmZ1bmN0aW9uKGEsXG5iKXs4PT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGIsYSk6YS5hcHBlbmRDaGlsZChiKX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKGEsYixjKXthLmluc2VydEJlZm9yZShiLGMpfSxpbnNlcnRJbkNvbnRhaW5lckJlZm9yZTpmdW5jdGlvbihhLGIsYyl7OD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiLGMpOmEuaW5zZXJ0QmVmb3JlKGIsYyl9LHJlbW92ZUNoaWxkOmZ1bmN0aW9uKGEsYil7YS5yZW1vdmVDaGlsZChiKX0scmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyOmZ1bmN0aW9uKGEsYil7OD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpOmEucmVtb3ZlQ2hpbGQoYil9fSxoeWRyYXRpb246e2Nhbkh5ZHJhdGVJbnN0YW5jZTpmdW5jdGlvbihhLGIpe3JldHVybiAxIT09YS5ub2RlVHlwZXx8Yi50b0xvd2VyQ2FzZSgpIT09YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpP251bGw6YX0sY2FuSHlkcmF0ZVRleHRJbnN0YW5jZTpmdW5jdGlvbihhLFxuYil7cmV0dXJuXCJcIj09PWJ8fDMhPT1hLm5vZGVUeXBlP251bGw6YX0sZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nOmZ1bmN0aW9uKGEpe2ZvcihhPWEubmV4dFNpYmxpbmc7YSYmMSE9PWEubm9kZVR5cGUmJjMhPT1hLm5vZGVUeXBlOylhPWEubmV4dFNpYmxpbmc7cmV0dXJuIGF9LGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkOmZ1bmN0aW9uKGEpe2ZvcihhPWEuZmlyc3RDaGlsZDthJiYxIT09YS5ub2RlVHlwZSYmMyE9PWEubm9kZVR5cGU7KWE9YS5uZXh0U2libGluZztyZXR1cm4gYX0saHlkcmF0ZUluc3RhbmNlOmZ1bmN0aW9uKGEsYixjLGQsZSxmKXthW1FdPWY7YVtvYl09YztyZXR1cm4gdWcoYSxiLGMsZSxkKX0saHlkcmF0ZVRleHRJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyl7YVtRXT1jO3JldHVybiB2ZyhhLGIpfSxkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7fSxcbmRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90SHlkcmF0ZUluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXt9fSxzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2s6c2YsY2FuY2VsRGVmZXJyZWRDYWxsYmFjazp0Zix1c2VTeW5jU2NoZWR1bGluZzohMH0pO3JjPVouYmF0Y2hlZFVwZGF0ZXM7XG5mdW5jdGlvbiBQZyhhLGIsYyxkLGUpe05nKGMpP3ZvaWQgMDpFKFwiMjAwXCIpO3ZhciBmPWMuX3JlYWN0Um9vdENvbnRhaW5lcjtpZihmKVoudXBkYXRlQ29udGFpbmVyKGIsZixhLGUpO2Vsc2V7ZD1kfHxPZyhjKTtpZighZClmb3IoZj12b2lkIDA7Zj1jLmxhc3RDaGlsZDspYy5yZW1vdmVDaGlsZChmKTt2YXIgZz1aLmNyZWF0ZUNvbnRhaW5lcihjLGQpO2Y9Yy5fcmVhY3RSb290Q29udGFpbmVyPWc7Wi51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uKCl7Wi51cGRhdGVDb250YWluZXIoYixnLGEsZSl9KX1yZXR1cm4gWi5nZXRQdWJsaWNSb290SW5zdGFuY2UoZil9ZnVuY3Rpb24gUWcoYSxiKXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbDtOZyhiKT92b2lkIDA6RShcIjIwMFwiKTtyZXR1cm4gcGYoYSxiLG51bGwsYyl9XG5mdW5jdGlvbiBSZyhhLGIpe3RoaXMuX3JlYWN0Um9vdENvbnRhaW5lcj1aLmNyZWF0ZUNvbnRhaW5lcihhLGIpfVJnLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oYSxiKXtaLnVwZGF0ZUNvbnRhaW5lcihhLHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcixudWxsLGIpfTtSZy5wcm90b3R5cGUudW5tb3VudD1mdW5jdGlvbihhKXtaLnVwZGF0ZUNvbnRhaW5lcihudWxsLHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcixudWxsLGEpfTtcbnZhciBTZz17Y3JlYXRlUG9ydGFsOlFnLGZpbmRET01Ob2RlOmZ1bmN0aW9uKGEpe2lmKG51bGw9PWEpcmV0dXJuIG51bGw7aWYoMT09PWEubm9kZVR5cGUpcmV0dXJuIGE7dmFyIGI9YS5fcmVhY3RJbnRlcm5hbEZpYmVyO2lmKGIpcmV0dXJuIFouZmluZEhvc3RJbnN0YW5jZShiKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYS5yZW5kZXI/RShcIjE4OFwiKTpFKFwiMjEzXCIsT2JqZWN0LmtleXMoYSkpfSxoeWRyYXRlOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gUGcobnVsbCxhLGIsITAsYyl9LHJlbmRlcjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIFBnKG51bGwsYSxiLCExLGMpfSx1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjpmdW5jdGlvbihhLGIsYyxkKXtudWxsPT1hfHx2b2lkIDA9PT1hLl9yZWFjdEludGVybmFsRmliZXI/RShcIjM4XCIpOnZvaWQgMDtyZXR1cm4gUGcoYSxiLGMsITEsZCl9LHVubW91bnRDb21wb25lbnRBdE5vZGU6ZnVuY3Rpb24oYSl7TmcoYSk/dm9pZCAwOlxuRShcIjQwXCIpO3JldHVybiBhLl9yZWFjdFJvb3RDb250YWluZXI/KFoudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbigpe1BnKG51bGwsbnVsbCxhLCExLGZ1bmN0aW9uKCl7YS5fcmVhY3RSb290Q29udGFpbmVyPW51bGx9KX0pLCEwKTohMX0sdW5zdGFibGVfY3JlYXRlUG9ydGFsOlFnLHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOnRjLHVuc3RhYmxlX2RlZmVycmVkVXBkYXRlczpaLmRlZmVycmVkVXBkYXRlcyxmbHVzaFN5bmM6Wi5mbHVzaFN5bmMsX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6e0V2ZW50UGx1Z2luSHViOm1iLEV2ZW50UGx1Z2luUmVnaXN0cnk6VmEsRXZlbnRQcm9wYWdhdG9yczpDYixSZWFjdENvbnRyb2xsZWRDb21wb25lbnQ6cWMsUmVhY3RET01Db21wb25lbnRUcmVlOnNiLFJlYWN0RE9NRXZlbnRMaXN0ZW5lcjp4ZH19O1xuWi5pbmplY3RJbnRvRGV2VG9vbHMoe2ZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOnBiLGJ1bmRsZVR5cGU6MCx2ZXJzaW9uOlwiMTYuMi4wXCIscmVuZGVyZXJQYWNrYWdlTmFtZTpcInJlYWN0LWRvbVwifSk7dmFyIFRnPU9iamVjdC5mcmVlemUoe2RlZmF1bHQ6U2d9KSxVZz1UZyYmU2d8fFRnO21vZHVsZS5leHBvcnRzPVVnW1wiZGVmYXVsdFwiXT9VZ1tcImRlZmF1bHRcIl06VWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICB2YXIgZG9jID0gb2JqZWN0ID8gb2JqZWN0Lm93bmVyRG9jdW1lbnQgfHwgb2JqZWN0IDogZG9jdW1lbnQ7XG4gIHZhciBkZWZhdWx0VmlldyA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIHJldHVybiAhIShvYmplY3QgJiYgKHR5cGVvZiBkZWZhdWx0Vmlldy5Ob2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgZGVmYXVsdFZpZXcuTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb2RlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMi4wXG4gKiByZWFjdC1kb20uZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcbnZhciBoeXBoZW5hdGVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUnKTtcbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lJyk7XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG4hUmVhY3QgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTSB3YXMgbG9hZGVkIGJlZm9yZSBSZWFjdC4gTWFrZSBzdXJlIHlvdSBsb2FkIHRoZSBSZWFjdCBwYWNrYWdlIGJlZm9yZSBsb2FkaW5nIFJlYWN0RE9NLicpIDogdm9pZCAwO1xuXG4vLyBUaGVzZSBhdHRyaWJ1dGVzIHNob3VsZCBiZSBhbGwgbG93ZXJjYXNlIHRvIGFsbG93IGZvclxuLy8gY2FzZSBpbnNlbnNpdGl2ZSBjaGVja3NcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAgY2hpbGRyZW46IHRydWUsXG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB0cnVlLFxuICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gIGRlZmF1bHRDaGVja2VkOiB0cnVlLFxuICBpbm5lckhUTUw6IHRydWUsXG4gIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogdHJ1ZSxcbiAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiB0cnVlLFxuICBzdHlsZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gY2hlY2tNYXNrKHZhbHVlLCBiaXRtYXNrKSB7XG4gIHJldHVybiAodmFsdWUgJiBiaXRtYXNrKSA9PT0gYml0bWFzaztcbn1cblxudmFyIERPTVByb3BlcnR5SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQsIGNhbWVsY2FzZWQgcHJvcGVydHkgbmFtZXMgdG8gYSBjb25maWd1cmF0aW9uIHRoYXRcbiAgICogc3BlY2lmaWVzIGhvdyB0aGUgYXNzb2NpYXRlZCBET00gcHJvcGVydHkgc2hvdWxkIGJlIGFjY2Vzc2VkIG9yIHJlbmRlcmVkLlxuICAgKi9cbiAgTVVTVF9VU0VfUFJPUEVSVFk6IDB4MSxcbiAgSEFTX0JPT0xFQU5fVkFMVUU6IDB4NCxcbiAgSEFTX05VTUVSSUNfVkFMVUU6IDB4OCxcbiAgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU6IDB4MTAgfCAweDgsXG4gIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU6IDB4MjAsXG4gIEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTogMHg0MCxcblxuICAvKipcbiAgICogSW5qZWN0IHNvbWUgc3BlY2lhbGl6ZWQga25vd2xlZGdlIGFib3V0IHRoZSBET00uIFRoaXMgdGFrZXMgYSBjb25maWcgb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiBQcm9wZXJ0aWVzOiBvYmplY3QgbWFwcGluZyBET00gcHJvcGVydHkgbmFtZSB0byBvbmUgb2YgdGhlXG4gICAqIERPTVByb3BlcnR5SW5qZWN0aW9uIGNvbnN0YW50cyBvciBudWxsLiBJZiB5b3VyIGF0dHJpYnV0ZSBpc24ndCBpbiBoZXJlLFxuICAgKiBpdCB3b24ndCBnZXQgd3JpdHRlbiB0byB0aGUgRE9NLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lczogb2JqZWN0IG1hcHBpbmcgUmVhY3QgYXR0cmlidXRlIG5hbWUgdG8gdGhlIERPTVxuICAgKiBhdHRyaWJ1dGUgbmFtZS4gQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSAqKmxvd2VyY2FzZSoqXG4gICAqIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXNwYWNlczogb2JqZWN0IG1hcHBpbmcgUmVhY3QgYXR0cmlidXRlIG5hbWUgdG8gdGhlIERPTVxuICAgKiBhdHRyaWJ1dGUgbmFtZXNwYWNlIFVSTC4gKEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSBubyBuYW1lc3BhY2UuKVxuICAgKlxuICAgKiBET01Qcm9wZXJ0eU5hbWVzOiBzaW1pbGFyIHRvIERPTUF0dHJpYnV0ZU5hbWVzIGJ1dCBmb3IgRE9NIHByb3BlcnRpZXMuXG4gICAqIFByb3BlcnR5IG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTU11dGF0aW9uTWV0aG9kczogUHJvcGVydGllcyB0aGF0IHJlcXVpcmUgc3BlY2lhbCBtdXRhdGlvbiBtZXRob2RzLiBJZlxuICAgKiBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgdGhlIG11dGF0aW9uIG1ldGhvZCBzaG91bGQgdW5zZXQgdGhlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZG9tUHJvcGVydHlDb25maWcgdGhlIGNvbmZpZyBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAqL1xuICBpbmplY3RET01Qcm9wZXJ0eUNvbmZpZzogZnVuY3Rpb24gKGRvbVByb3BlcnR5Q29uZmlnKSB7XG4gICAgdmFyIEluamVjdGlvbiA9IERPTVByb3BlcnR5SW5qZWN0aW9uO1xuICAgIHZhciBQcm9wZXJ0aWVzID0gZG9tUHJvcGVydHlDb25maWcuUHJvcGVydGllcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXNwYWNlcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXMgfHwge307XG4gICAgdmFyIERPTU11dGF0aW9uTWV0aG9kcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTU11dGF0aW9uTWV0aG9kcyB8fCB7fTtcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIFByb3BlcnRpZXMpIHtcbiAgICAgICEhcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPyBpbnZhcmlhbnQoZmFsc2UsIFwiaW5qZWN0RE9NUHJvcGVydHlDb25maWcoLi4uKTogWW91J3JlIHRyeWluZyB0byBpbmplY3QgRE9NIHByb3BlcnR5ICclcycgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBpbmplY3RlZC4gWW91IG1heSBiZSBhY2NpZGVudGFsbHkgaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgaW5qZWN0aW5nIHR3byBjb25maWdzIHRoYXQgaGF2ZSBjb25mbGljdGluZyBwcm9wZXJ0eSBuYW1lcy5cIiwgcHJvcE5hbWUpIDogdm9pZCAwO1xuXG4gICAgICB2YXIgbG93ZXJDYXNlZCA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcHJvcENvbmZpZyA9IFByb3BlcnRpZXNbcHJvcE5hbWVdO1xuXG4gICAgICB2YXIgcHJvcGVydHlJbmZvID0ge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBsb3dlckNhc2VkLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lc3BhY2U6IG51bGwsXG4gICAgICAgIHByb3BlcnR5TmFtZTogcHJvcE5hbWUsXG4gICAgICAgIG11dGF0aW9uTWV0aG9kOiBudWxsLFxuXG4gICAgICAgIG11c3RVc2VQcm9wZXJ0eTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWSksXG4gICAgICAgIGhhc0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc051bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFKSxcbiAgICAgICAgaGFzU3RyaW5nQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSlcbiAgICAgIH07XG4gICAgICAhKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICsgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgPD0gMSkgPyBpbnZhcmlhbnQoZmFsc2UsIFwiRE9NUHJvcGVydHk6IFZhbHVlIGNhbiBiZSBvbmUgb2YgYm9vbGVhbiwgb3ZlcmxvYWRlZCBib29sZWFuLCBvciBudW1lcmljIHZhbHVlLCBidXQgbm90IGEgY29tYmluYXRpb246ICVzXCIsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IERPTUF0dHJpYnV0ZU5hbWVzW3Byb3BOYW1lXTtcblxuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlID0gRE9NQXR0cmlidXRlTmFtZXNwYWNlc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01NdXRhdGlvbk1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZCA9IERPTU11dGF0aW9uTWV0aG9kc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIC8vIERvd25jYXNlIHJlZmVyZW5jZXMgdG8gd2hpdGVsaXN0IHByb3BlcnRpZXMgdG8gY2hlY2sgZm9yIG1lbWJlcnNoaXBcbiAgICAgIC8vIHdpdGhvdXQgY2FzZS1zZW5zaXRpdml0eS4gVGhpcyBhbGxvd3MgdGhlIHdoaXRlbGlzdCB0byBwaWNrIHVwXG4gICAgICAvLyBgYWxsb3dmdWxsc2NyZWVuYCwgd2hpY2ggc2hvdWxkIGJlIHdyaXR0ZW4gdXNpbmcgdGhlIHByb3BlcnR5IGNvbmZpZ3VyYXRpb25cbiAgICAgIC8vIGZvciBgYWxsb3dGdWxsc2NyZWVuYFxuICAgICAgcHJvcGVydGllc1twcm9wTmFtZV0gPSBwcm9wZXJ0eUluZm87XG4gICAgfVxuICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9IFwiOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfQ0hBUiA9IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyBcIlxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXCI7XG5cblxudmFyIFJPT1RfQVRUUklCVVRFX05BTUUgPSAnZGF0YS1yZWFjdHJvb3QnO1xuXG4vKipcbiAqIE1hcCBmcm9tIHByb3BlcnR5IFwic3RhbmRhcmQgbmFtZVwiIHRvIGFuIG9iamVjdCB3aXRoIGluZm8gYWJvdXQgaG93IHRvIHNldFxuICogdGhlIHByb3BlcnR5IGluIHRoZSBET00uIEVhY2ggb2JqZWN0IGNvbnRhaW5zOlxuICpcbiAqIGF0dHJpYnV0ZU5hbWU6XG4gKiAgIFVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gKiBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAqIHByb3BlcnR5TmFtZTpcbiAqICAgVXNlZCBvbiBET00gbm9kZSBpbnN0YW5jZXMuIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvXG4gKiAgIGV4dGVybmFsIGZhY3RvcnMuKVxuICogbXV0YXRpb25NZXRob2Q6XG4gKiAgIElmIG5vbi1udWxsLCB1c2VkIGluc3RlYWQgb2YgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAgYWZ0ZXJcbiAqICAgaW5pdGlhbCByZW5kZXIuXG4gKiBtdXN0VXNlUHJvcGVydHk6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICogaGFzQm9vbGVhblZhbHVlOlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAqIGhhc051bWVyaWNWYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYyBhbmQgc2hvdWxkIGJlXG4gKiAgIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmVcbiAqICAgbnVtZXJpYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4gKiAgIFJlbW92ZWQgd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlblxuICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gKi9cbnZhciBwcm9wZXJ0aWVzID0ge307XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wZXJ0eSBuYW1lIGlzIGEgd3JpdGVhYmxlIGF0dHJpYnV0ZS5cbiAqIEBtZXRob2RcbiAqL1xuZnVuY3Rpb24gc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gIGlmIChpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobmFtZS5sZW5ndGggPiAyICYmIChuYW1lWzBdID09PSAnbycgfHwgbmFtZVswXSA9PT0gJ08nKSAmJiAobmFtZVsxXSA9PT0gJ24nIHx8IG5hbWVbMV0gPT09ICdOJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBzaG91bGRBdHRyaWJ1dGVBY2NlcHRCb29sZWFuVmFsdWUobmFtZSk7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBmdW5jdGlvbiwgc3ltYm9sXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlJbmZvKG5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBwcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpIHtcbiAgaWYgKGlzUmVzZXJ2ZWRQcm9wKG5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgIHJldHVybiBwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNTdHJpbmdCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU7XG4gIH1cbiAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgcmV0dXJuIHByZWZpeCA9PT0gJ2RhdGEtJyB8fCBwcmVmaXggPT09ICdhcmlhLSc7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiBhIHByb3BlcnR5IG5hbWUgaXMgd2l0aGluIHRoZSBsaXN0IG9mIHByb3BlcnRpZXNcbiAqIHJlc2VydmVkIGZvciBpbnRlcm5hbCBSZWFjdCBvcGVyYXRpb25zLiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZFxuICogbm90IGJlIHNldCBvbiBhbiBIVE1MIGVsZW1lbnQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgbmFtZSBpcyB3aXRoaW4gcmVzZXJ2ZWQgcHJvcHNcbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZFByb3AobmFtZSkge1xuICByZXR1cm4gUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkobmFtZSk7XG59XG5cbnZhciBpbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcblxudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gaW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19OVU1FUklDX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUgPSBpbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUgPSBpbmplY3Rpb24uSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFO1xuXG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0ge1xuICAvLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4gIC8vIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4gIC8vIG5hbWUgd2FybmluZ3MuXG4gIFByb3BlcnRpZXM6IHtcbiAgICBhbGxvd0Z1bGxTY3JlZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIHNwZWNpZmllcyB0YXJnZXQgY29udGV4dCBmb3IgbGlua3Mgd2l0aCBgcHJlbG9hZGAgdHlwZVxuICAgIGFzeW5jOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBOb3RlOiB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IHByZXZlbnRzIGl0IGZyb20gYmVpbmcgd3JpdHRlbiB0byB0aGUgRE9NXG4gICAgLy8gb24gdGhlIGNsaWVudCBzaWRlIGJlY2F1c2UgdGhlIGJyb3dzZXJzIGFyZSBpbmNvbnNpc3RlbnQuIEluc3RlYWQgd2UgY2FsbCBmb2N1cygpLlxuICAgIGF1dG9Gb2N1czogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b1BsYXk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNhcHR1cmU6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjb2xzOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBjb250ZW50RWRpdGFibGU6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICBjb250cm9sczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgJ2RlZmF1bHQnOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlzYWJsZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRvd25sb2FkOiBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLFxuICAgIGRyYWdnYWJsZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLFxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBoaWRkZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGxvb3A6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIENhdXRpb247IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4gICAgLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC5cbiAgICBtdWx0aXBsZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtdXRlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBub1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBvcGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBwbGF5c0lubGluZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmVhZE9ubHk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlcXVpcmVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXZlcnNlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcm93czogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgcm93U3BhbjogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc2NvcGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzZWFtbGVzczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2l6ZTogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3RhcnQ6IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIC8vIHN1cHBvcnQgZm9yIHByb2plY3RpbmcgcmVndWxhciBET00gRWxlbWVudHMgdmlhIFYxIG5hbWVkIHNsb3RzICggc2hhZG93IGRvbSApXG4gICAgc3BhbjogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BlbGxDaGVjazogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIFN0eWxlIG11c3QgYmUgZXhwbGljaXRseSBzZXQgaW4gdGhlIGF0dHJpYnV0ZSBsaXN0LiBSZWFjdCBjb21wb25lbnRzXG4gICAgLy8gZXhwZWN0IGEgc3R5bGUgb2JqZWN0XG4gICAgc3R5bGU6IDAsXG4gICAgLy8gS2VlcCBpdCBpbiB0aGUgd2hpdGVsaXN0IGJlY2F1c2UgaXQgaXMgY2FzZS1zZW5zaXRpdmUgZm9yIFNWRy5cbiAgICB0YWJJbmRleDogMCxcbiAgICAvLyBpdGVtU2NvcGUgaXMgZm9yIGZvciBNaWNyb2RhdGEgc3VwcG9ydC5cbiAgICAvLyBTZWUgaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgaXRlbVNjb3BlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBUaGVzZSBhdHRyaWJ1dGVzIG11c3Qgc3RheSBpbiB0aGUgd2hpdGUtbGlzdCBiZWNhdXNlIHRoZXkgaGF2ZVxuICAgIC8vIGRpZmZlcmVudCBhdHRyaWJ1dGUgbmFtZXMgKHNlZSBET01BdHRyaWJ1dGVOYW1lcyBiZWxvdylcbiAgICBhY2NlcHRDaGFyc2V0OiAwLFxuICAgIGNsYXNzTmFtZTogMCxcbiAgICBodG1sRm9yOiAwLFxuICAgIGh0dHBFcXVpdjogMCxcbiAgICAvLyBBdHRyaWJ1dGVzIHdpdGggbXV0YXRpb24gbWV0aG9kcyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgd2hpdGVsaXN0XG4gICAgLy8gU2V0IHRoZSBzdHJpbmcgYm9vbGVhbiBmbGFnIHRvIGFsbG93IHRoZSBiZWhhdmlvclxuICAgIHZhbHVlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUVcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xuICB9LFxuICBET01NdXRhdGlvbk1ldGhvZHM6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIE51bWJlciBpbnB1dHMgZ2V0IHNwZWNpYWwgdHJlYXRtZW50IGR1ZSB0byBzb21lIGVkZ2UgY2FzZXMgaW5cbiAgICAgIC8vIENocm9tZS4gTGV0IGV2ZXJ5dGhpbmcgZWxzZSBhc3NpZ24gdGhlIHZhbHVlIGF0dHJpYnV0ZSBhcyBub3JtYWwuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTMjaXNzdWVjb21tZW50LTIzNjA3NDMyNlxuICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ251bWJlcicgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykgPT09IGZhbHNlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnZhbGlkaXR5ICYmICFub2RlLnZhbGlkaXR5LmJhZElucHV0ICYmIG5vZGUub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBub2RlKSB7XG4gICAgICAgIC8vIERvbid0IGFzc2lnbiBhbiBhdHRyaWJ1dGUgaWYgdmFsaWRhdGlvbiByZXBvcnRzIGJhZFxuICAgICAgICAvLyBpbnB1dC4gQ2hyb21lIHdpbGwgY2xlYXIgdGhlIHZhbHVlLiBBZGRpdGlvbmFsbHksIGRvbid0XG4gICAgICAgIC8vIG9wZXJhdGUgb24gaW5wdXRzIHRoYXQgaGF2ZSBmb2N1cywgb3RoZXJ3aXNlIENocm9tZSBtaWdodFxuICAgICAgICAvLyBzdHJpcCBvZmYgdHJhaWxpbmcgZGVjaW1hbCBwbGFjZXMgYW5kIGNhdXNlIHRoZSB1c2VyJ3NcbiAgICAgICAgLy8gY3Vyc29yIHBvc2l0aW9uIHRvIGp1bXAgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgaW5wdXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluIFJlYWN0RE9NSW5wdXQsIHdlIGhhdmUgYW4gb25CbHVyIGV2ZW50IHRoYXQgd2lsbCB0cmlnZ2VyXG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gYWdhaW4gd2hlbiBmb2N1cyBpcyBsb3N0LlxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSA9IGluamVjdGlvbi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU7XG5cblxudmFyIE5TID0ge1xuICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsXG4gKiBuYW1lc3BhY2luZywgb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LlxuICpcbiAqIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhpcyBsaXN0LCBiZSBzdXJlIHRvIGFsc28gYWRkIHRoZW0gdG9cbiAqIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4gKiBuYW1lIHdhcm5pbmdzLlxuICpcbiAqIFNWRyBBdHRyaWJ1dGVzIExpc3Q6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHL2F0dGluZGV4Lmh0bWxcbiAqIFNNSUwgU3BlYzpcbiAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zbWlsXG4gKi9cbnZhciBBVFRSUyA9IFsnYWNjZW50LWhlaWdodCcsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXJhYmljLWZvcm0nLCAnYmFzZWxpbmUtc2hpZnQnLCAnY2FwLWhlaWdodCcsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2RvbWluYW50LWJhc2VsaW5lJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZ2x5cGgtbmFtZScsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJywgJ2hvcml6LWFkdi14JywgJ2hvcml6LW9yaWdpbi14JywgJ2ltYWdlLXJlbmRlcmluZycsICdsZXR0ZXItc3BhY2luZycsICdsaWdodGluZy1jb2xvcicsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ292ZXJsaW5lLXBvc2l0aW9uJywgJ292ZXJsaW5lLXRoaWNrbmVzcycsICdwYWludC1vcmRlcicsICdwYW5vc2UtMScsICdwb2ludGVyLWV2ZW50cycsICdyZW5kZXJpbmctaW50ZW50JywgJ3NoYXBlLXJlbmRlcmluZycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndW5kZXJsaW5lLXBvc2l0aW9uJywgJ3VuZGVybGluZS10aGlja25lc3MnLCAndW5pY29kZS1iaWRpJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd2ZWN0b3ItZWZmZWN0JywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dvcmQtc3BhY2luZycsICd3cml0aW5nLW1vZGUnLCAneC1oZWlnaHQnLCAneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnLCAneG1sOmJhc2UnLCAneG1sbnM6eGxpbmsnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ107XG5cbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgUHJvcGVydGllczoge1xuICAgIGF1dG9SZXZlcnNlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSxcbiAgICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSxcbiAgICBwcmVzZXJ2ZUFscGhhOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMVxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGF1dG9SZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICAgIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgICBwcmVzZXJ2ZUFscGhhOiAncHJlc2VydmVBbHBoYSdcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXNwYWNlczoge1xuICAgIHhsaW5rQWN0dWF0ZTogTlMueGxpbmssXG4gICAgeGxpbmtBcmNyb2xlOiBOUy54bGluayxcbiAgICB4bGlua0hyZWY6IE5TLnhsaW5rLFxuICAgIHhsaW5rUm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtTaG93OiBOUy54bGluayxcbiAgICB4bGlua1RpdGxlOiBOUy54bGluayxcbiAgICB4bGlua1R5cGU6IE5TLnhsaW5rLFxuICAgIHhtbEJhc2U6IE5TLnhtbCxcbiAgICB4bWxMYW5nOiBOUy54bWwsXG4gICAgeG1sU3BhY2U6IE5TLnhtbFxuICB9XG59O1xuXG52YXIgQ0FNRUxJWkUgPSAvW1xcLVxcOl0oW2Etel0pL2c7XG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTtcbn07XG5cbkFUVFJTLmZvckVhY2goZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIHZhciByZWFjdE5hbWUgPSBvcmlnaW5hbC5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcblxuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzW3JlYWN0TmFtZV0gPSAwO1xuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc1tyZWFjdE5hbWVdID0gb3JpZ2luYWw7XG59KTtcblxuaW5qZWN0aW9uLmluamVjdERPTVByb3BlcnR5Q29uZmlnKEhUTUxET01Qcm9wZXJ0eUNvbmZpZyk7XG5pbmplY3Rpb24uaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICAvLyBVc2VkIGJ5IEZpYmVyIHRvIHNpbXVsYXRlIGEgdHJ5LWNhdGNoLlxuICBfY2F1Z2h0RXJyb3I6IG51bGwsXG4gIF9oYXNDYXVnaHRFcnJvcjogZmFsc2UsXG5cbiAgLy8gVXNlZCBieSBldmVudCBzeXN0ZW0gdG8gY2FwdHVyZS9yZXRocm93IHRoZSBmaXJzdCBlcnJvci5cbiAgX3JldGhyb3dFcnJvcjogbnVsbCxcbiAgX2hhc1JldGhyb3dFcnJvcjogZmFsc2UsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RXJyb3JVdGlsczogZnVuY3Rpb24gKGluamVjdGVkRXJyb3JVdGlscykge1xuICAgICAgISh0eXBlb2YgaW5qZWN0ZWRFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbmplY3RlZCBpbnZva2VHdWFyZGVkQ2FsbGJhY2soKSBtdXN0IGJlIGEgZnVuY3Rpb24uJykgOiB2b2lkIDA7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBpbmplY3RlZEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gICAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgdGhyb3dzLCBvdGhlcndpc2UgbnVsbC5cbiAgICpcbiAgICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuICAgKiB1c2UgYSB0cnktY2F0Y2ggZGlyZWN0bHkgaXMgc28gdGhhdCB3ZSBjYW4gc3dhcCBvdXQgYSBkaWZmZXJlbnRcbiAgICogaW1wbGVtZW50YXRpb24gaW4gREVWIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICAgKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkoUmVhY3RFcnJvclV0aWxzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYnV0IGluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIGVycm9yLCBpdCBzdG9yZXNcbiAgICogaXQgaW4gYSBnbG9iYWwgc28gaXQgY2FuIGJlIHJldGhyb3duIGJ5IGByZXRocm93Q2F1Z2h0RXJyb3JgIGxhdGVyLlxuICAgKiBUT0RPOiBTZWUgaWYgX2NhdWdodEVycm9yIGFuZCBfcmV0aHJvd0Vycm9yIGNhbiBiZSB1bmlmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3I6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLmNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIGlmICghUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IpIHtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IgPSB0cnVlO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX3JldGhyb3dFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gICAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAgICovXG4gIHJldGhyb3dDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXRocm93Q2F1Z2h0RXJyb3IuYXBwbHkoUmVhY3RFcnJvclV0aWxzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIGhhc0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3I7XG4gIH0sXG5cbiAgY2xlYXJDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ2NsZWFyQ2F1Z2h0RXJyb3Igd2FzIGNhbGxlZCBidXQgbm8gZXJyb3Igd2FzIGNhcHR1cmVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gIHRyeSB7XG4gICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSB0cnVlO1xuICB9XG59O1xuXG57XG4gIC8vIEluIERFViBtb2RlLCB3ZSBzd2FwIG91dCBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgZm9yIGEgc3BlY2lhbCB2ZXJzaW9uXG4gIC8vIHRoYXQgcGxheXMgbW9yZSBuaWNlbHkgd2l0aCB0aGUgYnJvd3NlcidzIERldlRvb2xzLiBUaGUgaWRlYSBpcyB0byBwcmVzZXJ2ZVxuICAvLyBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvci4gQmVjYXVzZSBSZWFjdCB3cmFwcyBhbGwgdXNlci1wcm92aWRlZFxuICAvLyBmdW5jdGlvbnMgaW4gaW52b2tlR3VhcmRlZENhbGxiYWNrLCBhbmQgdGhlIHByb2R1Y3Rpb24gdmVyc2lvbiBvZlxuICAvLyBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgdXNlcyBhIHRyeS1jYXRjaCwgYWxsIHVzZXIgZXhjZXB0aW9ucyBhcmUgdHJlYXRlZFxuICAvLyBsaWtlIGNhdWdodCBleGNlcHRpb25zLCBhbmQgdGhlIERldlRvb2xzIHdvbid0IHBhdXNlIHVubGVzcyB0aGUgZGV2ZWxvcGVyXG4gIC8vIHRha2VzIHRoZSBleHRyYSBzdGVwIG9mIGVuYWJsaW5nIHBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zLiBUaGlzIGlzXG4gIC8vIHVudGludHVpdGl2ZSwgdGhvdWdoLCBiZWNhdXNlIGV2ZW4gdGhvdWdoIFJlYWN0IGhhcyBjYXVnaHQgdGhlIGVycm9yLCBmcm9tXG4gIC8vIHRoZSBkZXZlbG9wZXIncyBwZXJzcGVjdGl2ZSwgdGhlIGVycm9yIGlzIHVuY2F1Z2h0LlxuICAvL1xuICAvLyBUbyBwcmVzZXJ2ZSB0aGUgZXhwZWN0ZWQgXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IsIHdlIGRvbid0IHVzZSBhXG4gIC8vIHRyeS1jYXRjaCBpbiBERVYuIEluc3RlYWQsIHdlIHN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IHRvIGEgZmFrZVxuICAvLyBET00gbm9kZSwgYW5kIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgZnJvbSBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlclxuICAvLyBmb3IgdGhhdCBmYWtlIGV2ZW50LiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzLCB0aGUgZXJyb3IgaXMgXCJjYXB0dXJlZFwiIHVzaW5nXG4gIC8vIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuIEJ1dCBiZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5zIGluIGEgZGlmZmVyZW50XG4gIC8vIGV2ZW50IGxvb3AgY29udGV4dCwgaXQgZG9lcyBub3QgaW50ZXJydXB0IHRoZSBub3JtYWwgcHJvZ3JhbSBmbG93LlxuICAvLyBFZmZlY3RpdmVseSwgdGhpcyBnaXZlcyB1cyB0cnktY2F0Y2ggYmVoYXZpb3Igd2l0aG91dCBhY3R1YWxseSB1c2luZ1xuICAvLyB0cnktY2F0Y2guIE5lYXQhXG5cbiAgLy8gQ2hlY2sgdGhhdCB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgQVBJcyB3ZSBuZWVkIHRvIGltcGxlbWVudCBvdXIgc3BlY2lhbFxuICAvLyBERVYgdmVyc2lvbiBvZiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XG5cbiAgICB2YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2ID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuIFdlXG4gICAgICAvLyBzZXQgdGhpcyB0byB0cnVlIGF0IHRoZSBiZWdpbm5pbmcsIHRoZW4gc2V0IGl0IHRvIGZhbHNlIHJpZ2h0IGFmdGVyXG4gICAgICAvLyBjYWxsaW5nIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGVycm9ycywgYGRpZEVycm9yYCB3aWxsIG5ldmVyIGJlXG4gICAgICAvLyBzZXQgdG8gZmFsc2UuIFRoaXMgc3RyYXRlZ3kgd29ya3MgZXZlbiBpZiB0aGUgYnJvd3NlciBpcyBmbGFreSBhbmRcbiAgICAgIC8vIGZhaWxzIHRvIGNhbGwgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIGl0IGRvZXNuJ3QgcmVseSBvblxuICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IGF0IGFsbC5cbiAgICAgIHZhciBkaWRFcnJvciA9IHRydWU7XG5cbiAgICAgIC8vIENyZWF0ZSBhbiBldmVudCBoYW5kbGVyIGZvciBvdXIgZmFrZSBldmVudC4gV2Ugd2lsbCBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBkaXNwYXRjaCBvdXIgZmFrZSBldmVudCB1c2luZyBgZGlzcGF0Y2hFdmVudGAuIEluc2lkZSB0aGUgaGFuZGxlciwgd2VcbiAgICAgIC8vIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2suXG4gICAgICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICAgICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKCkge1xuICAgICAgICAvLyBXZSBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXRcbiAgICAgICAgLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4gICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4gICAgICAgIC8vIGluIHRoZSBzdGFjay5cbiAgICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gICAgICAgIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGdsb2JhbCBlcnJvciBldmVudCBoYW5kbGVyLiBXZSB1c2UgdGhpcyB0byBjYXB0dXJlIHRoZSB2YWx1ZVxuICAgICAgLy8gdGhhdCB3YXMgdGhyb3duLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhpcyBlcnJvciBoYW5kbGVyIHdpbGwgZmlyZSBtb3JlXG4gICAgICAvLyB0aGFuIG9uY2U7IGZvciBleGFtcGxlLCBpZiBub24tUmVhY3QgY29kZSBhbHNvIGNhbGxzIGBkaXNwYXRjaEV2ZW50YFxuICAgICAgLy8gYW5kIGEgaGFuZGxlciBmb3IgdGhhdCBldmVudCB0aHJvd3MuIFdlIHNob3VsZCBiZSByZXNpbGllbnQgdG8gbW9zdCBvZlxuICAgICAgLy8gdGhvc2UgY2FzZXMuIEV2ZW4gaWYgb3VyIGVycm9yIGV2ZW50IGhhbmRsZXIgZmlyZXMgbW9yZSB0aGFuIG9uY2UsIHRoZVxuICAgICAgLy8gbGFzdCBlcnJvciBldmVudCBpcyBhbHdheXMgdXNlZC4gSWYgdGhlIGNhbGxiYWNrIGFjdHVhbGx5IGRvZXMgZXJyb3IsXG4gICAgICAvLyB3ZSBrbm93IHRoYXQgdGhlIGxhc3QgZXJyb3IgZXZlbnQgaXMgdGhlIGNvcnJlY3Qgb25lLCBiZWNhdXNlIGl0J3Mgbm90XG4gICAgICAvLyBwb3NzaWJsZSBmb3IgYW55dGhpbmcgZWxzZSB0byBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gb3VyIGNhbGxiYWNrXG4gICAgICAvLyBlcnJvcmluZyBhbmQgdGhlIGNvZGUgdGhhdCBmb2xsb3dzIHRoZSBgZGlzcGF0Y2hFdmVudGAgY2FsbCBiZWxvdy4gSWZcbiAgICAgIC8vIHRoZSBjYWxsYmFjayBkb2Vzbid0IGVycm9yLCBidXQgdGhlIGVycm9yIGV2ZW50IHdhcyBmaXJlZCwgd2Uga25vdyB0b1xuICAgICAgLy8gaWdub3JlIGl0IGJlY2F1c2UgYGRpZEVycm9yYCB3aWxsIGJlIGZhbHNlLCBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgICAvLyBVc2UgdGhpcyB0byB0cmFjayB3aGV0aGVyIHRoZSBlcnJvciBldmVudCBpcyBldmVyIGNhbGxlZC5cbiAgICAgIHZhciBkaWRTZXRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBvbkVycm9yKGV2ZW50KSB7XG4gICAgICAgIGVycm9yID0gZXZlbnQuZXJyb3I7XG4gICAgICAgIGRpZFNldEVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZmFrZSBldmVudCB0eXBlLlxuICAgICAgdmFyIGV2dFR5cGUgPSAncmVhY3QtJyArIChuYW1lID8gbmFtZSA6ICdpbnZva2VndWFyZGVkY2FsbGJhY2snKTtcblxuICAgICAgLy8gQXR0YWNoIG91ciBldmVudCBoYW5kbGVyc1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpO1xuXG4gICAgICAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiQSBjcm9zcy1vcmlnaW4gZXJyb3Igd2FzIHRocm93bi4gUmVhY3QgZG9lc24ndCBoYXZlIGFjY2VzcyB0byBcIiArICd0aGUgYWN0dWFsIGVycm9yIG9iamVjdCBpbiBkZXZlbG9wbWVudC4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1jcm9zc29yaWdpbi1lcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIG91ciBldmVudCBsaXN0ZW5lcnNcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgIH07XG5cbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXY7XG4gIH1cbn1cblxudmFyIHJldGhyb3dDYXVnaHRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3I7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBudWxsO1xuICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghZXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYGV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IGV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAhKHBsdWdpbkluZGV4ID4gLTEpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgaWYgKHBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIXBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgbWV0aG9kLCBidXQgYCVzYCBkb2VzIG5vdC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBwbHVnaW5zW3BsdWdpbkluZGV4XSA9IHBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgc3VwcGxpZWQgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBEaXNwYXRjaCBjb25maWd1cmF0aW9uIGZvciB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaEV2ZW50Rm9yUGx1Z2luKGRpc3BhdGNoQ29uZmlnLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIWV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIGV2ZW50IG5hbWUsIGAlc2AuJywgZXZlbnROYW1lKSA6IHZvaWQgMDtcbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcblxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIgcGhhc2VOYW1lIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XG4gICAgICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFyZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IHZvaWQgMDtcbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcblxuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cblxuLyoqXG4gKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAqL1xudmFyIHBsdWdpbnMgPSBbXTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAqL1xudmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0ge307XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gKiBvbmx5IGluIHRydWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IHt9O1xuLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIHRydWVcblxuLyoqXG4gKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAqL1xuZnVuY3Rpb24gaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgISFldmVudFBsdWdpbk9yZGVyID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW4gb3JkZXJpbmcgbW9yZSB0aGFuIG9uY2UuIFlvdSBhcmUgbGlrZWx5IHRyeWluZyB0byBsb2FkIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICBldmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbn1cblxuLyoqXG4gKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAqIGluIHRoZSBvcmRlcmluZyBpbmplY3RlZCBieSBgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcmAuXG4gKlxuICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWV9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZShpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gcGx1Z2luTW9kdWxlKSB7XG4gICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICAgICAgaXNPcmRlcmluZ0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzT3JkZXJpbmdEaXJ0eSkge1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH1cbn1cblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSBPYmplY3QuZnJlZXplKHtcblx0cGx1Z2luczogcGx1Z2lucyxcblx0ZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MsXG5cdHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcblx0cmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczogcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcblx0cG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyxcblx0aW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblx0aW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcbn0pO1xuXG52YXIgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSA9IG51bGw7XG52YXIgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IG51bGw7XG52YXIgZ2V0Tm9kZUZyb21JbnN0YW5jZSA9IG51bGw7XG5cbnZhciBpbmplY3Rpb24kMiA9IHtcbiAgaW5qZWN0Q29tcG9uZW50VHJlZTogZnVuY3Rpb24gKEluamVjdGVkKSB7XG4gICAgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSA9IEluamVjdGVkLmdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU7XG4gICAgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IEluamVjdGVkLmdldEluc3RhbmNlRnJvbU5vZGU7XG4gICAgZ2V0Tm9kZUZyb21JbnN0YW5jZSA9IEluamVjdGVkLmdldE5vZGVGcm9tSW5zdGFuY2U7XG5cbiAgICB7XG4gICAgICB3YXJuaW5nKGdldE5vZGVGcm9tSW5zdGFuY2UgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdENvbXBvbmVudFRyZWUoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBnZXROb2RlRnJvbUluc3RhbmNlIG9yIGdldEluc3RhbmNlRnJvbU5vZGUuJyk7XG4gICAgfVxuICB9XG59O1xuXG5cblxuXG5cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xue1xuICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG5cbiAgICB2YXIgbGlzdGVuZXJzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKTtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgPyBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGggOiBkaXNwYXRjaExpc3RlbmVycyA/IDEgOiAwO1xuXG4gICAgdmFyIGluc3RhbmNlc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaEluc3RhbmNlcyk7XG4gICAgdmFyIGluc3RhbmNlc0xlbiA9IGluc3RhbmNlc0lzQXJyID8gZGlzcGF0Y2hJbnN0YW5jZXMubGVuZ3RoIDogZGlzcGF0Y2hJbnN0YW5jZXMgPyAxIDogMDtcblxuICAgIHdhcm5pbmcoaW5zdGFuY2VzSXNBcnIgPT09IGxpc3RlbmVyc0lzQXJyICYmIGluc3RhbmNlc0xlbiA9PT0gbGlzdGVuZXJzTGVuLCAnRXZlbnRQbHVnaW5VdGlsczogSW52YWxpZCBgZXZlbnRgLicpO1xuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIHRoZSBldmVudCB0byB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gaW5zdCBJbnRlcm5hbCBjb21wb25lbnQgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGxpc3RlbmVyLCBpbnN0KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKHR5cGUsIGxpc3RlbmVyLCB1bmRlZmluZWQsIGV2ZW50KTtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJbnN0YW5jZXMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnNbaV0sIGRpc3BhdGNoSW5zdGFuY2VzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgfVxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcbiAqL1xuXG5cbi8qKlxuICogRXhlY3V0aW9uIG9mIGEgXCJkaXJlY3RcIiBkaXNwYXRjaCAtIHRoZXJlIG11c3QgYmUgYXQgbW9zdCBvbmUgZGlzcGF0Y2hcbiAqIGFjY3VtdWxhdGVkIG9uIHRoZSBldmVudCBvciBpdCBpcyBjb25zaWRlcmVkIGFuIGVycm9yLiBJdCBkb2Vzbid0IHJlYWxseSBtYWtlXG4gKiBzZW5zZSBmb3IgYW4gZXZlbnQgd2l0aCBtdWx0aXBsZSBkaXNwYXRjaGVzIChidWJibGVkKSB0byBrZWVwIHRyYWNrIG9mIHRoZVxuICogcmV0dXJuIHZhbHVlcyBhdCBlYWNoIGRpc3BhdGNoIGV4ZWN1dGlvbiwgYnV0IGl0IGRvZXMgdGVuZCB0byBtYWtlIHNlbnNlIHdoZW5cbiAqIGRlYWxpbmcgd2l0aCBcImRpcmVjdFwiIGRpc3BhdGNoZXMuXG4gKlxuICogQHJldHVybiB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiBleGVjdXRpbmcgdGhlIHNpbmdsZSBkaXNwYXRjaC5cbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5cbi8qKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbnRvIHRoZSBmaXJzdCBvbmUuIFRoaXNcbiAqIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLCBhbmQgdGh1cyBzYWNyaWZpY2VzXG4gKiBBUEkgY2xlYW5uZXNzLiBTaW5jZSBgY3VycmVudGAgY2FuIGJlIG51bGwgYmVmb3JlIGJlaW5nIHBhc3NlZCBpbiBhbmQgbm90XG4gKiBudWxsIGFmdGVyIHRoaXMgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBhc3NpZ24gaXQgYmFjayB0byBgY3VycmVudGA6XG4gKlxuICogYGEgPSBhY2N1bXVsYXRlSW50byhhLCBiKTtgXG4gKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIHNwYXJpbmdseSB1c2VkLiBUcnkgYGFjY3VtdWxhdGVgIGZvciBzb21ldGhpbmcgY2xlYW5lci5cbiAqXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXG4gKi9cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUludG8oY3VycmVudCwgbmV4dCkge1xuICAhKG5leHQgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKSA6IHZvaWQgMDtcblxuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxuICAvLyBjZXJ0YWluIHRoYXQgeCBpcyBhbiBBcnJheSAoeCBjb3VsZCBiZSBhIHN0cmluZyB3aXRoIGNvbmNhdCBtZXRob2QpLlxuICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgICBjdXJyZW50LnB1c2guYXBwbHkoY3VycmVudCwgbmV4dCk7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAvLyBBIGJpdCB0b28gZGFuZ2Vyb3VzIHRvIG11dGF0ZSBgbmV4dGAuXG4gICAgcmV0dXJuIFtjdXJyZW50XS5jb25jYXQobmV4dCk7XG4gIH1cblxuICByZXR1cm4gW2N1cnJlbnQsIG5leHRdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgaW52b2tlZCB3aXRoIGVhY2ggZWxlbWVudCBvciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0gez99IFtzY29wZV0gU2NvcGUgdXNlZCBhcyBgdGhpc2AgaW4gYSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEFjY3VtdWxhdGVkKGFyciwgY2IsIHNjb3BlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIuZm9yRWFjaChjYiwgc2NvcGUpO1xuICB9IGVsc2UgaWYgKGFycikge1xuICAgIGNiLmNhbGwoc2NvcGUsIGFycik7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBxdWV1ZSBvZiBldmVudHMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRoZWlyIGRpc3BhdGNoZXMgYW5kIGFyZVxuICogd2FpdGluZyB0byBoYXZlIHRoZWlyIGRpc3BhdGNoZXMgZXhlY3V0ZWQuXG4gKi9cbnZhciBldmVudFF1ZXVlID0gbnVsbDtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCByZWxlYXNlcyBpdCBiYWNrIGludG8gdGhlIHBvb2wsIHVubGVzcyBwZXJzaXN0ZW50LlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnQgU3ludGhldGljIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnQsIHNpbXVsYXRlZCkge1xuICBpZiAoZXZlbnQpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCk7XG5cbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCB0cnVlKTtcbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIGlzSW50ZXJhY3RpdmUodGFnKSB7XG4gIHJldHVybiB0YWcgPT09ICdidXR0b24nIHx8IHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICdzZWxlY3QnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJztcbn1cblxuZnVuY3Rpb24gc2hvdWxkUHJldmVudE1vdXNlRXZlbnQobmFtZSwgdHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnb25DbGljayc6XG4gICAgY2FzZSAnb25DbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uRG91YmxlQ2xpY2snOlxuICAgIGNhc2UgJ29uRG91YmxlQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bic6XG4gICAgY2FzZSAnb25Nb3VzZURvd25DYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmVDYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlVXAnOlxuICAgIGNhc2UgJ29uTW91c2VVcENhcHR1cmUnOlxuICAgICAgcmV0dXJuICEhKHByb3BzLmRpc2FibGVkICYmIGlzSW50ZXJhY3RpdmUodHlwZSkpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxuICpcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBgZXh0cmFjdEV2ZW50c2Age2Z1bmN0aW9uKHN0cmluZywgRE9NRXZlbnRUYXJnZXQsIHN0cmluZywgb2JqZWN0KTogKn1cbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxuICpcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxuICogICAgIG5hbWVzIHRoYXQgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLiBWYWx1ZXMgb2YgdGhpcyBtYXBwaW5nIG11c3RcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cbiAqXG4gKiAgIGBleGVjdXRlRGlzcGF0Y2hgIHtmdW5jdGlvbihvYmplY3QsIGZ1bmN0aW9uLCBzdHJpbmcpfVxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cbiAqXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5cbi8qKlxuICogTWV0aG9kcyBmb3IgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAqL1xudmFyIGluamVjdGlvbiQxID0ge1xuICAvKipcbiAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICB2YXIgbGlzdGVuZXI7XG5cbiAgLy8gVE9ETzogc2hvdWxkUHJldmVudE1vdXNlRXZlbnQgaXMgRE9NLXNwZWNpZmljIGFuZCBkZWZpbml0ZWx5IHNob3VsZCBub3RcbiAgLy8gbGl2ZSBoZXJlOyBuZWVkcyB0byBiZSBtb3ZlZCB0byBhIGJldHRlciBwbGFjZSBzb29uXG4gIHZhciBzdGF0ZU5vZGUgPSBpbnN0LnN0YXRlTm9kZTtcbiAgaWYgKCFzdGF0ZU5vZGUpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzIChleDogb25sb2FkIGV2ZW50cyBpbiBpbmNyZW1lbnRhbCBtb2RlKS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKHN0YXRlTm9kZSk7XG4gIGlmICghcHJvcHMpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxpc3RlbmVyID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGlmIChzaG91bGRQcmV2ZW50TW91c2VFdmVudChyZWdpc3RyYXRpb25OYW1lLCBpbnN0LnR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gICEoIWxpc3RlbmVyIHx8IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLicsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiB2b2lkIDA7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBBbGxvd3MgcmVnaXN0ZXJlZCBwbHVnaW5zIGFuIG9wcG9ydHVuaXR5IHRvIGV4dHJhY3QgZXZlbnRzIGZyb20gdG9wLWxldmVsXG4gKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXG4gKlxuICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgZXZlbnRzID0gYWNjdW11bGF0ZUludG8oZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnRzO1xufVxuXG4vKipcbiAqIEVucXVldWVzIGEgc3ludGhldGljIGV2ZW50IHRoYXQgc2hvdWxkIGJlIGRpc3BhdGNoZWQgd2hlblxuICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICpcbiAqIEBwYXJhbSB7Kn0gZXZlbnRzIEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVFdmVudHMoZXZlbnRzKSB7XG4gIGlmIChldmVudHMpIHtcbiAgICBldmVudFF1ZXVlID0gYWNjdW11bGF0ZUludG8oZXZlbnRRdWV1ZSwgZXZlbnRzKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoZXMgYWxsIHN5bnRoZXRpYyBldmVudHMgb24gdGhlIGV2ZW50IHF1ZXVlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBwcm9jZXNzRXZlbnRRdWV1ZShzaW11bGF0ZWQpIHtcbiAgLy8gU2V0IGBldmVudFF1ZXVlYCB0byBudWxsIGJlZm9yZSBwcm9jZXNzaW5nIGl0IHNvIHRoYXQgd2UgY2FuIHRlbGwgaWYgbW9yZVxuICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gIHZhciBwcm9jZXNzaW5nRXZlbnRRdWV1ZSA9IGV2ZW50UXVldWU7XG4gIGV2ZW50UXVldWUgPSBudWxsO1xuXG4gIGlmICghcHJvY2Vzc2luZ0V2ZW50UXVldWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQpO1xuICB9IGVsc2Uge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwpO1xuICB9XG4gICEhZXZlbnRRdWV1ZSA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NFdmVudFF1ZXVlKCk6IEFkZGl0aW9uYWwgZXZlbnRzIHdlcmUgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZyBhbiBldmVudCBxdWV1ZS4gU3VwcG9ydCBmb3IgdGhpcyBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLicpIDogdm9pZCAwO1xuICAvLyBUaGlzIHdvdWxkIGJlIGEgZ29vZCB0aW1lIHRvIHJldGhyb3cgaWYgYW55IG9mIHRoZSBldmVudCBoYW5kbGVycyB0aHJldy5cbiAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xufVxuXG52YXIgRXZlbnRQbHVnaW5IdWIgPSBPYmplY3QuZnJlZXplKHtcblx0aW5qZWN0aW9uOiBpbmplY3Rpb24kMSxcblx0Z2V0TGlzdGVuZXI6IGdldExpc3RlbmVyLFxuXHRleHRyYWN0RXZlbnRzOiBleHRyYWN0RXZlbnRzLFxuXHRlbnF1ZXVlRXZlbnRzOiBlbnF1ZXVlRXZlbnRzLFxuXHRwcm9jZXNzRXZlbnRRdWV1ZTogcHJvY2Vzc0V2ZW50UXVldWVcbn0pO1xuXG52YXIgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCA9IDA7IC8vIEJlZm9yZSB3ZSBrbm93IHdoZXRoZXIgaXQgaXMgZnVuY3Rpb25hbCBvciBjbGFzc1xudmFyIEZ1bmN0aW9uYWxDb21wb25lbnQgPSAxO1xudmFyIENsYXNzQ29tcG9uZW50ID0gMjtcbnZhciBIb3N0Um9vdCA9IDM7IC8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxudmFyIEhvc3RQb3J0YWwgPSA0OyAvLyBBIHN1YnRyZWUuIENvdWxkIGJlIGFuIGVudHJ5IHBvaW50IHRvIGEgZGlmZmVyZW50IHJlbmRlcmVyLlxudmFyIEhvc3RDb21wb25lbnQgPSA1O1xudmFyIEhvc3RUZXh0ID0gNjtcbnZhciBDYWxsQ29tcG9uZW50ID0gNztcbnZhciBDYWxsSGFuZGxlclBoYXNlID0gODtcbnZhciBSZXR1cm5Db21wb25lbnQgPSA5O1xudmFyIEZyYWdtZW50ID0gMTA7XG5cbnZhciByYW5kb21LZXkgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbnZhciBpbnRlcm5hbEluc3RhbmNlS2V5ID0gJ19fcmVhY3RJbnRlcm5hbEluc3RhbmNlJCcgKyByYW5kb21LZXk7XG52YXIgaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5ID0gJ19fcmVhY3RFdmVudEhhbmRsZXJzJCcgKyByYW5kb21LZXk7XG5cbmZ1bmN0aW9uIHByZWNhY2hlRmliZXJOb2RlJDEoaG9zdEluc3QsIG5vZGUpIHtcbiAgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGhvc3RJbnN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgY2xvc2VzdCBSZWFjdERPTUNvbXBvbmVudCBvclxuICogUmVhY3RET01UZXh0Q29tcG9uZW50IGluc3RhbmNlIGFuY2VzdG9yLlxuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIGlmIChub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcmV0dXJuIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYW4gYW5jZXN0b3Igd2hvc2UgaW5zdGFuY2Ugd2UgaGF2ZSBjYWNoZWQuXG4gIHZhciBwYXJlbnRzID0gW107XG4gIHdoaWxlICghbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUb3Agb2YgdGhlIHRyZWUuIFRoaXMgbm9kZSBtdXN0IG5vdCBiZSBwYXJ0IG9mIGEgUmVhY3QgdHJlZSAob3IgaXNcbiAgICAgIC8vIHVubW91bnRlZCwgcG90ZW50aWFsbHkpLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNsb3Nlc3QgPSB2b2lkIDA7XG4gIHZhciBpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIEluIEZpYmVyLCB0aGlzIHdpbGwgYWx3YXlzIGJlIHRoZSBkZWVwZXN0IHJvb3QuXG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgZm9yICg7IG5vZGUgJiYgKGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKTsgbm9kZSA9IHBhcmVudHMucG9wKCkpIHtcbiAgICBjbG9zZXN0ID0gaW5zdDtcbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBpbnN0YW5jZSwgb3IgbnVsbCBpZiB0aGUgbm9kZSB3YXMgbm90IHJlbmRlcmVkIGJ5IHRoaXMgUmVhY3QuXG4gKi9cbmZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUkMShub2RlKSB7XG4gIHZhciBpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgaWYgKGluc3QpIHtcbiAgICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gaW5zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlJDEoaW5zdCkge1xuICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgLy8gSW4gRmliZXIgdGhpcywgaXMganVzdCB0aGUgc3RhdGUgbm9kZSByaWdodCBub3cuIFdlIGFzc3VtZSBpdCB3aWxsIGJlXG4gICAgLy8gYSBob3N0IGNvbXBvbmVudCBvciBob3N0IHRleHQuXG4gICAgcmV0dXJuIGluc3Quc3RhdGVOb2RlO1xuICB9XG5cbiAgLy8gV2l0aG91dCB0aGlzIGZpcnN0IGludmFyaWFudCwgcGFzc2luZyBhIG5vbi1ET00tY29tcG9uZW50IHRyaWdnZXJzIHRoZSBuZXh0XG4gIC8vIGludmFyaWFudCBmb3IgYSBtaXNzaW5nIHBhcmVudCwgd2hpY2ggaXMgc3VwZXIgY29uZnVzaW5nLlxuICBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpO1xufVxuXG5mdW5jdGlvbiBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEobm9kZSkge1xuICByZXR1cm4gbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZpYmVyUHJvcHMkMShub2RlLCBwcm9wcykge1xuICBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gPSBwcm9wcztcbn1cblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IE9iamVjdC5mcmVlemUoe1xuXHRwcmVjYWNoZUZpYmVyTm9kZTogcHJlY2FjaGVGaWJlck5vZGUkMSxcblx0Z2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuXHRnZXRJbnN0YW5jZUZyb21Ob2RlOiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEsXG5cdGdldE5vZGVGcm9tSW5zdGFuY2U6IGdldE5vZGVGcm9tSW5zdGFuY2UkMSxcblx0Z2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTogZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxLFxuXHR1cGRhdGVGaWJlclByb3BzOiB1cGRhdGVGaWJlclByb3BzJDFcbn0pO1xuXG5mdW5jdGlvbiBnZXRQYXJlbnQoaW5zdCkge1xuICBkbyB7XG4gICAgaW5zdCA9IGluc3RbJ3JldHVybiddO1xuICAgIC8vIFRPRE86IElmIHRoaXMgaXMgYSBIb3N0Um9vdCB3ZSBtaWdodCB3YW50IHRvIGJhaWwgb3V0LlxuICAgIC8vIFRoYXQgaXMgZGVwZW5kaW5nIG9uIGlmIHdlIHdhbnQgbmVzdGVkIHN1YnRyZWVzIChsYXllcnMpIHRvIGJ1YmJsZVxuICAgIC8vIGV2ZW50cyB0byB0aGVpciBwYXJlbnQuIFdlIGNvdWxkIGFsc28gZ28gdGhyb3VnaCBwYXJlbnROb2RlIG9uIHRoZVxuICAgIC8vIGhvc3Qgbm9kZSBidXQgdGhhdCB3b3VsZG4ndCB3b3JrIGZvciBSZWFjdCBOYXRpdmUgYW5kIGRvZXNuJ3QgbGV0IHVzXG4gICAgLy8gZG8gdGhlIHBvcnRhbCBmZWF0dXJlLlxuICB9IHdoaWxlIChpbnN0ICYmIGluc3QudGFnICE9PSBIb3N0Q29tcG9uZW50KTtcbiAgaWYgKGluc3QpIHtcbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3Igb2YgQSBhbmQgQiwgb3IgbnVsbCBpZiB0aGV5IGFyZSBpblxuICogZGlmZmVyZW50IHRyZWVzLlxuICovXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgdmFyIGRlcHRoQSA9IDA7XG4gIGZvciAodmFyIHRlbXBBID0gaW5zdEE7IHRlbXBBOyB0ZW1wQSA9IGdldFBhcmVudCh0ZW1wQSkpIHtcbiAgICBkZXB0aEErKztcbiAgfVxuICB2YXIgZGVwdGhCID0gMDtcbiAgZm9yICh2YXIgdGVtcEIgPSBpbnN0QjsgdGVtcEI7IHRlbXBCID0gZ2V0UGFyZW50KHRlbXBCKSkge1xuICAgIGRlcHRoQisrO1xuICB9XG5cbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIGluc3RBID0gZ2V0UGFyZW50KGluc3RBKTtcbiAgICBkZXB0aEEtLTtcbiAgfVxuXG4gIC8vIElmIEIgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBpbnN0QiA9IGdldFBhcmVudChpbnN0Qik7XG4gICAgZGVwdGhCLS07XG4gIH1cblxuICAvLyBXYWxrIGluIGxvY2tzdGVwIHVudGlsIHdlIGZpbmQgYSBtYXRjaC5cbiAgdmFyIGRlcHRoID0gZGVwdGhBO1xuICB3aGlsZSAoZGVwdGgtLSkge1xuICAgIGlmIChpbnN0QSA9PT0gaW5zdEIgfHwgaW5zdEEgPT09IGluc3RCLmFsdGVybmF0ZSkge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiBpZiBBIGlzIGFuIGFuY2VzdG9yIG9mIEIuXG4gKi9cblxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudEluc3RhbmNlKGluc3QpIHtcbiAgcmV0dXJuIGdldFBhcmVudChpbnN0KTtcbn1cblxuLyoqXG4gKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlVHdvUGhhc2UoaW5zdCwgZm4sIGFyZykge1xuICB2YXIgcGF0aCA9IFtdO1xuICB3aGlsZSAoaW5zdCkge1xuICAgIHBhdGgucHVzaChpbnN0KTtcbiAgICBpbnN0ID0gZ2V0UGFyZW50KGluc3QpO1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCAnY2FwdHVyZWQnLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFmcm9tKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGZyb20gPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBhbHRlcm5hdGUgPSBmcm9tLmFsdGVybmF0ZTtcbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aEZyb20ucHVzaChmcm9tKTtcbiAgICBmcm9tID0gZ2V0UGFyZW50KGZyb20pO1xuICB9XG4gIHZhciBwYXRoVG8gPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIXRvKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRvID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgX2FsdGVybmF0ZSA9IHRvLmFsdGVybmF0ZTtcbiAgICBpZiAoX2FsdGVybmF0ZSAhPT0gbnVsbCAmJiBfYWx0ZXJuYXRlID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRoVG8ucHVzaCh0byk7XG4gICAgdG8gPSBnZXRQYXJlbnQodG8pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoRnJvbVtpXSwgJ2J1YmJsZWQnLCBhcmdGcm9tKTtcbiAgfVxuICBmb3IgKHZhciBfaSA9IHBhdGhUby5sZW5ndGg7IF9pLS0gPiAwOykge1xuICAgIGZuKHBhdGhUb1tfaV0sICdjYXB0dXJlZCcsIGFyZ1RvKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbiBhXG4gKiBzaW5nbGUgb25lLlxuICovXG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGluc3QsIHBoYXNlLCBldmVudCkge1xuICB7XG4gICAgd2FybmluZyhpbnN0LCAnRGlzcGF0Y2hpbmcgaW5zdCBtdXN0IG5vdCBiZSBudWxsJyk7XG4gIH1cbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwaGFzZSk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRpc3BhdGNoZXMgKG11c3QgYmUgZW50aXJlbHkgY29sbGVjdGVkIGJlZm9yZSBkaXNwYXRjaGluZyAtIHNlZSB1bml0XG4gKiB0ZXN0cykuIExhemlseSBhbGxvY2F0ZSB0aGUgYXJyYXkgdG8gY29uc2VydmUgbWVtb3J5LiAgV2UgbXVzdCBsb29wIHRocm91Z2hcbiAqIGVhY2ggZXZlbnQgYW5kIHBlcmZvcm0gdGhlIHRyYXZlcnNhbCBmb3IgZWFjaCBvbmUuIFdlIGNhbm5vdCBwZXJmb3JtIGFcbiAqIHNpbmdsZSB0cmF2ZXJzYWwgZm9yIHRoZSBlbnRpcmUgY29sbGVjdGlvbiBvZiBldmVudHMgYmVjYXVzZSBlYWNoIGV2ZW50IG1heVxuICogaGF2ZSBhIGRpZmZlcmVudCB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgdHJhdmVyc2VUd29QaGFzZShldmVudC5fdGFyZ2V0SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZWAsIGJ1dCBza2lwcyBvdmVyIHRoZSB0YXJnZXRJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgdmFyIHRhcmdldEluc3QgPSBldmVudC5fdGFyZ2V0SW5zdDtcbiAgICB2YXIgcGFyZW50SW5zdCA9IHRhcmdldEluc3QgPyBnZXRQYXJlbnRJbnN0YW5jZSh0YXJnZXRJbnN0KSA6IG51bGw7XG4gICAgdHJhdmVyc2VUd29QaGFzZShwYXJlbnRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpbnN0LCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoaW5zdCAmJiBldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcbiAgdHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBhY2N1bXVsYXRlRGlzcGF0Y2hlcywgbGVhdmUsIGVudGVyKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSBPYmplY3QuZnJlZXplKHtcblx0YWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcblx0YWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQ6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0LFxuXHRhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyxcblx0YWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzXG59KTtcblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgb2JqZWN0IHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqXG4gKi9cbnZhciBjb21wb3NpdGlvblN0YXRlID0ge1xuICBfcm9vdDogbnVsbCxcbiAgX3N0YXJ0VGV4dDogbnVsbCxcbiAgX2ZhbGxiYWNrVGV4dDogbnVsbFxufTtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCkge1xuICBjb21wb3NpdGlvblN0YXRlLl9yb290ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IGdldFRleHQoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0KCkge1xuICBjb21wb3NpdGlvblN0YXRlLl9yb290ID0gbnVsbDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0ID0gbnVsbDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgaWYgKGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCkge1xuICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQ7XG4gIH1cblxuICB2YXIgc3RhcnQ7XG4gIHZhciBzdGFydFZhbHVlID0gY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0O1xuICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgdmFyIGVuZDtcbiAgdmFyIGVuZFZhbHVlID0gZ2V0VGV4dCgpO1xuICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgc2xpY2VUYWlsID0gZW5kID4gMSA/IDEgLSBlbmQgOiB1bmRlZmluZWQ7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0KCkge1xuICBpZiAoJ3ZhbHVlJyBpbiBjb21wb3NpdGlvblN0YXRlLl9yb290KSB7XG4gICAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QudmFsdWU7XG4gIH1cbiAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3RbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXTtcbn1cblxuLyogZXNsaW50IHZhbGlkLXR5cGVvZjogMCAqL1xuXG52YXIgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSBmYWxzZTtcbnZhciBpc1Byb3h5U3VwcG9ydGVkID0gdHlwZW9mIFByb3h5ID09PSAnZnVuY3Rpb24nO1xudmFyIEVWRU5UX1BPT0xfU0laRSA9IDEwO1xuXG52YXIgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMgPSBbJ2Rpc3BhdGNoQ29uZmlnJywgJ190YXJnZXRJbnN0JywgJ25hdGl2ZUV2ZW50JywgJ2lzRGVmYXVsdFByZXZlbnRlZCcsICdpc1Byb3BhZ2F0aW9uU3RvcHBlZCcsICdfZGlzcGF0Y2hMaXN0ZW5lcnMnLCAnX2Rpc3BhdGNoSW5zdGFuY2VzJ107XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgdHlwZTogbnVsbCxcbiAgdGFyZ2V0OiBudWxsLFxuICAvLyBjdXJyZW50VGFyZ2V0IGlzIHNldCB3aGVuIGRpc3BhdGNoaW5nOyBubyB1c2UgaW4gY29weWluZyBpdCBoZXJlXG4gIGN1cnJlbnRUYXJnZXQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLFxuICBldmVudFBoYXNlOiBudWxsLFxuICBidWJibGVzOiBudWxsLFxuICBjYW5jZWxhYmxlOiBudWxsLFxuICB0aW1lU3RhbXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgfSxcbiAgZGVmYXVsdFByZXZlbnRlZDogbnVsbCxcbiAgaXNUcnVzdGVkOiBudWxsXG59O1xuXG4vKipcbiAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gKlxuICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxuICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAqXG4gKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XG4gKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0SW5zdCBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IG5hdGl2ZUV2ZW50VGFyZ2V0IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHtcbiAgICAvLyB0aGVzZSBoYXZlIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICBkZWxldGUgdGhpcy5uYXRpdmVFdmVudDtcbiAgICBkZWxldGUgdGhpcy5wcmV2ZW50RGVmYXVsdDtcbiAgICBkZWxldGUgdGhpcy5zdG9wUHJvcGFnYXRpb247XG4gIH1cblxuICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gZGlzcGF0Y2hDb25maWc7XG4gIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB7XG4gICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07IC8vIHRoaXMgaGFzIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtwcm9wTmFtZV07XG4gICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBub3JtYWxpemUobmF0aXZlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcE5hbWUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgfVxuICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICByZXR1cm4gdGhpcztcbn1cblxuX2Fzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5yZXR1cm5WYWx1ZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAvLyBUaGUgQ2hhbmdlRXZlbnRQbHVnaW4gcmVnaXN0ZXJzIGEgXCJwcm9wZXJ0eWNoYW5nZVwiIGV2ZW50IGZvclxuICAgICAgLy8gSUUuIFRoaXMgZXZlbnQgZG9lcyBub3Qgc3VwcG9ydCBidWJibGluZyBvciBjYW5jZWxsaW5nLCBhbmRcbiAgICAgIC8vIGFueSByZWZlcmVuY2VzIHRvIGNhbmNlbEJ1YmJsZSB0aHJvdyBcIk1lbWJlciBub3QgZm91bmRcIi4gIEFcbiAgICAgIC8vIHR5cGVvZiBjaGVjayBvZiBcInVua25vd25cIiBjaXJjdW12ZW50cyB0aGlzIGlzc3VlIChhbmQgaXMgYWxzb1xuICAgICAgLy8gSUUgc3BlY2lmaWMpLlxuICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICogdGhlbSBiYWNrIGludG8gdGhlIHBvb2wuIFRoaXMgYWxsb3dzIGEgd2F5IHRvIGhvbGQgb250byBhIHJlZmVyZW5jZSB0aGF0XG4gICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICovXG4gIHBlcnNpc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzUGVyc2lzdGVudCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNQZXJzaXN0ZW50OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UsXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIGBkZXN0cnVjdG9yYCBvbiBlYWNoIGluc3RhbmNlIGl0IHJlbGVhc2VzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICAgIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BOYW1lLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBJbnRlcmZhY2VbcHJvcE5hbWVdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXNbc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXNbaV1dID0gbnVsbDtcbiAgICB9XG4gICAge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYXRpdmVFdmVudCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ25hdGl2ZUV2ZW50JywgbnVsbCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwcmV2ZW50RGVmYXVsdCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3ByZXZlbnREZWZhdWx0JywgZW1wdHlGdW5jdGlvbikpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdG9wUHJvcGFnYXRpb24nLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdzdG9wUHJvcGFnYXRpb24nLCBlbXB0eUZ1bmN0aW9uKSk7XG4gICAgfVxuICB9XG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3NcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXG4gKi9cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyA9IGZ1bmN0aW9uIChDbGFzcywgSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIEUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgRS5wcm90b3R5cGUgPSBTdXBlci5wcm90b3R5cGU7XG4gIHZhciBwcm90b3R5cGUgPSBuZXcgRSgpO1xuXG4gIF9hc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzO1xuXG4gIENsYXNzLkludGVyZmFjZSA9IF9hc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuYXVnbWVudENsYXNzID0gU3VwZXIuYXVnbWVudENsYXNzO1xuICBhZGRFdmVudFBvb2xpbmdUbyhDbGFzcyk7XG59O1xuXG4vKiogUHJveHlpbmcgYWZ0ZXIgZXZlcnl0aGluZyBzZXQgb24gU3ludGhldGljRXZlbnRcbiAqIHRvIHJlc29sdmUgUHJveHkgaXNzdWUgb24gc29tZSBXZWJLaXQgYnJvd3NlcnNcbiAqIGluIHdoaWNoIHNvbWUgRXZlbnQgcHJvcGVydGllcyBhcmUgc2V0IHRvIHVuZGVmaW5lZCAoR0gjMTAwMTApXG4gKi9cbntcbiAgaWYgKGlzUHJveHlTdXBwb3J0ZWQpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gICAgU3ludGhldGljRXZlbnQgPSBuZXcgUHJveHkoU3ludGhldGljRXZlbnQsIHtcbiAgICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseSh0YXJnZXQsIE9iamVjdC5jcmVhdGUodGFyZ2V0LnByb3RvdHlwZSksIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHRoYXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShjb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmdzKSwge1xuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnaXNQZXJzaXN0ZW50JyAmJiAhdGFyZ2V0LmNvbnN0cnVjdG9yLkludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICB3YXJuaW5nKGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5IHx8IHRhcmdldC5pc1BlcnNpc3RlbnQoKSwgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBcIiArIFwic2VlaW5nIHRoaXMsIHlvdSdyZSBhZGRpbmcgYSBuZXcgcHJvcGVydHkgaW4gdGhlIHN5bnRoZXRpYyBldmVudCBvYmplY3QuIFwiICsgJ1RoZSBwcm9wZXJ0eSBpcyBuZXZlciByZWxlYXNlZC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICAgICAgICBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyplc2xpbnQtZW5hYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gIH1cbn1cblxuYWRkRXZlbnRQb29saW5nVG8oU3ludGhldGljRXZlbnQpO1xuXG4vKipcbiAqIEhlbHBlciB0byBudWxsaWZ5IHN5bnRoZXRpY0V2ZW50IGluc3RhbmNlIHByb3BlcnRpZXMgd2hlbiBkZXN0cnVjdGluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZVxuICogQHBhcmFtIHs/b2JqZWN0fSBnZXRWYWxcbiAqIEByZXR1cm4ge29iamVjdH0gZGVmaW5lUHJvcGVydHkgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIGdldFZhbCkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBnZXRWYWwgPT09ICdmdW5jdGlvbic7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHNldDogc2V0LFxuICAgIGdldDogZ2V0XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ3NldHRpbmcgdGhlIG1ldGhvZCcgOiAnc2V0dGluZyB0aGUgcHJvcGVydHknO1xuICAgIHdhcm4oYWN0aW9uLCAnVGhpcyBpcyBlZmZlY3RpdmVseSBhIG5vLW9wJyk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdhY2Nlc3NpbmcgdGhlIG1ldGhvZCcgOiAnYWNjZXNzaW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgdmFyIHJlc3VsdCA9IGlzRnVuY3Rpb24gPyAnVGhpcyBpcyBhIG5vLW9wIGZ1bmN0aW9uJyA6ICdUaGlzIGlzIHNldCB0byBudWxsJztcbiAgICB3YXJuKGFjdGlvbiwgcmVzdWx0KTtcbiAgICByZXR1cm4gZ2V0VmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FybihhY3Rpb24sIHJlc3VsdCkge1xuICAgIHZhciB3YXJuaW5nQ29uZGl0aW9uID0gZmFsc2U7XG4gICAgd2FybmluZyh3YXJuaW5nQ29uZGl0aW9uLCBcIlRoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91J3JlIHNlZWluZyB0aGlzLCBcIiArIFwieW91J3JlICVzIGAlc2Agb24gYSByZWxlYXNlZC9udWxsaWZpZWQgc3ludGhldGljIGV2ZW50LiAlcy4gXCIgKyAnSWYgeW91IG11c3Qga2VlcCB0aGUgb3JpZ2luYWwgc3ludGhldGljIGV2ZW50IGFyb3VuZCwgdXNlIGV2ZW50LnBlcnNpc3QoKS4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGFjdGlvbiwgcHJvcE5hbWUsIHJlc3VsdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9vbGVkRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KSB7XG4gIHZhciBFdmVudENvbnN0cnVjdG9yID0gdGhpcztcbiAgaWYgKEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLnBvcCgpO1xuICAgIEV2ZW50Q29uc3RydWN0b3IuY2FsbChpbnN0YW5jZSwgZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIG5ldyBFdmVudENvbnN0cnVjdG9yKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCk7XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VQb29sZWRFdmVudChldmVudCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gICEoZXZlbnQgaW5zdGFuY2VvZiBFdmVudENvbnN0cnVjdG9yKSA/IGludmFyaWFudChmYWxzZSwgJ1RyeWluZyB0byByZWxlYXNlIGFuIGV2ZW50IGluc3RhbmNlICBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogdm9pZCAwO1xuICBldmVudC5kZXN0cnVjdG9yKCk7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGggPCBFVkVOVF9QT09MX1NJWkUpIHtcbiAgICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wdXNoKGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRFdmVudFBvb2xpbmdUbyhFdmVudENvbnN0cnVjdG9yKSB7XG4gIEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sID0gW107XG4gIEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkID0gZ2V0UG9vbGVkRXZlbnQ7XG4gIEV2ZW50Q29uc3RydWN0b3IucmVsZWFzZSA9IHJlbGVhc2VQb29sZWRFdmVudDtcbn1cblxudmFyIFN5bnRoZXRpY0V2ZW50JDEgPSBTeW50aGV0aWNFdmVudDtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ29tcG9zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljQ29tcG9zaXRpb25FdmVudCwgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgSW5wdXRFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0lucHV0RXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0lucHV0RXZlbnQsIElucHV0RXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgJiYgIWlzUHJlc3RvKCk7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbi8qKlxuICogT3BlcmEgPD0gMTIgaW5jbHVkZXMgVGV4dEV2ZW50IGluIHdpbmRvdywgYnV0IGRvZXMgbm90IGZpcmVcbiAqIHRleHQgaW5wdXQgZXZlbnRzLiBSZWx5IG9uIGtleXByZXNzIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJlc3RvKCkge1xuICB2YXIgb3BlcmEgPSB3aW5kb3cub3BlcmE7XG4gIHJldHVybiB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09PSAnZnVuY3Rpb24nICYmIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyO1xufVxuXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmVmb3JlSW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQmVmb3JlSW5wdXQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkJlZm9yZUlucHV0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlQcmVzcycsICd0b3BUZXh0SW5wdXQnLCAndG9wUGFzdGUnXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvbkVuZCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25FbmRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25TdGFydCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvblVwZGF0ZScsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25TdGFydCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJyAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgY2FzZSAndG9wQmx1cic6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gc3RhdHVzLCBpZiBhbnkuXG52YXIgaXNDb21wb3NpbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFpc0NvbXBvc2luZykge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWlzQ29tcG9zaW5nICYmIGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0KSB7XG4gICAgICBpc0NvbXBvc2luZyA9IGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgLy8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4gICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKGN1c3RvbURhdGEgIT09IG51bGwpIHtcbiAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgIH1cbiAgfVxuXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUb3BMZXZlbFR5cGVzfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAqIEluIFdlYmtpdCwgcHJldmVudGluZyBkZWZhdWx0IG9uIGEgc3BhY2ViYXIgYHRleHRJbnB1dGAgZXZlbnRcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgKiBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM1NTEwM1xuICAgICAgICpcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAqIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG4gICAgICBpZiAod2hpY2ggIT09IFNQQUNFQkFSX0NPREUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGhhc1NwYWNlS2V5cHJlc3MgPSB0cnVlO1xuICAgICAgcmV0dXJuIFNQQUNFQkFSX0NIQVI7XG5cbiAgICBjYXNlICd0b3BUZXh0SW5wdXQnOlxuICAgICAgLy8gUmVjb3JkIHRoZSBjaGFyYWN0ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBET00uXG4gICAgICB2YXIgY2hhcnMgPSBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgICAvLyBJZiBpdCdzIGEgc3BhY2ViYXIgY2hhcmFjdGVyLCBhc3N1bWUgdGhhdCB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxuICAgICAgLy8gaXQgYXQgdGhlIGtleXByZXNzIGxldmVsIGFuZCBiYWlsIGltbWVkaWF0ZWx5LiBBbmRyb2lkIENocm9tZVxuICAgICAgLy8gZG9lc24ndCBnaXZlIHVzIGtleWNvZGVzLCBzbyB3ZSBuZWVkIHRvIGJsYWNrbGlzdCBpdC5cbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHByb3ZpZGUgdGhlIGB0ZXh0SW5wdXRgIGV2ZW50LCBleHRyYWN0IHRoZVxuICogYXBwcm9wcmlhdGUgc3RyaW5nIHRvIHVzZSBmb3IgU3ludGhldGljSW5wdXRFdmVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZhbGxiYWNrIHN0cmluZyBmb3IgdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICAvLyBJZiBjb21wb3NpdGlvbiBldmVudCBpcyBhdmFpbGFibGUsIHdlIGV4dHJhY3QgYSBzdHJpbmcgb25seSBhdFxuICAvLyBjb21wb3NpdGlvbmV2ZW50LCBvdGhlcndpc2UgZXh0cmFjdCBpdCBhdCBmYWxsYmFjayBldmVudHMuXG4gIGlmIChpc0NvbXBvc2luZykge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDb21wb3NpdGlvbkVuZCcgfHwgIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgJiYgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICB2YXIgY2hhcnMgPSBnZXREYXRhKCk7XG4gICAgICByZXNldCgpO1xuICAgICAgaXNDb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcFBhc3RlJzpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmICghaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIC8vIElFIGZpcmVzIHRoZSBga2V5cHJlc3NgIGV2ZW50IHdoZW4gYSB1c2VyIHR5cGVzIGFuIGVtb2ppIHZpYVxuICAgICAgICAvLyBUb3VjaCBrZXlib2FyZCBvZiBXaW5kb3dzLiAgSW4gc3VjaCBhIGNhc2UsIHRoZSBgY2hhcmAgcHJvcGVydHlcbiAgICAgICAgLy8gaG9sZHMgYW4gZW1vamkgY2hhcmFjdGVyIGxpa2UgYFxcdUQ4M0RcXHVERTBBYC4gIEJlY2F1c2UgaXRzIGxlbmd0aFxuICAgICAgICAvLyBpcyAyLCB0aGUgcHJvcGVydHkgYHdoaWNoYCBkb2VzIG5vdCByZXByZXNlbnQgYW4gZW1vamkgY29ycmVjdGx5LlxuICAgICAgICAvLyBJbiBzdWNoIGEgY2FzZSwgd2UgZGlyZWN0bHkgcmV0dXJuIHRoZSBgY2hhcmAgcHJvcGVydHkgaW5zdGVhZCBvZlxuICAgICAgICAvLyB1c2luZyBgd2hpY2hgLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuY2hhciAmJiBuYXRpdmVFdmVudC5jaGFyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlRXZlbnQuY2hhcjtcbiAgICAgICAgfSBlbHNlIGlmIChuYXRpdmVFdmVudC53aGljaCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID8gbnVsbCA6IG5hdGl2ZUV2ZW50LmRhdGE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGNoYXJzO1xuXG4gIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xuICAgIGNoYXJzID0gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFycyA9IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfVxuXG4gIC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHJldHVybiBbZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpLCBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCldO1xuICB9XG59O1xuXG4vLyBVc2UgdG8gcmVzdG9yZSBjb250cm9sbGVkIHN0YXRlIGFmdGVyIGEgY2hhbmdlIGV2ZW50IGhhcyBmaXJlZC5cblxudmFyIGZpYmVySG9zdENvbXBvbmVudCA9IG51bGw7XG5cbnZhciBSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIGluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQ6IGZ1bmN0aW9uIChob3N0Q29tcG9uZW50SW1wbCkge1xuICAgIC8vIFRoZSBmaWJlciBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IHVzZSBkeW5hbWljIGRpc3BhdGNoIHNvIHdlIG5lZWQgdG9cbiAgICAvLyBpbmplY3QgdGhlIGltcGxlbWVudGF0aW9uLlxuICAgIGZpYmVySG9zdENvbXBvbmVudCA9IGhvc3RDb21wb25lbnRJbXBsO1xuICB9XG59O1xuXG52YXIgcmVzdG9yZVRhcmdldCA9IG51bGw7XG52YXIgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KSB7XG4gIC8vIFdlIHBlcmZvcm0gdGhpcyB0cmFuc2xhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXQgd2VcbiAgLy8gYWx3YXlzIHJlY2VpdmUgdGhlIGNvcnJlY3QgZmliZXIgaGVyZVxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgLy8gVW5tb3VudGVkXG4gICAgcmV0dXJuO1xuICB9XG4gICEoZmliZXJIb3N0Q29tcG9uZW50ICYmIHR5cGVvZiBmaWJlckhvc3RDb21wb25lbnQucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdGaWJlciBuZWVkcyB0byBiZSBpbmplY3RlZCB0byBoYW5kbGUgYSBmaWJlciB0YXJnZXQgZm9yIGNvbnRyb2xsZWQgZXZlbnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICB2YXIgcHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlKTtcbiAgZmliZXJIb3N0Q29tcG9uZW50LnJlc3RvcmVDb250cm9sbGVkU3RhdGUoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUsIGludGVybmFsSW5zdGFuY2UudHlwZSwgcHJvcHMpO1xufVxuXG52YXIgaW5qZWN0aW9uJDMgPSBSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb247XG5cbmZ1bmN0aW9uIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KSB7XG4gIGlmIChyZXN0b3JlVGFyZ2V0KSB7XG4gICAgaWYgKHJlc3RvcmVRdWV1ZSkge1xuICAgICAgcmVzdG9yZVF1ZXVlLnB1c2godGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdG9yZVF1ZXVlID0gW3RhcmdldF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3RvcmVUYXJnZXQgPSB0YXJnZXQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlSWZOZWVkZWQoKSB7XG4gIGlmICghcmVzdG9yZVRhcmdldCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdGFyZ2V0ID0gcmVzdG9yZVRhcmdldDtcbiAgdmFyIHF1ZXVlZFRhcmdldHMgPSByZXN0b3JlUXVldWU7XG4gIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xuICByZXN0b3JlUXVldWUgPSBudWxsO1xuXG4gIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCk7XG4gIGlmIChxdWV1ZWRUYXJnZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZWRUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN0b3JlU3RhdGVPZlRhcmdldChxdWV1ZWRUYXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q29udHJvbGxlZENvbXBvbmVudCA9IE9iamVjdC5mcmVlemUoe1xuXHRpbmplY3Rpb246IGluamVjdGlvbiQzLFxuXHRlbnF1ZXVlU3RhdGVSZXN0b3JlOiBlbnF1ZXVlU3RhdGVSZXN0b3JlLFxuXHRyZXN0b3JlU3RhdGVJZk5lZWRlZDogcmVzdG9yZVN0YXRlSWZOZWVkZWRcbn0pO1xuXG4vLyBVc2VkIGFzIGEgd2F5IHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMgd2hlbiB3ZSBkb24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvXG4vLyB0aGUgcmVuZGVyZXIuIFN1Y2ggYXMgd2hlbiB3ZSdyZSBkaXNwYXRjaGluZyBldmVudHMgb3IgaWYgdGhpcmQgcGFydHlcbi8vIGxpYnJhcmllcyBuZWVkIHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMuIEV2ZW50dWFsbHksIHRoaXMgQVBJIHdpbGwgZ28gYXdheSB3aGVuXG4vLyBldmVyeXRoaW5nIGlzIGJhdGNoZWQgYnkgZGVmYXVsdC4gV2UnbGwgdGhlbiBoYXZlIGEgc2ltaWxhciBBUEkgdG8gb3B0LW91dCBvZlxuLy8gc2NoZWR1bGVkIHdvcmsgYW5kIGluc3RlYWQgZG8gc3luY2hyb25vdXMgd29yay5cblxuLy8gRGVmYXVsdHNcbnZhciBmaWJlckJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKGZuLCBib29ra2VlcGluZykge1xuICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xufTtcblxudmFyIGlzTmVzdGluZ0JhdGNoZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZykge1xuICBpZiAoaXNOZXN0aW5nQmF0Y2hlZCkge1xuICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgaW5zaWRlIGFub3RoZXIgYmF0Y2gsIHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdFxuICAgIC8vIGZ1bGx5IGNvbXBsZXRlcyBiZWZvcmUgcmVzdG9yaW5nIHN0YXRlLiBUaGVyZWZvcmUsIHdlIGFkZCB0aGUgdGFyZ2V0IHRvXG4gICAgLy8gYSBxdWV1ZSBvZiB3b3JrLlxuICAgIHJldHVybiBmaWJlckJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZyk7XG4gIH1cbiAgaXNOZXN0aW5nQmF0Y2hlZCA9IHRydWU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZpYmVyQmF0Y2hlZFVwZGF0ZXMoZm4sIGJvb2trZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBIZXJlIHdlIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgICAvLyB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAgIC8vIFRoZW4gd2UgcmVzdG9yZSBzdGF0ZSBvZiBhbnkgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAgaXNOZXN0aW5nQmF0Y2hlZCA9IGZhbHNlO1xuICAgIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCk7XG4gIH1cbn1cblxudmFyIFJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uID0ge1xuICBpbmplY3RGaWJlckJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoX2JhdGNoZWRVcGRhdGVzKSB7XG4gICAgZmliZXJCYXRjaGVkVXBkYXRlcyA9IF9iYXRjaGVkVXBkYXRlcztcbiAgfVxufTtcblxudmFyIGluamVjdGlvbiQ0ID0gUmVhY3RHZW5lcmljQmF0Y2hpbmdJbmplY3Rpb247XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICBjb2xvcjogdHJ1ZSxcbiAgZGF0ZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgcmFuZ2U6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdGVsOiB0cnVlLFxuICB0ZXh0OiB0cnVlLFxuICB0aW1lOiB0cnVlLFxuICB1cmw6IHRydWUsXG4gIHdlZWs6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL1xuXG52YXIgRUxFTUVOVF9OT0RFID0gMTtcbnZhciBURVhUX05PREUgPSAzO1xudmFyIENPTU1FTlRfTk9ERSA9IDg7XG52YXIgRE9DVU1FTlRfTk9ERSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuXG4gIC8vIE5vcm1hbGl6ZSBTVkcgPHVzZT4gZWxlbWVudCBldmVudHMgIzQ5NjNcbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfVxuXG4gIC8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXG4gIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG52YXIgdXNlSGFzRmVhdHVyZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdXNlSGFzRmVhdHVyZSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiZcbiAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxuICAvLyBAc2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZG9taW1wbGVtZW50YXRpb24taGFzZmVhdHVyZVxuICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCcnLCAnJykgIT09IHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4LCBjYXB0dXJlKSB7XG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8IGNhcHR1cmUgJiYgISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IGV2ZW50TmFtZSBpbiBkb2N1bWVudDtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCAmJiB1c2VIYXNGZWF0dXJlICYmIGV2ZW50TmFtZVN1ZmZpeCA9PT0gJ3doZWVsJykge1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIHRlc3Qgc3VwcG9ydCBmb3IgdGhlIGB3aGVlbGAgZXZlbnQgaW4gSUU5Ky5cbiAgICBpc1N1cHBvcnRlZCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ0V2ZW50cy53aGVlbCcsICczLjAnKTtcbiAgfVxuXG4gIHJldHVybiBpc1N1cHBvcnRlZDtcbn1cblxuZnVuY3Rpb24gaXNDaGVja2FibGUoZWxlbSkge1xuICB2YXIgdHlwZSA9IGVsZW0udHlwZTtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRyYWNrZXIobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdmFsdWVUcmFja2VyO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hUcmFja2VyKG5vZGUpIHtcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZSA9ICcnO1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNDaGVja2FibGUobm9kZSkpIHtcbiAgICB2YWx1ZSA9IG5vZGUuY2hlY2tlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBub2RlLnZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cmFja1ZhbHVlT25Ob2RlKG5vZGUpIHtcbiAgdmFyIHZhbHVlRmllbGQgPSBpc0NoZWNrYWJsZShub2RlKSA/ICdjaGVja2VkJyA6ICd2YWx1ZSc7XG4gIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgdmFsdWVGaWVsZCk7XG5cbiAgdmFyIGN1cnJlbnRWYWx1ZSA9ICcnICsgbm9kZVt2YWx1ZUZpZWxkXTtcblxuICAvLyBpZiBzb21lb25lIGhhcyBhbHJlYWR5IGRlZmluZWQgYSB2YWx1ZSBvciBTYWZhcmksIHRoZW4gYmFpbFxuICAvLyBhbmQgZG9uJ3QgdHJhY2sgdmFsdWUgd2lsbCBjYXVzZSBvdmVyIHJlcG9ydGluZyBvZiBjaGFuZ2VzLFxuICAvLyBidXQgaXQncyBiZXR0ZXIgdGhlbiBhIGhhcmQgZmFpbHVyZVxuICAvLyAobmVlZGVkIGZvciBjZXJ0YWluIHRlc3RzIHRoYXQgc3B5T24gaW5wdXQgdmFsdWVzIGFuZCBTYWZhcmkpXG4gIGlmIChub2RlLmhhc093blByb3BlcnR5KHZhbHVlRmllbGQpIHx8IHR5cGVvZiBkZXNjcmlwdG9yLmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZGVzY3JpcHRvci5zZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRvci5nZXQuY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgZGVzY3JpcHRvci5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgdHJhY2tlciA9IHtcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICB9LFxuICAgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfSxcbiAgICBzdG9wVHJhY2tpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRldGFjaFRyYWNrZXIobm9kZSk7XG4gICAgICBkZWxldGUgbm9kZVt2YWx1ZUZpZWxkXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFja2VyO1xufVxuXG5mdW5jdGlvbiB0cmFjayhub2RlKSB7XG4gIGlmIChnZXRUcmFja2VyKG5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETzogT25jZSBpdCdzIGp1c3QgRmliZXIgd2UgY2FuIG1vdmUgdGhpcyB0byBub2RlLl93cmFwcGVyU3RhdGVcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVmFsdWVJZkNoYW5nZWQobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHJhY2tlciA9IGdldFRyYWNrZXIobm9kZSk7XG4gIC8vIGlmIHRoZXJlIGlzIG5vIHRyYWNrZXIgYXQgdGhpcyBwb2ludCBpdCdzIHVubGlrZWx5XG4gIC8vIHRoYXQgdHJ5aW5nIGFnYWluIHdpbGwgc3VjY2VlZFxuICBpZiAoIXRyYWNrZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gIHZhciBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpO1xuICBpZiAobmV4dFZhbHVlICE9PSBsYXN0VmFsdWUpIHtcbiAgICB0cmFja2VyLnNldFZhbHVlKG5leHRWYWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgZXZlbnRUeXBlcyQxID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ2hhbmdlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25DaGFuZ2VDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ2hhbmdlJywgJ3RvcENsaWNrJywgJ3RvcEZvY3VzJywgJ3RvcElucHV0JywgJ3RvcEtleURvd24nLCAndG9wS2V5VXAnLCAndG9wU2VsZWN0aW9uQ2hhbmdlJ11cbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQkMS5nZXRQb29sZWQoZXZlbnRUeXBlcyQxLmNoYW5nZSwgaW5zdCwgbmF0aXZlRXZlbnQsIHRhcmdldCk7XG4gIGV2ZW50LnR5cGUgPSAnY2hhbmdlJztcbiAgLy8gRmxhZyB0aGlzIGV2ZW50IGxvb3AgYXMgbmVlZGluZyBzdGF0ZSByZXN0b3JlLlxuICBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCk7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgPT09ICdzZWxlY3QnIHx8IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnO1xufVxuXG5mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBldmVudCA9IGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIGJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZXZlbnQpIHtcbiAgZW5xdWV1ZUV2ZW50cyhldmVudCk7XG4gIHByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCk7XG4gIGlmICh1cGRhdGVWYWx1ZUlmQ2hhbmdlZCh0YXJnZXROb2RlKSkge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENoYW5nZScpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzLlxuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBpc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpICYmICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDkpO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpKSB7XG4gICAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BGb2N1cycpIHtcbiAgICAvLyBJbiBJRTksIHByb3BlcnR5Y2hhbmdlIGZpcmVzIGZvciBtb3N0IGlucHV0IGV2ZW50cyBidXQgaXMgYnVnZ3kgYW5kXG4gICAgLy8gZG9lc24ndCBmaXJlIHdoZW4gdGV4dCBpcyBkZWxldGVkLCBidXQgY29udmVuaWVudGx5LCBzZWxlY3Rpb25jaGFuZ2VcbiAgICAvLyBhcHBlYXJzIHRvIGZpcmUgaW4gYWxsIG9mIHRoZSByZW1haW5pbmcgY2FzZXMgc28gd2UgY2F0Y2ggdGhvc2UgYW5kXG4gICAgLy8gZm9yd2FyZCB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgLy8gSW4gZWl0aGVyIGNhc2UsIHdlIGRvbid0IHdhbnQgdG8gY2FsbCB0aGUgZXZlbnQgaGFuZGxlciBpZiB0aGUgdmFsdWVcbiAgICAvLyBpcyBjaGFuZ2VkIGZyb20gSlMgc28gd2UgcmVkZWZpbmUgYSBzZXR0ZXIgZm9yIGAudmFsdWVgIHRoYXQgdXBkYXRlc1xuICAgIC8vIG91ciBhY3RpdmVFbGVtZW50VmFsdWUgdmFyaWFibGUsIGFsbG93aW5nIHVzIHRvIGlnbm9yZSB0aG9zZSBjaGFuZ2VzXG4gICAgLy9cbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQmx1cicpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BTZWxlY3Rpb25DaGFuZ2UnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleVVwJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJykge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpO1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ2xpY2snKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wSW5wdXQnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcENoYW5nZScpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIoaW5zdCwgbm9kZSkge1xuICAvLyBUT0RPOiBJbiBJRSwgaW5zdCBpcyBvY2Nhc2lvbmFsbHkgbnVsbC4gV2h5P1xuICBpZiAoaW5zdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRmliZXIgYW5kIFJlYWN0RE9NIGtlZXAgd3JhcHBlciBzdGF0ZSBpbiBzZXBhcmF0ZSBwbGFjZXNcbiAgdmFyIHN0YXRlID0gaW5zdC5fd3JhcHBlclN0YXRlIHx8IG5vZGUuX3dyYXBwZXJTdGF0ZTtcblxuICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5jb250cm9sbGVkIHx8IG5vZGUudHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBjb250cm9sbGVkLCBhc3NpZ24gdGhlIHZhbHVlIGF0dHJpYnV0ZSB0byB0aGUgY3VycmVudCB2YWx1ZSBvbiBibHVyXG4gIHZhciB2YWx1ZSA9ICcnICsgbm9kZS52YWx1ZTtcbiAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICE9PSB2YWx1ZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMSxcblxuICBfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOiBpc0lucHV0RXZlbnRTdXBwb3J0ZWQsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoaW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gYmx1cnJpbmcsIHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIGZvciBudW1iZXIgaW5wdXRzXG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKHRhcmdldEluc3QsIHRhcmdldE5vZGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xudmFyIERPTUV2ZW50UGx1Z2luT3JkZXIgPSBbJ1Jlc3BvbmRlckV2ZW50UGx1Z2luJywgJ1NpbXBsZUV2ZW50UGx1Z2luJywgJ1RhcEV2ZW50UGx1Z2luJywgJ0VudGVyTGVhdmVFdmVudFBsdWdpbicsICdDaGFuZ2VFdmVudFBsdWdpbicsICdTZWxlY3RFdmVudFBsdWdpbicsICdCZWZvcmVJbnB1dEV2ZW50UGx1Z2luJ107XG5cbi8qKlxuICogQGludGVyZmFjZSBVSUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHZpZXc6IG51bGwsXG4gIGRldGFpbDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1VJRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgQWx0OiAnYWx0S2V5JyxcbiAgQ29udHJvbDogJ2N0cmxLZXknLFxuICBNZXRhOiAnbWV0YUtleScsXG4gIFNoaWZ0OiAnc2hpZnRLZXknXG59O1xuXG4vLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGdldE1vZGlmaWVyU3RhdGUgc28gd2Ugc2ltcGx5IG1hcCBpdCB0byB0aGUgb25seVxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudCBpdHNlbGYsIGRvZXMgbm90IHN1cHBvcnQgTG9jay1rZXlzLlxuLy8gQ3VycmVudGx5LCBhbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IENocm9tZSBzZWVtcyB0byBzdXBwb3J0IExvY2sta2V5cy5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBwYWdlWDogbnVsbCxcbiAgcGFnZVk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBudWxsLFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCAoZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY01vdXNlRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY01vdXNlRXZlbnQsIE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgZXZlbnRUeXBlcyQyID0ge1xuICBtb3VzZUVudGVyOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VFbnRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH0sXG4gIG1vdXNlTGVhdmU6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUxlYXZlJyxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wTW91c2VPdXQnLCAndG9wTW91c2VPdmVyJ11cbiAgfVxufTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQyLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdmVyJyAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxUeXBlICE9PSAndG9wTW91c2VPdXQnICYmIHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3ZlcicpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luO1xuICAgIGlmIChuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU91dCcpIHtcbiAgICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcbiAgICAgIHRvID0gcmVsYXRlZCA/IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlbGF0ZWQpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbiAgICAgIGZyb20gPSBudWxsO1xuICAgICAgdG8gPSB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZyb21Ob2RlID0gZnJvbSA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGZyb20pO1xuICAgIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMi5tb3VzZUxlYXZlLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbU5vZGU7XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcblxuICAgIHZhciBlbnRlciA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMi5tb3VzZUVudGVyLCB0bywgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBlbnRlci50eXBlID0gJ21vdXNlZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvTm9kZTtcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbU5vZGU7XG5cbiAgICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG5cbiAgICByZXR1cm4gW2xlYXZlLCBlbnRlcl07XG4gIH1cbn07XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuXG4vKipcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXG4gKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlcjtcbn1cblxuZnVuY3Rpb24gaGFzKGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXIgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAga2V5Ll9yZWFjdEludGVybmFsRmliZXIgPSB2YWx1ZTtcbn1cblxudmFyIFJlYWN0SW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0SW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBEb24ndCBjaGFuZ2UgdGhlc2UgdHdvIHZhbHVlczpcbnZhciBOb0VmZmVjdCA9IDA7IC8vICAgICAgICAgICAwYjAwMDAwMDAwXG52YXIgUGVyZm9ybWVkV29yayA9IDE7IC8vICAgICAgMGIwMDAwMDAwMVxuXG4vLyBZb3UgY2FuIGNoYW5nZSB0aGUgcmVzdCAoYW5kIGFkZCBtb3JlKS5cbnZhciBQbGFjZW1lbnQgPSAyOyAvLyAgICAgICAgICAwYjAwMDAwMDEwXG52YXIgVXBkYXRlID0gNDsgLy8gICAgICAgICAgICAgMGIwMDAwMDEwMFxudmFyIFBsYWNlbWVudEFuZFVwZGF0ZSA9IDY7IC8vIDBiMDAwMDAxMTBcbnZhciBEZWxldGlvbiA9IDg7IC8vICAgICAgICAgICAwYjAwMDAxMDAwXG52YXIgQ29udGVudFJlc2V0ID0gMTY7IC8vICAgICAgMGIwMDAxMDAwMFxudmFyIENhbGxiYWNrID0gMzI7IC8vICAgICAgICAgIDBiMDAxMDAwMDBcbnZhciBFcnIgPSA2NDsgLy8gICAgICAgICAgICAgICAwYjAxMDAwMDAwXG52YXIgUmVmID0gMTI4OyAvLyAgICAgICAgICAgICAgMGIxMDAwMDAwMFxuXG52YXIgTU9VTlRJTkcgPSAxO1xudmFyIE1PVU5URUQgPSAyO1xudmFyIFVOTU9VTlRFRCA9IDM7XG5cbmZ1bmN0aW9uIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikge1xuICB2YXIgbm9kZSA9IGZpYmVyO1xuICBpZiAoIWZpYmVyLmFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhpcyBtaWdodCBiZSBhIG5ldyB0cmVlIHRoYXQgaXNuJ3QgaW5zZXJ0ZWRcbiAgICAvLyB5ZXQuIElmIGl0IGlzLCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHBlbmRpbmcgaW5zZXJ0aW9uIGVmZmVjdCBvbiBpdC5cbiAgICBpZiAoKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSAhPT0gTm9FZmZlY3QpIHtcbiAgICAgIHJldHVybiBNT1VOVElORztcbiAgICB9XG4gICAgd2hpbGUgKG5vZGVbJ3JldHVybiddKSB7XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBpZiAoKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSAhPT0gTm9FZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuIE1PVU5USU5HO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobm9kZVsncmV0dXJuJ10pIHtcbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4gICAgLy8gcmVuZGVyQ29udGFpbmVySW50b1N1YnRyZWUuXG4gICAgcmV0dXJuIE1PVU5URUQ7XG4gIH1cbiAgLy8gSWYgd2UgZGlkbid0IGhpdCB0aGUgcm9vdCwgdGhhdCBtZWFucyB0aGF0IHdlJ3JlIGluIGFuIGRpc2Nvbm5lY3RlZCB0cmVlXG4gIC8vIHRoYXQgaGFzIGJlZW4gdW5tb3VudGVkLlxuICByZXR1cm4gVU5NT1VOVEVEO1xufVxuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZChmaWJlcikge1xuICByZXR1cm4gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNNb3VudGVkKGNvbXBvbmVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgb3duZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgd2FybmluZyhpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyRmliZXIpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcbiAgaWYgKCFmaWJlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gICEoaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiBpdCBpcyBtb3VudGVkLlxuICAgIHZhciBzdGF0ZSA9IGlzRmliZXJNb3VudGVkSW1wbChmaWJlcik7XG4gICAgIShzdGF0ZSAhPT0gVU5NT1VOVEVEKSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgICBpZiAoc3RhdGUgPT09IE1PVU5USU5HKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG4gIHZhciBhID0gZmliZXI7XG4gIHZhciBiID0gYWx0ZXJuYXRlO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwYXJlbnRBID0gYVsncmV0dXJuJ107XG4gICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBID8gcGFyZW50QS5hbHRlcm5hdGUgOiBudWxsO1xuICAgIGlmICghcGFyZW50QSB8fCAhcGFyZW50Qikge1xuICAgICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBJZiBib3RoIGNvcGllcyBvZiB0aGUgcGFyZW50IGZpYmVyIHBvaW50IHRvIHRoZSBzYW1lIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG4gICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBhKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkID09PSBiKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEIgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKGFbJ3JldHVybiddICE9PSBiWydyZXR1cm4nXSkge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVyIG9mIEEgYW5kIHRoZSByZXR1cm4gcG9pbnRlciBvZiBCIHBvaW50IHRvIGRpZmZlcmVudFxuICAgICAgLy8gZmliZXJzLiBXZSBhc3N1bWUgdGhhdCByZXR1cm4gcG9pbnRlcnMgbmV2ZXIgY3Jpc3MtY3Jvc3MsIHNvIEEgbXVzdFxuICAgICAgLy8gYmVsb25nIHRvIHRoZSBjaGlsZCBzZXQgb2YgQS5yZXR1cm4sIGFuZCBCIG11c3QgYmVsb25nIHRvIHRoZSBjaGlsZFxuICAgICAgLy8gc2V0IG9mIEIucmV0dXJuLlxuICAgICAgYSA9IHBhcmVudEE7XG4gICAgICBiID0gcGFyZW50QjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVycyBwb2ludCB0byB0aGUgc2FtZSBmaWJlci4gV2UnbGwgaGF2ZSB0byB1c2UgdGhlXG4gICAgICAvLyBkZWZhdWx0LCBzbG93IHBhdGg6IHNjYW4gdGhlIGNoaWxkIHNldHMgb2YgZWFjaCBwYXJlbnQgYWx0ZXJuYXRlIHRvIHNlZVxuICAgICAgLy8gd2hpY2ggY2hpbGQgYmVsb25ncyB0byB3aGljaCBzZXQuXG4gICAgICAvL1xuICAgICAgLy8gU2VhcmNoIHBhcmVudCBBJ3MgY2hpbGQgc2V0XG4gICAgICB2YXIgZGlkRmluZENoaWxkID0gZmFsc2U7XG4gICAgICB2YXIgX2NoaWxkID0gcGFyZW50QS5jaGlsZDtcbiAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgX2NoaWxkID0gcGFyZW50Qi5jaGlsZDtcbiAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgICFkaWRGaW5kQ2hpbGQgPyBpbnZhcmlhbnQoZmFsc2UsICdDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShhLmFsdGVybmF0ZSA9PT0gYikgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnNcXCcgYWx0ZXJuYXRlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgfVxuICAvLyBJZiB0aGUgcm9vdCBpcyBub3QgYSBob3N0IGNvbnRhaW5lciwgd2UncmUgaW4gYSBkaXNjb25uZWN0ZWQgdHJlZS4gSS5lLlxuICAvLyB1bm1vdW50ZWQuXG4gICEoYS50YWcgPT09IEhvc3RSb290KSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgaWYgKGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEpIHtcbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIC8vIE90aGVyd2lzZSBCIGhhcyB0byBiZSBjdXJyZW50IGJyYW5jaC5cbiAgcmV0dXJuIGFsdGVybmF0ZTtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXIocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkKSB7XG4gICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGVbJ3JldHVybiddIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICYmIG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSB7XG4gICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGVbJ3JldHVybiddIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgQ0FMTEJBQ0tfQk9PS0tFRVBJTkdfUE9PTF9TSVpFID0gMTA7XG52YXIgY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wgPSBbXTtcblxuLyoqXG4gKiBGaW5kIHRoZSBkZWVwZXN0IFJlYWN0IGNvbXBvbmVudCBjb21wbGV0ZWx5IGNvbnRhaW5pbmcgdGhlIHJvb3Qgb2YgdGhlXG4gKiBwYXNzZWQtaW4gaW5zdGFuY2UgKGZvciB1c2Ugd2hlbiBlbnRpcmUgUmVhY3QgdHJlZXMgYXJlIG5lc3RlZCB3aXRoaW4gZWFjaFxuICogb3RoZXIpLiBJZiBSZWFjdCB0cmVlcyBhcmUgbm90IG5lc3RlZCwgcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBmaW5kUm9vdENvbnRhaW5lck5vZGUoaW5zdCkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB3aGlsZSAoaW5zdFsncmV0dXJuJ10pIHtcbiAgICBpbnN0ID0gaW5zdFsncmV0dXJuJ107XG4gIH1cbiAgaWYgKGluc3QudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB3ZSdyZSBpbiBhIGRldGFjaGVkIHRyZWUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGluc3Quc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYW5jZXN0b3IgaGllcmFyY2h5IGluIHRvcCBsZXZlbCBjYWxsYmFja1xuZnVuY3Rpb24gZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QpIHtcbiAgaWYgKGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnBvcCgpO1xuICAgIGluc3RhbmNlLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgIGluc3RhbmNlLnRhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcExldmVsVHlwZTogdG9wTGV2ZWxUeXBlLFxuICAgIG5hdGl2ZUV2ZW50OiBuYXRpdmVFdmVudCxcbiAgICB0YXJnZXRJbnN0OiB0YXJnZXRJbnN0LFxuICAgIGFuY2VzdG9yczogW11cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyhpbnN0YW5jZSkge1xuICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSBudWxsO1xuICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG51bGw7XG4gIGluc3RhbmNlLnRhcmdldEluc3QgPSBudWxsO1xuICBpbnN0YW5jZS5hbmNlc3RvcnMubGVuZ3RoID0gMDtcbiAgaWYgKGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLmxlbmd0aCA8IENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSkge1xuICAgIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsSW1wbChib29rS2VlcGluZykge1xuICB2YXIgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLnRhcmdldEluc3Q7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRhcmdldEluc3Q7XG4gIGRvIHtcbiAgICBpZiAoIWFuY2VzdG9yKSB7XG4gICAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHJvb3QgPSBmaW5kUm9vdENvbnRhaW5lck5vZGUoYW5jZXN0b3IpO1xuICAgIGlmICghcm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJvb3QpO1xuICB9IHdoaWxlIChhbmNlc3Rvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIF9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbi8vIFRPRE86IGNhbiB3ZSBzdG9wIGV4cG9ydGluZyB0aGVzZT9cbnZhciBfZW5hYmxlZCA9IHRydWU7XG52YXIgX2hhbmRsZVRvcExldmVsID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBzZXRIYW5kbGVUb3BMZXZlbChoYW5kbGVUb3BMZXZlbCkge1xuICBfaGFuZGxlVG9wTGV2ZWwgPSBoYW5kbGVUb3BMZXZlbDtcbn1cblxuZnVuY3Rpb24gc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gIF9lbmFibGVkID0gISFlbmFibGVkO1xufVxuXG5mdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gIHJldHVybiBfZW5hYmxlZDtcbn1cblxuLyoqXG4gKiBUcmFwcyB0b3AtbGV2ZWwgZXZlbnRzIGJ5IHVzaW5nIGV2ZW50IGJ1YmJsaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gRXZlbnRMaXN0ZW5lci5saXN0ZW4oZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG59XG5cbi8qKlxuICogVHJhcHMgYSB0b3AtbGV2ZWwgZXZlbnQgYnkgdXNpbmcgZXZlbnQgY2FwdHVyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEV2ZW50TGlzdGVuZXIuY2FwdHVyZShlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIGRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmICghX2VuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCk7XG4gIHZhciB0YXJnZXRJbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuICBpZiAodGFyZ2V0SW5zdCAhPT0gbnVsbCAmJiB0eXBlb2YgdGFyZ2V0SW5zdC50YWcgPT09ICdudW1iZXInICYmICFpc0ZpYmVyTW91bnRlZCh0YXJnZXRJbnN0KSkge1xuICAgIC8vIElmIHdlIGdldCBhbiBldmVudCAoZXg6IGltZyBvbmxvYWQpIGJlZm9yZSBjb21taXR0aW5nIHRoYXRcbiAgICAvLyBjb21wb25lbnQncyBtb3VudCwgaWdub3JlIGl0IGZvciBub3cgKHRoYXQgaXMsIHRyZWF0IGl0IGFzIGlmIGl0IHdhcyBhblxuICAgIC8vIGV2ZW50IG9uIGEgbm9uLVJlYWN0IHRyZWUpLiBXZSBtaWdodCBhbHNvIGNvbnNpZGVyIHF1ZXVlaW5nIGV2ZW50cyBhbmRcbiAgICAvLyBkaXNwYXRjaGluZyB0aGVtIGFmdGVyIHRoZSBtb3VudC5cbiAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBib29rS2VlcGluZyA9IGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KTtcblxuICB0cnkge1xuICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcbiAgICAvLyBgcHJldmVudERlZmF1bHRgLlxuICAgIGJhdGNoZWRVcGRhdGVzKGhhbmRsZVRvcExldmVsSW1wbCwgYm9va0tlZXBpbmcpO1xuICB9IGZpbmFsbHkge1xuICAgIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoYm9va0tlZXBpbmcpO1xuICB9XG59XG5cbnZhciBSZWFjdERPTUV2ZW50TGlzdGVuZXIgPSBPYmplY3QuZnJlZXplKHtcblx0Z2V0IF9lbmFibGVkICgpIHsgcmV0dXJuIF9lbmFibGVkOyB9LFxuXHRnZXQgX2hhbmRsZVRvcExldmVsICgpIHsgcmV0dXJuIF9oYW5kbGVUb3BMZXZlbDsgfSxcblx0c2V0SGFuZGxlVG9wTGV2ZWw6IHNldEhhbmRsZVRvcExldmVsLFxuXHRzZXRFbmFibGVkOiBzZXRFbmFibGVkLFxuXHRpc0VuYWJsZWQ6IGlzRW5hYmxlZCxcblx0dHJhcEJ1YmJsZWRFdmVudDogdHJhcEJ1YmJsZWRFdmVudCxcblx0dHJhcENhcHR1cmVkRXZlbnQ6IHRyYXBDYXB0dXJlZEV2ZW50LFxuXHRkaXNwYXRjaEV2ZW50OiBkaXNwYXRjaEV2ZW50XG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1ha2VQcmVmaXhNYXAoc3R5bGVQcm9wLCBldmVudE5hbWUpIHtcbiAgdmFyIHByZWZpeGVzID0ge307XG5cbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ21zJyArIHN0eWxlUHJvcF0gPSAnTVMnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTycgKyBzdHlsZVByb3BdID0gJ28nICsgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHZlbmRvclByZWZpeGVzID0ge1xuICBhbmltYXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25FbmQnKSxcbiAgYW5pbWF0aW9uaXRlcmF0aW9uOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uSXRlcmF0aW9uJyksXG4gIGFuaW1hdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uU3RhcnQnKSxcbiAgdHJhbnNpdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsICdUcmFuc2l0aW9uRW5kJylcbn07XG5cbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG52YXIgcHJlZml4ZWRFdmVudE5hbWVzID0ge307XG5cbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cbnZhciBzdHlsZSA9IHt9O1xuXG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb247XG4gIH1cblxuICAvLyBTYW1lIGFzIGFib3ZlXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBUeXBlcyBvZiByYXcgc2lnbmFscyBmcm9tIHRoZSBicm93c2VyIGNhdWdodCBhdCB0aGUgdG9wIGxldmVsLlxuICpcbiAqIEZvciBldmVudHMgbGlrZSAnc3VibWl0JyB3aGljaCBkb24ndCBjb25zaXN0ZW50bHkgYnViYmxlICh3aGljaCB3ZVxuICogdHJhcCBhdCBhIGxvd2VyIG5vZGUgdGhhbiBgZG9jdW1lbnRgKSwgYmluZGluZyBhdCBgZG9jdW1lbnRgIHdvdWxkXG4gKiBjYXVzZSBkdXBsaWNhdGUgZXZlbnRzIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBoZXJlLlxuICovXG52YXIgdG9wTGV2ZWxUeXBlcyQxID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQW5pbWF0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJykgfHwgJ2FuaW1hdGlvbmVuZCcsXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbml0ZXJhdGlvbicpIHx8ICdhbmltYXRpb25pdGVyYXRpb24nLFxuICB0b3BBbmltYXRpb25TdGFydDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0JykgfHwgJ2FuaW1hdGlvbnN0YXJ0JyxcbiAgdG9wQmx1cjogJ2JsdXInLFxuICB0b3BDYW5jZWw6ICdjYW5jZWwnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BDaGFuZ2U6ICdjaGFuZ2UnLFxuICB0b3BDbGljazogJ2NsaWNrJyxcbiAgdG9wQ2xvc2U6ICdjbG9zZScsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiAnY29tcG9zaXRpb25lbmQnLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiAnY29tcG9zaXRpb25zdGFydCcsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiAnY29tcG9zaXRpb251cGRhdGUnLFxuICB0b3BDb250ZXh0TWVudTogJ2NvbnRleHRtZW51JyxcbiAgdG9wQ29weTogJ2NvcHknLFxuICB0b3BDdXQ6ICdjdXQnLFxuICB0b3BEb3VibGVDbGljazogJ2RibGNsaWNrJyxcbiAgdG9wRHJhZzogJ2RyYWcnLFxuICB0b3BEcmFnRW5kOiAnZHJhZ2VuZCcsXG4gIHRvcERyYWdFbnRlcjogJ2RyYWdlbnRlcicsXG4gIHRvcERyYWdFeGl0OiAnZHJhZ2V4aXQnLFxuICB0b3BEcmFnTGVhdmU6ICdkcmFnbGVhdmUnLFxuICB0b3BEcmFnT3ZlcjogJ2RyYWdvdmVyJyxcbiAgdG9wRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgdG9wRHJvcDogJ2Ryb3AnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcEZvY3VzOiAnZm9jdXMnLFxuICB0b3BJbnB1dDogJ2lucHV0JyxcbiAgdG9wS2V5RG93bjogJ2tleWRvd24nLFxuICB0b3BLZXlQcmVzczogJ2tleXByZXNzJyxcbiAgdG9wS2V5VXA6ICdrZXl1cCcsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZDogJ2xvYWQnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgdG9wTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG9wTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gIHRvcE1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gIHRvcE1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgdG9wUGFzdGU6ICdwYXN0ZScsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6ICdzZWxlY3Rpb25jaGFuZ2UnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BUb2dnbGU6ICd0b2dnbGUnLFxuICB0b3BUb3VjaENhbmNlbDogJ3RvdWNoY2FuY2VsJyxcbiAgdG9wVG91Y2hFbmQ6ICd0b3VjaGVuZCcsXG4gIHRvcFRvdWNoTW92ZTogJ3RvdWNobW92ZScsXG4gIHRvcFRvdWNoU3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgdG9wVHJhbnNpdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ3RyYW5zaXRpb25lbmQnKSB8fCAndHJhbnNpdGlvbmVuZCcsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJyxcbiAgdG9wV2hlZWw6ICd3aGVlbCdcbn07XG5cbnZhciBCcm93c2VyRXZlbnRDb25zdGFudHMgPSB7XG4gIHRvcExldmVsVHlwZXM6IHRvcExldmVsVHlwZXMkMVxufTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIGVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgcHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG4vKipcbiAqIFN0cmVhbXMgYSBmaXJlZCB0b3AtbGV2ZWwgZXZlbnQgdG8gYEV2ZW50UGx1Z2luSHViYCB3aGVyZSBwbHVnaW5zIGhhdmUgdGhlXG4gKiBvcHBvcnR1bml0eSB0byBjcmVhdGUgYFJlYWN0RXZlbnRgcyB0byBiZSBkaXNwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzID0gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG59XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gQnJvd3NlckV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnRcbiAqICAgIHBsdWdnYWJsZSBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW5cbiAqICAgIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArICgnJyArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gKlxuICogRmlyZWZveCB2OC4wMSAoYW5kIHBvc3NpYmx5IG90aGVycykgZXhoaWJpdGVkIHN0cmFuZ2UgYmVoYXZpb3Igd2hlblxuICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gKiBjb250YWluZWQgd2l0aGluIHRoYXQgbW91bnQgcG9pbnQgKGZvciBleGFtcGxlIG9uIHRoZSBiYWNrZ3JvdW5kKSB0aGVcbiAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gKiBjYXRjaCBhbGwgYG1vdXNlbW92ZWBzLiBUaGlzIGFsb25nIHdpdGggaU9TIHF1aXJrcywganVzdGlmaWVzIHJlc3RyaWN0aW5nXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICpcbiAqIEFsc28sIGBrZXl1cGAvYGtleXByZXNzYC9ga2V5ZG93bmAgZG8gbm90IGJ1YmJsZSB0byB0aGUgd2luZG93IG9uIElFLCBidXRcbiAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gKi9cbmZ1bmN0aW9uIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcbiAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcFNjcm9sbCcpIHtcbiAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcFNjcm9sbCcsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcEZvY3VzJyB8fCBkZXBlbmRlbmN5ID09PSAndG9wQmx1cicpIHtcbiAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcEZvY3VzJywgJ2ZvY3VzJywgbW91bnRBdCk7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BCbHVyJywgJ2JsdXInLCBtb3VudEF0KTtcblxuICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQmx1ciA9IHRydWU7XG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcEZvY3VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcENhbmNlbCcpIHtcbiAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2NhbmNlbCcsIHRydWUpKSB7XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcENhbmNlbCcsICdjYW5jZWwnLCBtb3VudEF0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0xpc3RlbmluZy50b3BDYW5jZWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSAndG9wQ2xvc2UnKSB7XG4gICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdjbG9zZScsIHRydWUpKSB7XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcENsb3NlJywgJ2Nsb3NlJywgbW91bnRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQ2xvc2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGVzLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgIHRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wTGV2ZWxUeXBlc1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XG4gICAgICB9XG5cbiAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcyhyZWdpc3RyYXRpb25OYW1lLCBtb3VudEF0KSB7XG4gIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2l2ZW4gYW55IG5vZGUgcmV0dXJuIHRoZSBmaXJzdCBsZWFmIG5vZGUgd2l0aG91dCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgc2libGluZyB3aXRoaW4gYSBjb250YWluZXIuIFRoaXMgd2lsbCB3YWxrIHVwIHRoZVxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2libGluZ05vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBvYmplY3QgZGVzY3JpYmluZyB0aGUgbm9kZXMgd2hpY2ggY29udGFpbiBjaGFyYWN0ZXJzIGF0IG9mZnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHZhciBub2RlU3RhcnQgPSAwO1xuICB2YXIgbm9kZUVuZCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG91dGVyTm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0cyhvdXRlck5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZSQkMSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICAvLyBJbiBGaXJlZm94LCBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgY2FuIGJlIFwiYW5vbnltb3VzIGRpdnNcIiwgZS5nLiB0aGVcbiAgLy8gdXAvZG93biBidXR0b25zIG9uIGFuIDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+LiBBbm9ueW1vdXMgZGl2cyBkbyBub3Qgc2VlbSB0b1xuICAvLyBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWQgZXJyb3JcIiBpZiBhbnkgb2YgaXRzXG4gIC8vIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGUgd2F5IHRvIGF2b2lkIGVycm9yaW5nXG4gIC8vIGlzIHRvIGFjY2VzcyBhIHByb3BlcnR5IHRoYXQgdHlwaWNhbGx5IHdvcmtzIGZvciBub24tYW5vbnltb3VzIGRpdnMgYW5kXG4gIC8vIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcblxuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGFuY2hvck5vZGUubm9kZVR5cGU7XG4gICAgZm9jdXNOb2RlJCQxLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlJCQxLCBmb2N1c09mZnNldCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB7c3RhcnQsIGVuZH0gd2hlcmUgYHN0YXJ0YCBpcyB0aGUgY2hhcmFjdGVyL2NvZGVwb2ludCBpbmRleCBvZlxuICogKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCkgd2l0aGluIHRoZSB0ZXh0Q29udGVudCBvZiBgb3V0ZXJOb2RlYCwgYW5kXG4gKiBgZW5kYCBpcyB0aGUgaW5kZXggb2YgKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpLlxuICpcbiAqIFJldHVybnMgbnVsbCBpZiB5b3UgcGFzcyBpbiBnYXJiYWdlIGlucHV0IGJ1dCB3ZSBzaG91bGQgcHJvYmFibHkganVzdCBjcmFzaC5cbiAqXG4gKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0aW5nLlxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlJCQxLCBmb2N1c09mZnNldCkge1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIGluZGV4V2l0aGluQW5jaG9yID0gMDtcbiAgdmFyIGluZGV4V2l0aGluRm9jdXMgPSAwO1xuICB2YXIgbm9kZSA9IG91dGVyTm9kZTtcbiAgdmFyIHBhcmVudE5vZGUgPSBudWxsO1xuXG4gIG91dGVyOiB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBuZXh0ID0gbnVsbDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gYW5jaG9yTm9kZSAmJiAoYW5jaG9yT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGggKyBhbmNob3JPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZm9jdXNOb2RlJCQxICYmIChmb2N1c09mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aCArIGZvY3VzT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIGxlbmd0aCArPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgobmV4dCA9IG5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIGZpcnN0IGNoaWxkIGBuZXh0YC5cbiAgICAgIHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgbm9kZSA9IG5leHQ7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBvdXRlck5vZGUpIHtcbiAgICAgICAgLy8gSWYgYG91dGVyTm9kZWAgaGFzIGNoaWxkcmVuLCB0aGlzIGlzIGFsd2F5cyB0aGUgc2Vjb25kIHRpbWUgdmlzaXRpbmdcbiAgICAgICAgLy8gaXQuIElmIGl0IGhhcyBubyBjaGlsZHJlbiwgdGhpcyBpcyBzdGlsbCB0aGUgZmlyc3QgbG9vcCwgYW5kIHRoZSBvbmx5XG4gICAgICAgIC8vIHZhbGlkIHNlbGVjdGlvbiBpcyBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgYm90aCBlcXVhbCB0byB0aGlzIG5vZGVcbiAgICAgICAgLy8gYW5kIGJvdGggb2Zmc2V0cyAwLCBpbiB3aGljaCBjYXNlIHdlIHdpbGwgaGF2ZSBoYW5kbGVkIGFib3ZlLlxuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBhbmNob3JOb2RlICYmICsraW5kZXhXaXRoaW5BbmNob3IgPT09IGFuY2hvck9mZnNldCkge1xuICAgICAgICBzdGFydCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBmb2N1c05vZGUkJDEgJiYgKytpbmRleFdpdGhpbkZvY3VzID09PSBmb2N1c09mZnNldCkge1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoKG5leHQgPSBub2RlLm5leHRTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIG5leHQgc2libGluZyBgbmV4dGAuXG4gICAgbm9kZSA9IG5leHQ7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uIChXb3VsZCBoYXBwZW4gaWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhcmVuJ3RcbiAgICAvLyBhY3R1YWxseSBpbnNpZGUgdGhlIHBhc3NlZC1pbiBub2RlLilcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogZW5kXG4gIH07XG59XG5cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIGxlbmd0aCA9IG5vZGVbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXS5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAxICYmIHNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBzdGFydE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPT09IHN0YXJ0TWFya2VyLm9mZnNldCAmJiBzZWxlY3Rpb24uZm9jdXNOb2RlID09PSBlbmRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgPT09IGVuZE1hcmtlci5vZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zTm9kZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xuXG5mdW5jdGlvbiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpIHtcbiAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICByZXR1cm4ge1xuICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICBzZWxlY3Rpb25SYW5nZTogaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IGdldFNlbGVjdGlvbiQxKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9cbmZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24ocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgaWYgKGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgIH1cblxuICAgIC8vIEZvY3VzaW5nIGEgbm9kZSBjYW4gY2hhbmdlIHRoZSBzY3JvbGwgcG9zaXRpb24sIHdoaWNoIGlzIHVuZGVzaXJhYmxlXG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgIHZhciBhbmNlc3RvciA9IHByaW9yRm9jdXNlZEVsZW07XG4gICAgd2hpbGUgKGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGFuY2VzdG9yLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGFuY2VzdG9yLFxuICAgICAgICAgIGxlZnQ6IGFuY2VzdG9yLnNjcm9sbExlZnQsXG4gICAgICAgICAgdG9wOiBhbmNlc3Rvci5zY3JvbGxUb3BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9jdXNOb2RlKHByaW9yRm9jdXNlZEVsZW0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmZvID0gYW5jZXN0b3JzW2ldO1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbExlZnQgPSBpbmZvLmxlZnQ7XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsVG9wID0gaW5mby50b3A7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uJDEoaW5wdXQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHZvaWQgMDtcblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0ge1xuICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IGdldE9mZnNldHMoaW5wdXQpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbn1cblxuLyoqXG4gKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAqIHRoZSBpbnB1dC5cbiAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAqL1xuZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGlucHV0LCBvZmZzZXRzKSB7XG4gIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQsXG4gICAgICBlbmQgPSBvZmZzZXRzLmVuZDtcblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSBzdGFydDtcbiAgfVxuXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gIH1cbn1cblxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbnZhciBldmVudFR5cGVzJDMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25TZWxlY3QnLFxuICAgICAgY2FwdHVyZWQ6ICdvblNlbGVjdENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb250ZXh0TWVudScsICd0b3BGb2N1cycsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93bicsICd0b3BNb3VzZVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQkMSA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQkMSAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQkMSk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmdldFBvb2xlZChldmVudFR5cGVzJDMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SW5zdCQxLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQkMTtcblxuICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQgPyBuYXRpdmVFdmVudFRhcmdldC5kb2N1bWVudCA6IG5hdGl2ZUV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gbmF0aXZlRXZlbnRUYXJnZXQgOiBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRyYWNrIHdoZXRoZXIgYWxsIGxpc3RlbmVycyBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuICAgIC8vIG5vdCBleHRyYWN0IGV2ZW50cy4gU2VlICMzNjM5LlxuICAgIGlmICghZG9jIHx8ICFpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzKCdvblNlbGVjdCcsIGRvYykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSB8fCB0YXJnZXROb2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgICBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIC8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4gICAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAgIC8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuICAgICAgLy9cbiAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbiAgICAgIC8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXG4gICAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAgIC8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cbiAgICAgIGNhc2UgJ3RvcFNlbGVjdGlvbkNoYW5nZSc6XG4gICAgICAgIGlmIChza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNBbmltYXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljQW5pbWF0aW9uRXZlbnQsIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDbGlwYm9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljQ2xpcGJvYXJkRXZlbnQsIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRm9jdXNFdmVudEludGVyZmFjZSA9IHtcbiAgcmVsYXRlZFRhcmdldDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRm9jdXNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRm9jdXNFdmVudCwgRm9jdXNFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogYGNoYXJDb2RlYCByZXByZXNlbnRzIHRoZSBhY3R1YWwgXCJjaGFyYWN0ZXIgY29kZVwiIGFuZCBpcyBzYWZlIHRvIHVzZSB3aXRoXG4gKiBgU3RyaW5nLmZyb21DaGFyQ29kZWAuIEFzIHN1Y2gsIG9ubHkga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gcHJpbnRhYmxlXG4gKiBjaGFyYWN0ZXJzIHByb2R1Y2UgYSB2YWxpZCBgY2hhckNvZGVgLCB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyBFbnRlci5cbiAqIFRoZSBUYWIta2V5IGlzIGNvbnNpZGVyZWQgbm9uLXByaW50YWJsZSBhbmQgZG9lcyBub3QgaGF2ZSBhIGBjaGFyQ29kZWAsXG4gKiBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgZG9lcyBub3QgcHJvZHVjZSBhIHRhYi1jaGFyYWN0ZXIgaW4gYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBOb3JtYWxpemVkIGBjaGFyQ29kZWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGNoYXJDb2RlO1xuICB2YXIga2V5Q29kZSA9IG5hdGl2ZUV2ZW50LmtleUNvZGU7XG5cbiAgaWYgKCdjaGFyQ29kZScgaW4gbmF0aXZlRXZlbnQpIHtcbiAgICBjaGFyQ29kZSA9IG5hdGl2ZUV2ZW50LmNoYXJDb2RlO1xuXG4gICAgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH1cblxuICAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gIEVzYzogJ0VzY2FwZScsXG4gIFNwYWNlYmFyOiAnICcsXG4gIExlZnQ6ICdBcnJvd0xlZnQnLFxuICBVcDogJ0Fycm93VXAnLFxuICBSaWdodDogJ0Fycm93UmlnaHQnLFxuICBEb3duOiAnQXJyb3dEb3duJyxcbiAgRGVsOiAnRGVsZXRlJyxcbiAgV2luOiAnT1MnLFxuICBNZW51OiAnQ29udGV4dE1lbnUnLFxuICBBcHBzOiAnQ29udGV4dE1lbnUnLFxuICBTY3JvbGw6ICdTY3JvbGxMb2NrJyxcbiAgTW96UHJpbnRhYmxlS2V5OiAnVW5pZGVudGlmaWVkJ1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcbiAqIE9ubHkgc3BlY2lhbCBrZXlzIHN1cHBvcnRlZCwgYWxsIG90aGVycyBkZXBlbmQgb24ga2V5Ym9hcmQgbGF5b3V0IG9yIGJyb3dzZXJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgJzgnOiAnQmFja3NwYWNlJyxcbiAgJzknOiAnVGFiJyxcbiAgJzEyJzogJ0NsZWFyJyxcbiAgJzEzJzogJ0VudGVyJyxcbiAgJzE2JzogJ1NoaWZ0JyxcbiAgJzE3JzogJ0NvbnRyb2wnLFxuICAnMTgnOiAnQWx0JyxcbiAgJzE5JzogJ1BhdXNlJyxcbiAgJzIwJzogJ0NhcHNMb2NrJyxcbiAgJzI3JzogJ0VzY2FwZScsXG4gICczMic6ICcgJyxcbiAgJzMzJzogJ1BhZ2VVcCcsXG4gICczNCc6ICdQYWdlRG93bicsXG4gICczNSc6ICdFbmQnLFxuICAnMzYnOiAnSG9tZScsXG4gICczNyc6ICdBcnJvd0xlZnQnLFxuICAnMzgnOiAnQXJyb3dVcCcsXG4gICczOSc6ICdBcnJvd1JpZ2h0JyxcbiAgJzQwJzogJ0Fycm93RG93bicsXG4gICc0NSc6ICdJbnNlcnQnLFxuICAnNDYnOiAnRGVsZXRlJyxcbiAgJzExMic6ICdGMScsXG4gICcxMTMnOiAnRjInLFxuICAnMTE0JzogJ0YzJyxcbiAgJzExNSc6ICdGNCcsXG4gICcxMTYnOiAnRjUnLFxuICAnMTE3JzogJ0Y2JyxcbiAgJzExOCc6ICdGNycsXG4gICcxMTknOiAnRjgnLFxuICAnMTIwJzogJ0Y5JyxcbiAgJzEyMSc6ICdGMTAnLFxuICAnMTIyJzogJ0YxMScsXG4gICcxMjMnOiAnRjEyJyxcbiAgJzE0NCc6ICdOdW1Mb2NrJyxcbiAgJzE0NSc6ICdTY3JvbGxMb2NrJyxcbiAgJzIyNCc6ICdNZXRhJ1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgIHZhciBjaGFyQ29kZSA9IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpO1xuXG4gICAgLy8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4gICAgLy8gdGh1cyBiZSBjYXB0dXJlZCBieSBga2V5cHJlc3NgLCBubyBvdGhlciBub24tcHJpbnRhYmxlIGtleSBzaG91bGQuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXG4gICAgLy8gYGtleUNvZGVgIHZhbHVlLCBhbG1vc3QgYWxsIGZ1bmN0aW9uIGtleXMgaGF2ZSBhIHVuaXZlcnNhbCB2YWx1ZS5cbiAgICByZXR1cm4gdHJhbnNsYXRlVG9LZXlbbmF0aXZlRXZlbnQua2V5Q29kZV0gfHwgJ1VuaWRlbnRpZmllZCc7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBrZXk6IGdldEV2ZW50S2V5LFxuICBsb2NhdGlvbjogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgcmVwZWF0OiBudWxsLFxuICBsb2NhbGU6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxuICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuXG4gICAgLy8gS2V5UHJlc3MgaXMgZGVwcmVjYXRlZCwgYnV0IGl0cyByZXBsYWNlbWVudCBpcyBub3QgeWV0IGZpbmFsIGFuZCBub3RcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBhbnkgbWFqb3IgYnJvd3Nlci4gT25seSBLZXlQcmVzcyBoYXMgY2hhckNvZGUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyBwaHlzaWNhbCBrZXlib2FyZCBrZXkuXG5cbiAgICAvLyBUaGUgYWN0dWFsIG1lYW5pbmcgb2YgdGhlIHZhbHVlIGRlcGVuZHMgb24gdGhlIHVzZXJzJyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyB3aGljaCBjYW5ub3QgYmUgZGV0ZWN0ZWQuIEFzc3VtaW5nIHRoYXQgaXQgaXMgYSBVUyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyBwcm92aWRlcyBhIHN1cnByaXNpbmdseSBhY2N1cmF0ZSBtYXBwaW5nIGZvciBVUyBhbmQgRXVyb3BlYW4gdXNlcnMuXG4gICAgLy8gRHVlIHRvIHRoaXMsIGl0IGlzIGxlZnQgdG8gdGhlIHVzZXIgdG8gaW1wbGVtZW50IGF0IHRoaXMgdGltZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0tleWJvYXJkRXZlbnQsIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRHJhZ0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIERyYWdFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YVRyYW5zZmVyOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNEcmFnRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0RyYWdFdmVudCwgRHJhZ0V2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFRvdWNoRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzL1xuICovXG52YXIgVG91Y2hFdmVudEludGVyZmFjZSA9IHtcbiAgdG91Y2hlczogbnVsbCxcbiAgdGFyZ2V0VG91Y2hlczogbnVsbCxcbiAgY2hhbmdlZFRvdWNoZXM6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVG91Y2hFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVG91Y2hFdmVudCwgVG91Y2hFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELWNzczMtdHJhbnNpdGlvbnMtMjAwOTAzMjAvI3RyYW5zaXRpb24tZXZlbnRzLVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNpdGlvbkV2ZW50XG4gKi9cbnZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHByb3BlcnR5TmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCwgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNXaGVlbEV2ZW50LCBXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqIGludG9cbiAqIGV2ZW50VHlwZXMgPSB7XG4gKiAgICdhYm9ydCc6IHtcbiAqICAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICogICAgICAgYnViYmxlZDogJ29uQWJvcnQnLFxuICogICAgICAgY2FwdHVyZWQ6ICdvbkFib3J0Q2FwdHVyZScsXG4gKiAgICAgfSxcbiAqICAgICBkZXBlbmRlbmNpZXM6IFsndG9wQWJvcnQnXSxcbiAqICAgfSxcbiAqICAgLi4uXG4gKiB9O1xuICogdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICogICAndG9wQWJvcnQnOiB7IHNhbWVDb25maWcgfVxuICogfTtcbiAqL1xudmFyIGV2ZW50VHlwZXMkNCA9IHt9O1xudmFyIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHt9O1xuWydhYm9ydCcsICdhbmltYXRpb25FbmQnLCAnYW5pbWF0aW9uSXRlcmF0aW9uJywgJ2FuaW1hdGlvblN0YXJ0JywgJ2JsdXInLCAnY2FuY2VsJywgJ2NhblBsYXknLCAnY2FuUGxheVRocm91Z2gnLCAnY2xpY2snLCAnY2xvc2UnLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjdXQnLCAnZG91YmxlQ2xpY2snLCAnZHJhZycsICdkcmFnRW5kJywgJ2RyYWdFbnRlcicsICdkcmFnRXhpdCcsICdkcmFnTGVhdmUnLCAnZHJhZ092ZXInLCAnZHJhZ1N0YXJ0JywgJ2Ryb3AnLCAnZHVyYXRpb25DaGFuZ2UnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5kZWQnLCAnZXJyb3InLCAnZm9jdXMnLCAnaW5wdXQnLCAnaW52YWxpZCcsICdrZXlEb3duJywgJ2tleVByZXNzJywgJ2tleVVwJywgJ2xvYWQnLCAnbG9hZGVkRGF0YScsICdsb2FkZWRNZXRhZGF0YScsICdsb2FkU3RhcnQnLCAnbW91c2VEb3duJywgJ21vdXNlTW92ZScsICdtb3VzZU91dCcsICdtb3VzZU92ZXInLCAnbW91c2VVcCcsICdwYXN0ZScsICdwYXVzZScsICdwbGF5JywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAncmF0ZUNoYW5nZScsICdyZXNldCcsICdzY3JvbGwnLCAnc2Vla2VkJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdWJtaXQnLCAnc3VzcGVuZCcsICd0aW1lVXBkYXRlJywgJ3RvZ2dsZScsICd0b3VjaENhbmNlbCcsICd0b3VjaEVuZCcsICd0b3VjaE1vdmUnLCAndG91Y2hTdGFydCcsICd0cmFuc2l0aW9uRW5kJywgJ3ZvbHVtZUNoYW5nZScsICd3YWl0aW5nJywgJ3doZWVsJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIGNhcGl0YWxpemVkRXZlbnQgPSBldmVudFswXS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc2xpY2UoMSk7XG4gIHZhciBvbkV2ZW50ID0gJ29uJyArIGNhcGl0YWxpemVkRXZlbnQ7XG4gIHZhciB0b3BFdmVudCA9ICd0b3AnICsgY2FwaXRhbGl6ZWRFdmVudDtcblxuICB2YXIgdHlwZSA9IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogb25FdmVudCxcbiAgICAgIGNhcHR1cmVkOiBvbkV2ZW50ICsgJ0NhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BFdmVudF1cbiAgfTtcbiAgZXZlbnRUeXBlcyQ0W2V2ZW50XSA9IHR5cGU7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BFdmVudF0gPSB0eXBlO1xufSk7XG5cbi8vIE9ubHkgdXNlZCBpbiBERVYgZm9yIGV4aGF1c3RpdmVuZXNzIHZhbGlkYXRpb24uXG52YXIga25vd25IVE1MVG9wTGV2ZWxUeXBlcyA9IFsndG9wQWJvcnQnLCAndG9wQ2FuY2VsJywgJ3RvcENhblBsYXknLCAndG9wQ2FuUGxheVRocm91Z2gnLCAndG9wQ2xvc2UnLCAndG9wRHVyYXRpb25DaGFuZ2UnLCAndG9wRW1wdGllZCcsICd0b3BFbmNyeXB0ZWQnLCAndG9wRW5kZWQnLCAndG9wRXJyb3InLCAndG9wSW5wdXQnLCAndG9wSW52YWxpZCcsICd0b3BMb2FkJywgJ3RvcExvYWRlZERhdGEnLCAndG9wTG9hZGVkTWV0YWRhdGEnLCAndG9wTG9hZFN0YXJ0JywgJ3RvcFBhdXNlJywgJ3RvcFBsYXknLCAndG9wUGxheWluZycsICd0b3BQcm9ncmVzcycsICd0b3BSYXRlQ2hhbmdlJywgJ3RvcFJlc2V0JywgJ3RvcFNlZWtlZCcsICd0b3BTZWVraW5nJywgJ3RvcFN0YWxsZWQnLCAndG9wU3VibWl0JywgJ3RvcFN1c3BlbmQnLCAndG9wVGltZVVwZGF0ZScsICd0b3BUb2dnbGUnLCAndG9wVm9sdW1lQ2hhbmdlJywgJ3RvcFdhaXRpbmcnXTtcblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDQsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV07XG4gICAgaWYgKCFkaXNwYXRjaENvbmZpZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBFdmVudENvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGtleXByZXNzIGV2ZW50IGZvciBmdW5jdGlvbiBrZXlzIHRvby4gVGhpcyByZW1vdmVzXG4gICAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAgIC8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG4gICAgICAgIGlmIChnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQmx1cic6XG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENsaWNrJzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAgIC8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BEb3VibGVDbGljayc6XG4gICAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgICAgY2FzZSAndG9wTW91c2VNb3ZlJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlVXAnOlxuICAgICAgLy8gVE9ETzogRGlzYWJsZWQgZWxlbWVudHMgc2hvdWxkIG5vdCByZXNwb25kIHRvIG1vdXNlIGV2ZW50c1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wTW91c2VPdXQnOlxuICAgICAgY2FzZSAndG9wTW91c2VPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcENvbnRleHRNZW51JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wRHJhZyc6XG4gICAgICBjYXNlICd0b3BEcmFnRW5kJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFbnRlcic6XG4gICAgICBjYXNlICd0b3BEcmFnRXhpdCc6XG4gICAgICBjYXNlICd0b3BEcmFnTGVhdmUnOlxuICAgICAgY2FzZSAndG9wRHJhZ092ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ1N0YXJ0JzpcbiAgICAgIGNhc2UgJ3RvcERyb3AnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFRvdWNoQ2FuY2VsJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoRW5kJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoTW92ZSc6XG4gICAgICBjYXNlICd0b3BUb3VjaFN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uRW5kJzpcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvbkl0ZXJhdGlvbic6XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25TdGFydCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BUcmFuc2l0aW9uRW5kJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BTY3JvbGwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVUlFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BXaGVlbCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENvcHknOlxuICAgICAgY2FzZSAndG9wQ3V0JzpcbiAgICAgIGNhc2UgJ3RvcFBhc3RlJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoa25vd25IVE1MVG9wTGV2ZWxUeXBlcy5pbmRleE9mKHRvcExldmVsVHlwZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnU2ltcGxlRXZlbnRQbHVnaW46IFVuaGFuZGxlZCBldmVudCB0eXBlLCBgJXNgLiBUaGlzIHdhcm5pbmcgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCB0b3BMZXZlbFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50JDE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbn07XG5cbnNldEhhbmRsZVRvcExldmVsKGhhbmRsZVRvcExldmVsKTtcblxuLyoqXG4gKiBJbmplY3QgbW9kdWxlcyBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqL1xuaW5qZWN0aW9uJDEuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihET01FdmVudFBsdWdpbk9yZGVyKTtcbmluamVjdGlvbiQyLmluamVjdENvbXBvbmVudFRyZWUoUmVhY3RET01Db21wb25lbnRUcmVlKTtcblxuLyoqXG4gKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAqIHRoZW0pLlxuICovXG5pbmplY3Rpb24kMS5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoe1xuICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLFxuICBDaGFuZ2VFdmVudFBsdWdpbjogQ2hhbmdlRXZlbnRQbHVnaW4sXG4gIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpblxufSk7XG5cbnZhciBlbmFibGVBc3luY1N1YnRyZWVBUEkgPSB0cnVlO1xudmFyIGVuYWJsZUFzeW5jU2NoZWR1bGluZ0J5RGVmYXVsdEluUmVhY3RET00gPSBmYWxzZTtcbi8vIEV4cG9ydHMgUmVhY3RET00uY3JlYXRlUm9vdFxudmFyIGVuYWJsZUNyZWF0ZVJvb3QgPSBmYWxzZTtcbnZhciBlbmFibGVVc2VyVGltaW5nQVBJID0gdHJ1ZTtcblxuLy8gTXV0YXRpbmcgbW9kZSAoUmVhY3QgRE9NLCBSZWFjdCBBUlQsIFJlYWN0IE5hdGl2ZSk6XG52YXIgZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyID0gdHJ1ZTtcbi8vIEV4cGVyaW1lbnRhbCBub29wIG1vZGUgKGN1cnJlbnRseSB1bnVzZWQpOlxudmFyIGVuYWJsZU5vb3BSZWNvbmNpbGVyID0gZmFsc2U7XG4vLyBFeHBlcmltZW50YWwgcGVyc2lzdGVudCBtb2RlIChDUyk6XG52YXIgZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgPSBmYWxzZTtcblxuLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIGJlZ2luLXBoYXNlIGxpZmVjeWNsZSBob29rcyBhbmQgc2V0U3RhdGUgcmVkdWNlcnM6XG52YXIgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzID0gZmFsc2U7XG5cbi8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xuXG57XG4gIHZhciBmaWJlclN0YWNrID0gW107XG59XG5cbnZhciBpbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjcmVhdGVDdXJzb3IoZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogZGVmYXVsdFZhbHVlXG4gIH07XG59XG5cblxuXG5mdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1VuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWVTdGFja1tpbmRleF07XG5cbiAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gIH1cblxuICBpbmRleC0tO1xufVxuXG5mdW5jdGlvbiBwdXNoKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gIGluZGV4Kys7XG5cbiAgdmFsdWVTdGFja1tpbmRleF0gPSBjdXJzb3IuY3VycmVudDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBmaWJlcjtcbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0JDEoKSB7XG4gIHdoaWxlIChpbmRleCA+IC0xKSB7XG4gICAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gICAge1xuICAgICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICAgIH1cblxuICAgIGluZGV4LS07XG4gIH1cbn1cblxudmFyIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyAoc291cmNlID8gJyAoYXQgJyArIHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJykgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJyA6IG93bmVyTmFtZSA/ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJyA6ICcnKTtcbn07XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgICB2YXIgc291cmNlID0gZmliZXIuX2RlYnVnU291cmNlO1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKTtcbiAgICAgIHZhciBvd25lck5hbWUgPSBudWxsO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIG93bmVyTmFtZSA9IGdldENvbXBvbmVudE5hbWUob3duZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lck5hbWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIgYW5kXG4vLyBvbmx5IGR1cmluZyBiZWdpbiBvciBjb21wbGV0ZSBwaGFzZS4gRG8gbm90IGNhbGwgaXQgdW5kZXIgYW55IG90aGVyXG4vLyBjaXJjdW1zdGFuY2VzLlxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcih3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaW5mbyA9ICcnO1xuICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuICBkbyB7XG4gICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKG5vZGUpO1xuICAgIC8vIE90aGVyd2lzZSB0aGlzIHJldHVybiBwb2ludGVyIG1pZ2h0IHBvaW50IHRvIHRoZSB3cm9uZyB0cmVlOlxuICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgfSB3aGlsZSAobm9kZSk7XG4gIHJldHVybiBpbmZvO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWUoKSB7XG4gIHtcbiAgICB2YXIgZmliZXIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQ7XG4gICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIHR5cGVvZiBvd25lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKG93bmVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0oKSB7XG4gIHtcbiAgICB2YXIgZmliZXIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQ7XG4gICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gU2FmZSBiZWNhdXNlIGlmIGN1cnJlbnQgZmliZXIgZXhpc3RzLCB3ZSBhcmUgcmVjb25jaWxpbmcsXG4gICAgLy8gYW5kIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdmVyc2lvbi5cbiAgICByZXR1cm4gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcihmaWJlcik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q3VycmVudEZpYmVyKCkge1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCA9IG51bGw7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50RmliZXIoZmliZXIpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBmaWJlcjtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRQaGFzZShwaGFzZSkge1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gcGhhc2U7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZpYmVyID0ge1xuICBjdXJyZW50OiBudWxsLFxuICBwaGFzZTogbnVsbCxcbiAgcmVzZXRDdXJyZW50RmliZXI6IHJlc2V0Q3VycmVudEZpYmVyLFxuICBzZXRDdXJyZW50RmliZXI6IHNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudFBoYXNlOiBzZXRDdXJyZW50UGhhc2UsXG4gIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZTogZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lLFxuICBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtOiBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtXG59O1xuXG4vLyBQcmVmaXggbWVhc3VyZW1lbnRzIHNvIHRoYXQgaXQncyBwb3NzaWJsZSB0byBmaWx0ZXIgdGhlbS5cbi8vIExvbmdlciBwcmVmaXhlcyBhcmUgaGFyZCB0byByZWFkIGluIERldlRvb2xzLlxudmFyIHJlYWN0RW1vamkgPSAnXFx1MjY5Qic7XG52YXIgd2FybmluZ0Vtb2ppID0gJ1xcdTI2RDQnO1xudmFyIHN1cHBvcnRzVXNlclRpbWluZyA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMgPT09ICdmdW5jdGlvbic7XG5cbi8vIEtlZXAgdHJhY2sgb2YgY3VycmVudCBmaWJlciBzbyB0aGF0IHdlIGtub3cgdGhlIHBhdGggdG8gdW53aW5kIG9uIHBhdXNlLlxuLy8gVE9ETzogdGhpcyBsb29rcyB0aGUgc2FtZSBhcyBuZXh0VW5pdE9mV29yayBpbiBzY2hlZHVsZXIuIENhbiB3ZSB1bmlmeSB0aGVtP1xudmFyIGN1cnJlbnRGaWJlciA9IG51bGw7XG4vLyBJZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIHVzZXIgY29kZSwgd2hpY2ggZmliZXIgYW5kIG1ldGhvZCBpcyBpdD9cbi8vIFJldXNpbmcgYGN1cnJlbnRGaWJlcmAgd291bGQgYmUgY29uZnVzaW5nIGZvciB0aGlzIGJlY2F1c2UgdXNlciBjb2RlIGZpYmVyXG4vLyBjYW4gY2hhbmdlIGR1cmluZyBjb21taXQgcGhhc2UgdG9vLCBidXQgd2UgZG9uJ3QgbmVlZCB0byB1bndpbmQgaXQgKHNpbmNlXG4vLyBsaWZlY3ljbGVzIGluIHRoZSBjb21taXQgcGhhc2UgZG9uJ3QgcmVzZW1ibGUgYSB0cmVlKS5cbnZhciBjdXJyZW50UGhhc2UgPSBudWxsO1xudmFyIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbi8vIERpZCBsaWZlY3ljbGUgaG9vayBzY2hlZHVsZSBhbiB1cGRhdGU/IFRoaXMgaXMgb2Z0ZW4gYSBwZXJmb3JtYW5jZSBwcm9ibGVtLFxuLy8gc28gd2Ugd2lsbCBrZWVwIHRyYWNrIG9mIGl0LCBhbmQgaW5jbHVkZSBpdCBpbiB0aGUgcmVwb3J0LlxuLy8gVHJhY2sgY29tbWl0cyBjYXVzZWQgYnkgY2FzY2FkaW5nIHVwZGF0ZXMuXG52YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbnZhciBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbnZhciBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG52YXIgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbi8vIER1cmluZyBjb21taXRzLCB3ZSBvbmx5IHNob3cgYSBtZWFzdXJlbWVudCBvbmNlIHBlciBtZXRob2QgbmFtZVxuLy8gdG8gYXZvaWQgc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIHdpdGggbWVhc3VyZW1lbnQgb3ZlcmhlYWQuXG52YXIgbGFiZWxzSW5DdXJyZW50Q29tbWl0ID0gbmV3IFNldCgpO1xuXG52YXIgZm9ybWF0TWFya05hbWUgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcmV0dXJuIHJlYWN0RW1vamkgKyAnICcgKyBtYXJrTmFtZTtcbn07XG5cbnZhciBmb3JtYXRMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCwgd2FybmluZyQkMSkge1xuICB2YXIgcHJlZml4ID0gd2FybmluZyQkMSA/IHdhcm5pbmdFbW9qaSArICcgJyA6IHJlYWN0RW1vamkgKyAnICc7XG4gIHZhciBzdWZmaXggPSB3YXJuaW5nJCQxID8gJyBXYXJuaW5nOiAnICsgd2FybmluZyQkMSA6ICcnO1xuICByZXR1cm4gJycgKyBwcmVmaXggKyBsYWJlbCArIHN1ZmZpeDtcbn07XG5cbnZhciBiZWdpbk1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UubWFyayhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGNsZWFyTWFyayA9IGZ1bmN0aW9uIChtYXJrTmFtZSkge1xuICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKSk7XG59O1xuXG52YXIgZW5kTWFyayA9IGZ1bmN0aW9uIChsYWJlbCwgbWFya05hbWUsIHdhcm5pbmckJDEpIHtcbiAgdmFyIGZvcm1hdHRlZE1hcmtOYW1lID0gZm9ybWF0TWFya05hbWUobWFya05hbWUpO1xuICB2YXIgZm9ybWF0dGVkTGFiZWwgPSBmb3JtYXRMYWJlbChsYWJlbCwgd2FybmluZyQkMSk7XG4gIHRyeSB7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZShmb3JtYXR0ZWRMYWJlbCwgZm9ybWF0dGVkTWFya05hbWUpO1xuICB9IGNhdGNoIChlcnIpIHt9XG4gIC8vIElmIHByZXZpb3VzIG1hcmsgd2FzIG1pc3NpbmcgZm9yIHNvbWUgcmVhc29uLCB0aGlzIHdpbGwgdGhyb3cuXG4gIC8vIFRoaXMgY291bGQgb25seSBoYXBwZW4gaWYgUmVhY3QgY3Jhc2hlZCBpbiBhbiB1bmV4cGVjdGVkIHBsYWNlIGVhcmxpZXIuXG4gIC8vIERvbid0IHBpbGUgb24gd2l0aCBtb3JlIGVycm9ycy5cblxuICAvLyBDbGVhciBtYXJrcyBpbW1lZGlhdGVseSB0byBhdm9pZCBncm93aW5nIGJ1ZmZlci5cbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXR0ZWRNYXJrTmFtZSk7XG4gIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMoZm9ybWF0dGVkTGFiZWwpO1xufTtcblxudmFyIGdldEZpYmVyTWFya05hbWUgPSBmdW5jdGlvbiAobGFiZWwsIGRlYnVnSUQpIHtcbiAgcmV0dXJuIGxhYmVsICsgJyAoIycgKyBkZWJ1Z0lEICsgJyknO1xufTtcblxudmFyIGdldEZpYmVyTGFiZWwgPSBmdW5jdGlvbiAoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSkge1xuICBpZiAocGhhc2UgPT09IG51bGwpIHtcbiAgICAvLyBUaGVzZSBhcmUgY29tcG9zaXRlIGNvbXBvbmVudCB0b3RhbCB0aW1lIG1lYXN1cmVtZW50cy5cbiAgICByZXR1cm4gY29tcG9uZW50TmFtZSArICcgWycgKyAoaXNNb3VudGVkID8gJ3VwZGF0ZScgOiAnbW91bnQnKSArICddJztcbiAgfSBlbHNlIHtcbiAgICAvLyBDb21wb3NpdGUgY29tcG9uZW50IG1ldGhvZHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnLicgKyBwaGFzZTtcbiAgfVxufTtcblxudmFyIGJlZ2luRmliZXJNYXJrID0gZnVuY3Rpb24gKGZpYmVyLCBwaGFzZSkge1xuICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcbiAgdmFyIGRlYnVnSUQgPSBmaWJlci5fZGVidWdJRDtcbiAgdmFyIGlzTW91bnRlZCA9IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbDtcbiAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcblxuICBpZiAoaXNDb21taXR0aW5nICYmIGxhYmVsc0luQ3VycmVudENvbW1pdC5oYXMobGFiZWwpKSB7XG4gICAgLy8gRHVyaW5nIHRoZSBjb21taXQgcGhhc2UsIHdlIGRvbid0IHNob3cgZHVwbGljYXRlIGxhYmVscyBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgYSBmaXhlZCBvdmVyaGVhZCBmb3IgZXZlcnkgbWVhc3VyZW1lbnQsIGFuZCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgdG8gc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIGJleW9uZCBuZWNlc3NhcnkuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxhYmVsc0luQ3VycmVudENvbW1pdC5hZGQobGFiZWwpO1xuXG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBiZWdpbk1hcmsobWFya05hbWUpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBjbGVhckZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBjbGVhck1hcmsobWFya05hbWUpO1xufTtcblxudmFyIGVuZEZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UsIHdhcm5pbmckJDEpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBlbmRNYXJrKGxhYmVsLCBtYXJrTmFtZSwgd2FybmluZyQkMSk7XG59O1xuXG52YXIgc2hvdWxkSWdub3JlRmliZXIgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgLy8gSG9zdCBjb21wb25lbnRzIHNob3VsZCBiZSBza2lwcGVkIGluIHRoZSB0aW1lbGluZS5cbiAgLy8gV2UgY291bGQgY2hlY2sgdHlwZW9mIGZpYmVyLnR5cGUsIGJ1dCBkb2VzIHRoaXMgd29yayB3aXRoIFJOP1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgIGNsZWFyRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UpO1xuICB9XG4gIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbn07XG5cbnZhciBwYXVzZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gU3RvcHMgYWxsIGN1cnJlbnRseSBhY3RpdmUgbWVhc3VyZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVzdW1lZFxuICAvLyBpZiB3ZSBjb250aW51ZSBpbiBhIGxhdGVyIGRlZmVycmVkIGxvb3AgZnJvbSB0aGUgc2FtZSB1bml0IG9mIHdvcmsuXG4gIHZhciBmaWJlciA9IGN1cnJlbnRGaWJlcjtcbiAgd2hpbGUgKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBmaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIGlmIChmaWJlclsncmV0dXJuJ10gIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShmaWJlclsncmV0dXJuJ10pO1xuICB9XG4gIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgIGJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVzdW1lcyBhbGwgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBhY3RpdmUgZHVyaW5nIHRoZSBsYXN0IGRlZmVycmVkIGxvb3AuXG4gIGlmIChjdXJyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShjdXJyZW50RmliZXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWNvcmRFZmZlY3QoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQrKztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxNb3VudCcgJiYgY3VycmVudFBoYXNlICE9PSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRSZXF1ZXN0Q2FsbGJhY2tUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nICYmICFpc1dhaXRpbmdGb3JDYWxsYmFjaykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgYmVnaW5NYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BSZXF1ZXN0Q2FsbGJhY2tUaW1lcihkaWRFeHBpcmUpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICBpc1dhaXRpbmdGb3JDYWxsYmFjayA9IGZhbHNlO1xuICAgICAgdmFyIHdhcm5pbmckJDEgPSBkaWRFeHBpcmUgPyAnUmVhY3Qgd2FzIGJsb2NrZWQgYnkgbWFpbiB0aHJlYWQnIDogbnVsbDtcbiAgICAgIGVuZE1hcmsoJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiknLCAnKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uKScsIHdhcm5pbmckJDEpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgdGhpcyBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXI7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbmNlbFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZW1lbWJlciB3ZSBzaG91bGRuJ3QgY29tcGxldGUgbWVhc3VyZW1lbnQgZm9yIHRoaXMgZmliZXIuXG4gICAgLy8gT3RoZXJ3aXNlIGZsYW1lY2hhcnQgd2lsbCBiZSBkZWVwIGV2ZW4gZm9yIHNtYWxsIHVwZGF0ZXMuXG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBjbGVhckZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgaXRzIHBhcmVudCBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXJbJ3JldHVybiddO1xuICAgIGlmICghZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BGYWlsZWRXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgdmFyIHdhcm5pbmckJDEgPSAnQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgdGhpcyBlcnJvciBib3VuZGFyeSc7XG4gICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFBoYXNlVGltZXIoZmliZXIsIHBoYXNlKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCgpO1xuICAgIGlmICghYmVnaW5GaWJlck1hcmsoZmliZXIsIHBoYXNlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdXJyZW50UGhhc2VGaWJlciA9IGZpYmVyO1xuICAgIGN1cnJlbnRQaGFzZSA9IHBoYXNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BQaGFzZVRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciB3YXJuaW5nJCQxID0gaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPyAnU2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZScgOiBudWxsO1xuICAgICAgZW5kRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UsIHdhcm5pbmckJDEpO1xuICAgIH1cbiAgICBjdXJyZW50UGhhc2UgPSBudWxsO1xuICAgIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFdvcmtMb29wVGltZXIobmV4dFVuaXRPZldvcmspIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBjdXJyZW50RmliZXIgPSBuZXh0VW5pdE9mV29yaztcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbiAgICAvLyBUaGlzIGlzIHRvcCBsZXZlbCBjYWxsLlxuICAgIC8vIEFueSBvdGhlciBtZWFzdXJlbWVudHMgYXJlIHBlcmZvcm1lZCB3aXRoaW4uXG4gICAgYmVnaW5NYXJrKCcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbiknKTtcbiAgICAvLyBSZXN1bWUgYW55IG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgaW4gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBsYXN0IGxvb3AuXG4gICAgcmVzdW1lVGltZXJzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB3YXJuaW5nJCQxID0gbnVsbDtcbiAgICBpZiAoaW50ZXJydXB0ZWRCeSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGludGVycnVwdGVkQnkudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0EgdG9wLWxldmVsIHVwZGF0ZSBpbnRlcnJ1cHRlZCB0aGUgcHJldmlvdXMgcmVuZGVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShpbnRlcnJ1cHRlZEJ5KSB8fCAnVW5rbm93bic7XG4gICAgICAgIHdhcm5pbmckJDEgPSAnQW4gdXBkYXRlIHRvICcgKyBjb21wb25lbnROYW1lICsgJyBpbnRlcnJ1cHRlZCB0aGUgcHJldmlvdXMgcmVuZGVyJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPiAxKSB7XG4gICAgICB3YXJuaW5nJCQxID0gJ1RoZXJlIHdlcmUgY2FzY2FkaW5nIHVwZGF0ZXMnO1xuICAgIH1cbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbiAgICAvLyBQYXVzZSBhbnkgbWVhc3VyZW1lbnRzIHVudGlsIHRoZSBuZXh0IGxvb3AuXG4gICAgcGF1c2VUaW1lcnMoKTtcbiAgICBlbmRNYXJrKCcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbiknLCAnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJywgd2FybmluZyQkMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc0NvbW1pdHRpbmcgPSB0cnVlO1xuICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCkge1xuICAgICAgd2FybmluZyQkMSA9ICdMaWZlY3ljbGUgaG9vayBzY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJztcbiAgICB9IGVsc2UgaWYgKGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPiAwKSB7XG4gICAgICB3YXJuaW5nJCQxID0gJ0NhdXNlZCBieSBhIGNhc2NhZGluZyB1cGRhdGUgaW4gZWFybGllciBjb21taXQnO1xuICAgIH1cbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wKys7XG4gICAgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gICAgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmNsZWFyKCk7XG5cbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBDaGFuZ2VzKScsICcoQ29tbWl0dGluZyBDaGFuZ2VzKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0czogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknLCBudWxsKTtcbiAgfVxufVxuXG57XG4gIHZhciB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxuLy8gQSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgbWVyZ2VkIGNvbnRleHQgb2JqZWN0IG9uIHRoZSBzdGFjay5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZW1wdHlPYmplY3QpO1xuLy8gQSBjdXJzb3IgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29udGV4dCBoYXMgY2hhbmdlZC5cbnZhciBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGZhbHNlKTtcbi8vIEtlZXAgdHJhY2sgb2YgdGhlIHByZXZpb3VzIGNvbnRleHQgb2JqZWN0IHRoYXQgd2FzIG9uIHRoZSBzdGFjay5cbi8vIFdlIHVzZSB0aGlzIHRvIGdldCBhY2Nlc3MgdG8gdGhlIHBhcmVudCBjb250ZXh0IGFmdGVyIHdlIGhhdmUgYWxyZWFkeVxuLy8gcHVzaGVkIHRoZSBuZXh0IGNvbnRleHQgcHJvdmlkZXIsIGFuZCBub3cgbmVlZCB0byBtZXJnZSB0aGVpciBjb250ZXh0cy5cbnZhciBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcblxuZnVuY3Rpb24gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBoYXNPd25Db250ZXh0ID0gaXNDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICBpZiAoaGFzT3duQ29udGV4dCkge1xuICAgIC8vIElmIHRoZSBmaWJlciBpcyBhIGNvbnRleHQgcHJvdmlkZXIgaXRzZWxmLCB3aGVuIHdlIHJlYWQgaXRzIGNvbnRleHRcbiAgICAvLyB3ZSBoYXZlIGFscmVhZHkgcHVzaGVkIGl0cyBvd24gY2hpbGQgY29udGV4dCBvbiB0aGUgc3RhY2suIEEgY29udGV4dFxuICAgIC8vIHByb3ZpZGVyIHNob3VsZCBub3QgXCJzZWVcIiBpdHMgb3duIGNoaWxkIGNvbnRleHQuIFRoZXJlZm9yZSB3ZSByZWFkIHRoZVxuICAgIC8vIHByZXZpb3VzIChwYXJlbnQpIGNvbnRleHQgaW5zdGVhZCBmb3IgYSBjb250ZXh0IHByb3ZpZGVyLlxuICAgIHJldHVybiBwcmV2aW91c0NvbnRleHQ7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgbWFza2VkQ29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0ID0gbWFza2VkQ29udGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIC8vIEF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIHVubWFza2VkIGNvbnRleHQgaGFzIGNoYW5nZWQuXG4gIC8vIEZhaWxpbmcgdG8gZG8gdGhpcyB3aWxsIHJlc3VsdCBpbiB1bm5lY2Vzc2FyeSBjYWxscyB0byBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLlxuICAvLyBUaGlzIG1heSB0cmlnZ2VyIGluZmluaXRlIGxvb3BzIGlmIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgY2FsbHMgc2V0U3RhdGUuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPT09IHVubWFza2VkQ29udGV4dCkge1xuICAgIHJldHVybiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge307XG4gIGZvciAodmFyIGtleSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcbiAgfVxuXG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJztcbiAgICBjaGVja1Byb3BUeXBlcyhjb250ZXh0VHlwZXMsIGNvbnRleHQsICdjb250ZXh0JywgbmFtZSwgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKTtcbiAgfVxuXG4gIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGJlZm9yZSB0aGUgY2xhc3MgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCBzbyBjaGVjayBmb3IgaW5zdGFuY2UuXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAgcmV0dXJuIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgJiYgZmliZXIudHlwZS5jb250ZXh0VHlwZXMgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgJiYgZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyAhPSBudWxsO1xufVxuXG5mdW5jdGlvbiBwb3BDb250ZXh0UHJvdmlkZXIoZmliZXIpIHtcbiAgaWYgKCFpc0NvbnRleHRQcm92aWRlcihmaWJlcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlcikge1xuICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsIGNvbnRleHQsIGRpZENoYW5nZSkge1xuICAhKGNvbnRleHRTdGFja0N1cnNvci5jdXJzb3IgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIGNvbnRleHQgZm91bmQgb24gc3RhY2suIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgcGFyZW50Q29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgLy8gVE9ETyAoYnZhdWdobikgUmVwbGFjZSB0aGlzIGJlaGF2aW9yIHdpdGggYW4gaW52YXJpYW50KCkgaW4gdGhlIGZ1dHVyZS5cbiAgLy8gSXQgaGFzIG9ubHkgYmVlbiBhZGRlZCBpbiBGaWJlciB0byBtYXRjaCB0aGUgKHVuaW50ZW50aW9uYWwpIGJlaGF2aW9yIGluIFN0YWNrLlxuICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIXdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY2hpbGRDb250ZXh0VHlwZXMgaXMgc3BlY2lmaWVkIGJ1dCB0aGVyZSBpcyBubyBnZXRDaGlsZENvbnRleHQoKSBtZXRob2QgJyArICdvbiB0aGUgaW5zdGFuY2UuIFlvdSBjYW4gZWl0aGVyIGRlZmluZSBnZXRDaGlsZENvbnRleHQoKSBvbiAlcyBvciByZW1vdmUgJyArICdjaGlsZENvbnRleHRUeXBlcyBmcm9tIGl0LicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Q29udGV4dDtcbiAgfVxuXG4gIHZhciBjaGlsZENvbnRleHQgPSB2b2lkIDA7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gIH1cbiAgc3RhcnRQaGFzZVRpbWVyKGZpYmVyLCAnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuICBzdG9wUGhhc2VUaW1lcigpO1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gIH1cbiAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAhKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nLCBjb250ZXh0S2V5KSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkIGNvbnRleHQnLCBuYW1lLFxuICAgIC8vIEluIHByYWN0aWNlLCB0aGVyZSBpcyBvbmUgY2FzZSBpbiB3aGljaCB3ZSB3b24ndCBnZXQgYSBzdGFjay4gSXQncyB3aGVuXG4gICAgLy8gc29tZWJvZHkgY2FsbHMgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIoKSBhbmQgd2UgcHJvY2Vzc1xuICAgIC8vIGNvbnRleHQgZnJvbSB0aGUgcGFyZW50IGNvbXBvbmVudCBpbnN0YW5jZS4gVGhlIHN0YWNrIHdpbGwgYmUgbWlzc2luZ1xuICAgIC8vIGJlY2F1c2UgaXQncyBvdXRzaWRlIG9mIHRoZSByZWNvbmNpbGlhdGlvbiwgYW5kIHNvIHRoZSBwb2ludGVyIGhhcyBub3RcbiAgICAvLyBiZWVuIHNldC4gVGhpcyBpcyByYXJlIGFuZCBkb2Vzbid0IG1hdHRlci4gV2UnbGwgYWxzbyByZW1vdmUgdGhhdCBBUEkuXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKTtcbiAgfVxuXG4gIHJldHVybiBfYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSB7XG4gIGlmICghaXNDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAvLyBXZSBwdXNoIHRoZSBjb250ZXh0IGFzIGVhcmx5IGFzIHBvc3NpYmxlIHRvIGVuc3VyZSBzdGFjayBpbnRlZ3JpdHkuXG4gIC8vIElmIHRoZSBpbnN0YW5jZSBkb2VzIG5vdCBleGlzdCB5ZXQsIHdlIHdpbGwgcHVzaCBudWxsIGF0IGZpcnN0LFxuICAvLyBhbmQgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgbGF0ZXIgd2hlbiBpbnZhbGlkYXRpbmcgdGhlIGNvbnRleHQuXG4gIHZhciBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIFJlbWVtYmVyIHRoZSBwYXJlbnQgY29udGV4dCBzbyB3ZSBjYW4gbWVyZ2Ugd2l0aCBpdCBsYXRlci5cbiAgLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGlkLXBlcmZvcm0td29yayB2YWx1ZSB0byBhdm9pZCBpbmFkdmVydGVudGx5IGJsb2NraW5nIHVwZGF0ZXMuXG4gIHByZXZpb3VzQ29udGV4dCA9IGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgZGlkQ2hhbmdlKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgIWluc3RhbmNlID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gaGF2ZSBhbiBpbnN0YW5jZSBieSB0aGlzIHBvaW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAvLyBNZXJnZSBwYXJlbnQgYW5kIG93biBjb250ZXh0LlxuICAgIC8vIFNraXAgdGhpcyBpZiB3ZSdyZSBub3QgdXBkYXRpbmcgZHVlIHRvIHNDVS5cbiAgICAvLyBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyaWx5IHJlY29tcHV0aW5nIG1lbW9pemVkIHZhbHVlcy5cbiAgICB2YXIgbWVyZ2VkQ29udGV4dCA9IHByb2Nlc3NDaGlsZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHByZXZpb3VzQ29udGV4dCk7XG4gICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBtZXJnZWRDb250ZXh0O1xuXG4gICAgLy8gUmVwbGFjZSB0aGUgb2xkIChvciBlbXB0eSkgY29udGV4dCB3aXRoIHRoZSBuZXcgb25lLlxuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byB1bndpbmQgdGhlIGNvbnRleHQgaW4gdGhlIHJldmVyc2Ugb3JkZXIuXG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgLy8gTm93IHB1c2ggdGhlIG5ldyBjb250ZXh0IGFuZCBtYXJrIHRoYXQgaXQgaGFzIGNoYW5nZWQuXG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lcmdlZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICB9IGVsc2Uge1xuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldENvbnRleHQoKSB7XG4gIHByZXZpb3VzQ29udGV4dCA9IGVtcHR5T2JqZWN0O1xuICBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCA9IGVtcHR5T2JqZWN0O1xuICBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpIHtcbiAgLy8gQ3VycmVudGx5IHRoaXMgaXMgb25seSB1c2VkIHdpdGggcmVuZGVyU3VidHJlZUludG9Db250YWluZXI7IG5vdCBzdXJlIGlmIGl0XG4gIC8vIG1ha2VzIHNlbnNlIGVsc2V3aGVyZVxuICAhKGlzRmliZXJNb3VudGVkKGZpYmVyKSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHN1YnRyZWUgcGFyZW50IHRvIGJlIGEgbW91bnRlZCBjbGFzcyBjb21wb25lbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gbm9kZVsncmV0dXJuJ107XG4gICAgIXBhcmVudCA/IGludmFyaWFudChmYWxzZSwgJ0ZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgbm9kZSA9IHBhcmVudDtcbiAgfVxuICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuY29udGV4dDtcbn1cblxudmFyIE5vV29yayA9IDA7IC8vIFRPRE86IFVzZSBhbiBvcGFxdWUgdHlwZSBvbmNlIEVTTGludCBldCBhbCBzdXBwb3J0IHRoZSBzeW50YXhcblxudmFyIFN5bmMgPSAxO1xudmFyIE5ldmVyID0gMjE0NzQ4MzY0NzsgLy8gTWF4IGludDMyOiBNYXRoLnBvdygyLCAzMSkgLSAxXG5cbnZhciBVTklUX1NJWkUgPSAxMDtcbnZhciBNQUdJQ19OVU1CRVJfT0ZGU0VUID0gMjtcblxuLy8gMSB1bml0IG9mIGV4cGlyYXRpb24gdGltZSByZXByZXNlbnRzIDEwbXMuXG5mdW5jdGlvbiBtc1RvRXhwaXJhdGlvblRpbWUobXMpIHtcbiAgLy8gQWx3YXlzIGFkZCBhbiBvZmZzZXQgc28gdGhhdCB3ZSBkb24ndCBjbGFzaCB3aXRoIHRoZSBtYWdpYyBudW1iZXIgZm9yIE5vV29yay5cbiAgcmV0dXJuIChtcyAvIFVOSVRfU0laRSB8IDApICsgTUFHSUNfTlVNQkVSX09GRlNFVDtcbn1cblxuZnVuY3Rpb24gZXhwaXJhdGlvblRpbWVUb01zKGV4cGlyYXRpb25UaW1lKSB7XG4gIHJldHVybiAoZXhwaXJhdGlvblRpbWUgLSBNQUdJQ19OVU1CRVJfT0ZGU0VUKSAqIFVOSVRfU0laRTtcbn1cblxuZnVuY3Rpb24gY2VpbGluZyhudW0sIHByZWNpc2lvbikge1xuICByZXR1cm4gKChudW0gLyBwcmVjaXNpb24gfCAwKSArIDEpICogcHJlY2lzaW9uO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbkluTXMsIGJ1Y2tldFNpemVNcykge1xuICByZXR1cm4gY2VpbGluZyhjdXJyZW50VGltZSArIGV4cGlyYXRpb25Jbk1zIC8gVU5JVF9TSVpFLCBidWNrZXRTaXplTXMgLyBVTklUX1NJWkUpO1xufVxuXG52YXIgTm9Db250ZXh0ID0gMDtcbnZhciBBc3luY1VwZGF0ZXMgPSAxO1xuXG57XG4gIHZhciBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cbiAgICBcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBhYm91dCBiYWQgcG9seWZpbGxzXG4gICAgaGFzQmFkTWFwUG9seWZpbGwgPSB0cnVlO1xuICB9XG59XG5cbi8vIEEgRmliZXIgaXMgd29yayBvbiBhIENvbXBvbmVudCB0aGF0IG5lZWRzIHRvIGJlIGRvbmUgb3Igd2FzIGRvbmUuIFRoZXJlIGNhblxuLy8gYmUgbW9yZSB0aGFuIG9uZSBwZXIgY29tcG9uZW50LlxuXG5cbntcbiAgdmFyIGRlYnVnQ291bnRlciA9IDE7XG59XG5cbmZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSB7XG4gIC8vIEluc3RhbmNlXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy50eXBlID0gbnVsbDtcbiAgdGhpcy5zdGF0ZU5vZGUgPSBudWxsO1xuXG4gIC8vIEZpYmVyXG4gIHRoaXNbJ3JldHVybiddID0gbnVsbDtcbiAgdGhpcy5jaGlsZCA9IG51bGw7XG4gIHRoaXMuc2libGluZyA9IG51bGw7XG4gIHRoaXMuaW5kZXggPSAwO1xuXG4gIHRoaXMucmVmID0gbnVsbDtcblxuICB0aGlzLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuXG4gIHRoaXMuaW50ZXJuYWxDb250ZXh0VGFnID0gaW50ZXJuYWxDb250ZXh0VGFnO1xuXG4gIC8vIEVmZmVjdHNcbiAgdGhpcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcbiAgdGhpcy5uZXh0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcblxuICB7XG4gICAgdGhpcy5fZGVidWdJRCA9IGRlYnVnQ291bnRlcisrO1xuICAgIHRoaXMuX2RlYnVnU291cmNlID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxudmFyIGNyZWF0ZUZpYmVyID0gZnVuY3Rpb24gKHRhZywga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpIHtcbiAgLy8gJEZsb3dGaXhNZTogdGhlIHNoYXBlcyBhcmUgZXhhY3QgaGVyZSBidXQgRmxvdyBkb2Vzbid0IGxpa2UgY29uc3RydWN0b3JzXG4gIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG4vLyBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGFuIGFsdGVybmF0ZSBmaWJlciB0byBkbyB3b3JrIG9uLlxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcbiAgaWYgKHdvcmtJblByb2dyZXNzID09PSBudWxsKSB7XG4gICAgLy8gV2UgdXNlIGEgZG91YmxlIGJ1ZmZlcmluZyBwb29saW5nIHRlY2huaXF1ZSBiZWNhdXNlIHdlIGtub3cgdGhhdCB3ZSdsbFxuICAgIC8vIG9ubHkgZXZlciBuZWVkIGF0IG1vc3QgdHdvIHZlcnNpb25zIG9mIGEgdHJlZS4gV2UgcG9vbCB0aGUgXCJvdGhlclwiIHVudXNlZFxuICAgIC8vIG5vZGUgdGhhdCB3ZSdyZSBmcmVlIHRvIHJldXNlLiBUaGlzIGlzIGxhemlseSBjcmVhdGVkIHRvIGF2b2lkIGFsbG9jYXRpbmdcbiAgICAvLyBleHRyYSBvYmplY3RzIGZvciB0aGluZ3MgdGhhdCBhcmUgbmV2ZXIgdXBkYXRlZC4gSXQgYWxzbyBhbGxvdyB1cyB0b1xuICAgIC8vIHJlY2xhaW0gdGhlIGV4dHJhIG1lbW9yeSBpZiBuZWVkZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVGaWJlcihjdXJyZW50LnRhZywgY3VycmVudC5rZXksIGN1cnJlbnQuaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCA9IGN1cnJlbnQuX2RlYnVnSUQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBjdXJyZW50O1xuICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gd29ya0luUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGFsdGVybmF0ZS5cbiAgICAvLyBSZXNldCB0aGUgZWZmZWN0IHRhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcblxuICAgIC8vIFRoZSBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgd29ya0luUHJvZ3Jlc3MubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIC8vIFRoZXNlIHdpbGwgYmUgb3ZlcnJpZGRlbiBkdXJpbmcgdGhlIHBhcmVudCdzIHJlY29uY2lsaWF0aW9uXG4gIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIb3N0Um9vdEZpYmVyKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgTm9Db250ZXh0KTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG93bmVyID0gbnVsbDtcbiAge1xuICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICB2YXIgZmliZXIgPSB2b2lkIDA7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlLFxuICAgICAga2V5ID0gZWxlbWVudC5rZXk7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmliZXIgPSBzaG91bGRDb25zdHJ1Y3QodHlwZSkgPyBjcmVhdGVGaWJlcihDbGFzc0NvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpIDogY3JlYXRlRmliZXIoSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICAgIGZpYmVyLnR5cGUgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBrZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gICAgZmliZXIudHlwZSA9IHR5cGU7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiB0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgLy8gQ3VycmVudGx5IGFzc3VtZWQgdG8gYmUgYSBjb250aW51YXRpb24gYW5kIHRoZXJlZm9yZSBpcyBhIGZpYmVyIGFscmVhZHkuXG4gICAgLy8gVE9ETzogVGhlIHlpZWxkIHN5c3RlbSBpcyBjdXJyZW50bHkgYnJva2VuIGZvciB1cGRhdGVzIGluIHNvbWUgY2FzZXMuXG4gICAgLy8gVGhlIHJlaWZpZWQgeWllbGQgc3RvcmVzIGEgZmliZXIsIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZpYmVyIHRoYXQgaXM7XG4gICAgLy8gdGhlIGN1cnJlbnQgb3IgYSB3b3JrSW5Qcm9ncmVzcz8gV2hlbiB0aGUgY29udGludWF0aW9uIGdldHMgcmVuZGVyZWQgaGVyZVxuICAgIC8vIHdlIGRvbid0IGtub3cgaWYgd2UgY2FuIHJldXNlIHRoYXQgZmliZXIgb3IgaWYgd2UgbmVlZCB0byBjbG9uZSBpdC5cbiAgICAvLyBUaGVyZSBpcyBwcm9iYWJseSBhIGNsZXZlciB3YXkgdG8gcmVzdHJ1Y3R1cmUgdGhpcy5cbiAgICBmaWJlciA9IHR5cGU7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHtcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG4gICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBnZXRDb21wb25lbnROYW1lKG93bmVyKSA6IG51bGw7XG4gICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gICAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbyk7XG4gIH1cblxuICB7XG4gICAgZmliZXIuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihGcmFnbWVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50cztcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UZXh0KGNvbnRlbnQsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFRleHQsIG51bGwsIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvbnRlbnQ7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsIG51bGwsIE5vQ29udGV4dCk7XG4gIGZpYmVyLnR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKENhbGxDb21wb25lbnQsIGNhbGwua2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci50eXBlID0gY2FsbC5oYW5kbGVyO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjYWxsO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVJldHVybihyZXR1cm5Ob2RlLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFJldHVybkNvbXBvbmVudCwgbnVsbCwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBvcnRhbC5rZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IHBvcnRhbC5jaGlsZHJlbiB8fCBbXTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgZmliZXIuc3RhdGVOb2RlID0ge1xuICAgIGNvbnRhaW5lckluZm86IHBvcnRhbC5jb250YWluZXJJbmZvLFxuICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCwgLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpIHtcbiAgLy8gQ3ljbGljIGNvbnN0cnVjdGlvbi4gVGhpcyBjaGVhdHMgdGhlIHR5cGUgc3lzdGVtIHJpZ2h0IG5vdyBiZWNhdXNlXG4gIC8vIHN0YXRlTm9kZSBpcyBhbnkuXG4gIHZhciB1bmluaXRpYWxpemVkRmliZXIgPSBjcmVhdGVIb3N0Um9vdEZpYmVyKCk7XG4gIHZhciByb290ID0ge1xuICAgIGN1cnJlbnQ6IHVuaW5pdGlhbGl6ZWRGaWJlcixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCxcbiAgICByZW1haW5pbmdFeHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGlzUmVhZHlGb3JDb21taXQ6IGZhbHNlLFxuICAgIGZpbmlzaGVkV29yazogbnVsbCxcbiAgICBjb250ZXh0OiBudWxsLFxuICAgIHBlbmRpbmdDb250ZXh0OiBudWxsLFxuICAgIGh5ZHJhdGU6IGh5ZHJhdGUsXG4gICAgbmV4dFNjaGVkdWxlZFJvb3Q6IG51bGxcbiAgfTtcbiAgdW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZSA9IHJvb3Q7XG4gIHJldHVybiByb290O1xufVxuXG52YXIgb25Db21taXRGaWJlclJvb3QgPSBudWxsO1xudmFyIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjYXRjaEVycm9ycyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYXJnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0cnVlICYmICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscykge1xuICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBObyBEZXZUb29sc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaG9vayA9IF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFob29rLnN1cHBvcnRzRmliZXIpIHtcbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIFJlYWN0IERldlRvb2xzIGlzIHRvbyBvbGQgYW5kIHdpbGwgbm90IHdvcmsgJyArICd3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgIH1cbiAgICAvLyBEZXZUb29scyBleGlzdHMsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3Qgc3VwcG9ydCBGaWJlci5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTtcbiAgICAvLyBXZSBoYXZlIHN1Y2Nlc3NmdWxseSBpbmplY3RlZCwgc28gbm93IGl0IGlzIHNhZmUgdG8gc2V0IHVwIGhvb2tzLlxuICAgIG9uQ29tbWl0RmliZXJSb290ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIHJldHVybiBob29rLm9uQ29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QpO1xuICAgIH0pO1xuICAgIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudChyZW5kZXJlcklELCBmaWJlcik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgLy8gRGV2VG9vbHMgZXhpc3RzXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbW1pdFJvb3Qocm9vdCkge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclJvb3Qocm9vdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmICh0eXBlb2Ygb25Db21taXRGaWJlclVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudChmaWJlcik7XG4gIH1cbn1cblxue1xuICB2YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IGZhbHNlO1xufVxuXG4vLyBDYWxsYmFja3MgYXJlIG5vdCB2YWxpZGF0ZWQgdW50aWwgaW52b2NhdGlvblxuXG5cbi8vIFNpbmdseSBsaW5rZWQtbGlzdCBvZiB1cGRhdGVzLiBXaGVuIGFuIHVwZGF0ZSBpcyBzY2hlZHVsZWQsIGl0IGlzIGFkZGVkIHRvXG4vLyB0aGUgcXVldWUgb2YgdGhlIGN1cnJlbnQgZmliZXIgYW5kIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBUaGUgdHdvIHF1ZXVlc1xuLy8gYXJlIHNlcGFyYXRlIGJ1dCB0aGV5IHNoYXJlIGEgcGVyc2lzdGVudCBzdHJ1Y3R1cmUuXG4vL1xuLy8gRHVyaW5nIHJlY29uY2lsaWF0aW9uLCB1cGRhdGVzIGFyZSByZW1vdmVkIGZyb20gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIsXG4vLyBidXQgdGhleSByZW1haW4gb24gdGhlIGN1cnJlbnQgZmliZXIuIFRoYXQgZW5zdXJlcyB0aGF0IGlmIGEgd29yay1pbi1wcm9ncmVzc1xuLy8gaXMgYWJvcnRlZCwgdGhlIGFib3J0ZWQgdXBkYXRlcyBhcmUgcmVjb3ZlcmVkIGJ5IGNsb25pbmcgZnJvbSBjdXJyZW50LlxuLy9cbi8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIGFsd2F5cyBhIHN1YnNldCBvZiB0aGUgY3VycmVudCBxdWV1ZS5cbi8vXG4vLyBXaGVuIHRoZSB0cmVlIGlzIGNvbW1pdHRlZCwgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgYmVjb21lcyB0aGUgY3VycmVudC5cblxuXG5mdW5jdGlvbiBjcmVhdGVVcGRhdGVRdWV1ZShiYXNlU3RhdGUpIHtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIGJhc2VTdGF0ZTogYmFzZVN0YXRlLFxuICAgIGV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgZmlyc3Q6IG51bGwsXG4gICAgbGFzdDogbnVsbCxcbiAgICBjYWxsYmFja0xpc3Q6IG51bGwsXG4gICAgaGFzRm9yY2VVcGRhdGU6IGZhbHNlLFxuICAgIGlzSW5pdGlhbGl6ZWQ6IGZhbHNlXG4gIH07XG4gIHtcbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gcXVldWU7XG59XG5cbmZ1bmN0aW9uIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZSwgdXBkYXRlKSB7XG4gIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gIGlmIChxdWV1ZS5sYXN0ID09PSBudWxsKSB7XG4gICAgLy8gUXVldWUgaXMgZW1wdHlcbiAgICBxdWV1ZS5maXJzdCA9IHF1ZXVlLmxhc3QgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgcXVldWUubGFzdC5uZXh0ID0gdXBkYXRlO1xuICAgIHF1ZXVlLmxhc3QgPSB1cGRhdGU7XG4gIH1cbiAgaWYgKHF1ZXVlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgcXVldWUuZXhwaXJhdGlvblRpbWUgPiB1cGRhdGUuZXhwaXJhdGlvblRpbWUpIHtcbiAgICBxdWV1ZS5leHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSkge1xuICAvLyBXZSdsbCBoYXZlIGF0IGxlYXN0IG9uZSBhbmQgYXQgbW9zdCB0d28gZGlzdGluY3QgdXBkYXRlIHF1ZXVlcy5cbiAgdmFyIGFsdGVybmF0ZUZpYmVyID0gZmliZXIuYWx0ZXJuYXRlO1xuICB2YXIgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWU7XG4gIGlmIChxdWV1ZTEgPT09IG51bGwpIHtcbiAgICAvLyBUT0RPOiBXZSBkb24ndCBrbm93IHdoYXQgdGhlIGJhc2Ugc3RhdGUgd2lsbCBiZSB1bnRpbCB3ZSBiZWdpbiB3b3JrLlxuICAgIC8vIEl0IGRlcGVuZHMgb24gd2hpY2ggZmliZXIgaXMgdGhlIG5leHQgY3VycmVudC4gSW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5XG4gICAgLy8gYmFzZSBzdGF0ZSwgdGhlbiBzZXQgdG8gdGhlIG1lbW9pemVkU3RhdGUgd2hlbiByZW5kZXJpbmcuIE5vdCBzdXBlclxuICAgIC8vIGhhcHB5IHdpdGggdGhpcyBhcHByb2FjaC5cbiAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZSA9IGNyZWF0ZVVwZGF0ZVF1ZXVlKG51bGwpO1xuICB9XG5cbiAgdmFyIHF1ZXVlMiA9IHZvaWQgMDtcbiAgaWYgKGFsdGVybmF0ZUZpYmVyICE9PSBudWxsKSB7XG4gICAgcXVldWUyID0gYWx0ZXJuYXRlRmliZXIudXBkYXRlUXVldWU7XG4gICAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgICAgcXVldWUyID0gYWx0ZXJuYXRlRmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShudWxsKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcXVldWUyID0gbnVsbDtcbiAgfVxuICBxdWV1ZTIgPSBxdWV1ZTIgIT09IHF1ZXVlMSA/IHF1ZXVlMiA6IG51bGw7XG5cbiAgLy8gV2FybiBpZiBhbiB1cGRhdGUgaXMgc2NoZWR1bGVkIGZyb20gaW5zaWRlIGFuIHVwZGF0ZXIgZnVuY3Rpb24uXG4gIHtcbiAgICBpZiAoKHF1ZXVlMS5pc1Byb2Nlc3NpbmcgfHwgcXVldWUyICE9PSBudWxsICYmIHF1ZXVlMi5pc1Byb2Nlc3NpbmcpICYmICFkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCAnICsgJ2Zyb20gaW5zaWRlIGFuIHVwZGF0ZSBmdW5jdGlvbi4gVXBkYXRlIGZ1bmN0aW9ucyBzaG91bGQgYmUgcHVyZSwgJyArICd3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSAnICsgJ2NhbGxiYWNrLicpO1xuICAgICAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlcmUncyBvbmx5IG9uZSBxdWV1ZSwgYWRkIHRoZSB1cGRhdGUgdG8gdGhhdCBxdWV1ZSBhbmQgZXhpdC5cbiAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgZWl0aGVyIHF1ZXVlIGlzIGVtcHR5LCB3ZSBuZWVkIHRvIGFkZCB0byBib3RoIHF1ZXVlcy5cbiAgaWYgKHF1ZXVlMS5sYXN0ID09PSBudWxsIHx8IHF1ZXVlMi5sYXN0ID09PSBudWxsKSB7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUyLCB1cGRhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGJvdGggbGlzdHMgYXJlIG5vdCBlbXB0eSwgdGhlIGxhc3QgdXBkYXRlIGlzIHRoZSBzYW1lIGZvciBib3RoIGxpc3RzXG4gIC8vIGJlY2F1c2Ugb2Ygc3RydWN0dXJhbCBzaGFyaW5nLiBTbywgd2Ugc2hvdWxkIG9ubHkgYXBwZW5kIHRvIG9uZSBvZlxuICAvLyB0aGUgbGlzdHMuXG4gIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gIC8vIEJ1dCB3ZSBzdGlsbCBuZWVkIHRvIHVwZGF0ZSB0aGUgYGxhc3RgIHBvaW50ZXIgb2YgcXVldWUyLlxuICBxdWV1ZTIubGFzdCA9IHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0VXBkYXRlRXhwaXJhdGlvblRpbWUoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gQ2xhc3NDb21wb25lbnQgJiYgZmliZXIudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIHJldHVybiBOb1dvcms7XG4gIH1cbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBOb1dvcms7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVF1ZXVlLmV4cGlyYXRpb25UaW1lO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgcHJldlN0YXRlLCBwcm9wcykge1xuICB2YXIgcGFydGlhbFN0YXRlID0gdXBkYXRlLnBhcnRpYWxTdGF0ZTtcbiAgaWYgKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgdXBkYXRlRm4gPSBwYXJ0aWFsU3RhdGU7XG5cbiAgICAvLyBJbnZva2Ugc2V0U3RhdGUgY2FsbGJhY2sgYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgdXBkYXRlRm4uY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZUZuLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJ0aWFsU3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgaW5zdGFuY2UsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnVwZGF0ZVF1ZXVlID09PSBxdWV1ZSkge1xuICAgIC8vIFdlIG5lZWQgdG8gY3JlYXRlIGEgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgYnkgY2xvbmluZyB0aGUgY3VycmVudCBxdWV1ZS5cbiAgICB2YXIgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHtcbiAgICAgIGJhc2VTdGF0ZTogY3VycmVudFF1ZXVlLmJhc2VTdGF0ZSxcbiAgICAgIGV4cGlyYXRpb25UaW1lOiBjdXJyZW50UXVldWUuZXhwaXJhdGlvblRpbWUsXG4gICAgICBmaXJzdDogY3VycmVudFF1ZXVlLmZpcnN0LFxuICAgICAgbGFzdDogY3VycmVudFF1ZXVlLmxhc3QsXG4gICAgICBpc0luaXRpYWxpemVkOiBjdXJyZW50UXVldWUuaXNJbml0aWFsaXplZCxcbiAgICAgIC8vIFRoZXNlIGZpZWxkcyBhcmUgbm8gbG9uZ2VyIHZhbGlkIGJlY2F1c2UgdGhleSB3ZXJlIGFscmVhZHkgY29tbWl0dGVkLlxuICAgICAgLy8gUmVzZXQgdGhlbS5cbiAgICAgIGNhbGxiYWNrTGlzdDogbnVsbCxcbiAgICAgIGhhc0ZvcmNlVXBkYXRlOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICB7XG4gICAgLy8gU2V0IHRoaXMgZmxhZyBzbyB3ZSBjYW4gd2FybiBpZiBzZXRTdGF0ZSBpcyBjYWxsZWQgaW5zaWRlIHRoZSB1cGRhdGVcbiAgICAvLyBmdW5jdGlvbiBvZiBhbm90aGVyIHNldFN0YXRlLlxuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IHRydWU7XG4gIH1cblxuICAvLyBSZXNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZS4gSWYgd2Ugc2tpcCBvdmVyIGFueSB1cGRhdGVzLCB3ZSdsbFxuICAvLyBpbmNyZWFzZSB0aGlzIGFjY29yZGluZ2x5LlxuICBxdWV1ZS5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICAvLyBUT0RPOiBXZSBkb24ndCBrbm93IHdoYXQgdGhlIGJhc2Ugc3RhdGUgd2lsbCBiZSB1bnRpbCB3ZSBiZWdpbiB3b3JrLlxuICAvLyBJdCBkZXBlbmRzIG9uIHdoaWNoIGZpYmVyIGlzIHRoZSBuZXh0IGN1cnJlbnQuIEluaXRpYWxpemUgd2l0aCBhbiBlbXB0eVxuICAvLyBiYXNlIHN0YXRlLCB0aGVuIHNldCB0byB0aGUgbWVtb2l6ZWRTdGF0ZSB3aGVuIHJlbmRlcmluZy4gTm90IHN1cGVyXG4gIC8vIGhhcHB5IHdpdGggdGhpcyBhcHByb2FjaC5cbiAgdmFyIHN0YXRlID0gdm9pZCAwO1xuICBpZiAocXVldWUuaXNJbml0aWFsaXplZCkge1xuICAgIHN0YXRlID0gcXVldWUuYmFzZVN0YXRlO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlID0gcXVldWUuYmFzZVN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICBxdWV1ZS5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuICB2YXIgZG9udE11dGF0ZVByZXZTdGF0ZSA9IHRydWU7XG4gIHZhciB1cGRhdGUgPSBxdWV1ZS5maXJzdDtcbiAgdmFyIGRpZFNraXAgPSBmYWxzZTtcbiAgd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIHZhciB1cGRhdGVFeHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgICBpZiAodXBkYXRlRXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBub3QgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LiBTa2lwIGl0LlxuICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcXVldWUuZXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA+IHVwZGF0ZUV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZS5cbiAgICAgICAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSB1cGRhdGVFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmICghZGlkU2tpcCkge1xuICAgICAgICBkaWRTa2lwID0gdHJ1ZTtcbiAgICAgICAgcXVldWUuYmFzZVN0YXRlID0gc3RhdGU7XG4gICAgICB9XG4gICAgICAvLyBDb250aW51ZSB0byB0aGUgbmV4dCB1cGRhdGUuXG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuXG4gICAgLy8gSWYgbm8gcHJldmlvdXMgdXBkYXRlcyB3ZXJlIHNraXBwZWQsIGRyb3AgdGhpcyB1cGRhdGUgZnJvbSB0aGUgcXVldWUgYnlcbiAgICAvLyBhZHZhbmNpbmcgdGhlIGhlYWQgb2YgdGhlIGxpc3QuXG4gICAgaWYgKCFkaWRTa2lwKSB7XG4gICAgICBxdWV1ZS5maXJzdCA9IHVwZGF0ZS5uZXh0O1xuICAgICAgaWYgKHF1ZXVlLmZpcnN0ID09PSBudWxsKSB7XG4gICAgICAgIHF1ZXVlLmxhc3QgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgdGhlIHVwZGF0ZVxuICAgIHZhciBfcGFydGlhbFN0YXRlID0gdm9pZCAwO1xuICAgIGlmICh1cGRhdGUuaXNSZXBsYWNlKSB7XG4gICAgICBzdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh1cGRhdGUsIGluc3RhbmNlLCBzdGF0ZSwgcHJvcHMpO1xuICAgICAgZG9udE11dGF0ZVByZXZTdGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9wYXJ0aWFsU3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgIGlmIChfcGFydGlhbFN0YXRlKSB7XG4gICAgICAgIGlmIChkb250TXV0YXRlUHJldlN0YXRlKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZTogSWRrIGhvdyB0byB0eXBlIHRoaXMgcHJvcGVybHkuXG4gICAgICAgICAgc3RhdGUgPSBfYXNzaWduKHt9LCBzdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUgPSBfYXNzaWduKHN0YXRlLCBfcGFydGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBkb250TXV0YXRlUHJldlN0YXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1cGRhdGUuaXNGb3JjZWQpIHtcbiAgICAgIHF1ZXVlLmhhc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZS5jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgLy8gQXBwZW5kIHRvIGxpc3Qgb2YgY2FsbGJhY2tzLlxuICAgICAgdmFyIF9jYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3Q7XG4gICAgICBpZiAoX2NhbGxiYWNrTGlzdCA9PT0gbnVsbCkge1xuICAgICAgICBfY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0ID0gW107XG4gICAgICB9XG4gICAgICBfY2FsbGJhY2tMaXN0LnB1c2godXBkYXRlKTtcbiAgICB9XG4gICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gIH1cblxuICBpZiAocXVldWUuY2FsbGJhY2tMaXN0ICE9PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENhbGxiYWNrO1xuICB9IGVsc2UgaWYgKHF1ZXVlLmZpcnN0ID09PSBudWxsICYmICFxdWV1ZS5oYXNGb3JjZVVwZGF0ZSkge1xuICAgIC8vIFRoZSBxdWV1ZSBpcyBlbXB0eS4gV2UgY2FuIHJlc2V0IGl0LlxuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgfVxuXG4gIGlmICghZGlkU2tpcCkge1xuICAgIGRpZFNraXAgPSB0cnVlO1xuICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAge1xuICAgIC8vIE5vIGxvbmdlciBwcm9jZXNzaW5nLlxuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiBjb21taXRDYWxsYmFja3MocXVldWUsIGNvbnRleHQpIHtcbiAgdmFyIGNhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdDtcbiAgaWYgKGNhbGxiYWNrTGlzdCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBTZXQgdGhlIGxpc3QgdG8gbnVsbCB0byBtYWtlIHN1cmUgdGhleSBkb24ndCBnZXQgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLlxuICBxdWV1ZS5jYWxsYmFja0xpc3QgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB1cGRhdGUgPSBjYWxsYmFja0xpc3RbaV07XG4gICAgdmFyIF9jYWxsYmFjayA9IHVwZGF0ZS5jYWxsYmFjaztcbiAgICAvLyBUaGlzIHVwZGF0ZSBtaWdodCBiZSBwcm9jZXNzZWQgYWdhaW4uIENsZWFyIHRoZSBjYWxsYmFjayBzbyBpdCdzIG9ubHlcbiAgICAvLyBjYWxsZWQgb25jZS5cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBudWxsO1xuICAgICEodHlwZW9mIF9jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBfY2FsbGJhY2spIDogdm9pZCAwO1xuICAgIF9jYWxsYmFjay5jYWxsKGNvbnRleHQpO1xuICB9XG59XG5cbnZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG57XG4gIHZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSB7fTtcblxuICB2YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2FybmluZyhjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmYWtlSW50ZXJuYWxJbnN0YW5jZSwgJ19wcm9jZXNzQ2hpbGRDb250ZXh0Jywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYXZhaWxhYmxlIGluIFJlYWN0IDE2Ky4gVGhpcyBsaWtlbHkgbWVhbnMgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGFuZCBhcmUgYXR0ZW1wdGluZyB0byBuZXN0IGEgUmVhY3QgMTUgdHJlZSBpbnNpZGUgYSBSZWFjdCAxNiB0cmVlIHVzaW5nIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLCB3aGljaCBpc25cXCd0IHN1cHBvcnRlZC4gVHJ5IHRvIG1ha2Ugc3VyZSB5b3UgaGF2ZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0IChhbmQgaWRlYWxseSwgc3dpdGNoIHRvIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbCkuJyk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbnZhciBSZWFjdEZpYmVyQ2xhc3NDb21wb25lbnQgPSBmdW5jdGlvbiAoc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLCBtZW1vaXplUHJvcHMsIG1lbW9pemVTdGF0ZSkge1xuICAvLyBDbGFzcyBjb21wb25lbnQgc3RhdGUgdXBkYXRlclxuICB2YXIgdXBkYXRlciA9IHtcbiAgICBpc01vdW50ZWQ6IGlzTW91bnRlZCxcbiAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IHBhcnRpYWxTdGF0ZSxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0sXG4gICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBzdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZTogc3RhdGUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiB0cnVlLFxuICAgICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0sXG4gICAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZTogbnVsbCxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgICBpc0ZvcmNlZDogdHJ1ZSxcbiAgICAgICAgbmV4dENhbGxiYWNrOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpO1xuICAgICAgc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCkge1xuICAgIGlmIChvbGRQcm9wcyA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSkge1xuICAgICAgLy8gSWYgdGhlIHdvcmtJblByb2dyZXNzIGFscmVhZHkgaGFzIGFuIFVwZGF0ZSBlZmZlY3QsIHJldHVybiB0cnVlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIGlmICh0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdzaG91bGRDb21wb25lbnRVcGRhdGUnKTtcbiAgICAgIHZhciBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgd2FybmluZyhzaG91bGRVcGRhdGUgIT09IHVuZGVmaW5lZCwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gIXNoYWxsb3dFcXVhbChvbGRQcm9wcywgbmV3UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwob2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgICBpZiAoIXJlbmRlclByZXNlbnQpIHtcbiAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj8nLCBuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5vR2V0SW5pdGlhbFN0YXRlT25FUzYgPSAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCB8fCBpbnN0YW5jZS5zdGF0ZTtcbiAgICAgIHdhcm5pbmcobm9HZXRJbml0aWFsU3RhdGVPbkVTNiwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKTtcbiAgICAgIHZhciBub0dldERlZmF1bHRQcm9wc09uRVM2ID0gIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcyB8fCBpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQ7XG4gICAgICB3YXJuaW5nKG5vR2V0RGVmYXVsdFByb3BzT25FUzYsICdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIHZhciBub0luc3RhbmNlUHJvcFR5cGVzID0gIWluc3RhbmNlLnByb3BUeXBlcztcbiAgICAgIHdhcm5pbmcobm9JbnN0YW5jZVByb3BUeXBlcywgJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIHByb3BUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgdmFyIG5vSW5zdGFuY2VDb250ZXh0VHlwZXMgPSAhaW5zdGFuY2UuY29udGV4dFR5cGVzO1xuICAgICAgd2FybmluZyhub0luc3RhbmNlQ29udGV4dFR5cGVzLCAnY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB2YXIgbm9Db21wb25lbnRTaG91bGRVcGRhdGUgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nO1xuICAgICAgd2FybmluZyhub0NvbXBvbmVudFNob3VsZFVwZGF0ZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpO1xuICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmIHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiAnICsgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gJyArICdQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQSBwdXJlIGNvbXBvbmVudCcpO1xuICAgICAgfVxuICAgICAgdmFyIG5vQ29tcG9uZW50RGlkVW5tb3VudCA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ICE9PSAnZnVuY3Rpb24nO1xuICAgICAgd2FybmluZyhub0NvbXBvbmVudERpZFVubW91bnQsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIG5hbWUpO1xuICAgICAgdmFyIG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHMsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsICcgKyAndXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgJyArICdydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgd2FybmluZyhpbnN0YW5jZS5wcm9wcyA9PT0gdW5kZWZpbmVkIHx8ICFoYXNNdXRhdGVkUHJvcHMsICclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSwgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZURlZmF1bHRQcm9wcyA9ICFpbnN0YW5jZS5kZWZhdWx0UHJvcHM7XG4gICAgICB3YXJuaW5nKG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMsICdTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuJyArICcgSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy4nLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICBpZiAoc3RhdGUgJiYgKHR5cGVvZiBzdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShzdGF0ZSkpKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2FybmluZyh0eXBlb2Ygd29ya0luUHJvZ3Jlc3MudHlwZS5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcsICclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgKyAndXNlIGdldENoaWxkQ29udGV4dCgpLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UucHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZS51cGRhdGVyID0gdXBkYXRlcjtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICAvLyBUaGUgaW5zdGFuY2UgbmVlZHMgYWNjZXNzIHRvIHRoZSBmaWJlciBzbyB0aGF0IGl0IGNhbiBzY2hlZHVsZSB1cGRhdGVzXG4gICAgc2V0KGluc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAge1xuICAgICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHByb3BzKSB7XG4gICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBuZWVkc0NvbnRleHQgPSBpc0NvbnRleHRDb25zdW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBuZWVkc0NvbnRleHQgPyBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIDogZW1wdHlPYmplY3Q7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpO1xuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuXG4gICAgLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAgIC8vIFJlYWN0RmliZXJDb250ZXh0IHVzdWFsbHkgdXBkYXRlcyB0aGlzIGNhY2hlIGJ1dCBjYW4ndCBmb3IgbmV3bHktY3JlYXRlZCBpbnN0YW5jZXMuXG4gICAgaWYgKG5lZWRzQ29udGV4dCkge1xuICAgICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICB9XG5cbiAgICBpZiAob2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgfVxuICAgICAgdXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgLy8gU2ltdWxhdGUgYW4gYXN5bmMgYmFpbG91dC9pbnRlcnJ1cHRpb24gYnkgaW52b2tpbmcgbGlmZWN5Y2xlIHR3aWNlLlxuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50JztcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gJyArIFwidGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnZva2VzIHRoZSBtb3VudCBsaWZlLWN5Y2xlcyBvbiBhIHByZXZpb3VzbHkgbmV2ZXIgcmVuZGVyZWQgaW5zdGFuY2UuXG4gIGZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIHtcbiAgICAgIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlIHx8IG51bGw7XG5cbiAgICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgIXByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnVGhlcmUgbXVzdCBiZSBwZW5kaW5nIHByb3BzIGZvciBhbiBpbml0aWFsIG1vdW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHN0YXRlO1xuICAgIGluc3RhbmNlLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIGlmIChlbmFibGVBc3luY1N1YnRyZWVBUEkgJiYgd29ya0luUHJvZ3Jlc3MudHlwZSAhPSBudWxsICYmIHdvcmtJblByb2dyZXNzLnR5cGUucHJvdG90eXBlICE9IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50ID09PSB0cnVlKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5pbnRlcm5hbENvbnRleHRUYWcgfD0gQXN5bmNVcGRhdGVzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgICAvLyBJZiB3ZSBoYWQgYWRkaXRpb25hbCBzdGF0ZSB1cGRhdGVzIGR1cmluZyB0aGlzIGxpZmUtY3ljbGUsIGxldCdzXG4gICAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSwgcHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgb24gYSBwcmVleGlzdGluZyBjbGFzcyBpbnN0YW5jZS4gUmV0dXJucyBmYWxzZSBpZiBhIHJlc3VtZWQgcmVuZGVyXG4gIC8vIGNvdWxkIGJlIHJldXNlZC5cbiAgLy8gZnVuY3Rpb24gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKFxuICAvLyAgIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgLy8gICBwcmlvcml0eUxldmVsOiBQcmlvcml0eUxldmVsLFxuICAvLyApOiBib29sZWFuIHtcbiAgLy8gICBjb25zdCBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAvLyAgIGxldCBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIC8vICAgbGV0IG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAvLyAgIGlmICghbmV3UHJvcHMpIHtcbiAgLy8gICAgIC8vIElmIHRoZXJlIGlzbid0IGFueSBuZXcgcHJvcHMsIHRoZW4gd2UnbGwgcmV1c2UgdGhlIG1lbW9pemVkIHByb3BzLlxuICAvLyAgICAgLy8gVGhpcyBjb3VsZCBiZSBmcm9tIGFscmVhZHkgY29tcGxldGVkIHdvcmsuXG4gIC8vICAgICBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIC8vICAgICBpbnZhcmlhbnQoXG4gIC8vICAgICAgIG5ld1Byb3BzICE9IG51bGwsXG4gIC8vICAgICAgICdUaGVyZSBzaG91bGQgYWx3YXlzIGJlIHBlbmRpbmcgb3IgbWVtb2l6ZWQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgJyArXG4gIC8vICAgICAgICAgJ2xpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gIC8vICAgICApO1xuICAvLyAgIH1cbiAgLy8gICBjb25zdCBuZXdVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAvLyAgIGNvbnN0IG5ld0NvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXdVbm1hc2tlZENvbnRleHQpO1xuXG4gIC8vICAgY29uc3Qgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIC8vICAgY29uc3Qgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuXG4gIC8vICAgaWYgKFxuICAvLyAgICAgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiZcbiAgLy8gICAgIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dClcbiAgLy8gICApIHtcbiAgLy8gICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgaW5zdGFuY2UsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICBuZXdDb250ZXh0LFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUgYmVmb3JlIGNhbGxpbmcgc2hvdWxkQ29tcG9uZW50VXBkYXRlXG4gIC8vICAgY29uc3QgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgLy8gICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgLy8gICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgdXBkYXRlUXVldWUsXG4gIC8vICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgbmV3UHJvcHMsXG4gIC8vICAgICAgIHByaW9yaXR5TGV2ZWwsXG4gIC8vICAgICApO1xuICAvLyAgIH1cblxuICAvLyAgIC8vIFRPRE86IFNob3VsZCB3ZSBkZWFsIHdpdGggYSBzZXRTdGF0ZSB0aGF0IGhhcHBlbmVkIGFmdGVyIHRoZSBsYXN0XG4gIC8vICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGFuZCBiZWZvcmUgdGhpcyBjb21wb25lbnRXaWxsTW91bnQ/IFByb2JhYmx5XG4gIC8vICAgLy8gdW5zdXBwb3J0ZWQgYW55d2F5LlxuXG4gIC8vICAgaWYgKFxuICAvLyAgICAgIWNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyxcbiAgLy8gICAgICAgbmV3UHJvcHMsXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUsXG4gIC8vICAgICAgIG5ld1N0YXRlLFxuICAvLyAgICAgICBuZXdDb250ZXh0LFxuICAvLyAgICAgKVxuICAvLyAgICkge1xuICAvLyAgICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyAgICAgLy8gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LlxuICAvLyAgICAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgLy8gICAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIC8vICAgICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcbiAgLy8gICAgIHJldHVybiBmYWxzZTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBVcGRhdGUgdGhlIGlucHV0IHBvaW50ZXJzIG5vdyBzbyB0aGF0IHRoZXkgYXJlIGNvcnJlY3Qgd2hlbiB3ZSBjYWxsXG4gIC8vICAgLy8gY29tcG9uZW50V2lsbE1vdW50XG4gIC8vICAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgLy8gICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAvLyAgIGluc3RhbmNlLmNvbnRleHQgPSBuZXdDb250ZXh0O1xuXG4gIC8vICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgLy8gICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBtYXkgaGF2ZSBjYWxsZWQgc2V0U3RhdGUuIFByb2Nlc3MgdGhlIHVwZGF0ZSBxdWV1ZS5cbiAgLy8gICAgIGNvbnN0IG5ld1VwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIC8vICAgICBpZiAobmV3VXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgLy8gICAgICAgbmV3U3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoXG4gIC8vICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgICAgbmV3VXBkYXRlUXVldWUsXG4gIC8vICAgICAgICAgaW5zdGFuY2UsXG4gIC8vICAgICAgICAgbmV3U3RhdGUsXG4gIC8vICAgICAgICAgbmV3UHJvcHMsXG4gIC8vICAgICAgICAgcHJpb3JpdHlMZXZlbCxcbiAgLy8gICAgICAgKTtcbiAgLy8gICAgIH1cbiAgLy8gICB9XG5cbiAgLy8gICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAvLyAgIH1cblxuICAvLyAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG5cbiAgLy8gICByZXR1cm4gdHJ1ZTtcbiAgLy8gfVxuXG4gIC8vIEludm9rZXMgdGhlIHVwZGF0ZSBsaWZlLWN5Y2xlcyBhbmQgcmV0dXJucyBmYWxzZSBpZiBpdCBzaG91bGRuJ3QgcmVyZW5kZXIuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHJlc2V0SW5wdXRQb2ludGVycyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuXG4gICAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlbid0IGFueSBuZXcgcHJvcHMsIHRoZW4gd2UnbGwgcmV1c2UgdGhlIG1lbW9pemVkIHByb3BzLlxuICAgICAgLy8gVGhpcyBjb3VsZCBiZSBmcm9tIGFscmVhZHkgY29tcGxldGVkIHdvcmsuXG4gICAgICBuZXdQcm9wcyA9IG9sZFByb3BzO1xuICAgICAgIShuZXdQcm9wcyAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIHNob3VsZCBhbHdheXMgYmUgcGVuZGluZyBvciBtZW1vaXplZCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAgIHZhciBuZXdVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBuZXdDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV3VW5tYXNrZWRDb250ZXh0KTtcblxuICAgIC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAgIC8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXdDb250ZXh0KSkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbmV4dCBzdGF0ZSB1c2luZyB0aGUgbWVtb2l6ZWQgc3RhdGUgYW5kIHRoZSB1cGRhdGUgcXVldWUuXG4gICAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAvLyBUT0RPOiBQcmV2aW91cyBzdGF0ZSBjYW4gYmUgbnVsbC5cbiAgICB2YXIgbmV3U3RhdGUgPSB2b2lkIDA7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUsIGluc3RhbmNlLCBuZXdQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdGF0ZSA9IG9sZFN0YXRlO1xuICAgIH1cblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICEod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpKSB7XG4gICAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuXG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICAgICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgICAgLy8gbWVtb2l6ZWQgcHJvcHMvc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV3UHJvcHMpO1xuICAgICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAgIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuICAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcblxuICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZTogYWRvcHRDbGFzc0luc3RhbmNlLFxuICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2U6IGNvbnN0cnVjdENsYXNzSW5zdGFuY2UsXG4gICAgbW91bnRDbGFzc0luc3RhbmNlOiBtb3VudENsYXNzSW5zdGFuY2UsXG4gICAgLy8gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlLFxuICAgIHVwZGF0ZUNsYXNzSW5zdGFuY2U6IHVwZGF0ZUNsYXNzSW5zdGFuY2VcbiAgfTtcbn07XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddO1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX0NBTExfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmNhbGwnKSA6IDB4ZWFjODtcbnZhciBSRUFDVF9SRVRVUk5fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnJldHVybicpIDogMHhlYWM5O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cblxue1xuICB2YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuICAvKipcbiAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAgICogdXBkYXRlcy5cbiAgICovXG4gIHZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgdmFyIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyA9IHt9O1xuXG4gIHZhciB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2hpbGQuX3N0b3JlIHx8IGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgfHwgY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgISh0eXBlb2YgY2hpbGQuX3N0b3JlID09PSAnb2JqZWN0JykgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlICcgKyAnXCJrZXlcIiBwcm9wLiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yICcgKyAnbW9yZSBpbmZvcm1hdGlvbi4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgICB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSk7XG4gIH07XG59XG5cbnZhciBpc0FycmF5JDEgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCkge1xuICB2YXIgbWl4ZWRSZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKG1peGVkUmVmICE9PSBudWxsICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChlbGVtZW50Ll9vd25lcikge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgaW5zdCA9IHZvaWQgMDtcbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgICAhKG93bmVyRmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogdm9pZCAwO1xuICAgICAgICBpbnN0ID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgICAhaW5zdCA/IGludmFyaWFudChmYWxzZSwgJ01pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgJXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgbWl4ZWRSZWYpIDogdm9pZCAwO1xuICAgICAgdmFyIHN0cmluZ1JlZiA9ICcnICsgbWl4ZWRSZWY7XG4gICAgICAvLyBDaGVjayBpZiBwcmV2aW91cyBzdHJpbmcgcmVmIG1hdGNoZXMgbmV3IHN0cmluZyByZWZcbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQucmVmICE9PSBudWxsICYmIGN1cnJlbnQucmVmLl9zdHJpbmdSZWYgPT09IHN0cmluZ1JlZikge1xuICAgICAgICByZXR1cm4gY3VycmVudC5yZWY7XG4gICAgICB9XG4gICAgICB2YXIgcmVmID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZWZzID0gaW5zdC5yZWZzID09PSBlbXB0eU9iamVjdCA/IGluc3QucmVmcyA9IHt9IDogaW5zdC5yZWZzO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgcmVmc1tzdHJpbmdSZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVmLl9zdHJpbmdSZWYgPSBzdHJpbmdSZWY7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICAhKHR5cGVvZiBtaXhlZFJlZiA9PT0gJ3N0cmluZycpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcuJykgOiB2b2lkIDA7XG4gICAgICAhZWxlbWVudC5fb3duZXIgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHJlZiB3YXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nICglcykgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFlvdSBtYXkgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkLiAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJywgbWl4ZWRSZWYpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWl4ZWRSZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgaWYgKHJldHVybkZpYmVyLnR5cGUgIT09ICd0ZXh0YXJlYScpIHtcbiAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICB7XG4gICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogbmV3Q2hpbGQsIGFkZGVuZHVtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUoKSB7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicgKyAoZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xuXG4gIGlmIChvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICB3YXJuaW5nKGZhbHNlLCAnRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG59XG5cbi8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBleGlzdHMgYmVjYXVzZSBJIGV4cGVjdCB0byBjbG9uZSB0aGUgY29kZSBpbiBlYWNoIHBhdGhcbi8vIHRvIGJlIGFibGUgdG8gb3B0aW1pemUgZWFjaCBwYXRoIGluZGl2aWR1YWxseSBieSBicmFuY2hpbmcgZWFybHkuIFRoaXMgbmVlZHNcbi8vIGEgY29tcGlsZXIgb3Igd2UgY2FuIGRvIGl0IG1hbnVhbGx5LiBIZWxwZXJzIHRoYXQgZG9uJ3QgbmVlZCB0aGlzIGJyYW5jaGluZ1xuLy8gbGl2ZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXG5mdW5jdGlvbiBDaGlsZFJlY29uY2lsZXIoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRGVsZXRpb25zIGFyZSBhZGRlZCBpbiByZXZlcnNlZCBvcmRlciBzbyB3ZSBhZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByZXR1cm4gZmliZXIncyBlZmZlY3QgbGlzdCBpcyBlbXB0eSBleGNlcHQgZm9yXG4gICAgLy8gZGVsZXRpb25zLCBzbyB3ZSBjYW4ganVzdCBhcHBlbmQgdGhlIGRlbGV0aW9uIHRvIHRoZSBsaXN0LiBUaGUgcmVtYWluaW5nXG4gICAgLy8gZWZmZWN0cyBhcmVuJ3QgYWRkZWQgdW50aWwgdGhlIGNvbXBsZXRlIHBoYXNlLiBPbmNlIHdlIGltcGxlbWVudFxuICAgIC8vIHJlc3VtaW5nLCB0aGlzIG1heSBub3QgYmUgdHJ1ZS5cbiAgICB2YXIgbGFzdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3Q7XG4gICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgIGxhc3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9XG4gICAgY2hpbGRUb0RlbGV0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICBjaGlsZFRvRGVsZXRlLmVmZmVjdFRhZyA9IERlbGV0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogRm9yIHRoZSBzaG91bGRDbG9uZSBjYXNlLCB0aGlzIGNvdWxkIGJlIG1pY3JvLW9wdGltaXplZCBhIGJpdCBieVxuICAgIC8vIGFzc3VtaW5nIHRoYXQgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIHdlJ3ZlIGFscmVhZHkgYWRkZWQgZXZlcnl0aGluZy5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZFRvRGVsZXRlICE9PSBudWxsKSB7XG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBjaGlsZFRvRGVsZXRlID0gY2hpbGRUb0RlbGV0ZS5zaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIC8vIEFkZCB0aGUgcmVtYWluaW5nIGNoaWxkcmVuIHRvIGEgdGVtcG9yYXJ5IG1hcCBzbyB0aGF0IHdlIGNhbiBmaW5kIHRoZW0gYnlcbiAgICAvLyBrZXlzIHF1aWNrbHkuIEltcGxpY2l0IChudWxsKSBrZXlzIGdldCBhZGRlZCB0byB0aGlzIHNldCB3aXRoIHRoZWlyIGluZGV4XG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7XG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChleGlzdGluZ0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoZXhpc3RpbmdDaGlsZC5rZXkgIT09IG51bGwpIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5rZXksIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5pbmRleCwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9XG4gICAgICBleGlzdGluZ0NoaWxkID0gZXhpc3RpbmdDaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gZXhpc3RpbmdDaGlsZHJlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUZpYmVyKGZpYmVyLCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gV2UgY3VycmVudGx5IHNldCBzaWJsaW5nIHRvIG51bGwgYW5kIGluZGV4IHRvIDAgaGVyZSBiZWNhdXNlIGl0IGlzIGVhc3lcbiAgICAvLyB0byBmb3JnZXQgdG8gZG8gYmVmb3JlIHJldHVybmluZyBpdC4gRS5nLiBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLlxuICAgIHZhciBjbG9uZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjbG9uZS5pbmRleCA9IDA7XG4gICAgY2xvbmUuc2libGluZyA9IG51bGw7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnQgPSBuZXdGaWJlci5hbHRlcm5hdGU7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gICAgICBpZiAob2xkSW5kZXggPCBsYXN0UGxhY2VkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG1vdmUuXG4gICAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXRlbSBjYW4gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbi5cbiAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxlciBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLiBXZSBvbmx5IG5lZWQgdG8gZG8gYVxuICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0ZpYmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBlbGVtZW50LnByb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnQsIGNhbGwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVE9ETzogU2hvdWxkIHRoaXMgYWxzbyBjb21wYXJlIGhhbmRsZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmV1c2U/XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IENhbGxDb21wb25lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21DYWxsKGNhbGwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBjYWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnQsIHJldHVybk5vZGUsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IFJldHVybkNvbXBvbmVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVJldHVybihyZXR1cm5Ob2RlLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnR5cGUgPSByZXR1cm5Ob2RlLnZhbHVlO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RQb3J0YWwgfHwgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHwgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSwga2V5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZnJhZ21lbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoJycgKyBuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgdmFyIF9jcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICAgIF9jcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2NyZWF0ZWQyID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICAgIF9jcmVhdGVkMi5yZWYgPSBjb2VyY2VSZWYobnVsbCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgICBfY3JlYXRlZDJbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDMgPSBjcmVhdGVGaWJlckZyb21DYWxsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkM1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDM7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkNCA9IGNyZWF0ZUZpYmVyRnJvbVJldHVybihuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDQudHlwZSA9IG5ld0NoaWxkLnZhbHVlO1xuICAgICAgICAgICAgX2NyZWF0ZWQ0WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQ1ID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkNVsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDU7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX2NyZWF0ZWQ2ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgICBfY3JlYXRlZDZbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBfY3JlYXRlZDY7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVXBkYXRlIHRoZSBmaWJlciBpZiB0aGUga2V5cyBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiBudWxsLlxuXG4gICAgdmFyIGtleSA9IG9sZEZpYmVyICE9PSBudWxsID8gb2xkRmliZXIua2V5IDogbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCAnJyArIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUmV0dXJucyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgICAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYVxuICAgICAgICAgICAgLy8geWllbGQuXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgdGV4dCBub2RlcywgdGhleSBtYXRjaC5cbiAgICAgIHZhciBtYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG1hdGNoZWRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgZG9uJ3QgaGF2ZSBrZXlzLCBzbyB3ZSBuZWl0aGVyIGhhdmUgdG8gY2hlY2sgdGhlIG9sZCBub3JcbiAgICAgICAgICAgIC8vIG5ldyBub2RlIGZvciB0aGUga2V5LiBJZiBib3RoIGFyZSByZXR1cm5zLCB0aGV5IG1hdGNoLlxuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIzID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVJldHVybihyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjMsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXI0ID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjUgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjUsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8IGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB3YXJuRm9yTWlzc2luZ0tleShjaGlsZCk7XG4gICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoa25vd25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCBgJXNgLiAnICsgJ0tleXMgc2hvdWxkIGJlIHVuaXF1ZSBzbyB0aGF0IGNvbXBvbmVudHMgbWFpbnRhaW4gdGhlaXIgaWRlbnRpdHkgJyArICdhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSAnICsgJ2R1cGxpY2F0ZWQgYW5kL29yIG9taXR0ZWQg4oCUIHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgJyArICdjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi4lcycsIGtleSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga25vd25LZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGNhbid0IG9wdGltaXplIGJ5IHNlYXJjaGluZyBmcm9tIGJvdGhzIGVuZHMgc2luY2Ugd2VcbiAgICAvLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG4gICAgLy8gYWRkIGl0IGxhdGVyLlxuXG4gICAgLy8gRXZlbiB3aXRoIGEgdHdvIGVuZGVkIG9wdGltaXphdGlvbiwgd2UnZCB3YW50IHRvIG9wdGltaXplIGZvciB0aGUgY2FzZVxuICAgIC8vIHdoZXJlIHRoZXJlIGFyZSBmZXcgY2hhbmdlcyBhbmQgYnJ1dGUgZm9yY2UgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZlxuICAgIC8vIGdvaW5nIGZvciB0aGUgTWFwLiBJdCdkIGxpa2UgdG8gZXhwbG9yZSBoaXR0aW5nIHRoYXQgcGF0aCBmaXJzdCBpblxuICAgIC8vIGZvcndhcmQtb25seSBtb2RlIGFuZCBvbmx5IGdvIGZvciB0aGUgTWFwIG9uY2Ugd2Ugbm90aWNlIHRoYXQgd2UgbmVlZFxuICAgIC8vIGxvdHMgb2YgbG9vayBhaGVhZC4gVGhpcyBkb2Vzbid0IGhhbmRsZSByZXZlcnNhbCBhcyB3ZWxsIGFzIHR3byBlbmRlZFxuICAgIC8vIHNlYXJjaCBidXQgdGhhdCdzIHVudXN1YWwuIEJlc2lkZXMsIGZvciB0aGUgdHdvIGVuZGVkIG9wdGltaXphdGlvbiB0b1xuICAgIC8vIHdvcmsgb24gSXRlcmFibGVzLCB3ZSdkIG5lZWQgdG8gY29weSB0aGUgd2hvbGUgc2V0LlxuXG4gICAgLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4gICAgLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG5cbiAgICAvLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4gICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG5cbiAgICB7XG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmICghX25ld0ZpYmVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgdmFyIF9uZXdGaWJlcjIgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXIyKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlblsnZGVsZXRlJ10oX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMiwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbkl0ZXJhYmxlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cblxuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICB7XG4gICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGRyZW5JdGVyYWJsZS5lbnRyaWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBwb3NzaWJsZU1hcCA9IG5ld0NoaWxkcmVuSXRlcmFibGU7XG4gICAgICAgIGlmIChwb3NzaWJsZU1hcC5lbnRyaWVzID09PSBpdGVyYXRvckZuKSB7XG4gICAgICAgICAgd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIC8vIFdlJ2xsIGdldCBhIGRpZmZlcmVudCBpdGVyYXRvciBsYXRlciBmb3IgdGhlIG1haW4gcGFzcy5cbiAgICAgIHZhciBfbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgICBpZiAoX25ld0NoaWxkcmVuKSB7XG4gICAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuICAgICAgICB2YXIgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgICAgICBmb3IgKDsgIV9zdGVwLmRvbmU7IF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgIShuZXdDaGlsZHJlbiAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci4nKSA6IHZvaWQgMDtcblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcblxuICAgIHZhciBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKCFvbGRGaWJlcikge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICB2YXIgX25ld0ZpYmVyMyA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChfbmV3RmliZXIzID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIzLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyNCA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKF9uZXdGaWJlcjQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyNC5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuWydkZWxldGUnXShfbmV3RmliZXI0LmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjQua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXI0LCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyNDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24gdGV4dCBub2RlcyBzaW5jZSB3ZSBkb24ndCBoYXZlIGFcbiAgICAvLyB3YXkgdG8gZGVmaW5lIHRoZW0uXG4gICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkICE9PSBudWxsICYmIGN1cnJlbnRGaXJzdENoaWxkLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBub2RlIHNvIGxldCdzIGp1c3QgdXBkYXRlIGl0IGFuZCBkZWxldGVcbiAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gICAgLy8gVGhlIGV4aXN0aW5nIGZpcnN0IGNoaWxkIGlzIG5vdCBhIHRleHQgbm9kZSBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmVcbiAgICAvLyBhbmQgZGVsZXRlIHRoZSBleGlzdGluZyBvbmVzLlxuICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEZyYWdtZW50ID8gZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIDogY2hpbGQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgPyBlbGVtZW50LnByb3BzLmNoaWxkcmVuIDogZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihjaGlsZCwgZWxlbWVudCk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50LnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBlbGVtZW50LmtleSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY3JlYXRlZDcgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgX2NyZWF0ZWQ3LnJlZiA9IGNvZXJjZVJlZihjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCk7XG4gICAgICBfY3JlYXRlZDdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gX2NyZWF0ZWQ3O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBjYWxsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBjYWxsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBDYWxsQ29tcG9uZW50KSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBjYWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21DYWxsKGNhbGwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCByZXR1cm5Ob2RlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB5aWVsZHMgc2luY2UgdGhleSdyZSBzdGF0ZWxlc3MuXG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBleGlzdGluZy50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZC50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBwb3J0YWwua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEhvc3RQb3J0YWwgJiYgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmIGNoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG4gICAgLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cblxuICAgIC8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbiAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG4gICAgLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCAmJiBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmIG5ld0NoaWxkLmtleSA9PT0gbnVsbCkge1xuICAgICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG4gICAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbDtcblxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlQ2FsbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVJldHVybihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIElmIHRoZSBuZXcgY2hpbGQgaXMgdW5kZWZpbmVkLCBhbmQgdGhlIHJldHVybiBmaWJlciBpcyBhIGNvbXBvc2l0ZVxuICAgICAgLy8gY29tcG9uZW50LCB0aHJvdyBhbiBlcnJvci4gSWYgRmliZXIgcmV0dXJuIHR5cGVzIGFyZSBkaXNhYmxlZCxcbiAgICAgIC8vIHdlIGFscmVhZHkgdGhyZXcgYWJvdmUuXG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCB0byB0aGUgbmV4dCBjYXNlLCB3aGljaCBoYW5kbGVzIGJvdGhcbiAgICAgICAgLy8gZnVuY3Rpb25zIGFuZCBjbGFzc2VzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZWQgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogTm90aGluZyB3YXMgcmV0dXJuZWQgZnJvbSByZW5kZXIuIFRoaXMgdXN1YWxseSBtZWFucyBhIHJldHVybiBzdGF0ZW1lbnQgaXMgbWlzc2luZy4gT3IsIHRvIHJlbmRlciBub3RoaW5nLCByZXR1cm4gbnVsbC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIodHJ1ZSk7XG52YXIgbW91bnRDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcihmYWxzZSk7XG5cbmZ1bmN0aW9uIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgIShjdXJyZW50ID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBjdXJyZW50LmNoaWxkKSA/IGludmFyaWFudChmYWxzZSwgJ1Jlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VycmVudENoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcblxuICBuZXdDaGlsZFsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgd2hpbGUgKGN1cnJlbnRDaGlsZC5zaWJsaW5nICE9PSBudWxsKSB7XG4gICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkLnNpYmxpbmc7XG4gICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5zaWJsaW5nID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzLCBjdXJyZW50Q2hpbGQuZXhwaXJhdGlvblRpbWUpO1xuICAgIG5ld0NoaWxkWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICB9XG4gIG5ld0NoaWxkLnNpYmxpbmcgPSBudWxsO1xufVxuXG57XG4gIHZhciB3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnMgPSB7fTtcbn1cblxudmFyIFJlYWN0RmliZXJCZWdpbldvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCwgc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKSB7XG4gIHZhciBzaG91bGRTZXRUZXh0Q29udGVudCA9IGNvbmZpZy5zaG91bGRTZXRUZXh0Q29udGVudCxcbiAgICAgIHVzZVN5bmNTY2hlZHVsaW5nID0gY29uZmlnLnVzZVN5bmNTY2hlZHVsaW5nLFxuICAgICAgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSA9IGNvbmZpZy5zaG91bGREZXByaW9yaXRpemVTdWJ0cmVlO1xuICB2YXIgcHVzaEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucHVzaEhvc3RDb250ZXh0LFxuICAgICAgcHVzaEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wdXNoSG9zdENvbnRhaW5lcjtcbiAgdmFyIGVudGVySHlkcmF0aW9uU3RhdGUgPSBoeWRyYXRpb25Db250ZXh0LmVudGVySHlkcmF0aW9uU3RhdGUsXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5yZXNldEh5ZHJhdGlvblN0YXRlLFxuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25Db250ZXh0LnRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gIHZhciBfUmVhY3RGaWJlckNsYXNzQ29tcG8gPSBSZWFjdEZpYmVyQ2xhc3NDb21wb25lbnQoc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLCBtZW1vaXplUHJvcHMsIG1lbW9pemVTdGF0ZSksXG4gICAgICBhZG9wdENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8uYWRvcHRDbGFzc0luc3RhbmNlLFxuICAgICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5jb25zdHJ1Y3RDbGFzc0luc3RhbmNlLFxuICAgICAgbW91bnRDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLm1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICAgIHVwZGF0ZUNsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8udXBkYXRlQ2xhc3NJbnN0YW5jZTtcblxuICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBhbmQgdXNlIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZSBkaXJlY3RseS5cblxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBmcmVzaCBuZXcgY29tcG9uZW50IHRoYXQgaGFzbid0IGJlZW4gcmVuZGVyZWQgeWV0LCB3ZVxuICAgICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgICAvLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbiAgICAgIC8vIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIHJlY29uY2lsaWF0aW9uIHBhc3MgYnkgbm90IHRyYWNraW5nIHNpZGUtZWZmZWN0cy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoaWxkIGlzIHRoZSBzYW1lIGFzIHRoZSB3b3JrIGluIHByb2dyZXNzLCBpdCBtZWFucyB0aGF0XG4gICAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgICAgLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cblxuICAgICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAgIC8vIGxldCdzIHRocm93IGl0IG91dC5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCAmJiAoIWN1cnJlbnQgfHwgY3VycmVudC5yZWYgIT09IHJlZikpIHtcbiAgICAgIC8vIFNjaGVkdWxlIGEgUmVmIGVmZmVjdFxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIGZuID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgdmFyIG1lbW9pemVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICAgIG5leHRQcm9wcyA9IG1lbW9pemVkUHJvcHM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXh0UHJvcHMgPT09IG51bGwgfHwgbWVtb2l6ZWRQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGJyaW5naW5nIGZuLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpIGJhY2suXG4gICAgICAvLyBJdCB1c2VkIHRvIGJlIGhlcmUuXG4gICAgfVxuXG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgdmFyIG5leHRDaGlsZHJlbjtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGZuKG5leHRQcm9wcywgY29udGV4dCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgdmFyIGhhc0NvbnRleHQgPSBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSB2b2lkIDA7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIGlmICghd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKSB7XG4gICAgICAgIC8vIEluIHRoZSBpbml0aWFsIHBhc3Mgd2UgbWlnaHQgbmVlZCB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlLlxuICAgICAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpO1xuICAgICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1Jlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC4nKTtcbiAgICAgICAgLy8gSW4gYSByZXN1bWUsIHdlJ2xsIGFscmVhZHkgaGF2ZSBhbiBpbnN0YW5jZSB3ZSBjYW4gcmV1c2UuXG4gICAgICAgIC8vIHNob3VsZFVwZGF0ZSA9IHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRVcGRhdGUgPSB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQpIHtcbiAgICAvLyBSZWZzIHNob3VsZCB1cGRhdGUgZXZlbiBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZVxuICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaWYgKCFzaG91bGRVcGRhdGUpIHtcbiAgICAgIC8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuICAgICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgLy8gUmVyZW5kZXJcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHZvaWQgMDtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICB9XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIC8vIE1lbW9pemUgcHJvcHMgYW5kIHN0YXRlIHVzaW5nIHRoZSB2YWx1ZXMgd2UganVzdCB1c2VkIHRvIHJlbmRlci5cbiAgICAvLyBUT0RPOiBSZXN0cnVjdHVyZSBzbyB3ZSBuZXZlciByZWFkIHZhbHVlcyBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnN0YXRlKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnByb3BzKTtcblxuICAgIC8vIFRoZSBjb250ZXh0IG1pZ2h0IGhhdmUgY2hhbmdlZCBzbyB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIGl0LlxuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaWYgKHJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QucGVuZGluZ0NvbnRleHQsIHJvb3QucGVuZGluZ0NvbnRleHQgIT09IHJvb3QuY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAgIC8vIFNob3VsZCBhbHdheXMgYmUgc2V0XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LmNvbnRleHQsIGZhbHNlKTtcbiAgICB9XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGFpbmVySW5mbyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgdmFyIHN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKHByZXZTdGF0ZSA9PT0gc3RhdGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIHN0YXRlIGlzIHRoZSBzYW1lIGFzIGJlZm9yZSwgdGhhdCdzIGEgYmFpbG91dCBiZWNhdXNlIHdlIGhhZFxuICAgICAgICAvLyBubyB3b3JrIHRoYXQgZXhwaXJlcyBhdCB0aGlzIHRpbWUuXG4gICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50O1xuICAgICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICBpZiAoKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkgJiYgcm9vdC5oeWRyYXRlICYmIGVudGVySHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IGN1cnJlbnQgY2hpbGRyZW4gdGhpcyBtaWdodCBiZSB0aGUgZmlyc3QgcGFzcy5cbiAgICAgICAgLy8gV2UgYWx3YXlzIHRyeSB0byBoeWRyYXRlLiBJZiB0aGlzIGlzbid0IGEgaHlkcmF0aW9uIHBhc3MgdGhlcmUgd29uJ3RcbiAgICAgICAgLy8gYmUgYW55IGNoaWxkcmVuIHRvIGh5ZHJhdGUgd2hpY2ggaXMgZWZmZWN0aXZlbHkgdGhlIHNhbWUgdGhpbmcgYXNcbiAgICAgICAgLy8gbm90IGh5ZHJhdGluZy5cblxuICAgICAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjay4gV2UgdHJhY2sgdGhlIGhvc3Qgcm9vdCBhcyBhIHBsYWNlbWVudCB0b1xuICAgICAgICAvLyBrbm93IHRoYXQgd2UncmUgY3VycmVudGx5IGluIGEgbW91bnRpbmcgc3RhdGUuIFRoYXQgd2F5IGlzTW91bnRlZFxuICAgICAgICAvLyB3b3JrcyBhcyBleHBlY3RlZC4gV2UgbXVzdCByZXNldCB0aGlzIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGxhY2VtZW50O1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IGNoaWxkcmVuIG1vdW50IGludG8gdGhpcyByb290IHdpdGhvdXQgdHJhY2tpbmdcbiAgICAgICAgLy8gc2lkZS1lZmZlY3RzLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBzdG9yZSBQbGFjZW1lbnQgZWZmZWN0cyBvblxuICAgICAgICAvLyBub2RlcyB0aGF0IHdpbGwgYmUgaHlkcmF0ZWQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgZWxlbWVudCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHJlc2V0IGh5ZHJhdGlvbiBzdGF0ZSBpbiBjYXNlIHdlIGFib3J0ZWQgYW5kIHJlc3VtZWQgYW5vdGhlclxuICAgICAgICAvLyByb290LlxuICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgc3RhdGUpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gdXBkYXRlIHF1ZXVlLCB0aGF0J3MgYSBiYWlsb3V0IGJlY2F1c2UgdGhlIHJvb3QgaGFzIG5vIHByb3BzLlxuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciBtZW1vaXplZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChuZXh0UHJvcHMgPT09IG51bGwpIHtcbiAgICAgIG5leHRQcm9wcyA9IG1lbW9pemVkUHJvcHM7XG4gICAgICAhKG5leHRQcm9wcyAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBzaG91bGQgYWx3YXlzIGhhdmUgcGVuZGluZyBvciBjdXJyZW50IHByb3BzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgcHJldlByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG5cbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAobmV4dFByb3BzID09PSBudWxsIHx8IG1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIGlzRGlyZWN0VGV4dENoaWxkID0gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgbmV4dFByb3BzKTtcblxuICAgIGlmIChpc0RpcmVjdFRleHRDaGlsZCkge1xuICAgICAgLy8gV2Ugc3BlY2lhbCBjYXNlIGEgZGlyZWN0IHRleHQgY2hpbGQgb2YgYSBob3N0IG5vZGUuIFRoaXMgaXMgYSBjb21tb25cbiAgICAgIC8vIGNhc2UuIFdlIHdvbid0IGhhbmRsZSBpdCBhcyBhIHJlaWZpZWQgY2hpbGQuIFdlIHdpbGwgaW5zdGVhZCBoYW5kbGVcbiAgICAgIC8vIHRoaXMgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQgdGhhdCBhbHNvIGhhdmUgYWNjZXNzIHRvIHRoaXMgcHJvcC4gVGhhdFxuICAgICAgLy8gYXZvaWRzIGFsbG9jYXRpbmcgYW5vdGhlciBIb3N0VGV4dCBmaWJlciBhbmQgdHJhdmVyc2luZyBpdC5cbiAgICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChwcmV2UHJvcHMgJiYgc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJldlByb3BzKSkge1xuICAgICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gYSBkaXJlY3QgdGV4dCBjaGlsZCB0byBhIG5vcm1hbCBjaGlsZCwgb3IgdG9cbiAgICAgIC8vIGVtcHR5LCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoZSB0ZXh0IGNvbnRlbnQgdG8gYmUgcmVzZXQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gQ29udGVudFJlc2V0O1xuICAgIH1cblxuICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGhvc3QgY29uZmlnIHRvIHNlZSBpZiB0aGUgY2hpbGRyZW4gYXJlIG9mZnNjcmVlbi9oaWRkZW4uXG4gICAgaWYgKHJlbmRlckV4cGlyYXRpb25UaW1lICE9PSBOZXZlciAmJiAhdXNlU3luY1NjaGVkdWxpbmcgJiYgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSh0eXBlLCBuZXh0UHJvcHMpKSB7XG4gICAgICAvLyBEb3duLXByaW9yaXRpemUgdGhlIGNoaWxkcmVuLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBOZXZlcjtcbiAgICAgIC8vIEJhaWxvdXQgYW5kIGNvbWUgYmFjayB0byB0aGlzIGZpYmVyIGxhdGVyLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIH1cbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgLy8gTm90aGluZyB0byBkbyBoZXJlLiBUaGlzIGlzIHRlcm1pbmFsLiBXZSdsbCBkbyB0aGUgY29tcGxldGlvbiBzdGVwXG4gICAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgIShjdXJyZW50ID09PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBuZXZlciBoYXZlIG1vdW50ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgdmFyIGZuID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgdmFyIHZhbHVlO1xuXG4gICAge1xuICAgICAgaWYgKGZuLnByb3RvdHlwZSAmJiB0eXBlb2YgZm4ucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCBcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFwiICsgJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHZhbHVlID0gZm4ocHJvcHMsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGNsYXNzIGluc3RhbmNlXG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDtcblxuICAgICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAgIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cbiAgICAgIHZhciBoYXNDb250ZXh0ID0gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHZhbHVlKTtcbiAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0cnVlLCBoYXNDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25hbENvbXBvbmVudDtcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm5pbmcoIUNvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb25hbCBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgICB2YXIgb3duZXJOYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWUoKTtcbiAgICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHdhcm5pbmdLZXkgPSBvd25lck5hbWUgfHwgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgfHwgJyc7XG4gICAgICAgICAgdmFyIGRlYnVnU291cmNlID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlO1xuICAgICAgICAgIGlmIChkZWJ1Z1NvdXJjZSkge1xuICAgICAgICAgICAgd2FybmluZ0tleSA9IGRlYnVnU291cmNlLmZpbGVOYW1lICsgJzonICsgZGVidWdTb3VyY2UubGluZU51bWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0pIHtcbiAgICAgICAgICAgIHdhcm5lZEFib3V0U3RhdGVsZXNzUmVmc1t3YXJuaW5nS2V5XSA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMuICcgKyAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4lcyVzJywgaW5mbywgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHZhbHVlKTtcbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgcHJvcHMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNhbGxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIG5leHRDYWxsID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENhbGwgPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENhbGwgPSBjdXJyZW50ICYmIGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgIShuZXh0Q2FsbCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBzaG91bGQgYWx3YXlzIGhhdmUgcGVuZGluZyBvciBjdXJyZW50IHByb3BzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENhbGwgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENhbGwpIHtcbiAgICAgIG5leHRDYWxsID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgIC8vIFRPRE86IFdoZW4gYmFpbGluZyBvdXQsIHdlIG1pZ2h0IG5lZWQgdG8gcmV0dXJuIHRoZSBzdGF0ZU5vZGUgaW5zdGVhZFxuICAgICAgLy8gb2YgdGhlIGNoaWxkLiBUbyBjaGVjayBpdCBmb3Igd29yay5cbiAgICAgIC8vIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dENhbGwuY2hpbGRyZW47XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGEgZm9yayBvZiByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUgYnV0IHVzaW5nXG4gICAgLy8gc3RhdGVOb2RlIHRvIHN0b3JlIHRoZSBjaGlsZC5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2FsbCk7XG4gICAgLy8gVGhpcyBkb2Vzbid0IHRha2UgYXJiaXRyYXJ5IHRpbWUgc28gd2UgY291bGQgc3luY2hyb25vdXNseSBqdXN0IGJlZ2luXG4gICAgLy8gZWFnZXJseSBkbyB0aGUgd29yayBvZiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCBhcyBhbiBvcHRpbWl6YXRpb24uXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gY3VycmVudCAmJiBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICEobmV4dENoaWxkcmVuICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gUG9ydGFscyBhcmUgc3BlY2lhbCBiZWNhdXNlIHdlIGRvbid0IGFwcGVuZCB0aGUgY2hpbGRyZW4gZHVyaW5nIG1vdW50XG4gICAgICAvLyBidXQgYXQgY29tbWl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byB0cmFjayBpbnNlcnRpb25zIHdoaWNoIHRoZSBub3JtYWxcbiAgICAgIC8vIGZsb3cgZG9lc24ndCBkbyBkdXJpbmcgbW91bnQuIFRoaXMgZG9lc24ndCBoYXBwZW4gYXQgdGhlIHJvb3QgYmVjYXVzZVxuICAgICAgLy8gdGhlIHJvb3QgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgXCJjdXJyZW50XCIgd2l0aCBhIG51bGwgY2hpbGQuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICAvKlxuICBmdW5jdGlvbiByZXVzZUNoaWxkcmVuRWZmZWN0cyhyZXR1cm5GaWJlciA6IEZpYmVyLCBmaXJzdENoaWxkIDogRmliZXIpIHtcbiAgICBsZXQgY2hpbGQgPSBmaXJzdENoaWxkO1xuICAgIGRvIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBmaXJzdCBhbmQgbGFzdCBlZmZlY3Qgb2YgdGhlIHBhcmVudCBjb3JyZXNwb25kc1xuICAgICAgLy8gdG8gdGhlIGNoaWxkcmVuJ3MgZmlyc3QgYW5kIGxhc3QgZWZmZWN0LlxuICAgICAgaWYgKCFyZXR1cm5GaWJlci5maXJzdEVmZmVjdCkge1xuICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IGNoaWxkLmZpcnN0RWZmZWN0O1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmxhc3RFZmZlY3QpIHtcbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QpIHtcbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZC5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGQubGFzdEVmZmVjdDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChjaGlsZCA9IGNoaWxkLnNpYmxpbmcpO1xuICB9XG4gICovXG5cbiAgZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGNhbmNlbFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgaWRlYWxseSBiZSBhYmxlIHRvIGJhaWwgb3V0IGVhcmx5IGlmIHRoZSBjaGlsZHJlbiBoYXZlIG5vXG4gICAgLy8gbW9yZSB3b3JrIHRvIGRvLiBIb3dldmVyLCBzaW5jZSB3ZSBkb24ndCBoYXZlIGEgc2VwYXJhdGlvbiBvZiB0aGlzXG4gICAgLy8gRmliZXIncyBwcmlvcml0eSBhbmQgaXRzIGNoaWxkcmVuIHlldCAtIHdlIGRvbid0IGtub3cgd2l0aG91dCBkb2luZyBsb3RzXG4gICAgLy8gb2YgdGhlIHNhbWUgd29yayB3ZSBkbyBhbnl3YXkuIE9uY2Ugd2UgaGF2ZSB0aGF0IHNlcGFyYXRpb24gd2UgY2FuIGp1c3RcbiAgICAvLyBiYWlsIG91dCBoZXJlIGlmIHRoZSBjaGlsZHJlbiBoYXMgbm8gbW9yZSB3b3JrIGF0IHRoaXMgcHJpb3JpdHkgbGV2ZWwuXG4gICAgLy8gaWYgKHdvcmtJblByb2dyZXNzLnByaW9yaXR5T2ZDaGlsZHJlbiA8PSBwcmlvcml0eUxldmVsKSB7XG4gICAgLy8gICAvLyBJZiB0aGVyZSBhcmUgc2lkZS1lZmZlY3RzIGluIHRoZXNlIGNoaWxkcmVuIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW5cbiAgICAvLyAgIC8vIGNvbW1pdHRlZCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHRoZXkgZ2V0IHByb3Blcmx5IHRyYW5zZmVycmVkIHVwLlxuICAgIC8vICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5jaGlsZCAhPT0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpIHtcbiAgICAvLyAgICAgcmV1c2VDaGlsZHJlbkVmZmVjdHMod29ya0luUHJvZ3Jlc3MsIGNoaWxkKTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIHJldHVybiBudWxsO1xuICAgIC8vIH1cblxuICAgIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhaWxvdXRPbkxvd1ByaW9yaXR5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgY2FuY2VsV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIFRPRE86IEhhbmRsZSBIb3N0Q29tcG9uZW50IHRhZ3MgaGVyZSBhcyB3ZWxsIGFuZCBjYWxsIHB1c2hIb3N0Q29udGV4dCgpP1xuICAgIC8vIFNlZSBQUiA4NTkwIGRpc2N1c3Npb24gZm9yIGNvbnRleHRcbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gVE9ETzogV2hhdCBpZiB0aGlzIGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcz9cbiAgICAvLyBIb3cgY2FuIHRoYXQgaGFwcGVuPyBIb3cgaXMgdGhpcyBub3QgYmVpbmcgY2xvbmVkP1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gVE9ETzogRGVsZXRlIG1lbW9pemVQcm9wcy9TdGF0ZSBhbmQgbW92ZSB0byByZWNvbmNpbGUvYmFpbG91dCBpbnN0ZWFkXG4gIGZ1bmN0aW9uIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFN0YXRlKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAvLyBEb24ndCByZXNldCB0aGUgdXBkYXRlUXVldWUsIGluIGNhc2UgdGhlcmUgYXJlIHBlbmRpbmcgdXBkYXRlcy4gUmVzZXR0aW5nXG4gICAgLy8gaXMgaGFuZGxlZCBieSBwcm9jZXNzVXBkYXRlUXVldWUuXG4gIH1cblxuICBmdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkxvd1ByaW9yaXR5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgY2FzZSBDYWxsSGFuZGxlclBoYXNlOlxuICAgICAgICAvLyBUaGlzIGlzIGEgcmVzdGFydC4gUmVzZXQgdGhlIHRhZyB0byB0aGUgaW5pdGlhbCBwaGFzZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbENvbXBvbmVudDtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoIHNpbmNlIHRoaXMgaXMgbm93IHRoZSBzYW1lLlxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgICAgIC8vIEEgcmV0dXJuIGNvbXBvbmVudCBpcyBqdXN0IGEgcGxhY2Vob2xkZXIsIHdlIGNhbiBqdXN0IHJ1biB0aHJvdWdoIHRoZVxuICAgICAgICAvLyBuZXh0IG9uZSBpbW1lZGlhdGVseS5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5GYWlsZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgaGVyZSB0byBhdm9pZCBhIHB1c2gvcG9wIGNvbnRleHQgbWlzbWF0Y2guXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdHlwZSBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbiBlcnJvciBlZmZlY3Qgc28gd2UgY2FuIGhhbmRsZSB0aGUgZXJyb3IgZHVyaW5nIHRoZSBjb21taXQgcGhhc2VcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gRXJyO1xuXG4gICAgLy8gVGhpcyBpcyBhIHdlaXJkIGNhc2Ugd2hlcmUgd2UgZG8gXCJyZXN1bWVcIiB3b3JrIOKAlCB3b3JrIHRoYXQgZmFpbGVkIG9uXG4gICAgLy8gb3VyIGZpcnN0IGF0dGVtcHQuIEJlY2F1c2Ugd2Ugbm8gbG9uZ2VyIGhhdmUgYSBub3Rpb24gb2YgXCJwcm9ncmVzc2VkXG4gICAgLy8gZGVsZXRpb25zLFwiIHJlc2V0IHRoZSBjaGlsZCB0byB0aGUgY3VycmVudCBjaGlsZCB0byBtYWtlIHN1cmUgd2UgZGVsZXRlXG4gICAgLy8gaXQgYWdhaW4uIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLCBwZXJoYXBzIGR1cmluZyBhIG1vcmVcbiAgICAvLyBnZW5lcmFsIG92ZXJoYXVsIG9mIGVycm9yIGhhbmRsaW5nLlxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudC5jaGlsZCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZG9uJ3QgYmFpbCBvdXQsIHdlJ3JlIGdvaW5nIGJlIHJlY29tcHV0aW5nIG91ciBjaGlsZHJlbiBzbyB3ZSBuZWVkXG4gICAgLy8gdG8gZHJvcCBvdXIgZWZmZWN0IGxpc3QuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gICAgLy8gVW5tb3VudCB0aGUgY3VycmVudCBjaGlsZHJlbiBhcyBpZiB0aGUgY29tcG9uZW50IHJlbmRlcmVkIG51bGxcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcztcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJlZ2luV29yazogYmVnaW5Xb3JrLFxuICAgIGJlZ2luRmFpbGVkV29yazogYmVnaW5GYWlsZWRXb3JrXG4gIH07XG59O1xuXG52YXIgUmVhY3RGaWJlckNvbXBsZXRlV29yayA9IGZ1bmN0aW9uIChjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0KSB7XG4gIHZhciBjcmVhdGVJbnN0YW5jZSA9IGNvbmZpZy5jcmVhdGVJbnN0YW5jZSxcbiAgICAgIGNyZWF0ZVRleHRJbnN0YW5jZSA9IGNvbmZpZy5jcmVhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBhcHBlbmRJbml0aWFsQ2hpbGQgPSBjb25maWcuYXBwZW5kSW5pdGlhbENoaWxkLFxuICAgICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4gPSBjb25maWcuZmluYWxpemVJbml0aWFsQ2hpbGRyZW4sXG4gICAgICBwcmVwYXJlVXBkYXRlID0gY29uZmlnLnByZXBhcmVVcGRhdGUsXG4gICAgICBtdXRhdGlvbiA9IGNvbmZpZy5tdXRhdGlvbixcbiAgICAgIHBlcnNpc3RlbmNlID0gY29uZmlnLnBlcnNpc3RlbmNlO1xuICB2YXIgZ2V0Um9vdEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5nZXRSb290SG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICBnZXRIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LmdldEhvc3RDb250ZXh0LFxuICAgICAgcG9wSG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250YWluZXI7XG4gIHZhciBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlLFxuICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb25Db250ZXh0LnByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLFxuICAgICAgcG9wSHlkcmF0aW9uU3RhdGUgPSBoeWRyYXRpb25Db250ZXh0LnBvcEh5ZHJhdGlvblN0YXRlO1xuXG5cbiAgZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFRhZyB0aGUgZmliZXIgd2l0aCBhbiB1cGRhdGUgZWZmZWN0LiBUaGlzIHR1cm5zIGEgUGxhY2VtZW50IGludG9cbiAgICAvLyBhbiBVcGRhdGVBbmRQbGFjZW1lbnQuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdBIGNhbGwgY2Fubm90IGhhdmUgaG9zdCBjb21wb25lbnQgY2hpbGRyZW4uJyk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJucy5wdXNoKG5vZGUudHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlQ2FsbFRvSGFuZGxlclBoYXNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBjYWxsID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAhY2FsbCA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBiZSByZXNvbHZlZCBieSBub3cuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICAvLyBGaXJzdCBzdGVwIG9mIHRoZSBjYWxsIGhhcyBjb21wbGV0ZWQuIE5vdyB3ZSBuZWVkIHRvIGRvIHRoZSBzZWNvbmQuXG4gICAgLy8gVE9ETzogSXQgd291bGQgYmUgbmljZSB0byBoYXZlIGEgbXVsdGkgc3RhZ2UgY2FsbCByZXByZXNlbnRlZCBieSBhXG4gICAgLy8gc2luZ2xlIGNvbXBvbmVudCwgb3IgYXQgbGVhc3QgdGFpbCBjYWxsIG9wdGltaXplIG5lc3RlZCBvbmVzLiBDdXJyZW50bHlcbiAgICAvLyB0aGF0IHJlcXVpcmVzIGFkZGl0aW9uYWwgZmllbGRzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byBhZGQgdG8gdGhlIGZpYmVyLlxuICAgIC8vIFNvIHRoaXMgcmVxdWlyZXMgbmVzdGVkIGhhbmRsZXJzLlxuICAgIC8vIE5vdGU6IFRoaXMgZG9lc24ndCBtdXRhdGUgdGhlIGFsdGVybmF0ZSBub2RlLiBJIGRvbid0IHRoaW5rIGl0IG5lZWRzIHRvXG4gICAgLy8gc2luY2UgdGhpcyBzdGFnZSBpcyByZXNldCBmb3IgZXZlcnkgcGFzcy5cbiAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDYWxsSGFuZGxlclBoYXNlO1xuXG4gICAgLy8gQnVpbGQgdXAgdGhlIHJldHVybnMuXG4gICAgLy8gVE9ETzogQ29tcGFyZSB0aGlzIHRvIGEgZ2VuZXJhdG9yIG9yIG9wYXF1ZSBoZWxwZXJzIGxpa2UgQ2hpbGRyZW4uXG4gICAgdmFyIHJldHVybnMgPSBbXTtcbiAgICBhcHBlbmRBbGxSZXR1cm5zKHJldHVybnMsIHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgZm4gPSBjYWxsLmhhbmRsZXI7XG4gICAgdmFyIHByb3BzID0gY2FsbC5wcm9wcztcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gZm4ocHJvcHMsIHJldHVybnMpO1xuXG4gICAgdmFyIGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQuY2hpbGQgOiBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVIb3N0Q29udGFpbmVyID0gdm9pZCAwO1xuICB2YXIgdXBkYXRlSG9zdENvbXBvbmVudCA9IHZvaWQgMDtcbiAgdmFyIHVwZGF0ZUhvc3RUZXh0ID0gdm9pZCAwO1xuICBpZiAobXV0YXRpb24pIHtcbiAgICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyKSB7XG4gICAgICAvLyBNdXRhdGlvbiBtb2RlXG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgICAgICAvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAgICAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAgICAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpcyBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgICAgIGlmICh1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0VGV4dCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgICAgICAvLyBJZiB0aGUgdGV4dCBkaWZmZXJzLCBtYXJrIGl0IGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGluIGRvbmUgaW4gY29tbWl0V29yay5cbiAgICAgICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTXV0YXRpbmcgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIFBlcnNpc3RlbnQgaG9zdCB0cmVlIG1vZGVcbiAgICAgIHZhciBjbG9uZUluc3RhbmNlID0gcGVyc2lzdGVuY2UuY2xvbmVJbnN0YW5jZSxcbiAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuID0gcGVyc2lzdGVuY2UuZmluYWxpemVDb250YWluZXJDaGlsZHJlbjtcblxuICAgICAgLy8gQW4gdW5mb3J0dW5hdGUgZm9yayBvZiBhcHBlbmRBbGxDaGlsZHJlbiBiZWNhdXNlIHdlIGhhdmUgdHdvIGRpZmZlcmVudCBwYXJlbnQgdHlwZXMuXG5cbiAgICAgIHZhciBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lckNoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICAgICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgICAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3J0YWwgY2hpbGQsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHZhciBwb3J0YWxPclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjaGlsZHJlblVuY2hhbmdlZCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID09PSBudWxsO1xuICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm87XG4gICAgICAgICAgdmFyIG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyKTtcbiAgICAgICAgICBpZiAoZmluYWxpemVDb250YWluZXJDaGlsZHJlbihjb250YWluZXIsIG5ld0NoaWxkU2V0KSkge1xuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW4gPSBuZXdDaGlsZFNldDtcbiAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihuZXdDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSBvbiB0aGUgY29udGFpbmVyIHRvIHN3YXAgb3V0IHRoZSBjb250YWluZXIuXG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCB0aGVuIG5vbmUgb2Ygb3VyIGNoaWxkcmVuIGhhZCBhbnkgdXBkYXRlcy5cbiAgICAgICAgLy8gVGhpcyBndWFyYW50ZWVzIHRoYXQgd2UgY2FuIHJldXNlIGFsbCBvZiB0aGVtLlxuICAgICAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQgJiYgdXBkYXRlUGF5bG9hZCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1pZ2h0IHJlbGVhc2UgYSBwcmV2aW91cyBjbG9uZS5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlY3ljbGFibGVJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgbmV3SW5zdGFuY2UgPSBjbG9uZUluc3RhbmNlKGN1cnJlbnRJbnN0YW5jZSwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGRyZW5VbmNoYW5nZWQsIHJlY3ljbGFibGVJbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKG5ld0luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5ld0luc3RhbmNlO1xuICAgICAgICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG90aGVyIGVmZmVjdHMgaW4gdGhpcyB0cmVlLCB3ZSBuZWVkIHRvIGZsYWcgdGhpcyBub2RlIGFzIGhhdmluZyBvbmUuXG4gICAgICAgICAgICAvLyBFdmVuIHRob3VnaCB3ZSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0IGZvciBhbnl0aGluZy5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBwYXJlbnRzIHdvbid0IGtub3cgdGhhdCB0aGVyZSBhcmUgbmV3IGNoaWxkcmVuIHRvIHByb3BhZ2F0ZSB1cHdhcmRzLlxuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cbiAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5ld0luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgdGV4dCBjb250ZW50IGRpZmZlcnMsIHdlJ2xsIGNyZWF0ZSBhIG5ldyB0ZXh0IGluc3RhbmNlIGZvciBpdC5cbiAgICAgICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAvLyBXZSdsbCBoYXZlIHRvIG1hcmsgaXQgYXMgaGF2aW5nIGFuIGVmZmVjdCwgZXZlbiB0aG91Z2ggd2Ugd29uJ3QgdXNlIHRoZSBlZmZlY3QgZm9yIGFueXRoaW5nLlxuICAgICAgICAgIC8vIFRoaXMgbGV0cyB0aGUgcGFyZW50cyBrbm93IHRoYXQgYXQgbGVhc3Qgb25lIG9mIHRoZWlyIGNoaWxkcmVuIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdQZXJzaXN0ZW50IHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChlbmFibGVOb29wUmVjb25jaWxlcikge1xuICAgICAgLy8gTm8gaG9zdCBvcGVyYXRpb25zXG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBHZXQgdGhlIGxhdGVzdCBwcm9wcy5cbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKG5ld1Byb3BzID09PSBudWxsKSB7XG4gICAgICBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgfHwgcmVuZGVyRXhwaXJhdGlvblRpbWUgPT09IE5ldmVyKSB7XG4gICAgICAvLyBSZXNldCB0aGUgcGVuZGluZyBwcm9wcywgdW5sZXNzIHRoaXMgd2FzIGEgZG93bi1wcmlvcml0aXphdGlvbi5cbiAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gICAgfVxuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgYXJlIGxlYXZpbmcgdGhpcyBzdWJ0cmVlLCBzbyBwb3AgY29udGV4dCBpZiBhbnkuXG4gICAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgdmFyIGZpYmVyUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoZmliZXJSb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBmaWJlclJvb3QuY29udGV4dCA9IGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dDtcbiAgICAgICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgICAgLy8gdGhhdCB3ZXJlbid0IGh5ZHJhdGVkLlxuICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgLy8gVGhpcyByZXNldHMgdGhlIGhhY2t5IHN0YXRlIHRvIGZpeCBpc01vdW50ZWQgYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIC8vIElmIHdlIGdldCB1cGRhdGVkIGJlY2F1c2Ugb25lIG9mIG91ciBjaGlsZHJlbiB1cGRhdGVkLCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gaGF2ZSBuZXdQcm9wcyBzbyB3ZSdsbCBoYXZlIHRvIHJldXNlIHRoZW0uXG4gICAgICAgICAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAgICAgICAgIC8vIEV2ZW4gYmV0dGVyIHdvdWxkIGJlIGlmIGNoaWxkcmVuIHdlcmVuJ3Qgc3BlY2lhbCBjYXNlZCBhdCBhbGwgdGhvLlxuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IHByZXBhcmVVcGRhdGUoaW5zdGFuY2UsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpO1xuXG4gICAgICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50LnJlZiAhPT0gd29ya0luUHJvZ3Jlc3MucmVmKSB7XG4gICAgICAgICAgICAgIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcbiAgICAgICAgICAgIC8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcbiAgICAgICAgICAgIC8vIG9yIGNvbXBsZXRlV29yayBkZXBlbmRpbmcgb24gd2Ugd2FudCB0byBhZGQgdGhlbiB0b3AtPmRvd24gb3JcbiAgICAgICAgICAgIC8vIGJvdHRvbS0+dXAuIFRvcC0+ZG93biBpcyBmYXN0ZXIgaW4gSUUxMS5cbiAgICAgICAgICAgIHZhciB3YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGlmICh3YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYW5kIGNyZWF0ZUluc3RhbmNlIHN0ZXAgaW50byB0aGUgYmVnaW5QaGFzZVxuICAgICAgICAgICAgICAvLyB0byBjb25zb2xpZGF0ZS5cbiAgICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2VzIHRvIHRoZSBoeWRyYXRlZCBub2RlIG5lZWRzIHRvIGJlIGFwcGxpZWQgYXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY29tbWl0LXBoYXNlIHdlIG1hcmsgdGhpcyBhcyBzdWNoLlxuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKF9pbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgIC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHN1Y2ggcmVuZGVyZXJzIGdldCBzY2hlZHVsZWQgZm9yIGxhdGVyIHdvcmsuXG4gICAgICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihfaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gX2luc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVmIG9uIGEgaG9zdCBub2RlIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuICAgICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyB0byBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgICAgICAgICAgdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld1RleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQyID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIHZhciBfd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQyLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBtb3ZlQ2FsbFRvSGFuZGxlclBoYXNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIENhbGxIYW5kbGVyUGhhc2U6XG4gICAgICAgIC8vIFJlc2V0IHRoZSB0YWcgdG8gbm93IGJlIGEgZmlyc3QgcGhhc2UgY2FsbC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbENvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIFJldHVybkNvbXBvbmVudDpcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgLy8gRXJyb3IgY2FzZXNcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgc2hvdWxkIGhhdmUgYmVjb21lIGRldGVybWluYXRlIGJlZm9yZSBjb21wbGV0aW5nLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wbGV0ZVdvcms6IGNvbXBsZXRlV29ya1xuICB9O1xufTtcblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayQyID0gUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbnZhciBoYXNDYXVnaHRFcnJvciQxID0gUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yO1xudmFyIGNsZWFyQ2F1Z2h0RXJyb3IkMSA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yO1xuXG5cbnZhciBSZWFjdEZpYmVyQ29tbWl0V29yayA9IGZ1bmN0aW9uIChjb25maWcsIGNhcHR1cmVFcnJvcikge1xuICB2YXIgZ2V0UHVibGljSW5zdGFuY2UgPSBjb25maWcuZ2V0UHVibGljSW5zdGFuY2UsXG4gICAgICBtdXRhdGlvbiA9IGNvbmZpZy5tdXRhdGlvbixcbiAgICAgIHBlcnNpc3RlbmNlID0gY29uZmlnLnBlcnNpc3RlbmNlO1xuXG5cbiAgdmFyIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciA9IGZ1bmN0aW9uIChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcihjdXJyZW50LCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gIH07XG5cbiAgLy8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgdW5tb3VudGluZy5cbiAgZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyLCBudWxsLCBjdXJyZW50LCBpbnN0YW5jZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IkMSgpKSB7XG4gICAgICAgIHZhciB1bm1vdW50RXJyb3IgPSBjbGVhckNhdWdodEVycm9yJDEoKTtcbiAgICAgICAgY2FwdHVyZUVycm9yKGN1cnJlbnQsIHVubW91bnRFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMihudWxsLCByZWYsIG51bGwsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IkMSgpKSB7XG4gICAgICAgICAgdmFyIHJlZkVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgICAgY2FwdHVyZUVycm9yKGN1cnJlbnQsIHJlZkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdExpZmVDeWNsZXMoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZE1vdW50Jyk7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBzdGFydFBoYXNlVGltZXIoZmluaXNoZWRXb3JrLCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICAgICAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbW1pdENhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3VwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGlmIChfdXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuY2hpbGQgIT09IG51bGwgPyBmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlIDogbnVsbDtcbiAgICAgICAgICAgIGNvbW1pdENhbGxiYWNrcyhfdXBkYXRlUXVldWUsIF9pbnN0YW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgLy8gUmVuZGVyZXJzIG1heSBzY2hlZHVsZSB3b3JrIHRvIGJlIGRvbmUgYWZ0ZXIgaG9zdCBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4gICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBtYXkgc2NoZWR1bGUgYXV0by1mb2N1cyBmb3IgaW5wdXRzIGFuZCBmb3JtIGNvbnRyb2xzKS5cbiAgICAgICAgICAvLyBUaGVzZSBlZmZlY3RzIHNob3VsZCBvbmx5IGJlIGNvbW1pdHRlZCB3aGVuIGNvbXBvbmVudHMgYXJlIGZpcnN0IG1vdW50ZWQsXG4gICAgICAgICAgLy8gYWthIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudC9hbHRlcm5hdGUuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgY29tbWl0TW91bnQoX2luc3RhbmNlMiwgdHlwZSwgcHJvcHMsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggdGV4dC5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHBvcnRhbHMuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBdHRhY2hSZWYoZmluaXNoZWRXb3JrKSB7XG4gICAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgcmVmKGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVmKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCkge1xuICAgIHZhciBjdXJyZW50UmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKGN1cnJlbnRSZWYgIT09IG51bGwpIHtcbiAgICAgIGN1cnJlbnRSZWYobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlci1vcmlnaW5hdGluZyBlcnJvcnMgKGxpZmVjeWNsZXMgYW5kIHJlZnMpIHNob3VsZCBub3QgaW50ZXJydXB0XG4gIC8vIGRlbGV0aW9uLCBzbyBkb24ndCBsZXQgdGhlbSB0aHJvdy4gSG9zdC1vcmlnaW5hdGluZyBlcnJvcnMgc2hvdWxkXG4gIC8vIGludGVycnVwdCBkZWxldGlvbiwgc28gaXQncyBva2F5XG4gIGZ1bmN0aW9uIGNvbW1pdFVubW91bnQoY3VycmVudCkge1xuICAgIGlmICh0eXBlb2Ygb25Db21taXRVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvbkNvbW1pdFVubW91bnQoY3VycmVudCk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjdXJyZW50LnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50KTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQuc3RhdGVOb2RlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRPRE86IHRoaXMgaXMgcmVjdXJzaXZlLlxuICAgICAgICAgIC8vIFdlIGFyZSBhbHNvIG5vdCB1c2luZyB0aGlzIHBhcmVudCBiZWNhdXNlXG4gICAgICAgICAgLy8gdGhlIHBvcnRhbCB3aWxsIGdldCBwdXNoZWQgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlciAmJiBtdXRhdGlvbikge1xuICAgICAgICAgICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgJiYgcGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgIGVtcHR5UG9ydGFsQ29udGFpbmVyKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXROZXN0ZWRVbm1vdW50cyhyb290KSB7XG4gICAgLy8gV2hpbGUgd2UncmUgaW5zaWRlIGEgcmVtb3ZlZCBob3N0IG5vZGUgd2UgZG9uJ3Qgd2FudCB0byBjYWxsXG4gICAgLy8gcmVtb3ZlQ2hpbGQgb24gdGhlIGlubmVyIG5vZGVzIGJlY2F1c2UgdGhleSdyZSByZW1vdmVkIGJ5IHRoZSB0b3BcbiAgICAvLyBjYWxsIGFueXdheS4gV2UgYWxzbyB3YW50IHRvIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQgb24gYWxsXG4gICAgLy8gY29tcG9zaXRlcyBiZWZvcmUgdGhpcyBob3N0IG5vZGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlLiBUaGVyZWZvcmVcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbW1pdFVubW91bnQobm9kZSk7XG4gICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHRoZXkgbWF5IGNvbnRhaW4gbW9yZSBjb21wb3NpdGUgb3IgaG9zdCBub2Rlcy5cbiAgICAgIC8vIFNraXAgcG9ydGFscyBiZWNhdXNlIGNvbW1pdFVubW91bnQoKSBjdXJyZW50bHkgdmlzaXRzIHRoZW0gcmVjdXJzaXZlbHkuXG4gICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCAmJiAoXG4gICAgICAvLyBJZiB3ZSB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgdXNpbmcgY29tbWl0VW5tb3VudCBhYm92ZS5cbiAgICAgIC8vIElmIHdlIGRvbid0IHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyBoZXJlIGluc3RlYWQuXG4gICAgICAhbXV0YXRpb24gfHwgbm9kZS50YWcgIT09IEhvc3RQb3J0YWwpKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHJvb3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHJvb3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hGaWJlcihjdXJyZW50KSB7XG4gICAgLy8gQ3V0IG9mZiB0aGUgcmV0dXJuIHBvaW50ZXJzIHRvIGRpc2Nvbm5lY3QgaXQgZnJvbSB0aGUgdHJlZS4gSWRlYWxseSwgd2VcbiAgICAvLyBzaG91bGQgY2xlYXIgdGhlIGNoaWxkIHBvaW50ZXIgb2YgdGhlIHBhcmVudCBhbHRlcm5hdGUgdG8gbGV0IHRoaXNcbiAgICAvLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG4gICAgLy8gb25lIHNvIHdlJ2xsIHNldHRsZSBmb3IgR0M6aW5nIHRoZSBzdWJ0cmVlIG9mIHRoaXMgY2hpbGQuIFRoaXMgY2hpbGRcbiAgICAvLyBpdHNlbGYgd2lsbCBiZSBHQzplZCB3aGVuIHRoZSBwYXJlbnQgdXBkYXRlcyB0aGUgbmV4dCB0aW1lLlxuICAgIGN1cnJlbnRbJ3JldHVybiddID0gbnVsbDtcbiAgICBjdXJyZW50LmNoaWxkID0gbnVsbDtcbiAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUpIHtcbiAgICAgIGN1cnJlbnQuYWx0ZXJuYXRlLmNoaWxkID0gbnVsbDtcbiAgICAgIGN1cnJlbnQuYWx0ZXJuYXRlWydyZXR1cm4nXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFtdXRhdGlvbikge1xuICAgIHZhciBjb21taXRDb250YWluZXIgPSB2b2lkIDA7XG4gICAgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgICB2YXIgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuID0gcGVyc2lzdGVuY2UucmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuLFxuICAgICAgICAgIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gcGVyc2lzdGVuY2UuY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQ7XG5cbiAgICAgIHZhciBlbXB0eVBvcnRhbENvbnRhaW5lciA9IGZ1bmN0aW9uIChjdXJyZW50KSB7XG4gICAgICAgIHZhciBwb3J0YWwgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWwuY29udGFpbmVySW5mbztcblxuICAgICAgICB2YXIgZW1wdHlDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckluZm8pO1xuICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgZW1wdHlDaGlsZFNldCk7XG4gICAgICB9O1xuICAgICAgY29tbWl0Q29udGFpbmVyID0gZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge1xuICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWxPclJvb3QuY29udGFpbmVySW5mbyxcbiAgICAgICAgICAgICAgICAgIF9wZW5kaW5nQ2hpbGRyZW4gPSBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuO1xuXG4gICAgICAgICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBfcGVuZGluZ0NoaWxkcmVuKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRDb250YWluZXIgPSBmdW5jdGlvbiAoZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChlbmFibGVQZXJzaXN0ZW50UmVjb25jaWxlciB8fCBlbmFibGVOb29wUmVjb25jaWxlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge30sXG4gICAgICAgIGNvbW1pdFBsYWNlbWVudDogZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge30sXG4gICAgICAgIGNvbW1pdERlbGV0aW9uOiBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgICAgICAgY29tbWl0TmVzdGVkVW5tb3VudHMoY3VycmVudCk7XG4gICAgICAgICAgZGV0YWNoRmliZXIoY3VycmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1pdFdvcms6IGZ1bmN0aW9uIChjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21taXRMaWZlQ3ljbGVzOiBjb21taXRMaWZlQ3ljbGVzLFxuICAgICAgICBjb21taXRBdHRhY2hSZWY6IGNvbW1pdEF0dGFjaFJlZixcbiAgICAgICAgY29tbWl0RGV0YWNoUmVmOiBjb21taXREZXRhY2hSZWZcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnUGVyc2lzdGVudCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdOb29wIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9XG4gIHZhciBjb21taXRNb3VudCA9IG11dGF0aW9uLmNvbW1pdE1vdW50LFxuICAgICAgY29tbWl0VXBkYXRlID0gbXV0YXRpb24uY29tbWl0VXBkYXRlLFxuICAgICAgcmVzZXRUZXh0Q29udGVudCA9IG11dGF0aW9uLnJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRUZXh0VXBkYXRlID0gbXV0YXRpb24uY29tbWl0VGV4dFVwZGF0ZSxcbiAgICAgIGFwcGVuZENoaWxkID0gbXV0YXRpb24uYXBwZW5kQ2hpbGQsXG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyID0gbXV0YXRpb24uYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcixcbiAgICAgIGluc2VydEJlZm9yZSA9IG11dGF0aW9uLmluc2VydEJlZm9yZSxcbiAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlID0gbXV0YXRpb24uaW5zZXJ0SW5Db250YWluZXJCZWZvcmUsXG4gICAgICByZW1vdmVDaGlsZCA9IG11dGF0aW9uLnJlbW92ZUNoaWxkLFxuICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyID0gbXV0YXRpb24ucmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyO1xuXG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFBhcmVudEZpYmVyKGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudCA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcikge1xuICAgIHJldHVybiBmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBIb3N0Um9vdCB8fCBmaWJlci50YWcgPT09IEhvc3RQb3J0YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIb3N0U2libGluZyhmaWJlcikge1xuICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuICAgIC8vIG5vZGUuIFVuZm9ydHVuYXRlbHksIGlmIG11bHRpcGxlIGluc2VydGlvbnMgYXJlIGRvbmUgaW4gYSByb3cgd2UgaGF2ZSB0b1xuICAgIC8vIHNlYXJjaCBwYXN0IHRoZW0uIFRoaXMgbGVhZHMgdG8gZXhwb25lbnRpYWwgc2VhcmNoIGZvciB0aGUgbmV4dCBzaWJsaW5nLlxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgc2libGluZ3M6IHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZywgbGV0J3MgdHJ5IHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBpc0hvc3RQYXJlbnQobm9kZVsncmV0dXJuJ10pKSB7XG4gICAgICAgICAgLy8gSWYgd2UgcG9wIG91dCBvZiB0aGUgcm9vdCBvciBoaXQgdGhlIHBhcmVudCB0aGUgZmliZXIgd2UgYXJlIHRoZVxuICAgICAgICAgIC8vIGxhc3Qgc2libGluZy5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIG5vZGUudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgICAvLyBJZiBpdCBpcyBub3QgaG9zdCBub2RlIGFuZCwgd2UgbWlnaHQgaGF2ZSBhIGhvc3Qgbm9kZSBpbnNpZGUgaXQuXG4gICAgICAgIC8vIFRyeSB0byBzZWFyY2ggZG93biB1bnRpbCB3ZSBmaW5kIG9uZS5cbiAgICAgICAgaWYgKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSB7XG4gICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAgIC8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG4gICAgICAgIGlmIChub2RlLmNoaWxkID09PSBudWxsIHx8IG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGhvc3Qgbm9kZSBpcyBzdGFibGUgb3IgYWJvdXQgdG8gYmUgcGxhY2VkLlxuICAgICAgaWYgKCEobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpKSB7XG4gICAgICAgIC8vIEZvdW5kIGl0IVxuICAgICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGluc2VydCBhbGwgaG9zdCBub2RlcyBpbnRvIHRoZSBwYXJlbnQuXG4gICAgdmFyIHBhcmVudEZpYmVyID0gZ2V0SG9zdFBhcmVudEZpYmVyKGZpbmlzaGVkV29yayk7XG4gICAgdmFyIHBhcmVudCA9IHZvaWQgMDtcbiAgICB2YXIgaXNDb250YWluZXIgPSB2b2lkIDA7XG4gICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICBpc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICBpc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgaG9zdCBwYXJlbnQgZmliZXIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICAgIGlmIChwYXJlbnRGaWJlci5lZmZlY3RUYWcgJiBDb250ZW50UmVzZXQpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIHBhcmVudCBiZWZvcmUgZG9pbmcgYW55IGluc2VydGlvbnNcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTtcbiAgICAgIC8vIENsZWFyIENvbnRlbnRSZXNldCBmcm9tIHRoZSBlZmZlY3QgdGFnXG4gICAgICBwYXJlbnRGaWJlci5lZmZlY3RUYWcgJj0gfkNvbnRlbnRSZXNldDtcbiAgICB9XG5cbiAgICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICBpZiAoaXNDb250YWluZXIpIHtcbiAgICAgICAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc2VydEJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNDb250YWluZXIpIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBJZiB0aGUgaW5zZXJ0aW9uIGl0c2VsZiBpcyBhIHBvcnRhbCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIHZhciBub2RlID0gY3VycmVudDtcblxuICAgIC8vIEVhY2ggaXRlcmF0aW9uLCBjdXJyZW50UGFyZW50IGlzIHBvcHVsYXRlZCB3aXRoIG5vZGUncyBob3N0IHBhcmVudCBpZiBub3RcbiAgICAvLyBjdXJyZW50UGFyZW50SXNWYWxpZC5cbiAgICB2YXIgY3VycmVudFBhcmVudElzVmFsaWQgPSBmYWxzZTtcbiAgICB2YXIgY3VycmVudFBhcmVudCA9IHZvaWQgMDtcbiAgICB2YXIgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdm9pZCAwO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudElzVmFsaWQpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICBmaW5kUGFyZW50OiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICEocGFyZW50ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50WydyZXR1cm4nXTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgY29tbWl0TmVzdGVkVW5tb3VudHMobm9kZSk7XG4gICAgICAgIC8vIEFmdGVyIGFsbCB0aGUgY2hpbGRyZW4gaGF2ZSB1bm1vdW50ZWQsIGl0IGlzIG5vdyBzYWZlIHRvIHJlbW92ZSB0aGVcbiAgICAgICAgLy8gbm9kZSBmcm9tIHRoZSB0cmVlLlxuICAgICAgICBpZiAoY3VycmVudFBhcmVudElzQ29udGFpbmVyKSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVDaGlsZChjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3QgdmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlbS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBnbyBpbnRvIGEgcG9ydGFsLCBpdCBiZWNvbWVzIHRoZSBwYXJlbnQgdG8gcmVtb3ZlIGZyb20uXG4gICAgICAgIC8vIFdlIHdpbGwgcmVhc3NpZ24gaXQgYmFjayB3aGVuIHdlIHBvcCB0aGUgcG9ydGFsIG9uIHRoZSB3YXkgdXAuXG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHBvcnRhbHMgbWlnaHQgY29udGFpbiBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHdlIG1heSBmaW5kIG1vcmUgaG9zdCBjb21wb25lbnRzIGJlbG93LlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAvLyBXaGVuIHdlIGdvIG91dCBvZiB0aGUgcG9ydGFsLCB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIHBhcmVudC5cbiAgICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrZWVwIGEgc3RhY2sgb2YgdGhlbSwgd2Ugd2lsbCBzZWFyY2ggZm9yIGl0LlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0RGVsZXRpb24oY3VycmVudCkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQuXG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCk7XG4gICAgZGV0YWNoRmliZXIoY3VycmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRXb3JrKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29tbWl0IHRoZSB3b3JrIHByZXBhcmVkIGVhcmxpZXIuXG4gICAgICAgICAgICB2YXIgbmV3UHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1Byb3BzO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICAgIC8vIFRPRE86IFR5cGUgdGhlIHVwZGF0ZVF1ZXVlIHRvIGJlIHNwZWNpZmljIHRvIGhvc3QgY29tcG9uZW50cy5cbiAgICAgICAgICAgIHZhciB1cGRhdGVQYXlsb2FkID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbW1pdFVwZGF0ZShpbnN0YW5jZSwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAhKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgbmV3VGV4dCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAvLyB0aGlzIGNhc2UuXG4gICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3VGV4dDtcbiAgICAgICAgICBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRSZXNldFRleHRDb250ZW50KGN1cnJlbnQpIHtcbiAgICByZXNldFRleHRDb250ZW50KGN1cnJlbnQuc3RhdGVOb2RlKTtcbiAgfVxuXG4gIGlmIChlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudDogY29tbWl0UmVzZXRUZXh0Q29udGVudCxcbiAgICAgIGNvbW1pdFBsYWNlbWVudDogY29tbWl0UGxhY2VtZW50LFxuICAgICAgY29tbWl0RGVsZXRpb246IGNvbW1pdERlbGV0aW9uLFxuICAgICAgY29tbWl0V29yazogY29tbWl0V29yayxcbiAgICAgIGNvbW1pdExpZmVDeWNsZXM6IGNvbW1pdExpZmVDeWNsZXMsXG4gICAgICBjb21taXRBdHRhY2hSZWY6IGNvbW1pdEF0dGFjaFJlZixcbiAgICAgIGNvbW1pdERldGFjaFJlZjogY29tbWl0RGV0YWNoUmVmXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdNdXRhdGluZyByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICB9XG59O1xuXG52YXIgTk9fQ09OVEVYVCA9IHt9O1xuXG52YXIgUmVhY3RGaWJlckhvc3RDb250ZXh0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgZ2V0Q2hpbGRIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRDaGlsZEhvc3RDb250ZXh0LFxuICAgICAgZ2V0Um9vdEhvc3RDb250ZXh0ID0gY29uZmlnLmdldFJvb3RIb3N0Q29udGV4dDtcblxuXG4gIHZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG4gIHZhciBjb250ZXh0RmliZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcbiAgdmFyIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuXG4gIGZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gICAgIShjICE9PSBOT19DT05URVhUKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGhvc3QgY29udGV4dCB0byBleGlzdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGFpbmVyKCkge1xuICAgIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgcmV0dXJuIHJvb3RJbnN0YW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gICAgLy8gUHVzaCBjdXJyZW50IHJvb3QgaW5zdGFuY2Ugb250byB0aGUgc3RhY2s7XG4gICAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gcmVzZXQgcm9vdCB3aGVuIHBvcnRhbHMgYXJlIHBvcHBlZC5cbiAgICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7XG5cbiAgICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpO1xuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Um9vdENvbnRleHQsIGZpYmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoZmliZXIpIHtcbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIb3N0Q29udGV4dCgpIHtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgbmV4dENvbnRleHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsIGZpYmVyLnR5cGUsIHJvb3RJbnN0YW5jZSk7XG5cbiAgICAvLyBEb24ndCBwdXNoIHRoaXMgRmliZXIncyBjb250ZXh0IHVubGVzcyBpdCdzIHVuaXF1ZS5cbiAgICBpZiAoY29udGV4dCA9PT0gbmV4dENvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gICAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICAgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGV4dChmaWJlcikge1xuICAgIC8vIERvIG5vdCBwb3AgdW5sZXNzIHRoaXMgRmliZXIgcHJvdmlkZWQgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICAvLyBwdXNoSG9zdENvbnRleHQoKSBvbmx5IHB1c2hlcyBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBpZiAoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IuY3VycmVudCAhPT0gZmliZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEhvc3RDb250YWluZXIoKSB7XG4gICAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBOT19DT05URVhUO1xuICAgIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBOT19DT05URVhUO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXRIb3N0Q29udGV4dDogZ2V0SG9zdENvbnRleHQsXG4gICAgZ2V0Um9vdEhvc3RDb250YWluZXI6IGdldFJvb3RIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250YWluZXI6IHBvcEhvc3RDb250YWluZXIsXG4gICAgcG9wSG9zdENvbnRleHQ6IHBvcEhvc3RDb250ZXh0LFxuICAgIHB1c2hIb3N0Q29udGFpbmVyOiBwdXNoSG9zdENvbnRhaW5lcixcbiAgICBwdXNoSG9zdENvbnRleHQ6IHB1c2hIb3N0Q29udGV4dCxcbiAgICByZXNldEhvc3RDb250YWluZXI6IHJlc2V0SG9zdENvbnRhaW5lclxuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICBoeWRyYXRpb24gPSBjb25maWcuaHlkcmF0aW9uO1xuXG4gIC8vIElmIHRoaXMgZG9lc24ndCBoYXZlIGh5ZHJhdGlvbiBtb2RlLlxuXG4gIGlmICghaHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudGVySHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgY2FuSHlkcmF0ZUluc3RhbmNlID0gaHlkcmF0aW9uLmNhbkh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGdldE5leHRIeWRyYXRhYmxlU2libGluZyA9IGh5ZHJhdGlvbi5nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcsXG4gICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCA9IGh5ZHJhdGlvbi5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCxcbiAgICAgIGh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5oeWRyYXRlSW5zdGFuY2UsXG4gICAgICBoeWRyYXRlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlLFxuICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlLFxuICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U7XG5cbiAgLy8gVGhlIGRlZXBlc3QgRmliZXIgb24gdGhlIHN0YWNrIGludm9sdmVkIGluIGEgaHlkcmF0aW9uIGNvbnRleHQuXG4gIC8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG5cbiAgdmFyIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgdmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICB2YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKTtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShyZXR1cm5GaWJlciwgaW5zdGFuY2UpIHtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlKHJldHVybkZpYmVyLnR5cGUsIHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHMsIHJldHVybkZpYmVyLnN0YXRlTm9kZSwgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZFRvRGVsZXRlID0gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKTtcbiAgICBjaGlsZFRvRGVsZXRlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgIGNoaWxkVG9EZWxldGVbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcblxuICAgIC8vIFRoaXMgbWlnaHQgc2VlbSBsaWtlIGl0IGJlbG9uZ3Mgb24gcHJvZ3Jlc3NlZEZpcnN0RGVsZXRpb24uIEhvd2V2ZXIsXG4gICAgLy8gdGhlc2UgY2hpbGRyZW4gYXJlIG5vdCBwYXJ0IG9mIHRoZSByZWNvbmNpbGlhdGlvbiBsaXN0IG9mIGNoaWxkcmVuLlxuICAgIC8vIEV2ZW4gaWYgd2UgYWJvcnQgYW5kIHJlcmVjb25jaWxlIHRoZSBjaGlsZHJlbiwgdGhhdCB3aWxsIHRyeSB0byBoeWRyYXRlXG4gICAgLy8gYWdhaW4gYW5kIHRoZSBub2RlcyBhcmUgc3RpbGwgaW4gdGhlIGhvc3QgdHJlZSBzbyB0aGVzZSB3aWxsIGJlXG4gICAgLy8gcmVjcmVhdGVkLlxuICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAgICBmaWJlci5lZmZlY3RUYWcgfD0gUGxhY2VtZW50O1xuICAgIHtcbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICB2YXIgX3R5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBfcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90eXBlLCBfcHJvcHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICAgIHZhciBfdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgICAgICBpZiAodGV4dEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSB0ZXh0SW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIpIHtcbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICAgIGlmICghbmV4dEluc3RhbmNlKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgLy8gSWYgd2UgY2FuJ3QgaHlkcmF0ZSB0aGlzIGluc3RhbmNlIGxldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG4gICAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgICAvLyBtaWdodCBiZSBmbGF3ZWQgb3IgdW5uZWNlc3NhcnkuXG4gICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgbmV4dCBvbmUsIHdlJ2xsIG5vdyBhc3N1bWUgdGhhdCB0aGUgZmlyc3Qgb25lIHdhc1xuICAgICAgLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcbiAgICAgIC8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcbiAgICAgIC8vIGZpYmVyIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSk7XG4gICAgfVxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRJbnN0YW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciB1cGRhdGVQYXlsb2FkID0gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBmaWJlcik7XG4gICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgZmliZXIudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAgIC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoZmliZXIpIHtcbiAgICB2YXIgdGV4dEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciB0ZXh0Q29udGVudCA9IGZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIpO1xuICAgIHtcbiAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgaXMgY2FsbGVkIGluIGEgY29udGV4dCB3aGVyZSB0aGVcbiAgICAgICAgLy8gaHlkcmF0aW9uIHBhcmVudCBpcyB0aGUgcGFyZW50IGhvc3QgY29tcG9uZW50IG9mIHRoaXMgaG9zdCB0ZXh0LlxuICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcbiAgICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudCA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgcGFyZW50LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgfVxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgICBpZiAoZmliZXIgIT09IGh5ZHJhdGlvblBhcmVudEZpYmVyKSB7XG4gICAgICAvLyBXZSdyZSBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBoeWRyYXRpb24gY29udGV4dCwgaW5zaWRlIGFuIGluc2VydGVkXG4gICAgICAvLyB0cmVlLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgICAgLy8gd2Ugd2VyZSBhbiBpbnNlcnRpb24gYW5kIG5vdyBuZWVkIHRvIHBvcCB1cCByZWVudGVyIGh5ZHJhdGlvbiBvZiBvdXJcbiAgICAgIC8vIHNpYmxpbmdzLlxuICAgICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhbnkgcmVtYWluaW5nIGh5ZHJhdGFibGUgbm9kZXMsIHdlIG5lZWQgdG8gZGVsZXRlIHRoZW0gbm93LlxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBkZWVwZXIgdGhhbiBoZWFkIGFuZCBib2R5IHNpbmNlIHRoZXkgdGVuZCB0byBoYXZlIHJhbmRvbVxuICAgIC8vIG90aGVyIG5vZGVzIGluIHRoZW0uIFdlIGFsc28gaWdub3JlIGNvbXBvbmVudHMgd2l0aCBwdXJlIHRleHQgY29udGVudCBpblxuICAgIC8vIHNpZGUgb2YgdGhlbS5cbiAgICAvLyBUT0RPOiBCZXR0ZXIgaGV1cmlzdGljLlxuICAgIGlmIChmaWJlci50YWcgIT09IEhvc3RDb21wb25lbnQgfHwgdHlwZSAhPT0gJ2hlYWQnICYmIHR5cGUgIT09ICdib2R5JyAmJiAhc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpIHtcbiAgICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICAgICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG4gICAgICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhuZXh0SW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpIDogbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudGVySHlkcmF0aW9uU3RhdGU6IGVudGVySHlkcmF0aW9uU3RhdGUsXG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZTogcmVzZXRIeWRyYXRpb25TdGF0ZSxcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTogdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTogcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTogcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UsXG4gICAgcG9wSHlkcmF0aW9uU3RhdGU6IHBvcEh5ZHJhdGlvblN0YXRlXG4gIH07XG59O1xuXG4vLyBUaGlzIGxldHMgdXMgaG9vayBpbnRvIEZpYmVyIHRvIGRlYnVnIHdoYXQgaXQncyBkb2luZy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC84MDMzLlxuLy8gVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgcHVibGljIEFQSSwgbm90IGV2ZW4gZm9yIFJlYWN0IERldlRvb2xzLlxuLy8gWW91IG1heSBvbmx5IGluamVjdCBhIGRlYnVnVG9vbCBpZiB5b3Ugd29yayBvbiBSZWFjdCBGaWJlciBpdHNlbGYuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiA9IHtcbiAgZGVidWdUb29sOiBudWxsXG59O1xuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xID0gUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbjtcblxudmFyIGRlZmF1bHRTaG93RGlhbG9nID0gZnVuY3Rpb24gKGNhcHR1cmVkRXJyb3IpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgc2hvd0RpYWxvZyA9IGRlZmF1bHRTaG93RGlhbG9nO1xuXG5mdW5jdGlvbiBsb2dDYXB0dXJlZEVycm9yKGNhcHR1cmVkRXJyb3IpIHtcbiAgdmFyIGxvZ0Vycm9yID0gc2hvd0RpYWxvZyhjYXB0dXJlZEVycm9yKTtcblxuICAvLyBBbGxvdyBpbmplY3RlZCBzaG93RGlhbG9nKCkgdG8gcHJldmVudCBkZWZhdWx0IGNvbnNvbGUuZXJyb3IgbG9nZ2luZy5cbiAgLy8gVGhpcyBlbmFibGVzIHJlbmRlcmVycyBsaWtlIFJlYWN0TmF0aXZlIHRvIGJldHRlciBtYW5hZ2UgcmVkYm94IGJlaGF2aW9yLlxuICBpZiAobG9nRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVycm9yID0gY2FwdHVyZWRFcnJvci5lcnJvcjtcbiAgdmFyIHN1cHByZXNzTG9nZ2luZyA9IGVycm9yICYmIGVycm9yLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmc7XG4gIGlmIChzdXBwcmVzc0xvZ2dpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjYXB0dXJlZEVycm9yLmNvbXBvbmVudE5hbWUsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnRTdGFjayxcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlOYW1lLFxuICAgICAgICBlcnJvckJvdW5kYXJ5Rm91bmQgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlGb3VuZCxcbiAgICAgICAgd2lsbFJldHJ5ID0gY2FwdHVyZWRFcnJvci53aWxsUmV0cnk7XG5cblxuICAgIHZhciBjb21wb25lbnROYW1lTWVzc2FnZSA9IGNvbXBvbmVudE5hbWUgPyAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8JyArIGNvbXBvbmVudE5hbWUgKyAnPiBjb21wb25lbnQ6JyA6ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50czonO1xuXG4gICAgdmFyIGVycm9yQm91bmRhcnlNZXNzYWdlID0gdm9pZCAwO1xuICAgIC8vIGVycm9yQm91bmRhcnlGb3VuZCBjaGVjayBpcyBzdWZmaWNpZW50OyBlcnJvckJvdW5kYXJ5TmFtZSBjaGVjayBpcyB0byBzYXRpc2Z5IEZsb3cuXG4gICAgaWYgKGVycm9yQm91bmRhcnlGb3VuZCAmJiBlcnJvckJvdW5kYXJ5TmFtZSkge1xuICAgICAgaWYgKHdpbGxSZXRyeSkge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCAnICsgKCd1c2luZyB0aGUgZXJyb3IgYm91bmRhcnkgeW91IHByb3ZpZGVkLCAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnVGhpcyBlcnJvciB3YXMgaW5pdGlhbGx5IGhhbmRsZWQgYnkgdGhlIGVycm9yIGJvdW5kYXJ5ICcgKyBlcnJvckJvdW5kYXJ5TmFtZSArICcuXFxuJyArICdSZWNyZWF0aW5nIHRoZSB0cmVlIGZyb20gc2NyYXRjaCBmYWlsZWQgc28gUmVhY3Qgd2lsbCB1bm1vdW50IHRoZSB0cmVlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ0NvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcbicgKyAnVmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy4nO1xuICAgIH1cbiAgICB2YXIgY29tYmluZWRNZXNzYWdlID0gJycgKyBjb21wb25lbnROYW1lTWVzc2FnZSArIGNvbXBvbmVudFN0YWNrICsgJ1xcblxcbicgKyAoJycgKyBlcnJvckJvdW5kYXJ5TWVzc2FnZSk7XG5cbiAgICAvLyBJbiBkZXZlbG9wbWVudCwgd2UgcHJvdmlkZSBvdXIgb3duIG1lc3NhZ2Ugd2l0aCBqdXN0IHRoZSBjb21wb25lbnQgc3RhY2suXG4gICAgLy8gV2UgZG9uJ3QgaW5jbHVkZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBhbmQgSlMgc3RhY2sgYmVjYXVzZSB0aGUgYnJvd3NlclxuICAgIC8vIGhhcyBhbHJlYWR5IHByaW50ZWQgaXQuIEV2ZW4gaWYgdGhlIGFwcGxpY2F0aW9uIHN3YWxsb3dzIHRoZSBlcnJvciwgaXQgaXMgc3RpbGxcbiAgICAvLyBkaXNwbGF5ZWQgYnkgdGhlIGJyb3dzZXIgdGhhbmtzIHRvIHRoZSBERVYtb25seSBmYWtlIGV2ZW50IHRyaWNrIGluIFJlYWN0RXJyb3JVdGlscy5cbiAgICBjb25zb2xlLmVycm9yKGNvbWJpbmVkTWVzc2FnZSk7XG4gIH1cbn1cblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayQxID0gUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbnZhciBoYXNDYXVnaHRFcnJvciA9IFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcjtcbnZhciBjbGVhckNhdWdodEVycm9yID0gUmVhY3RFcnJvclV0aWxzLmNsZWFyQ2F1Z2h0RXJyb3I7XG5cblxue1xuICB2YXIgZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uID0gZmFsc2U7XG4gIHZhciBkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQgPSBmYWxzZTtcbiAgdmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG4gIHZhciB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybmluZyhmYWxzZSwgJ0NhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgJyArICdjb21wb25lbnQuIFRoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkIHNldFN0YXRlLCByZXBsYWNlU3RhdGUsICcgKyAnb3IgZm9yY2VVcGRhdGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSAnICsgJ2NoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNvbXBvbmVudE5hbWUpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gIH07XG5cbiAgdmFyIHdhcm5BYm91dEludmFsaWRVcGRhdGVzID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgc3dpdGNoIChSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlKSB7XG4gICAgICBjYXNlICdnZXRDaGlsZENvbnRleHQnOlxuICAgICAgICBpZiAoZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiBDYW5ub3QgY2FsbCBzZXRTdGF0ZSgpIGluc2lkZSBnZXRDaGlsZENvbnRleHQoKScpO1xuICAgICAgICBkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JlbmRlcic6XG4gICAgICAgIGlmIChkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0Nhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgd2l0aGluICcgKyBcImByZW5kZXJgIG9yIGFub3RoZXIgY29tcG9uZW50J3MgY29uc3RydWN0b3IpLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgXCIgKyAnYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgY29uc3RydWN0b3Igc2lkZS1lZmZlY3RzIGFyZSAnICsgJ2FuIGFudGktcGF0dGVybiwgYnV0IGNhbiBiZSBtb3ZlZCB0byBgY29tcG9uZW50V2lsbE1vdW50YC4nKTtcbiAgICAgICAgZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xufVxuXG52YXIgUmVhY3RGaWJlclNjaGVkdWxlciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGhvc3RDb250ZXh0ID0gUmVhY3RGaWJlckhvc3RDb250ZXh0KGNvbmZpZyk7XG4gIHZhciBoeWRyYXRpb25Db250ZXh0ID0gUmVhY3RGaWJlckh5ZHJhdGlvbkNvbnRleHQoY29uZmlnKTtcbiAgdmFyIHBvcEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGFpbmVyLFxuICAgICAgcG9wSG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGV4dCxcbiAgICAgIHJlc2V0SG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnJlc2V0SG9zdENvbnRhaW5lcjtcblxuICB2YXIgX1JlYWN0RmliZXJCZWdpbldvcmsgPSBSZWFjdEZpYmVyQmVnaW5Xb3JrKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciksXG4gICAgICBiZWdpbldvcmsgPSBfUmVhY3RGaWJlckJlZ2luV29yay5iZWdpbldvcmssXG4gICAgICBiZWdpbkZhaWxlZFdvcmsgPSBfUmVhY3RGaWJlckJlZ2luV29yay5iZWdpbkZhaWxlZFdvcms7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQ29tcGxldGVXbyA9IFJlYWN0RmliZXJDb21wbGV0ZVdvcmsoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCksXG4gICAgICBjb21wbGV0ZVdvcmsgPSBfUmVhY3RGaWJlckNvbXBsZXRlV28uY29tcGxldGVXb3JrO1xuXG4gIHZhciBfUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBSZWFjdEZpYmVyQ29tbWl0V29yayhjb25maWcsIGNhcHR1cmVFcnJvciksXG4gICAgICBjb21taXRSZXNldFRleHRDb250ZW50ID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRQbGFjZW1lbnQgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0UGxhY2VtZW50LFxuICAgICAgY29tbWl0RGVsZXRpb24gPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0RGVsZXRpb24sXG4gICAgICBjb21taXRXb3JrID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFdvcmssXG4gICAgICBjb21taXRMaWZlQ3ljbGVzID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdExpZmVDeWNsZXMsXG4gICAgICBjb21taXRBdHRhY2hSZWYgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0QXR0YWNoUmVmLFxuICAgICAgY29tbWl0RGV0YWNoUmVmID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdERldGFjaFJlZjtcblxuICB2YXIgbm93ID0gY29uZmlnLm5vdyxcbiAgICAgIHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayA9IGNvbmZpZy5zY2hlZHVsZURlZmVycmVkQ2FsbGJhY2ssXG4gICAgICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrID0gY29uZmlnLmNhbmNlbERlZmVycmVkQ2FsbGJhY2ssXG4gICAgICB1c2VTeW5jU2NoZWR1bGluZyA9IGNvbmZpZy51c2VTeW5jU2NoZWR1bGluZyxcbiAgICAgIHByZXBhcmVGb3JDb21taXQgPSBjb25maWcucHJlcGFyZUZvckNvbW1pdCxcbiAgICAgIHJlc2V0QWZ0ZXJDb21taXQgPSBjb25maWcucmVzZXRBZnRlckNvbW1pdDtcblxuICAvLyBSZXByZXNlbnRzIHRoZSBjdXJyZW50IHRpbWUgaW4gbXMuXG5cbiAgdmFyIHN0YXJ0VGltZSA9IG5vdygpO1xuICB2YXIgbW9zdFJlY2VudEN1cnJlbnRUaW1lID0gbXNUb0V4cGlyYXRpb25UaW1lKDApO1xuXG4gIC8vIFJlcHJlc2VudHMgdGhlIGV4cGlyYXRpb24gdGltZSB0aGF0IGluY29taW5nIHVwZGF0ZXMgc2hvdWxkIHVzZS4gKElmIHRoaXNcbiAgLy8gaXMgTm9Xb3JrLCB1c2UgdGhlIGRlZmF1bHQgc3RyYXRlZ3k6IGFzeW5jIHVwZGF0ZXMgaW4gYXN5bmMgbW9kZSwgc3luY1xuICAvLyB1cGRhdGVzIGluIHN5bmMgbW9kZS4pXG4gIHZhciBleHBpcmF0aW9uQ29udGV4dCA9IE5vV29yaztcblxuICB2YXIgaXNXb3JraW5nID0gZmFsc2U7XG5cbiAgLy8gVGhlIG5leHQgd29yayBpbiBwcm9ncmVzcyBmaWJlciB0aGF0IHdlJ3JlIGN1cnJlbnRseSB3b3JraW5nIG9uLlxuICB2YXIgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xuICB2YXIgbmV4dFJvb3QgPSBudWxsO1xuICAvLyBUaGUgdGltZSBhdCB3aGljaCB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nIHdvcmsuXG4gIHZhciBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gVGhlIG5leHQgZmliZXIgd2l0aCBhbiBlZmZlY3QgdGhhdCB3ZSdyZSBjdXJyZW50bHkgY29tbWl0dGluZy5cbiAgdmFyIG5leHRFZmZlY3QgPSBudWxsO1xuXG4gIC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZmliZXJzIGhhdmUgY2FwdHVyZWQgYW4gZXJyb3IgdGhhdCBuZWVkIHRvIGJlIGhhbmRsZWQuXG4gIC8vIFdvcmsgaXMgcmVtb3ZlZCBmcm9tIHRoaXMgY29sbGVjdGlvbiBhZnRlciBjb21wb25lbnREaWRDYXRjaCBpcyBjYWxsZWQuXG4gIHZhciBjYXB0dXJlZEVycm9ycyA9IG51bGw7XG4gIC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZmliZXJzIGhhdmUgZmFpbGVkIGR1cmluZyB0aGUgY3VycmVudCBiYXRjaCBvZiB3b3JrLlxuICAvLyBUaGlzIGlzIGEgZGlmZmVyZW50IHNldCB0aGFuIGNhcHR1cmVkRXJyb3JzLCBiZWNhdXNlIGl0IGlzIG5vdCByZXNldCB1bnRpbFxuICAvLyB0aGUgZW5kIG9mIHRoZSBiYXRjaC4gVGhpcyBpcyBuZWVkZWQgdG8gcHJvcGFnYXRlIGVycm9ycyBjb3JyZWN0bHkgaWYgYVxuICAvLyBzdWJ0cmVlIGZhaWxzIG1vcmUgdGhhbiBvbmNlLlxuICB2YXIgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG4gIC8vIEVycm9yIGJvdW5kYXJpZXMgdGhhdCBjYXB0dXJlZCBhbiBlcnJvciBkdXJpbmcgdGhlIGN1cnJlbnQgY29tbWl0LlxuICB2YXIgY29tbWl0UGhhc2VCb3VuZGFyaWVzID0gbnVsbDtcbiAgdmFyIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gIHZhciBkaWRGYXRhbCA9IGZhbHNlO1xuXG4gIHZhciBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgdmFyIGlzVW5tb3VudGluZyA9IGZhbHNlO1xuXG4gIC8vIFVzZWQgZm9yIHBlcmZvcm1hbmNlIHRyYWNraW5nLlxuICB2YXIgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcmVzZXRDb250ZXh0U3RhY2soKSB7XG4gICAgLy8gUmVzZXQgdGhlIHN0YWNrXG4gICAgcmVzZXQkMSgpO1xuICAgIC8vIFJlc2V0IHRoZSBjdXJzb3JzXG4gICAgcmVzZXRDb250ZXh0KCk7XG4gICAgcmVzZXRIb3N0Q29udGFpbmVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBbGxIb3N0RWZmZWN0cygpIHtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICAgIH1cbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuXG4gICAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG4gICAgICBpZiAoZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQobmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBjb21taXREZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBzd2l0Y2ggc3RhdGVtZW50IGlzIG9ubHkgY29uY2VybmVkIGFib3V0IHBsYWNlbWVudCxcbiAgICAgIC8vIHVwZGF0ZXMsIGFuZCBkZWxldGlvbnMuIFRvIGF2b2lkIG5lZWRpbmcgdG8gYWRkIGEgY2FzZSBmb3IgZXZlcnlcbiAgICAgIC8vIHBvc3NpYmxlIGJpdG1hcCB2YWx1ZSwgd2UgcmVtb3ZlIHRoZSBzZWNvbmRhcnkgZWZmZWN0cyBmcm9tIHRoZVxuICAgICAgLy8gZWZmZWN0IHRhZyBhbmQgc3dpdGNoIG9uIHRoYXQgdmFsdWUuXG4gICAgICB2YXIgcHJpbWFyeUVmZmVjdFRhZyA9IGVmZmVjdFRhZyAmIH4oQ2FsbGJhY2sgfCBFcnIgfCBDb250ZW50UmVzZXQgfCBSZWYgfCBQZXJmb3JtZWRXb3JrKTtcbiAgICAgIHN3aXRjaCAocHJpbWFyeUVmZmVjdFRhZykge1xuICAgICAgICBjYXNlIFBsYWNlbWVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpcyBpbnNlcnRlZCwgYmVmb3JlXG4gICAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAgIC8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWRcbiAgICAgICAgICAgIC8vIGRvZXMgYW5kIGlzTW91bnRlZCBpcyBkZXByZWNhdGVkIGFueXdheSBzbyB3ZSBzaG91bGQgYmUgYWJsZVxuICAgICAgICAgICAgLy8gdG8ga2lsbCB0aGlzLlxuICAgICAgICAgICAgbmV4dEVmZmVjdC5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQbGFjZW1lbnRBbmRVcGRhdGU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUGxhY2VtZW50XG4gICAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpcyBpbnNlcnRlZCwgYmVmb3JlXG4gICAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZVxuICAgICAgICAgICAgdmFyIF9jdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBVcGRhdGU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jdXJyZW50MiA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgY29tbWl0V29yayhfY3VycmVudDIsIG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIERlbGV0aW9uOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzVW5tb3VudGluZyA9IHRydWU7XG4gICAgICAgICAgICBjb21taXREZWxldGlvbihuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGlzVW5tb3VudGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QWxsTGlmZUN5Y2xlcygpIHtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgKFVwZGF0ZSB8IENhbGxiYWNrKSkge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgY29tbWl0TGlmZUN5Y2xlcyhjdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIFJlZikge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmKG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgRXJyKSB7XG4gICAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgICBjb21taXRFcnJvckhhbmRsaW5nKG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIGNsZWFuIHRoZXNlIHVwIHNvIHRoYXQgd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IGtlZXAgdGhlbS5cbiAgICAgIC8vIEknbSBub3QgYWN0dWFsbHkgc3VyZSB0aGlzIG1hdHRlcnMgYmVjYXVzZSB3ZSBjYW4ndCByZXNldCBmaXJzdEVmZmVjdFxuICAgICAgLy8gYW5kIGxhc3RFZmZlY3Qgc2luY2UgdGhleSdyZSBvbiBldmVyeSBub2RlLCBub3QganVzdCB0aGUgZWZmZWN0ZnVsXG4gICAgICAvLyBvbmVzLiBTbyB3ZSBoYXZlIHRvIGNsZWFuIGV2ZXJ5dGhpbmcgYXMgd2UgcmV1c2Ugbm9kZXMgYW55d2F5LlxuICAgICAgbmV4dEVmZmVjdC5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIHJlc2V0IHRoZSBlZmZlY3RUYWcgaGVyZSBzbyB0aGF0IHdlIGNhbiByZWx5IG9uIGVmZmVjdFxuICAgICAgLy8gdGFncyB0byByZWFzb24gYWJvdXQgdGhlIGN1cnJlbnQgbGlmZS1jeWNsZS5cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKSB7XG4gICAgLy8gV2Uga2VlcCB0cmFjayBvZiB0aGlzIHNvIHRoYXQgY2FwdHVyZUVycm9yIGNhbiBjb2xsZWN0IGFueSBib3VuZGFyaWVzXG4gICAgLy8gdGhhdCBjYXB0dXJlIGFuIGVycm9yIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLiBUaGUgcmVhc29uIHRoZXNlIGFyZW4ndFxuICAgIC8vIGxvY2FsIHRvIHRoaXMgZnVuY3Rpb24gaXMgYmVjYXVzZSBlcnJvcnMgdGhhdCBvY2N1ciBkdXJpbmcgY1dVIGFyZVxuICAgIC8vIGNhcHR1cmVkIGVsc2V3aGVyZSwgdG8gcHJldmVudCB0aGUgdW5tb3VudCBmcm9tIGJlaW5nIGludGVycnVwdGVkLlxuICAgIGlzV29ya2luZyA9IHRydWU7XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBzdGFydENvbW1pdFRpbWVyKCk7XG5cbiAgICB2YXIgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgIShyb290LmN1cnJlbnQgIT09IGZpbmlzaGVkV29yaykgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIHJlbGF0ZWQgdG8gdGhlIHJldHVybiBmaWVsZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICByb290LmlzUmVhZHlGb3JDb21taXQgPSBmYWxzZTtcblxuICAgIC8vIFJlc2V0IHRoaXMgdG8gbnVsbCBiZWZvcmUgY2FsbGluZyBsaWZlY3ljbGVzXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICB2YXIgZmlyc3RFZmZlY3QgPSB2b2lkIDA7XG4gICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAvLyBBIGZpYmVyJ3MgZWZmZWN0IGxpc3QgY29uc2lzdHMgb25seSBvZiBpdHMgY2hpbGRyZW4sIG5vdCBpdHNlbGYuIFNvIGlmXG4gICAgICAvLyB0aGUgcm9vdCBoYXMgYW4gZWZmZWN0LCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LiBUaGVcbiAgICAgIC8vIHJlc3VsdGluZyBsaXN0IGlzIHRoZSBzZXQgdGhhdCB3b3VsZCBiZWxvbmcgdG8gdGhlIHJvb3QncyBwYXJlbnQsIGlmXG4gICAgICAvLyBpdCBoYWQgb25lOyB0aGF0IGlzLCBhbGwgdGhlIGVmZmVjdHMgaW4gdGhlIHRyZWUgaW5jbHVkaW5nIHRoZSByb290LlxuICAgICAgaWYgKGZpbmlzaGVkV29yay5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGZpbmlzaGVkV29yay5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIGVmZmVjdCBvbiB0aGUgcm9vdC5cbiAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgIH1cblxuICAgIHByZXBhcmVGb3JDb21taXQoKTtcblxuICAgIC8vIENvbW1pdCBhbGwgdGhlIHNpZGUtZWZmZWN0cyB3aXRoaW4gYSB0cmVlLiBXZSdsbCBkbyB0aGlzIGluIHR3byBwYXNzZXMuXG4gICAgLy8gVGhlIGZpcnN0IHBhc3MgcGVyZm9ybXMgYWxsIHRoZSBob3N0IGluc2VydGlvbnMsIHVwZGF0ZXMsIGRlbGV0aW9ucyBhbmRcbiAgICAvLyByZWYgdW5tb3VudHMuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICAgIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfZXJyb3IgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxKG51bGwsIGNvbW1pdEFsbEhvc3RFZmZlY3RzLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2Vycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgIShuZXh0RWZmZWN0ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBjYXB0dXJlRXJyb3IobmV4dEVmZmVjdCwgX2Vycm9yKTtcbiAgICAgICAgLy8gQ2xlYW4tdXBcbiAgICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCk7XG5cbiAgICByZXNldEFmdGVyQ29tbWl0KCk7XG5cbiAgICAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyB0cmVlIGlzIG5vdyB0aGUgY3VycmVudCB0cmVlLiBUaGlzIG11c3QgY29tZSBhZnRlclxuICAgIC8vIHRoZSBmaXJzdCBwYXNzIG9mIHRoZSBjb21taXQgcGhhc2UsIHNvIHRoYXQgdGhlIHByZXZpb3VzIHRyZWUgaXMgc3RpbGxcbiAgICAvLyBjdXJyZW50IGR1cmluZyBjb21wb25lbnRXaWxsVW5tb3VudCwgYnV0IGJlZm9yZSB0aGUgc2Vjb25kIHBhc3MsIHNvIHRoYXRcbiAgICAvLyB0aGUgZmluaXNoZWQgd29yayBpcyBjdXJyZW50IGR1cmluZyBjb21wb25lbnREaWRNb3VudC9VcGRhdGUuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrO1xuXG4gICAgLy8gSW4gdGhlIHNlY29uZCBwYXNzIHdlJ2xsIHBlcmZvcm0gYWxsIGxpZmUtY3ljbGVzIGFuZCByZWYgY2FsbGJhY2tzLlxuICAgIC8vIExpZmUtY3ljbGVzIGhhcHBlbiBhcyBhIHNlcGFyYXRlIHBhc3Mgc28gdGhhdCBhbGwgcGxhY2VtZW50cywgdXBkYXRlcyxcbiAgICAvLyBhbmQgZGVsZXRpb25zIGluIHRoZSBlbnRpcmUgdHJlZSBoYXZlIGFscmVhZHkgYmVlbiBpbnZva2VkLlxuICAgIC8vIFRoaXMgcGFzcyBhbHNvIHRyaWdnZXJzIGFueSByZW5kZXJlci1zcGVjaWZpYyBpbml0aWFsIGVmZmVjdHMuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICAgIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyKCk7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBfZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfZXJyb3IyID0gdm9pZCAwO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCBjb21taXRBbGxMaWZlQ3ljbGVzLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBfZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9lcnJvcjIgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfZGlkRXJyb3IpIHtcbiAgICAgICAgIShuZXh0RWZmZWN0ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBjYXB0dXJlRXJyb3IobmV4dEVmZmVjdCwgX2Vycm9yMik7XG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGlzV29ya2luZyA9IGZhbHNlO1xuICAgIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKTtcbiAgICBzdG9wQ29tbWl0VGltZXIoKTtcbiAgICBpZiAodHlwZW9mIG9uQ29tbWl0Um9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpO1xuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tbWl0V29yayhmaW5pc2hlZFdvcmspO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGNhdWdodCBhbnkgZXJyb3JzIGR1cmluZyB0aGlzIGNvbW1pdCwgc2NoZWR1bGUgdGhlaXIgYm91bmRhcmllc1xuICAgIC8vIHRvIHVwZGF0ZS5cbiAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzKSB7XG4gICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMuZm9yRWFjaChzY2hlZHVsZUVycm9yUmVjb3ZlcnkpO1xuICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3RVbmNhdWdodEVycm9yICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2Vycm9yMyA9IGZpcnN0VW5jYXVnaHRFcnJvcjtcbiAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICBvblVuY2F1Z2h0RXJyb3IoX2Vycm9yMyk7XG4gICAgfVxuXG4gICAgdmFyIHJlbWFpbmluZ1RpbWUgPSByb290LmN1cnJlbnQuZXhwaXJhdGlvblRpbWU7XG5cbiAgICBpZiAocmVtYWluaW5nVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgICBjYXB0dXJlZEVycm9ycyA9IG51bGw7XG4gICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVtYWluaW5nVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0RXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIHJlbmRlclRpbWUpIHtcbiAgICBpZiAocmVuZGVyVGltZSAhPT0gTmV2ZXIgJiYgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5ldmVyKSB7XG4gICAgICAvLyBUaGUgY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgYXJlIGhpZGRlbi4gRG9uJ3QgYnViYmxlIHRoZWlyXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWVzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBwZW5kaW5nIHVwZGF0ZXMuXG4gICAgdmFyIG5ld0V4cGlyYXRpb25UaW1lID0gZ2V0VXBkYXRlRXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogQ2FsbHMgbmVlZCB0byB2aXNpdCBzdGF0ZU5vZGVcblxuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuICAgIHZhciBjaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLmV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG5ld0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV3RXhwaXJhdGlvblRpbWUgPiBjaGlsZC5leHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSBjaGlsZC5leHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBuZXdFeHBpcmF0aW9uVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAgIC8vIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluXG4gICAgICAvLyBwcm9ncmVzcy5cbiAgICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzc1sncmV0dXJuJ107XG4gICAgICB2YXIgc2libGluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3Muc2libGluZztcblxuICAgICAgcmVzZXRFeHBpcmF0aW9uVGltZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBjb21wbGV0aW5nIHRoaXMgd29yayBzcGF3bmVkIG5ldyB3b3JrLCBkbyB0aGF0IG5leHQuIFdlJ2xsIGNvbWVcbiAgICAgICAgLy8gYmFjayBoZXJlIGFnYWluLlxuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEFwcGVuZCBhbGwgdGhlIGVmZmVjdHMgb2YgdGhlIHN1YnRyZWUgYW5kIHRoaXMgZmliZXIgb250byB0aGUgZWZmZWN0XG4gICAgICAgIC8vIGxpc3Qgb2YgdGhlIHBhcmVudC4gVGhlIGNvbXBsZXRpb24gb3JkZXIgb2YgdGhlIGNoaWxkcmVuIGFmZmVjdHMgdGhlXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0IG9yZGVyLlxuICAgICAgICBpZiAocmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgZmliZXIgaGFkIHNpZGUtZWZmZWN0cywgd2UgYXBwZW5kIGl0IEFGVEVSIHRoZSBjaGlsZHJlbidzXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gV2UgY2FuIHBlcmZvcm0gY2VydGFpbiBzaWRlLWVmZmVjdHMgZWFybGllciBpZlxuICAgICAgICAvLyBuZWVkZWQsIGJ5IGRvaW5nIG11bHRpcGxlIHBhc3NlcyBvdmVyIHRoZSBlZmZlY3QgbGlzdC4gV2UgZG9uJ3Qgd2FudFxuICAgICAgICAvLyB0byBzY2hlZHVsZSBvdXIgb3duIHNpZGUtZWZmZWN0IG9uIG91ciBvd24gbGlzdCBiZWNhdXNlIGlmIGVuZCB1cFxuICAgICAgICAvLyByZXVzaW5nIGNoaWxkcmVuIHdlJ2xsIHNjaGVkdWxlIHRoaXMgZWZmZWN0IG9udG8gaXRzZWxmIHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGF0IHRoZSBlbmQuXG4gICAgICAgIHZhciBlZmZlY3RUYWcgPSB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWc7XG4gICAgICAgIC8vIFNraXAgYm90aCBOb1dvcmsgYW5kIFBlcmZvcm1lZFdvcmsgdGFncyB3aGVuIGNyZWF0aW5nIHRoZSBlZmZlY3QgbGlzdC5cbiAgICAgICAgLy8gUGVyZm9ybWVkV29yayBlZmZlY3QgaXMgcmVhZCBieSBSZWFjdCBEZXZUb29scyBidXQgc2hvdWxkbid0IGJlIGNvbW1pdHRlZC5cbiAgICAgICAgaWYgKGVmZmVjdFRhZyA+IFBlcmZvcm1lZFdvcmspIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbW9yZSB3b3JrIHRvIGRvIGluIHRoaXMgcmV0dXJuRmliZXIsIGRvIHRoYXQgbmV4dC5cbiAgICAgICAgcmV0dXJuIHNpYmxpbmdGaWJlcjtcbiAgICAgIH0gZWxzZSBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBtb3JlIHdvcmsgaW4gdGhpcyByZXR1cm5GaWJlci4gQ29tcGxldGUgdGhlIHJldHVybkZpYmVyLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3QuXG4gICAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICByb290LmlzUmVhZHlGb3JDb21taXQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaXRob3V0IHRoaXMgZXhwbGljaXQgbnVsbCByZXR1cm4gRmxvdyBjb21wbGFpbnMgb2YgaW52YWxpZCByZXR1cm4gdHlwZVxuICAgIC8vIFRPRE8gUmVtb3ZlIHRoZSBhYm92ZSB3aGlsZSh0cnVlKSBsb29wXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgIC8vIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAgLy8gU2VlIGlmIGJlZ2lubmluZyB0aGlzIHdvcmsgc3Bhd25zIG1vcmUgd29yay5cbiAgICBzdGFydFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBuZXh0ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkJlZ2luV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICAgIG5leHQgPSBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgIC8vIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAgLy8gU2VlIGlmIGJlZ2lubmluZyB0aGlzIHdvcmsgc3Bhd25zIG1vcmUgd29yay5cbiAgICBzdGFydFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICB2YXIgbmV4dCA9IGJlZ2luRmFpbGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25CZWdpbldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgICBuZXh0ID0gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcblxuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gd29ya0xvb3AoZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY2FwdHVyZWRFcnJvcnMgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSB1bmhhbmRsZWQgZXJyb3JzLCBzd2l0Y2ggdG8gdGhlIHNsb3cgd29yayBsb29wLlxuICAgICAgLy8gVE9ETzogSG93IHRvIGF2b2lkIHRoaXMgY2hlY2sgaW4gdGhlIGZhc3QgcGF0aD8gTWF5YmUgdGhlIHJlbmRlcmVyXG4gICAgICAvLyBjb3VsZCBrZWVwIHRyYWNrIG9mIHdoaWNoIHJvb3RzIGhhdmUgdW5oYW5kbGVkIGVycm9ycyBhbmQgY2FsbCBhXG4gICAgICAvLyBmb3JrZWQgdmVyc2lvbiBvZiByZW5kZXJSb290LlxuICAgICAgc2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsoZXhwaXJhdGlvblRpbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIDw9IG1vc3RSZWNlbnRDdXJyZW50VGltZSkge1xuICAgICAgLy8gRmx1c2ggYWxsIGV4cGlyZWQgd29yay5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmx1c2ggYXN5bmNocm9ub3VzIHdvcmsgdW50aWwgdGhlIGRlYWRsaW5lIHJ1bnMgb3V0IG9mIHRpbWUuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwgJiYgIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsoZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIDw9IG1vc3RSZWNlbnRDdXJyZW50VGltZSkge1xuICAgICAgLy8gRmx1c2ggYWxsIGV4cGlyZWQgd29yay5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoaGFzQ2FwdHVyZWRFcnJvcihuZXh0VW5pdE9mV29yaykpIHtcbiAgICAgICAgICAvLyBVc2UgYSBmb3JrZWQgdmVyc2lvbiBvZiBwZXJmb3JtVW5pdE9mV29ya1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jaHJvbm91cyB3b3JrIHVudGlsIHRoZSBkZWFkbGluZSBydW5zIG91dCBvZiB0aW1lLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgIGlmIChoYXNDYXB0dXJlZEVycm9yKG5leHRVbml0T2ZXb3JrKSkge1xuICAgICAgICAgIC8vIFVzZSBhIGZvcmtlZCB2ZXJzaW9uIG9mIHBlcmZvcm1Vbml0T2ZXb3JrXG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJSb290Q2F0Y2hCbG9jayhyb290LCBmYWlsZWRXb3JrLCBib3VuZGFyeSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byByZXN0YXJ0IHRoZSBlcnJvciBib3VuZGFyeSB0aGF0IGNhcHR1cmVkIHRoZSBlcnJvci5cbiAgICAvLyBDb25jZXB0dWFsbHksIHdlJ3JlIHVud2luZGluZyB0aGUgc3RhY2suIFdlIG5lZWQgdG8gdW53aW5kIHRoZVxuICAgIC8vIGNvbnRleHQgc3RhY2ssIHRvby5cbiAgICB1bndpbmRDb250ZXh0cyhmYWlsZWRXb3JrLCBib3VuZGFyeSk7XG5cbiAgICAvLyBSZXN0YXJ0IHRoZSBlcnJvciBib3VuZGFyeSB1c2luZyBhIGZvcmtlZCB2ZXJzaW9uIG9mXG4gICAgLy8gcGVyZm9ybVVuaXRPZldvcmsgdGhhdCBkZWxldGVzIHRoZSBib3VuZGFyeSdzIGNoaWxkcmVuLiBUaGUgZW50aXJlXG4gICAgLy8gZmFpbGVkIHN1YnJlZSB3aWxsIGJlIHVubW91bnRlZC4gRHVyaW5nIHRoZSBjb21taXQgcGhhc2UsIGEgc3BlY2lhbFxuICAgIC8vIGxpZmVjeWNsZSBtZXRob2QgaXMgY2FsbGVkIG9uIHRoZSBlcnJvciBib3VuZGFyeSwgd2hpY2ggdHJpZ2dlcnNcbiAgICAvLyBhIHJlLXJlbmRlci5cbiAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKGJvdW5kYXJ5KTtcblxuICAgIC8vIENvbnRpbnVlIHdvcmtpbmcuXG4gICAgd29ya0xvb3AoZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAgICEhaXNXb3JraW5nID8gaW52YXJpYW50KGZhbHNlLCAncmVuZGVyUm9vdCB3YXMgY2FsbGVkIHJlY3Vyc2l2ZWx5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGlzV29ya2luZyA9IHRydWU7XG5cbiAgICAvLyBXZSdyZSBhYm91dCB0byBtdXRhdGUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZS4gSWYgdGhlIHJvb3Qgd2FzIHBlbmRpbmdcbiAgICAvLyBjb21taXQsIGl0IG5vIGxvbmdlciBpczogd2UnbGwgbmVlZCB0byBjb21wbGV0ZSBpdCBhZ2Fpbi5cbiAgICByb290LmlzUmVhZHlGb3JDb21taXQgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIGlmIHdlJ3JlIHN0YXJ0aW5nIGZyb20gYSBmcmVzaCBzdGFjaywgb3IgaWYgd2UncmUgcmVzdW1pbmcgZnJvbVxuICAgIC8vIHByZXZpb3VzbHkgeWllbGRlZCB3b3JrLlxuICAgIGlmIChyb290ICE9PSBuZXh0Um9vdCB8fCBleHBpcmF0aW9uVGltZSAhPT0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIHx8IG5leHRVbml0T2ZXb3JrID09PSBudWxsKSB7XG4gICAgICAvLyBSZXNldCB0aGUgc3RhY2sgYW5kIHN0YXJ0IHdvcmtpbmcgZnJvbSB0aGUgcm9vdC5cbiAgICAgIHJlc2V0Q29udGV4dFN0YWNrKCk7XG4gICAgICBuZXh0Um9vdCA9IHJvb3Q7XG4gICAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIG5leHRVbml0T2ZXb3JrID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MobmV4dFJvb3QuY3VycmVudCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yayk7XG5cbiAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxKG51bGwsIHdvcmtMb29wLCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFuIGVycm9yIHdhcyB0aHJvd24gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgd2hpbGUgKGRpZEVycm9yKSB7XG4gICAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgICAgLy8gVGhpcyB3YXMgYSBmYXRhbCBlcnJvci4gRG9uJ3QgYXR0ZW1wdCB0byByZWNvdmVyIGZyb20gaXQuXG4gICAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGZhaWxlZFdvcmsgPSBuZXh0VW5pdE9mV29yaztcbiAgICAgIGlmIChmYWlsZWRXb3JrID09PSBudWxsKSB7XG4gICAgICAgIC8vIEFuIGVycm9yIHdhcyB0aHJvd24gYnV0IHRoZXJlJ3Mgbm8gY3VycmVudCB1bml0IG9mIHdvcmsuIFRoaXMgY2FuXG4gICAgICAgIC8vIGhhcHBlbiBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSdzIGEgYnVnIGluIHRoZSByZW5kZXJlci5cbiAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gXCJDYXB0dXJlXCIgdGhlIGVycm9yIGJ5IGZpbmRpbmcgdGhlIG5lYXJlc3QgYm91bmRhcnkuIElmIHRoZXJlIGlzIG5vXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSwgd2UgdXNlIHRoZSByb290LlxuICAgICAgdmFyIGJvdW5kYXJ5ID0gY2FwdHVyZUVycm9yKGZhaWxlZFdvcmssIGVycm9yKTtcbiAgICAgICEoYm91bmRhcnkgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgZm91bmQgYW4gZXJyb3IgYm91bmRhcnkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChkaWRGYXRhbCkge1xuICAgICAgICAvLyBUaGUgZXJyb3Igd2UganVzdCBjYXB0dXJlZCB3YXMgYSBmYXRhbCBlcnJvci4gVGhpcyBoYXBwZW5zXG4gICAgICAgIC8vIHdoZW4gdGhlIGVycm9yIHByb3BhZ2F0ZXMgdG8gdGhlIHJvb3QgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCByZW5kZXJSb290Q2F0Y2hCbG9jaywgbnVsbCwgcm9vdCwgZmFpbGVkV29yaywgYm91bmRhcnksIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlJ3JlIGZpbmlzaGVkIHdvcmtpbmcuIEV4aXQgdGhlIGVycm9yIGxvb3AuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgdW5jYXVnaHRFcnJvciA9IGZpcnN0VW5jYXVnaHRFcnJvcjtcblxuICAgIC8vIFdlJ3JlIGRvbmUgcGVyZm9ybWluZyB3b3JrLiBUaW1lIHRvIGNsZWFuIHVwLlxuICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnkpO1xuICAgIGludGVycnVwdGVkQnkgPSBudWxsO1xuICAgIGlzV29ya2luZyA9IGZhbHNlO1xuICAgIGRpZEZhdGFsID0gZmFsc2U7XG4gICAgZmlyc3RVbmNhdWdodEVycm9yID0gbnVsbDtcblxuICAgIGlmICh1bmNhdWdodEVycm9yICE9PSBudWxsKSB7XG4gICAgICBvblVuY2F1Z2h0RXJyb3IodW5jYXVnaHRFcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3QuaXNSZWFkeUZvckNvbW1pdCA/IHJvb3QuY3VycmVudC5hbHRlcm5hdGUgOiBudWxsO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgYm91bmRhcnkgdGhhdCBjYXB0dXJlZCB0aGUgZXJyb3IsIG9yIG51bGwgaWYgdGhlIGVycm9yIGlzIGlnbm9yZWRcbiAgZnVuY3Rpb24gY2FwdHVyZUVycm9yKGZhaWxlZFdvcmssIGVycm9yKSB7XG4gICAgLy8gSXQgaXMgbm8gbG9uZ2VyIHZhbGlkIGJlY2F1c2Ugd2UgZXhpdGVkIHRoZSB1c2VyIGNvZGUuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmb3IgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkuXG4gICAgdmFyIGJvdW5kYXJ5ID0gbnVsbDtcblxuICAgIC8vIFBhc3NlZCB0byBsb2dDYXB0dXJlZEVycm9yKClcbiAgICB2YXIgZXJyb3JCb3VuZGFyeUZvdW5kID0gZmFsc2U7XG4gICAgdmFyIHdpbGxSZXRyeSA9IGZhbHNlO1xuICAgIHZhciBlcnJvckJvdW5kYXJ5TmFtZSA9IG51bGw7XG5cbiAgICAvLyBIb3N0IGNvbnRhaW5lcnMgYXJlIGEgc3BlY2lhbCBjYXNlLiBJZiB0aGUgZmFpbGVkIHdvcmsgaXRzZWxmIGlzIGEgaG9zdFxuICAgIC8vIGNvbnRhaW5lciwgdGhlbiBpdCBhY3RzIGFzIGl0cyBvd24gYm91bmRhcnkuIEluIGFsbCBvdGhlciBjYXNlcywgd2VcbiAgICAvLyBpZ25vcmUgdGhlIHdvcmsgaXRzZWxmIGFuZCBvbmx5IHNlYXJjaCB0aHJvdWdoIHRoZSBwYXJlbnRzLlxuICAgIGlmIChmYWlsZWRXb3JrLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgIGJvdW5kYXJ5ID0gZmFpbGVkV29yaztcblxuICAgICAgaWYgKGlzRmFpbGVkQm91bmRhcnkoZmFpbGVkV29yaykpIHtcbiAgICAgICAgLy8gSWYgdGhpcyByb290IGFscmVhZHkgZmFpbGVkLCB0aGVyZSBtdXN0IGhhdmUgYmVlbiBhbiBlcnJvciB3aGVuXG4gICAgICAgIC8vIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBpdC4gVGhpcyBpcyBhIHdvcnN0LWNhc2Ugc2NlbmFyaW8gYW5kXG4gICAgICAgIC8vIHNob3VsZCBvbmx5IGJlIHBvc3NpYmxlIGlmIHRoZXJlJ3MgYSBidWcgaW4gdGhlIHJlbmRlcmVyLlxuICAgICAgICBkaWRGYXRhbCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub2RlID0gZmFpbGVkV29ya1sncmV0dXJuJ107XG4gICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiBib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShub2RlKTtcblxuICAgICAgICAgICAgLy8gRm91bmQgYW4gZXJyb3IgYm91bmRhcnkhXG4gICAgICAgICAgICBib3VuZGFyeSA9IG5vZGU7XG4gICAgICAgICAgICB3aWxsUmV0cnkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgICAvLyBUcmVhdCB0aGUgcm9vdCBsaWtlIGEgbm8tb3AgZXJyb3IgYm91bmRhcnlcbiAgICAgICAgICBib3VuZGFyeSA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGYWlsZWRCb3VuZGFyeShub2RlKSkge1xuICAgICAgICAgIC8vIFRoaXMgYm91bmRhcnkgaXMgYWxyZWFkeSBpbiBhIGZhaWxlZCBzdGF0ZS5cblxuICAgICAgICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSB1bm1vdW50aW5nLCB0aGF0IG1lYW5zIHRoaXMgZXJyb3Igd2FzXG4gICAgICAgICAgLy8gdGhyb3duIHdoaWxlIHVubW91bnRpbmcgYSBmYWlsZWQgc3VidHJlZS4gV2Ugc2hvdWxkIGlnbm9yZVxuICAgICAgICAgIC8vIHRoZSBlcnJvci5cbiAgICAgICAgICBpZiAoaXNVbm1vdW50aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgY29tbWl0IHBoYXNlLCB3ZSBzaG91bGQgY2hlY2sgdG8gc2VlIGlmXG4gICAgICAgICAgLy8gdGhpcyBib3VuZGFyeSBhbHJlYWR5IGNhcHR1cmVkIGFuIGVycm9yIGR1cmluZyB0aGlzIGNvbW1pdC5cbiAgICAgICAgICAvLyBUaGlzIGNhc2UgZXhpc3RzIGJlY2F1c2UgbXVsdGlwbGUgZXJyb3JzIGNhbiBiZSB0aHJvd24gZHVyaW5nXG4gICAgICAgICAgLy8gYSBzaW5nbGUgY29tbWl0IHdpdGhvdXQgaW50ZXJydXB0aW9uLlxuICAgICAgICAgIGlmIChjb21taXRQaGFzZUJvdW5kYXJpZXMgIT09IG51bGwgJiYgKGNvbW1pdFBoYXNlQm91bmRhcmllcy5oYXMobm9kZSkgfHwgbm9kZS5hbHRlcm5hdGUgIT09IG51bGwgJiYgY29tbWl0UGhhc2VCb3VuZGFyaWVzLmhhcyhub2RlLmFsdGVybmF0ZSkpKSB7XG4gICAgICAgICAgICAvLyBJZiBzbywgd2Ugc2hvdWxkIGlnbm9yZSB0aGlzIGVycm9yLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVGhlIGVycm9yIHNob3VsZCBwcm9wYWdhdGUgdG8gdGhlIG5leHQgYm91bmRhcnkgLeKAlCB3ZSBrZWVwIGxvb2tpbmcuXG4gICAgICAgICAgYm91bmRhcnkgPSBudWxsO1xuICAgICAgICAgIHdpbGxSZXRyeSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChib3VuZGFyeSAhPT0gbnVsbCkge1xuICAgICAgLy8gQWRkIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGZhaWxlZCBib3VuZGFyaWVzLiBUaGlzIGxldHMgdXMga25vdyB0aGF0XG4gICAgICAvLyBzdWJzZXF1ZW50IGVycm9ycyBpbiB0aGlzIHN1YnRyZWUgc2hvdWxkIHByb3BhZ2F0ZSB0byB0aGUgbmV4dCBib3VuZGFyeS5cbiAgICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICAgIGZhaWxlZEJvdW5kYXJpZXMgPSBuZXcgU2V0KCk7XG4gICAgICB9XG4gICAgICBmYWlsZWRCb3VuZGFyaWVzLmFkZChib3VuZGFyeSk7XG5cbiAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIHVuc2FmZSBvdXRzaWRlIG9mIHRoZSBiZWdpbiBhbmQgY29tcGxldGUgcGhhc2VzLlxuICAgICAgLy8gV2UgbWlnaHQgYmUgaW4gdGhlIGNvbW1pdCBwaGFzZSB3aGVuIGFuIGVycm9yIGlzIGNhcHR1cmVkLlxuICAgICAgLy8gVGhlIHJpc2sgaXMgdGhhdCB0aGUgcmV0dXJuIHBhdGggZnJvbSB0aGlzIEZpYmVyIG1heSBub3QgYmUgYWNjdXJhdGUuXG4gICAgICAvLyBUaGF0IHJpc2sgaXMgYWNjZXB0YWJsZSBnaXZlbiB0aGUgYmVuZWZpdCBvZiBwcm92aWRpbmcgdXNlcnMgbW9yZSBjb250ZXh0LlxuICAgICAgdmFyIF9jb21wb25lbnRTdGFjayA9IGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmFpbGVkV29yayk7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZhaWxlZFdvcmspO1xuXG4gICAgICAvLyBBZGQgdG8gdGhlIGNvbGxlY3Rpb24gb2YgY2FwdHVyZWQgZXJyb3JzLiBUaGlzIGlzIHN0b3JlZCBhcyBhIGdsb2JhbFxuICAgICAgLy8gbWFwIG9mIGVycm9ycyBhbmQgdGhlaXIgY29tcG9uZW50IHN0YWNrIGxvY2F0aW9uIGtleWVkIGJ5IHRoZSBib3VuZGFyaWVzXG4gICAgICAvLyB0aGF0IGNhcHR1cmUgdGhlbS4gV2UgbW9zdGx5IHVzZSB0aGlzIE1hcCBhcyBhIFNldDsgaXQncyBhIE1hcCBvbmx5IHRvXG4gICAgICAvLyBhdm9pZCBhZGRpbmcgYSBmaWVsZCB0byBGaWJlciB0byBzdG9yZSB0aGUgZXJyb3IuXG4gICAgICBpZiAoY2FwdHVyZWRFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgY2FwdHVyZWRFcnJvcnMgPSBuZXcgTWFwKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYXB0dXJlZEVycm9yID0ge1xuICAgICAgICBjb21wb25lbnROYW1lOiBfY29tcG9uZW50TmFtZSxcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IF9jb21wb25lbnRTdGFjayxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBlcnJvckJvdW5kYXJ5OiBlcnJvckJvdW5kYXJ5Rm91bmQgPyBib3VuZGFyeS5zdGF0ZU5vZGUgOiBudWxsLFxuICAgICAgICBlcnJvckJvdW5kYXJ5Rm91bmQ6IGVycm9yQm91bmRhcnlGb3VuZCxcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWU6IGVycm9yQm91bmRhcnlOYW1lLFxuICAgICAgICB3aWxsUmV0cnk6IHdpbGxSZXRyeVxuICAgICAgfTtcblxuICAgICAgY2FwdHVyZWRFcnJvcnMuc2V0KGJvdW5kYXJ5LCBjYXB0dXJlZEVycm9yKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gUHJldmVudCBjeWNsZSBpZiBsb2dDYXB0dXJlZEVycm9yKCkgdGhyb3dzLlxuICAgICAgICAvLyBBIGN5Y2xlIG1heSBzdGlsbCBvY2N1ciBpZiBsb2dDYXB0dXJlZEVycm9yIHJlbmRlcnMgYSBjb21wb25lbnQgdGhhdCB0aHJvd3MuXG4gICAgICAgIHZhciBzdXBwcmVzc0xvZ2dpbmcgPSBlICYmIGUuc3VwcHJlc3NSZWFjdEVycm9yTG9nZ2luZztcbiAgICAgICAgaWYgKCFzdXBwcmVzc0xvZ2dpbmcpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlJ3JlIGluIHRoZSBjb21taXQgcGhhc2UsIGRlZmVyIHNjaGVkdWxpbmcgYW4gdXBkYXRlIG9uIHRoZVxuICAgICAgLy8gYm91bmRhcnkgdW50aWwgYWZ0ZXIgdGhlIGNvbW1pdCBpcyBjb21wbGV0ZVxuICAgICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzID0gbmV3IFNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcy5hZGQoYm91bmRhcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzY2hlZHVsZSBhbiB1cGRhdGUgbm93LlxuICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIGFjdHVhbGx5IG5lY2Vzc2FyeSBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZT8gSXMgaXRcbiAgICAgICAgLy8gcG9zc2libGUgdG8gdW53aW5kIGFuZCBjb250aW51ZSByZW5kZXJpbmcgYXQgdGhlIHNhbWUgcHJpb3JpdHksXG4gICAgICAgIC8vIHdpdGhvdXQgY29ycnVwdGluZyBpbnRlcm5hbCBzdGF0ZT9cbiAgICAgICAgc2NoZWR1bGVFcnJvclJlY292ZXJ5KGJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBib3VuZGFyeTtcbiAgICB9IGVsc2UgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgbm8gYm91bmRhcnkgaXMgZm91bmQsIHdlJ2xsIG5lZWQgdG8gdGhyb3cgdGhlIGVycm9yXG4gICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNDYXB0dXJlZEVycm9yKGZpYmVyKSB7XG4gICAgLy8gVE9ETzogY2FwdHVyZWRFcnJvcnMgc2hvdWxkIHN0b3JlIHRoZSBib3VuZGFyeSBpbnN0YW5jZSwgdG8gYXZvaWQgbmVlZGluZ1xuICAgIC8vIHRvIGNoZWNrIHRoZSBhbHRlcm5hdGUuXG4gICAgcmV0dXJuIGNhcHR1cmVkRXJyb3JzICE9PSBudWxsICYmIChjYXB0dXJlZEVycm9ycy5oYXMoZmliZXIpIHx8IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBjYXB0dXJlZEVycm9ycy5oYXMoZmliZXIuYWx0ZXJuYXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0ZhaWxlZEJvdW5kYXJ5KGZpYmVyKSB7XG4gICAgLy8gVE9ETzogZmFpbGVkQm91bmRhcmllcyBzaG91bGQgc3RvcmUgdGhlIGJvdW5kYXJ5IGluc3RhbmNlLCB0byBhdm9pZFxuICAgIC8vIG5lZWRpbmcgdG8gY2hlY2sgdGhlIGFsdGVybmF0ZS5cbiAgICByZXR1cm4gZmFpbGVkQm91bmRhcmllcyAhPT0gbnVsbCAmJiAoZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIpIHx8IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlci5hbHRlcm5hdGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEVycm9ySGFuZGxpbmcoZWZmZWN0ZnVsRmliZXIpIHtcbiAgICB2YXIgY2FwdHVyZWRFcnJvciA9IHZvaWQgMDtcbiAgICBpZiAoY2FwdHVyZWRFcnJvcnMgIT09IG51bGwpIHtcbiAgICAgIGNhcHR1cmVkRXJyb3IgPSBjYXB0dXJlZEVycm9ycy5nZXQoZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgY2FwdHVyZWRFcnJvcnNbJ2RlbGV0ZSddKGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgIGlmIChjYXB0dXJlZEVycm9yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGVmZmVjdGZ1bEZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGVmZmVjdGZ1bEZpYmVyID0gZWZmZWN0ZnVsRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNhcHR1cmVkRXJyb3IgPSBjYXB0dXJlZEVycm9ycy5nZXQoZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgICAgIGNhcHR1cmVkRXJyb3JzWydkZWxldGUnXShlZmZlY3RmdWxGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNhcHR1cmVkRXJyb3IgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdObyBlcnJvciBmb3IgZ2l2ZW4gdW5pdCBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgc3dpdGNoIChlZmZlY3RmdWxGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGVmZmVjdGZ1bEZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICBjb21wb25lbnRTdGFjazogY2FwdHVyZWRFcnJvci5jb21wb25lbnRTdGFja1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFsbG93IHRoZSBib3VuZGFyeSB0byBoYW5kbGUgdGhlIGVycm9yLCB1c3VhbGx5IGJ5IHNjaGVkdWxpbmdcbiAgICAgICAgLy8gYW4gdXBkYXRlIHRvIGl0c2VsZlxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaChjYXB0dXJlZEVycm9yLmVycm9yLCBpbmZvKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGNhcHR1cmVkRXJyb3IuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCB0eXBlIG9mIHdvcmsuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdW53aW5kQ29udGV4dHMoZnJvbSwgdG8pIHtcbiAgICB2YXIgbm9kZSA9IGZyb207XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICBwb3BDb250ZXh0UHJvdmlkZXIobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dChub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB0byB8fCBub2RlLmFsdGVybmF0ZSA9PT0gdG8pIHtcbiAgICAgICAgc3RvcEZhaWxlZFdvcmtUaW1lcihub2RlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9wV29ya1RpbWVyKG5vZGUpO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVBc3luY0V4cGlyYXRpb24oKSB7XG4gICAgLy8gR2l2ZW4gdGhlIGN1cnJlbnQgY2xvY2sgdGltZSwgcmV0dXJucyBhbiBleHBpcmF0aW9uIHRpbWUuIFdlIHVzZSByb3VuZGluZ1xuICAgIC8vIHRvIGJhdGNoIGxpa2UgdXBkYXRlcyB0b2dldGhlci5cbiAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIH4xMDAwbXMuIDEyMDBtcyBtYXguXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgIHZhciBleHBpcmF0aW9uTXMgPSAxMDAwO1xuICAgIHZhciBidWNrZXRTaXplTXMgPSAyMDA7XG4gICAgcmV0dXJuIGNvbXB1dGVFeHBpcmF0aW9uQnVja2V0KGN1cnJlbnRUaW1lLCBleHBpcmF0aW9uTXMsIGJ1Y2tldFNpemVNcyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKSB7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gdm9pZCAwO1xuICAgIGlmIChleHBpcmF0aW9uQ29udGV4dCAhPT0gTm9Xb3JrKSB7XG4gICAgICAvLyBBbiBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldDtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfSBlbHNlIGlmIChpc1dvcmtpbmcpIHtcbiAgICAgIGlmIChpc0NvbW1pdHRpbmcpIHtcbiAgICAgICAgLy8gVXBkYXRlcyB0aGF0IG9jY3VyIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlIHNob3VsZCBoYXZlIHN5bmMgcHJpb3JpdHlcbiAgICAgICAgLy8gYnkgZGVmYXVsdC5cbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXBkYXRlcyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSBzaG91bGQgZXhwaXJlIGF0IHRoZSBzYW1lIHRpbWUgYXNcbiAgICAgICAgLy8gdGhlIHdvcmsgdGhhdCBpcyBiZWluZyByZW5kZXJlZC5cbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGV4cGxpY2l0IGV4cGlyYXRpb24gY29udGV4dCB3YXMgc2V0LCBhbmQgd2UncmUgbm90IGN1cnJlbnRseVxuICAgICAgLy8gcGVyZm9ybWluZyB3b3JrLiBDYWxjdWxhdGUgYSBuZXcgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKHVzZVN5bmNTY2hlZHVsaW5nICYmICEoZmliZXIuaW50ZXJuYWxDb250ZXh0VGFnICYgQXN5bmNVcGRhdGVzKSkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3luYyB1cGRhdGVcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBhc3luYyB1cGRhdGVcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHBpcmF0aW9uVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICByZXR1cm4gc2NoZWR1bGVXb3JrSW1wbChmaWJlciwgZXhwaXJhdGlvblRpbWUsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrUm9vdE5lZWRzQ2xlYXJpbmcocm9vdCwgZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKCFpc1dvcmtpbmcgJiYgcm9vdCA9PT0gbmV4dFJvb3QgJiYgZXhwaXJhdGlvblRpbWUgPCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFJlc3RhcnQgdGhlIHJvb3QgZnJvbSB0aGUgdG9wLlxuICAgICAgaWYgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJydXB0aW9uLiAoVXNlZCBmb3IgcGVyZm9ybWFuY2UgdHJhY2tpbmcuKVxuICAgICAgICBpbnRlcnJ1cHRlZEJ5ID0gZmliZXI7XG4gICAgICB9XG4gICAgICBuZXh0Um9vdCA9IG51bGw7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IG51bGw7XG4gICAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVXb3JrSW1wbChmaWJlciwgZXhwaXJhdGlvblRpbWUsIGlzRXJyb3JSZWNvdmVyeSkge1xuICAgIHJlY29yZFNjaGVkdWxlVXBkYXRlKCk7XG5cbiAgICB7XG4gICAgICBpZiAoIWlzRXJyb3JSZWNvdmVyeSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMoaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFdhbGsgdGhlIHBhcmVudCBwYXRoIHRvIHRoZSByb290IGFuZCB1cGRhdGUgZWFjaCBub2RlJ3NcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmIChub2RlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5leHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIG5vZGUuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBub2RlLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgbm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgY2hlY2tSb290TmVlZHNDbGVhcmluZyhyb290LCBmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIHJlcXVlc3RXb3JrKHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBjaGVja1Jvb3ROZWVkc0NsZWFyaW5nKHJvb3QsIGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFpc0Vycm9yUmVjb3ZlcnkgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZChmaWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlRXJyb3JSZWNvdmVyeShmaWJlcikge1xuICAgIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIFN5bmMsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpIHtcbiAgICAvLyBTdWJ0cmFjdCBpbml0aWFsIHRpbWUgc28gaXQgZml0cyBpbnNpZGUgMzJiaXRzXG4gICAgdmFyIG1zID0gbm93KCkgLSBzdGFydFRpbWU7XG4gICAgbW9zdFJlY2VudEN1cnJlbnRUaW1lID0gbXNUb0V4cGlyYXRpb25UaW1lKG1zKTtcbiAgICByZXR1cm4gbW9zdFJlY2VudEN1cnJlbnRUaW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmZXJyZWRVcGRhdGVzKGZuKSB7XG4gICAgdmFyIHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgICBleHBpcmF0aW9uQ29udGV4dCA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cGlyYXRpb25Db250ZXh0ID0gcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzeW5jVXBkYXRlcyhmbikge1xuICAgIHZhciBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0ID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgZXhwaXJhdGlvbkNvbnRleHQgPSBTeW5jO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZXhwaXJhdGlvbkNvbnRleHQgPSBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0O1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEV2ZXJ5dGhpbmcgYmVsb3cgdGhpcyBpcyB3cml0dGVuIGFzIGlmIGl0IGhhcyBiZWVuIGxpZnRlZCB0byB0aGVcbiAgLy8gcmVuZGVyZXJzLiBJJ2xsIGRvIHRoaXMgaW4gYSBmb2xsb3ctdXAuXG5cbiAgLy8gTGlua2VkLWxpc3Qgb2Ygcm9vdHNcbiAgdmFyIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gIHZhciBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG5cbiAgdmFyIGNhbGxiYWNrRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIHZhciBjYWxsYmFja0lEID0gLTE7XG4gIHZhciBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB2YXIgbmV4dEZsdXNoZWRSb290ID0gbnVsbDtcbiAgdmFyIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIHZhciBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xuICB2YXIgaGFzVW5oYW5kbGVkRXJyb3IgPSBmYWxzZTtcbiAgdmFyIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbiAgdmFyIGRlYWRsaW5lID0gbnVsbDtcblxuICB2YXIgaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgdmFyIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcblxuICAvLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG4gIHZhciBORVNURURfVVBEQVRFX0xJTUlUID0gMTAwMDtcbiAgdmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICB2YXIgdGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmsgPSAxO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2tXaXRoRXhwaXJhdGlvbihleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjYWxsYmFja0V4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAgIC8vIEEgY2FsbGJhY2sgaXMgYWxyZWFkeSBzY2hlZHVsZWQuIENoZWNrIGl0cyBleHBpcmF0aW9uIHRpbWUgKHRpbWVvdXQpLlxuICAgICAgaWYgKGV4cGlyYXRpb25UaW1lID4gY2FsbGJhY2tFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgc3VmZmljaWVudCB0aW1lb3V0LiBFeGl0LlxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgaW5zdWZmaWNpZW50IHRpbWVvdXQuIENhbmNlbCBhbmQgc2NoZWR1bGUgYVxuICAgICAgICAvLyBuZXcgb25lLlxuICAgICAgICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrKGNhbGxiYWNrSUQpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHJlcXVlc3QgY2FsbGJhY2sgdGltZXIgaXMgYWxyZWFkeSBydW5uaW5nLiBEb24ndCBzdGFydCBhIG5ldyBvbmUuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIoKTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGEgdGltZW91dCBmb3IgdGhlIGdpdmVuIGV4cGlyYXRpb24gdGltZS5cbiAgICB2YXIgY3VycmVudE1zID0gbm93KCkgLSBzdGFydFRpbWU7XG4gICAgdmFyIGV4cGlyYXRpb25NcyA9IGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSk7XG4gICAgdmFyIHRpbWVvdXQgPSBleHBpcmF0aW9uTXMgLSBjdXJyZW50TXM7XG5cbiAgICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgY2FsbGJhY2tJRCA9IHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayhwZXJmb3JtQXN5bmNXb3JrLCB7IHRpbWVvdXQ6IHRpbWVvdXQgfSk7XG4gIH1cblxuICAvLyByZXF1ZXN0V29yayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB3aGVuZXZlciBhIHJvb3QgcmVjZWl2ZXMgYW4gdXBkYXRlLlxuICAvLyBJdCdzIHVwIHRvIHRoZSByZW5kZXJlciB0byBjYWxsIHJlbmRlclJvb3QgYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLlxuICBmdW5jdGlvbiByZXF1ZXN0V29yayhyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCByZXBlYXRlZGx5IGNhbGxzIHNldFN0YXRlIGluc2lkZSBjb21wb25lbnRXaWxsVXBkYXRlIG9yIGNvbXBvbmVudERpZFVwZGF0ZS4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHJvb3QgdG8gdGhlIHNjaGVkdWxlLlxuICAgIC8vIENoZWNrIGlmIHRoaXMgcm9vdCBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIHNjaGVkdWxlLlxuICAgIGlmIChyb290Lm5leHRTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHJvb3QgaXMgbm90IGFscmVhZHkgc2NoZWR1bGVkLiBBZGQgaXQuXG4gICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgc2NoZWR1bGVkLCBidXQgaXRzIHByaW9yaXR5IG1heSBoYXZlIGluY3JlYXNlZC5cbiAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBleHBpcmF0aW9uVGltZSA8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHkuXG4gICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICAgIC8vIFByZXZlbnQgcmVlbnRyYW5jeS4gUmVtYWluaW5nIHdvcmsgd2lsbCBiZSBzY2hlZHVsZWQgYXQgdGhlIGVuZCBvZlxuICAgICAgLy8gdGhlIGN1cnJlbnRseSByZW5kZXJpbmcgYmF0Y2guXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAvLyBGbHVzaCB3b3JrIGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLlxuICAgICAgaWYgKGlzVW5iYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgICAgLy8gLi4udW5sZXNzIHdlJ3JlIGluc2lkZSB1bmJhdGNoZWRVcGRhdGVzLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZFxuICAgICAgICAvLyBmbHVzaCBpdCBub3cuXG4gICAgICAgIG5leHRGbHVzaGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgICBwZXJmb3JtV29ya09uUm9vdChuZXh0Rmx1c2hlZFJvb3QsIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEdldCByaWQgb2YgU3luYyBhbmQgdXNlIGN1cnJlbnQgdGltZT9cbiAgICBpZiAoZXhwaXJhdGlvblRpbWUgPT09IFN5bmMpIHtcbiAgICAgIHBlcmZvcm1Xb3JrKFN5bmMsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24oZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCkge1xuICAgIHZhciBoaWdoZXN0UHJpb3JpdHlXb3JrID0gTm9Xb3JrO1xuICAgIHZhciBoaWdoZXN0UHJpb3JpdHlSb290ID0gbnVsbDtcblxuICAgIGlmIChsYXN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZpb3VzU2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290O1xuICAgICAgdmFyIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB3aGlsZSAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yaykge1xuICAgICAgICAgIC8vIFRoaXMgcm9vdCBubyBsb25nZXIgaGFzIHdvcmsuIFJlbW92ZSBpdCBmcm9tIHRoZSBzY2hlZHVsZXIuXG5cbiAgICAgICAgICAvLyBUT0RPOiBUaGlzIGNoZWNrIGlzIHJlZHVkYW50LCBidXQgRmxvdyBpcyBjb25mdXNlZCBieSB0aGUgYnJhbmNoXG4gICAgICAgICAgLy8gYmVsb3cgd2hlcmUgd2Ugc2V0IGxhc3RTY2hlZHVsZWRSb290IHRvIG51bGwsIGV2ZW4gdGhvdWdoIHdlIGJyZWFrXG4gICAgICAgICAgLy8gZnJvbSB0aGUgbG9vcCByaWdodCBhZnRlci5cbiAgICAgICAgICAhKHByZXZpb3VzU2NoZWR1bGVkUm9vdCAhPT0gbnVsbCAmJiBsYXN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBhIHByZXZpb3VzIGFuZCBsYXN0IHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgaWYgKHJvb3QgPT09IHJvb3QubmV4dFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChyb290ID09PSBmaXJzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICB2YXIgbmV4dCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBuZXh0O1xuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBuZXh0O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChyb290ID09PSBsYXN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGFzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZpb3VzU2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcm9vdCA9IHByZXZpb3VzU2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaGlnaGVzdFByaW9yaXR5V29yayA9PT0gTm9Xb3JrIHx8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lIDwgaGlnaGVzdFByaW9yaXR5V29yaykge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcmlvcml0eSwgaWYgaXQncyBoaWdoZXJcbiAgICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVdvcmsgPSByZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVJvb3QgPSByb290O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICAgIHJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG5leHQgcm9vdCBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgcm9vdCwgdGhpcyBpcyBhIG5lc3RlZFxuICAgIC8vIHVwZGF0ZS4gVG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLCBpbmNyZW1lbnQgdGhlIG5lc3RlZCB1cGRhdGUgY291bnQuXG4gICAgdmFyIHByZXZpb3VzRmx1c2hlZFJvb3QgPSBuZXh0Rmx1c2hlZFJvb3Q7XG4gICAgaWYgKHByZXZpb3VzRmx1c2hlZFJvb3QgIT09IG51bGwgJiYgcHJldmlvdXNGbHVzaGVkUm9vdCA9PT0gaGlnaGVzdFByaW9yaXR5Um9vdCkge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzZXQgd2hlbmV2ZXIgd2Ugc3dpdGNoIHJvb3RzLlxuICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgIH1cbiAgICBuZXh0Rmx1c2hlZFJvb3QgPSBoaWdoZXN0UHJpb3JpdHlSb290O1xuICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBoaWdoZXN0UHJpb3JpdHlXb3JrO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUFzeW5jV29yayhkbCkge1xuICAgIHBlcmZvcm1Xb3JrKE5vV29yaywgZGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVdvcmsobWluRXhwaXJhdGlvblRpbWUsIGRsKSB7XG4gICAgZGVhZGxpbmUgPSBkbDtcblxuICAgIC8vIEtlZXAgd29ya2luZyBvbiByb290cyB1bnRpbCB0aGVyZSdzIG5vIG1vcmUgd29yaywgb3IgdW50aWwgdGhlIHdlIHJlYWNoXG4gICAgLy8gdGhlIGRlYWRsaW5lLlxuICAgIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG5cbiAgICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSAmJiBkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRpZEV4cGlyZSA9IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPCByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCk7XG4gICAgICBzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIoZGlkRXhwaXJlKTtcbiAgICB9XG5cbiAgICB3aGlsZSAobmV4dEZsdXNoZWRSb290ICE9PSBudWxsICYmIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiAobWluRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIDw9IG1pbkV4cGlyYXRpb25UaW1lKSAmJiAhZGVhZGxpbmVEaWRFeHBpcmUpIHtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KG5leHRGbHVzaGVkUm9vdCwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICAvLyBGaW5kIHRoZSBuZXh0IGhpZ2hlc3QgcHJpb3JpdHkgd29yay5cbiAgICAgIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG4gICAgfVxuXG4gICAgLy8gV2UncmUgZG9uZSBmbHVzaGluZyB3b3JrLiBFaXRoZXIgd2UgcmFuIG91dCBvZiB0aW1lIGluIHRoaXMgY2FsbGJhY2ssXG4gICAgLy8gb3IgdGhlcmUncyBubyBtb3JlIHdvcmsgbGVmdCB3aXRoIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG5cbiAgICAvLyBJZiB3ZSdyZSBpbnNpZGUgYSBjYWxsYmFjaywgc2V0IHRoaXMgdG8gZmFsc2Ugc2luY2Ugd2UganVzdCBjb21wbGV0ZWQgaXQuXG4gICAgaWYgKGRlYWRsaW5lICE9PSBudWxsKSB7XG4gICAgICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgICAgY2FsbGJhY2tJRCA9IC0xO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIHdvcmsgbGVmdCBvdmVyLCBzY2hlZHVsZSBhIG5ldyBjYWxsYmFjay5cbiAgICBpZiAobmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24obmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4tdXAuXG4gICAgZGVhZGxpbmUgPSBudWxsO1xuICAgIGRlYWRsaW5lRGlkRXhwaXJlID0gZmFsc2U7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuXG4gICAgaWYgKGhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICB2YXIgX2Vycm9yNCA9IHVuaGFuZGxlZEVycm9yO1xuICAgICAgdW5oYW5kbGVkRXJyb3IgPSBudWxsO1xuICAgICAgaGFzVW5oYW5kbGVkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHRocm93IF9lcnJvcjQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAhIWlzUmVuZGVyaW5nID8gaW52YXJpYW50KGZhbHNlLCAncGVyZm9ybVdvcmtPblJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIGlzUmVuZGVyaW5nID0gdHJ1ZTtcblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYXN5bmMgd29yayBvciBzeW5jL2V4cGlyZWQgd29yay5cbiAgICAvLyBUT0RPOiBQYXNzIGN1cnJlbnQgdGltZSBhcyBhcmd1bWVudCB0byByZW5kZXJSb290LCBjb21taXRSb290XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lIDw9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSkge1xuICAgICAgLy8gRmx1c2ggc3luYyB3b3JrLlxuICAgICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKGZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBjb21wbGV0ZS4gV2UgY2FuIGNvbW1pdCBpdC5cbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgICBmaW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKGZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGNvbXBsZXRlZCB0aGUgcm9vdC4gQ29tbWl0IGl0LlxuICAgICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmx1c2ggYXN5bmMgd29yay5cbiAgICAgIHZhciBfZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gICAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBjb21wbGV0ZS4gV2UgY2FuIGNvbW1pdCBpdC5cbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChfZmluaXNoZWRXb3JrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgX2ZpbmlzaGVkV29yayA9IHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGNvbXBsZXRlZCB0aGUgcm9vdC4gQ2hlY2sgdGhlIGRlYWRsaW5lIG9uZSBtb3JlIHRpbWVcbiAgICAgICAgICAvLyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgICBpZiAoIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgICAgIC8vIFN0aWxsIHRpbWUgbGVmdC4gQ29tbWl0IHRoZSByb290LlxuICAgICAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoX2ZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0LiBNYXJrIHRoaXMgcm9vdCBhcyBjb21wbGV0ZS4gV2UnbGwgY29tZVxuICAgICAgICAgICAgLy8gYmFjayBhbmQgY29tbWl0IGl0IGxhdGVyLlxuICAgICAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBfZmluaXNoZWRXb3JrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cblxuICAvLyBXaGVuIHdvcmtpbmcgb24gYXN5bmMgd29yaywgdGhlIHJlY29uY2lsZXIgYXNrcyB0aGUgcmVuZGVyZXIgaWYgaXQgc2hvdWxkXG4gIC8vIHlpZWxkIGV4ZWN1dGlvbi4gRm9yIERPTSwgd2UgaW1wbGVtZW50IHRoaXMgd2l0aCByZXF1ZXN0SWRsZUNhbGxiYWNrLlxuICBmdW5jdGlvbiBzaG91bGRZaWVsZCgpIHtcbiAgICBpZiAoZGVhZGxpbmUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSA+IHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrKSB7XG4gICAgICAvLyBEaXNyZWdhcmQgZGVhZGxpbmUuZGlkVGltZW91dC4gT25seSBleHBpcmVkIHdvcmsgc2hvdWxkIGJlIGZsdXNoZWRcbiAgICAgIC8vIGR1cmluZyBhIHRpbWVvdXQuIFRoaXMgcGF0aCBpcyBvbmx5IGhpdCBmb3Igbm9uLWV4cGlyZWQgd29yay5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVhZGxpbmVEaWRFeHBpcmUgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVE9ETzogTm90IGhhcHB5IGFib3V0IHRoaXMgaG9vay4gQ29uY2VwdHVhbGx5LCByZW5kZXJSb290IHNob3VsZCByZXR1cm4gYVxuICAvLyB0dXBsZSBvZiAoaXNSZWFkeUZvckNvbW1pdCwgZGlkRXJyb3IsIGVycm9yKVxuICBmdW5jdGlvbiBvblVuY2F1Z2h0RXJyb3IoZXJyb3IpIHtcbiAgICAhKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgd29ya2luZyBvbiBhIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgLy8gVW5zY2hlZHVsZSB0aGlzIHJvb3Qgc28gd2UgZG9uJ3Qgd29yayBvbiBpdCBhZ2FpbiB1bnRpbCB0aGVyZSdzXG4gICAgLy8gYW5vdGhlciB1cGRhdGUuXG4gICAgbmV4dEZsdXNoZWRSb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIGlmICghaGFzVW5oYW5kbGVkRXJyb3IpIHtcbiAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICAgIHVuaGFuZGxlZEVycm9yID0gZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoZm4sIGEpIHtcbiAgICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgICBpZiAoIWlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1JlbmRlcmluZykge1xuICAgICAgICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3QgaW5zaWRlXG4gIC8vIHRoZSByZWNvbmNpbGVyLlxuICBmdW5jdGlvbiB1bmJhdGNoZWRVcGRhdGVzKGZuKSB7XG4gICAgaWYgKGlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm4oKTtcbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCB3aXRoaW5cbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGZsdXNoU3luYyhmbikge1xuICAgIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzID0gaXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gc3luY1VwZGF0ZXMoZm4pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgICAhIWlzUmVuZGVyaW5nID8gaW52YXJpYW50KGZhbHNlLCAnZmx1c2hTeW5jIHdhcyBjYWxsZWQgZnJvbSBpbnNpZGUgYSBsaWZlY3ljbGUgbWV0aG9kLiBJdCBjYW5ub3QgYmUgY2FsbGVkIHdoZW4gUmVhY3QgaXMgYWxyZWFkeSByZW5kZXJpbmcuJykgOiB2b2lkIDA7XG4gICAgICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbXB1dGVBc3luY0V4cGlyYXRpb246IGNvbXB1dGVBc3luY0V4cGlyYXRpb24sXG4gICAgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcjogY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcixcbiAgICBzY2hlZHVsZVdvcms6IHNjaGVkdWxlV29yayxcbiAgICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gICAgdW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcbiAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcbiAgICBkZWZlcnJlZFVwZGF0ZXM6IGRlZmVycmVkVXBkYXRlc1xuICB9O1xufTtcblxue1xuICB2YXIgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xufVxuXG4vLyAwIGlzIFBST0QsIDEgaXMgREVWLlxuLy8gTWlnaHQgYWRkIFBST0ZJTEUgbGF0ZXIuXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KSB7XG4gIGlmICghcGFyZW50Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gIHZhciBwYXJlbnRDb250ZXh0ID0gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpO1xuICByZXR1cm4gaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpID8gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgcGFyZW50Q29udGV4dCkgOiBwYXJlbnRDb250ZXh0O1xufVxuXG52YXIgUmVhY3RGaWJlclJlY29uY2lsZXIkMSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGdldFB1YmxpY0luc3RhbmNlID0gY29uZmlnLmdldFB1YmxpY0luc3RhbmNlO1xuXG4gIHZhciBfUmVhY3RGaWJlclNjaGVkdWxlciA9IFJlYWN0RmliZXJTY2hlZHVsZXIoY29uZmlnKSxcbiAgICAgIGNvbXB1dGVBc3luY0V4cGlyYXRpb24gPSBfUmVhY3RGaWJlclNjaGVkdWxlci5jb21wdXRlQXN5bmNFeHBpcmF0aW9uLFxuICAgICAgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsXG4gICAgICBzY2hlZHVsZVdvcmsgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5zY2hlZHVsZVdvcmssXG4gICAgICBiYXRjaGVkVXBkYXRlcyA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmJhdGNoZWRVcGRhdGVzLFxuICAgICAgdW5iYXRjaGVkVXBkYXRlcyA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLnVuYmF0Y2hlZFVwZGF0ZXMsXG4gICAgICBmbHVzaFN5bmMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5mbHVzaFN5bmMsXG4gICAgICBkZWZlcnJlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5kZWZlcnJlZFVwZGF0ZXM7XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVUb3BMZXZlbFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHtcbiAgICAgIGlmIChSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID09PSAncmVuZGVyJyAmJiBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgICAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgJyArICd0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyBub3QgYWxsb3dlZC4gJyArICdJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gY29tcG9uZW50RGlkVXBkYXRlLlxcblxcbicgKyAnQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgZ2V0Q29tcG9uZW50TmFtZShSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQpIHx8ICdVbmtub3duJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgIHtcbiAgICAgIHdhcm5pbmcoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLCAncmVuZGVyKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gdm9pZCAwO1xuICAgIC8vIENoZWNrIGlmIHRoZSB0b3AtbGV2ZWwgZWxlbWVudCBpcyBhbiBhc3luYyB3cmFwcGVyIGNvbXBvbmVudC4gSWYgc28sXG4gICAgLy8gdHJlYXQgdXBkYXRlcyB0byB0aGUgcm9vdCBhcyBhc3luYy4gVGhpcyBpcyBhIGJpdCB3ZWlyZCBidXQgbGV0cyB1c1xuICAgIC8vIGF2b2lkIGEgc2VwYXJhdGUgYHJlbmRlckFzeW5jYCBBUEkuXG4gICAgaWYgKGVuYWJsZUFzeW5jU3VidHJlZUFQSSAmJiBlbGVtZW50ICE9IG51bGwgJiYgZWxlbWVudC50eXBlICE9IG51bGwgJiYgZWxlbWVudC50eXBlLnByb3RvdHlwZSAhPSBudWxsICYmIGVsZW1lbnQudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50ID09PSB0cnVlKSB7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnQpO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICBwYXJ0aWFsU3RhdGU6IHsgZWxlbWVudDogZWxlbWVudCB9LFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgIGlzRm9yY2VkOiBmYWxzZSxcbiAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihjdXJyZW50LCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlV29yayhjdXJyZW50LCBleHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlKGZpYmVyKSB7XG4gICAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcbiAgICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZUNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgaHlkcmF0ZSk7XG4gICAgfSxcbiAgICB1cGRhdGVDb250YWluZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spIHtcbiAgICAgIC8vIFRPRE86IElmIHRoaXMgaXMgYSBuZXN0ZWQgY29udGFpbmVyLCB0aGlzIHdvbid0IGJlIHRoZSByb290LlxuICAgICAgdmFyIGN1cnJlbnQgPSBjb250YWluZXIuY3VycmVudDtcblxuICAgICAge1xuICAgICAgICBpZiAoUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICAgIGlmIChjdXJyZW50LmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbk1vdW50Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uVW5tb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uVXBkYXRlQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KTtcbiAgICAgIGlmIChjb250YWluZXIuY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICBjb250YWluZXIuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgfVxuXG4gICAgICBzY2hlZHVsZVRvcExldmVsVXBkYXRlKGN1cnJlbnQsIGVsZW1lbnQsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG5cbiAgICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgICB1bmJhdGNoZWRVcGRhdGVzOiB1bmJhdGNoZWRVcGRhdGVzLFxuXG4gICAgZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXMsXG5cbiAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcblxuICAgIGdldFB1YmxpY1Jvb3RJbnN0YW5jZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgdmFyIGNvbnRhaW5lckZpYmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjb250YWluZXJGaWJlci5jaGlsZC50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgfSxcblxuXG4gICAgZmluZEhvc3RJbnN0YW5jZTogZmluZEhvc3RJbnN0YW5jZSxcblxuICAgIGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMoZmliZXIpO1xuICAgICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICAgIH0sXG4gICAgaW5qZWN0SW50b0RldlRvb2xzOiBmdW5jdGlvbiAoZGV2VG9vbHNDb25maWcpIHtcbiAgICAgIHZhciBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSA9IGRldlRvb2xzQ29uZmlnLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO1xuXG4gICAgICByZXR1cm4gaW5qZWN0SW50ZXJuYWxzKF9hc3NpZ24oe30sIGRldlRvb2xzQ29uZmlnLCB7XG4gICAgICAgIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICByZXR1cm4gZmluZEhvc3RJbnN0YW5jZShmaWJlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICBpZiAoIWZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyBNaWdodCBub3QgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIHJlbmRlcmVyLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgUmVhY3RGaWJlclJlY29uY2lsZXIkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdEZpYmVyUmVjb25jaWxlciQxXG59KTtcblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDMgPSAoIFJlYWN0RmliZXJSZWNvbmNpbGVyJDIgJiYgUmVhY3RGaWJlclJlY29uY2lsZXIkMSApIHx8IFJlYWN0RmliZXJSZWNvbmNpbGVyJDI7XG5cbi8vIFRPRE86IGJ1bmRsZSBGbG93IHR5cGVzIHdpdGggdGhlIHBhY2thZ2UuXG5cblxuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdC5cbnZhciByZWFjdFJlY29uY2lsZXIgPSBSZWFjdEZpYmVyUmVjb25jaWxlciQzWydkZWZhdWx0J10gPyBSZWFjdEZpYmVyUmVjb25jaWxlciQzWydkZWZhdWx0J10gOiBSZWFjdEZpYmVyUmVjb25jaWxlciQzO1xuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVySW5mbyxcbi8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IFBvcnRhbFxuICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICBrZXk6IGtleSA9PSBudWxsID8gbnVsbCA6ICcnICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi4yLjAnO1xuXG4vLyBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgc3RvcmluZyB0aGUgdGltZSBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBmcmFtZSwgdGhlblxuLy8gc2NoZWR1bGluZyBhIHBvc3RNZXNzYWdlIHdoaWNoIGdldHMgc2NoZWR1bGVkIGFmdGVyIHBhaW50LiBXaXRoaW4gdGhlXG4vLyBwb3N0TWVzc2FnZSBoYW5kbGVyIGRvIGFzIG11Y2ggd29yayBhcyBwb3NzaWJsZSB1bnRpbCB0aW1lICsgZnJhbWUgcmF0ZS5cbi8vIEJ5IHNlcGFyYXRpbmcgdGhlIGlkbGUgY2FsbCBpbnRvIGEgc2VwYXJhdGUgZXZlbnQgdGljayB3ZSBlbnN1cmUgdGhhdFxuLy8gbGF5b3V0LCBwYWludCBhbmQgb3RoZXIgYnJvd3NlciB3b3JrIGlzIGNvdW50ZWQgYWdhaW5zdCB0aGUgYXZhaWxhYmxlIHRpbWUuXG4vLyBUaGUgZnJhbWUgcmF0ZSBpcyBkeW5hbWljYWxseSBhZGp1c3RlZC5cblxue1xuICBpZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgZGVwZW5kcyBvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cDovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICB9XG59XG5cbnZhciBoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdyA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIG5vdyA9IHZvaWQgMDtcbmlmIChoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdykge1xuICBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xufVxuXG4vLyBUT0RPOiBUaGVyZSdzIG5vIHdheSB0byBjYW5jZWwsIGJlY2F1c2UgRmliZXIgZG9lc24ndCBhdG0uXG52YXIgcklDID0gdm9pZCAwO1xudmFyIGNJQyA9IHZvaWQgMDtcblxuaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcklDID0gZnVuY3Rpb24gKGZyYW1lQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBmcmFtZUNhbGxiYWNrKHtcbiAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIGNJQyA9IGZ1bmN0aW9uICh0aW1lb3V0SUQpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGNhbmNlbElkbGVDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAvLyBQb2x5ZmlsbCByZXF1ZXN0SWRsZUNhbGxiYWNrIGFuZCBjYW5jZWxJZGxlQ2FsbGJhY2tcblxuICB2YXIgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICB2YXIgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciB0aW1lb3V0VGltZSA9IC0xO1xuXG4gIHZhciBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgdmFyIGZyYW1lRGVhZGxpbmUgPSAwO1xuICAvLyBXZSBzdGFydCBvdXQgYXNzdW1pbmcgdGhhdCB3ZSBydW4gYXQgMzBmcHMgYnV0IHRoZW4gdGhlIGhldXJpc3RpYyB0cmFja2luZ1xuICAvLyB3aWxsIGFkanVzdCB0aGlzIHZhbHVlIHRvIGEgZmFzdGVyIGZwcyBpZiB3ZSBnZXQgbW9yZSBmcmVxdWVudCBhbmltYXRpb25cbiAgLy8gZnJhbWVzLlxuICB2YXIgcHJldmlvdXNGcmFtZVRpbWUgPSAzMztcbiAgdmFyIGFjdGl2ZUZyYW1lVGltZSA9IDMzO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lT2JqZWN0O1xuICBpZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgICBmcmFtZURlYWRsaW5lT2JqZWN0ID0ge1xuICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGlmIHdlIGhhdmUgYSBwZXJmb3JtYW5jZSB0aW1lciB0aGF0IHRoZSByQUYgY2FsbGJhY2tcbiAgICAgICAgLy8gZ2V0cyBhIHBlcmZvcm1hbmNlIHRpbWVyIHZhbHVlLiBOb3Qgc3VyZSBpZiB0aGlzIGlzIGFsd2F5cyB0cnVlLlxuICAgICAgICB2YXIgcmVtYWluaW5nID0gZnJhbWVEZWFkbGluZSAtIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nID4gMCA/IHJlbWFpbmluZyA6IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBmcmFtZURlYWRsaW5lT2JqZWN0ID0ge1xuICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIERhdGUubm93KClcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGZyYW1lRGVhZGxpbmUgLSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nID4gMCA/IHJlbWFpbmluZyA6IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIFdlIHVzZSB0aGUgcG9zdE1lc3NhZ2UgdHJpY2sgdG8gZGVmZXIgaWRsZSB3b3JrIHVudGlsIGFmdGVyIHRoZSByZXBhaW50LlxuICB2YXIgbWVzc2FnZUtleSA9ICdfX3JlYWN0SWRsZUNhbGxiYWNrJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbiAgdmFyIGlkbGVUaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnNvdXJjZSAhPT0gd2luZG93IHx8IGV2ZW50LmRhdGEgIT09IG1lc3NhZ2VLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpc0lkbGVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgIHZhciBjdXJyZW50VGltZSA9IG5vdygpO1xuICAgIGlmIChmcmFtZURlYWRsaW5lIC0gY3VycmVudFRpbWUgPD0gMCkge1xuICAgICAgLy8gVGhlcmUncyBubyB0aW1lIGxlZnQgaW4gdGhpcyBpZGxlIHBlcmlvZC4gQ2hlY2sgaWYgdGhlIGNhbGxiYWNrIGhhc1xuICAgICAgLy8gYSB0aW1lb3V0IGFuZCB3aGV0aGVyIGl0J3MgYmVlbiBleGNlZWRlZC5cbiAgICAgIGlmICh0aW1lb3V0VGltZSAhPT0gLTEgJiYgdGltZW91dFRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgICAgLy8gRXhjZWVkZWQgdGhlIHRpbWVvdXQuIEludm9rZSB0aGUgY2FsbGJhY2sgZXZlbiB0aG91Z2ggdGhlcmUncyBub1xuICAgICAgICAvLyB0aW1lIGxlZnQuXG4gICAgICAgIGZyYW1lRGVhZGxpbmVPYmplY3QuZGlkVGltZW91dCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyB0aW1lb3V0LlxuICAgICAgICBpZiAoIWlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQpIHtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbm90aGVyIGFuaW1hdGlvbiBjYWxsYmFjayBzbyB3ZSByZXRyeSBsYXRlci5cbiAgICAgICAgICBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uVGljayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhpdCB3aXRob3V0IGludm9raW5nIHRoZSBjYWxsYmFjay5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIHN0aWxsIHRpbWUgbGVmdCBpbiB0aGlzIGlkbGUgcGVyaW9kLlxuICAgICAgZnJhbWVEZWFkbGluZU9iamVjdC5kaWRUaW1lb3V0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGltZW91dFRpbWUgPSAtMTtcbiAgICB2YXIgY2FsbGJhY2sgPSBzY2hlZHVsZWRSSUNDYWxsYmFjaztcbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IG51bGw7XG4gICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhmcmFtZURlYWRsaW5lT2JqZWN0KTtcbiAgICB9XG4gIH07XG4gIC8vIEFzc3VtZXMgdGhhdCB3ZSBoYXZlIGFkZEV2ZW50TGlzdGVuZXIgaW4gdGhpcyBlbnZpcm9ubWVudC4gTWlnaHQgbmVlZFxuICAvLyBzb21ldGhpbmcgYmV0dGVyIGZvciBvbGQgSUUuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaWRsZVRpY2ssIGZhbHNlKTtcblxuICB2YXIgYW5pbWF0aW9uVGljayA9IGZ1bmN0aW9uIChyYWZUaW1lKSB7XG4gICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0RnJhbWVUaW1lID0gcmFmVGltZSAtIGZyYW1lRGVhZGxpbmUgKyBhY3RpdmVGcmFtZVRpbWU7XG4gICAgaWYgKG5leHRGcmFtZVRpbWUgPCBhY3RpdmVGcmFtZVRpbWUgJiYgcHJldmlvdXNGcmFtZVRpbWUgPCBhY3RpdmVGcmFtZVRpbWUpIHtcbiAgICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgOCkge1xuICAgICAgICAvLyBEZWZlbnNpdmUgY29kaW5nLiBXZSBkb24ndCBzdXBwb3J0IGhpZ2hlciBmcmFtZSByYXRlcyB0aGFuIDEyMGh6LlxuICAgICAgICAvLyBJZiB3ZSBnZXQgbG93ZXIgdGhhbiB0aGF0LCBpdCBpcyBwcm9iYWJseSBhIGJ1Zy5cbiAgICAgICAgbmV4dEZyYW1lVGltZSA9IDg7XG4gICAgICB9XG4gICAgICAvLyBJZiBvbmUgZnJhbWUgZ29lcyBsb25nLCB0aGVuIHRoZSBuZXh0IG9uZSBjYW4gYmUgc2hvcnQgdG8gY2F0Y2ggdXAuXG4gICAgICAvLyBJZiB0d28gZnJhbWVzIGFyZSBzaG9ydCBpbiBhIHJvdywgdGhlbiB0aGF0J3MgYW4gaW5kaWNhdGlvbiB0aGF0IHdlXG4gICAgICAvLyBhY3R1YWxseSBoYXZlIGEgaGlnaGVyIGZyYW1lIHJhdGUgdGhhbiB3aGF0IHdlJ3JlIGN1cnJlbnRseSBvcHRpbWl6aW5nLlxuICAgICAgLy8gV2UgYWRqdXN0IG91ciBoZXVyaXN0aWMgZHluYW1pY2FsbHkgYWNjb3JkaW5nbHkuIEZvciBleGFtcGxlLCBpZiB3ZSdyZVxuICAgICAgLy8gcnVubmluZyBvbiAxMjBoeiBkaXNwbGF5IG9yIDkwaHogVlIgZGlzcGxheS5cbiAgICAgIC8vIFRha2UgdGhlIG1heCBvZiB0aGUgdHdvIGluIGNhc2Ugb25lIG9mIHRoZW0gd2FzIGFuIGFub21hbHkgZHVlIHRvXG4gICAgICAvLyBtaXNzZWQgZnJhbWUgZGVhZGxpbmVzLlxuICAgICAgYWN0aXZlRnJhbWVUaW1lID0gbmV4dEZyYW1lVGltZSA8IHByZXZpb3VzRnJhbWVUaW1lID8gcHJldmlvdXNGcmFtZVRpbWUgOiBuZXh0RnJhbWVUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91c0ZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWU7XG4gICAgfVxuICAgIGZyYW1lRGVhZGxpbmUgPSByYWZUaW1lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmICghaXNJZGxlU2NoZWR1bGVkKSB7XG4gICAgICBpc0lkbGVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgd2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2VLZXksICcqJyk7XG4gICAgfVxuICB9O1xuXG4gIHJJQyA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIC8vIFRoaXMgYXNzdW1lcyB0aGF0IHdlIG9ubHkgc2NoZWR1bGUgb25lIGNhbGxiYWNrIGF0IGEgdGltZSBiZWNhdXNlIHRoYXQnc1xuICAgIC8vIGhvdyBGaWJlciB1c2VzIGl0LlxuICAgIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9ucy50aW1lb3V0ID09PSAnbnVtYmVyJykge1xuICAgICAgdGltZW91dFRpbWUgPSBub3coKSArIG9wdGlvbnMudGltZW91dDtcbiAgICB9XG4gICAgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAvLyBJZiByQUYgZGlkbid0IGFscmVhZHkgc2NoZWR1bGUgb25lLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgZnJhbWUuXG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIHJBRiBkb2Vzbid0IG1hdGVyaWFsaXplIGJlY2F1c2UgdGhlIGJyb3dzZXIgdGhyb3R0bGVzLCB3ZVxuICAgICAgLy8gbWlnaHQgd2FudCB0byBzdGlsbCBoYXZlIHNldFRpbWVvdXQgdHJpZ2dlciBySUMgYXMgYSBiYWNrdXAgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHdlIGtlZXAgcGVyZm9ybWluZyB3b3JrLlxuICAgICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uVGljayk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIGNJQyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IG51bGw7XG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdGltZW91dFRpbWUgPSAtMTtcbiAgfTtcbn0gZWxzZSB7XG4gIHJJQyA9IHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrO1xuICBjSUMgPSB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrO1xufVxuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyQxID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG4vLyBpc0F0dHJpYnV0ZU5hbWVTYWZlKCkgaXMgY3VycmVudGx5IGR1cGxpY2F0ZWQgaW4gRE9NTWFya3VwT3BlcmF0aW9ucy5cbi8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgcGxhY2UgZm9yIHRoaXMuXG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmICh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc2hvdWxkSWdub3JlVmFsdWUoKSBpcyBjdXJyZW50bHkgZHVwbGljYXRlZCBpbiBET01NYXJrdXBPcGVyYXRpb25zLlxuLy8gVE9ETzogRmluZCBhIGJldHRlciBwbGFjZSBmb3IgdGhpcy5cbmZ1bmN0aW9uIHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSAmJiAhdmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSAmJiBpc05hTih2YWx1ZSkgfHwgcHJvcGVydHlJbmZvLmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlICYmIHZhbHVlIDwgMSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gZmFsc2U7XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERPTSBwcm9wZXJ0aWVzLlxuICovXG5cblxuXG5cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgXCJleHBlY3RlZFwiIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLlxuICogU29tZSBwcm9wZXJ0aWVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgZXhwZWN0ZWQpIHtcbiAge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kIHx8IHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVbcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuXG4gICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhZCBhbiBhdHRyaWJ1dGUgYnV0IHNob3VsZG4ndCBoYXZlIGhhZCBvbmUsIHNvIHJlYWQgaXRcbiAgICAgICAgICAgIC8vIGZvciB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGEgYm9vbGVhbiwgaXQgZG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgdmFsdWUgaXNcbiAgICAgICAgICAgIC8vIHRoZSBmYWN0IHRoYXQgd2UgaGF2ZSBpdCBpcyB0aGUgc2FtZSBhcyB0aGUgZXhwZWN0ZWQuXG4gICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSB1c2VzIGEgbmFtZXNwYWNlIHdlIHVzZSBnZXRBdHRyaWJ1dGVcbiAgICAgICAgICAvLyBiZWNhdXNlIHdlIGFzc3VtZSBpdHMgbmFtZXNwYWNlZCBuYW1lIGlzIHRoZSBzYW1lIGFzIG91ciBjb25maWcuXG4gICAgICAgICAgLy8gVG8gdXNlIGdldEF0dHJpYnV0ZU5TIHdlIG5lZWQgdGhlIGxvY2FsIG5hbWUgd2hpY2ggd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAgIC8vIGluIG91ciBjb25maWcgYXRtLlxuICAgICAgICAgIHN0cmluZ1ZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWUgPT09IG51bGwgPyBleHBlY3RlZCA6IHN0cmluZ1ZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmluZ1ZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgYXR0cmlidXRlIG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgdGhpcmQgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuIFNvbWVcbiAqIGF0dHJpYnV0ZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgZXhwZWN0ZWQpIHtcbiAge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW5vZGUuaGFzQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG51bGw7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG5cbiAgaWYgKHByb3BlcnR5SW5mbyAmJiBzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKSB7XG4gICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAvLyBDb250cmFyeSB0byBgc2V0QXR0cmlidXRlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHByb3Blcmx5XG4gICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICB2YXIgbmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCBzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpID8gdmFsdWUgOiBudWxsKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gIH1cblxuICB7XG4gICAgXG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGVzIGFuIGF0dHJpYnV0ZXMgZnJvbSBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiBkZWxldGVWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lKSB7XG4gIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xufVxuXG4vKipcbiAqIERlbGV0ZXMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSkge1xuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSkge1xuICAgICAgICBub2RlW3Byb3BOYW1lXSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSAnJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMgPSB7XG4gIGNoZWNrUHJvcFR5cGVzOiBudWxsXG59O1xuXG57XG4gIHZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICAgIGJ1dHRvbjogdHJ1ZSxcbiAgICBjaGVja2JveDogdHJ1ZSxcbiAgICBpbWFnZTogdHJ1ZSxcbiAgICBoaWRkZW46IHRydWUsXG4gICAgcmFkaW86IHRydWUsXG4gICAgcmVzZXQ6IHRydWUsXG4gICAgc3VibWl0OiB0cnVlXG4gIH07XG5cbiAgdmFyIHByb3BUeXBlcyA9IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfSxcbiAgICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gICAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gICAqL1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIHByb3BzLCAncHJvcCcsIHRhZ05hbWUsIGdldFN0YWNrKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGlzQ29udHJvbGxlZChwcm9wcykge1xuICB2YXIgdXNlc0NoZWNrZWQgPSBwcm9wcy50eXBlID09PSAnY2hlY2tib3gnIHx8IHByb3BzLnR5cGUgPT09ICdyYWRpbyc7XG4gIHJldHVybiB1c2VzQ2hlY2tlZCA/IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA6IHByb3BzLnZhbHVlICE9IG51bGw7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8aW5wdXQ+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgdGhlc2Ugb3B0aW9uYWxcbiAqIHByb3BzOiBgY2hlY2tlZGAsIGB2YWx1ZWAsIGBkZWZhdWx0Q2hlY2tlZGAsIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqXG4gKiBJZiBgY2hlY2tlZGAgb3IgYHZhbHVlYCBhcmUgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9uc1xuICogdGhhdCBhZmZlY3QgdGhlIGNoZWNrZWQgc3RhdGUgb3IgdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgdGhleSBhcmUgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIG5vdFxuICogdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgcHJvcHMgbXVzdCBjaGFuZ2UgaW4gb3JkZXIgZm9yXG4gKiB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgYXMgdW5jaGVja2VkIChvciBgZGVmYXVsdENoZWNrZWRgKVxuICogd2l0aCBhbiBlbXB0eSB2YWx1ZSAob3IgYGRlZmF1bHRWYWx1ZWApLlxuICpcbiAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEyL1dELWh0bWw1LTIwMTIxMDI1L3RoZS1pbnB1dC1lbGVtZW50Lmh0bWxcbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHtcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC50eXBlIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcyAoc2V0dGluZyAudmFsdWVcbiAgICAvLyBiZWZvcmUgLnR5cGUgbWVhbnMgLnZhbHVlIGlzIGxvc3QgaW4gSUUxMSBhbmQgYmVsb3cpXG4gICAgdHlwZTogdW5kZWZpbmVkLFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnN0ZXAgYmVmb3JlIC52YWx1ZSAoc2V0dGluZyAudmFsdWUgYmVmb3JlIC5zdGVwXG4gICAgLy8gbWVhbnMgLnZhbHVlIGlzIHJvdW5kZWQgb24gbW91bnQsIGJhc2VkIHVwb24gc3RlcCBwcmVjaXNpb24pXG4gICAgc3RlcDogdW5kZWZpbmVkLFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLm1pbiAmIC5tYXggYmVmb3JlIC52YWx1ZSAodG8gZW5zdXJlIHByb3BlciBvcmRlclxuICAgIC8vIGluIGNvcm5lciBjYXNlcyBzdWNoIGFzIG1pbiBvciBtYXggZGVyaXZpbmcgZnJvbSB2YWx1ZSwgZS5nLiBJc3N1ZSAjNzE3MClcbiAgICBtaW46IHVuZGVmaW5lZCxcbiAgICBtYXg6IHVuZGVmaW5lZFxuICB9LCBwcm9wcywge1xuICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgdmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZFxuICB9KTtcblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnaW5wdXQnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKTtcblxuICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMigpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgaW5pdGlhbFZhbHVlOiBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWUsXG4gICAgY29udHJvbGxlZDogaXNDb250cm9sbGVkKHByb3BzKVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICBpZiAoY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCAnY2hlY2tlZCcsIGNoZWNrZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgdmFyIGNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuXG4gICAgaWYgKCFub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiBjb250cm9sbGVkICYmICFkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYW4gdW5jb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMlcycsIHByb3BzLnR5cGUsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMygpKTtcbiAgICAgIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgIWNvbnRyb2xsZWQgJiYgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMoKSk7XG4gICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKTtcblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICBpZiAodmFsdWUgPT09IDAgJiYgbm9kZS52YWx1ZSA9PT0gJycpIHtcbiAgICAgIG5vZGUudmFsdWUgPSAnMCc7XG4gICAgICAvLyBOb3RlOiBJRTkgcmVwb3J0cyBhIG51bWJlciBpbnB1dHMgYXMgJ3RleHQnLCBzbyBjaGVjayBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFNpbXVsYXRlIGBpbnB1dC52YWx1ZUFzTnVtYmVyYC4gSUU5IGRvZXMgbm90IHN1cHBvcnQgaXRcbiAgICAgIHZhciB2YWx1ZUFzTnVtYmVyID0gcGFyc2VGbG9hdChub2RlLnZhbHVlKSB8fCAwO1xuXG4gICAgICBpZiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHZhbHVlICE9IHZhbHVlQXNOdW1iZXIgfHxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgdmFsdWUgPT0gdmFsdWVBc051bWJlciAmJiBub2RlLnZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgICAgbm9kZS52YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnZhbHVlICE9PSAnJyArIHZhbHVlKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgbm9kZS52YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwcm9wcy52YWx1ZSA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBJbiBDaHJvbWUsIGFzc2lnbmluZyBkZWZhdWx0VmFsdWUgdG8gY2VydGFpbiBpbnB1dCB0eXBlcyB0cmlnZ2VycyBpbnB1dCB2YWxpZGF0aW9uLlxuICAgICAgLy8gRm9yIG51bWJlciBpbnB1dHMsIHRoZSBkaXNwbGF5IHZhbHVlIGxvc2VzIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRzLiBGb3IgZW1haWwgaW5wdXRzLFxuICAgICAgLy8gQ2hyb21lIHJhaXNlcyBcIlRoZSBzcGVjaWZpZWQgdmFsdWUgPHg+IGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIi5cbiAgICAgIC8vXG4gICAgICAvLyBIZXJlIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgZGVmYXVsdFZhbHVlIGhhcyBhY3R1YWxseSBjaGFuZ2VkLCBhdm9pZGluZyB0aGVzZSBwcm9ibGVtc1xuICAgICAgLy8gd2hlbiB0aGUgdXNlciBpcyBpbnB1dHRpbmcgdGV4dFxuICAgICAgLy9cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1M1xuICAgICAgaWYgKG5vZGUuZGVmYXVsdFZhbHVlICE9PSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9ICcnICsgcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIXByb3BzLmRlZmF1bHRDaGVja2VkO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICAvLyBEZXRhY2ggdmFsdWUgZnJvbSBkZWZhdWx0VmFsdWUuIFdlIHdvbid0IGRvIGFueXRoaW5nIGlmIHdlJ3JlIHdvcmtpbmcgb25cbiAgLy8gc3VibWl0IG9yIHJlc2V0IGlucHV0cyBhcyB0aG9zZSB2YWx1ZXMgJiBkZWZhdWx0VmFsdWVzIGFyZSBsaW5rZWQuIFRoZXlcbiAgLy8gYXJlIG5vdCByZXNldGFibGUgbm9kZXMgc28gdGhpcyBvcGVyYXRpb24gZG9lc24ndCBtYXR0ZXIgYW5kIGFjdHVhbGx5XG4gIC8vIHJlbW92ZXMgYnJvd3Nlci1kZWZhdWx0IHZhbHVlcyAoZWcgXCJTdWJtaXQgUXVlcnlcIikgd2hlbiBubyB2YWx1ZSBpc1xuICAvLyBwcm92aWRlZC5cblxuICBzd2l0Y2ggKHByb3BzLnR5cGUpIHtcbiAgICBjYXNlICdzdWJtaXQnOlxuICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NvbG9yJzpcbiAgICBjYXNlICdkYXRlJzpcbiAgICBjYXNlICdkYXRldGltZSc6XG4gICAgY2FzZSAnZGF0ZXRpbWUtbG9jYWwnOlxuICAgIGNhc2UgJ21vbnRoJzpcbiAgICBjYXNlICd0aW1lJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICAgIC8vIFRoaXMgZml4ZXMgdGhlIG5vLXNob3cgaXNzdWUgb24gaU9TIFNhZmFyaSBhbmQgQW5kcm9pZCBDaHJvbWU6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyMzNcbiAgICAgIG5vZGUudmFsdWUgPSAnJztcbiAgICAgIG5vZGUudmFsdWUgPSBub2RlLmRlZmF1bHRWYWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBub2RlLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gJyc7XG4gIH1cbiAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdXBkYXRlV3JhcHBlcihub2RlLCBwcm9wcyk7XG4gIHVwZGF0ZU5hbWVkQ291c2lucyhub2RlLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5hbWVkQ291c2lucyhyb290Tm9kZSwgcHJvcHMpIHtcbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0uIEl0IG1pZ2h0IG5vdCBldmVuIGJlIGluIHRoZVxuICAgIC8vIGRvY3VtZW50LiBMZXQncyBqdXN0IHVzZSB0aGUgbG9jYWwgYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndFxuICAgIC8vIG1pc3MgYW55dGhpbmcuXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG4gICAgICB2YXIgb3RoZXJQcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMShvdGhlck5vZGUpO1xuICAgICAgIW90aGVyUHJvcHMgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IHZvaWQgMDtcblxuICAgICAgLy8gV2UgbmVlZCB1cGRhdGUgdGhlIHRyYWNrZWQgdmFsdWUgb24gdGhlIG5hbWVkIGNvdXNpbiBzaW5jZSB0aGUgdmFsdWVcbiAgICAgIC8vIHdhcyBjaGFuZ2VkIGJ1dCB0aGUgaW5wdXQgc2F3IG5vIGV2ZW50IG9yIHZhbHVlIHNldFxuICAgICAgdXBkYXRlVmFsdWVJZkNoYW5nZWQob3RoZXJOb2RlKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICB1cGRhdGVXcmFwcGVyKG90aGVyTm9kZSwgb3RoZXJQcm9wcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xuICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuICAvLyBXZSBjYW4gc2lsZW50bHkgc2tpcCB0aGVtIGJlY2F1c2UgaW52YWxpZCBET00gbmVzdGluZyB3YXJuaW5nXG4gIC8vIGNhdGNoZXMgdGhlc2UgY2FzZXMgaW4gRmliZXIuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICB7XG4gICAgd2FybmluZyhwcm9wcy5zZWxlY3RlZCA9PSBudWxsLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHByb3BzLnZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7IGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICB9XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQzID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ0ID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQzKCk7XG4gIGlmIChvd25lck5hbWUpIHtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG5cbi8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKSB7XG4gIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG4gICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKTtcbiAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBpc0FycmF5KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMobm9kZSwgbXVsdGlwbGUsIHByb3BWYWx1ZSwgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gIHZhciBvcHRpb25zID0gbm9kZS5vcHRpb25zO1xuXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHZhciBzZWxlY3RlZFZhbHVlcyA9IHByb3BWYWx1ZTtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFByZWZpeCB0byBhdm9pZCBjaGFvcyB3aXRoIHNwZWNpYWwga2V5cy5cbiAgICAgIHNlbGVjdGVkVmFsdWVbJyQnICsgc2VsZWN0ZWRWYWx1ZXNbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG9wdGlvbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KCckJyArIG9wdGlvbnNbX2ldLnZhbHVlKTtcbiAgICAgIGlmIChvcHRpb25zW19pXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RlZCAmJiBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHZhciBfc2VsZWN0ZWRWYWx1ZSA9ICcnICsgcHJvcFZhbHVlO1xuICAgIHZhciBkZWZhdWx0U2VsZWN0ZWQgPSBudWxsO1xuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG9wdGlvbnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgaWYgKG9wdGlvbnNbX2kyXS52YWx1ZSA9PT0gX3NlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tfaTJdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNldERlZmF1bHRTZWxlY3RlZCkge1xuICAgICAgICAgIG9wdGlvbnNbX2kyXS5kZWZhdWx0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgPT09IG51bGwgJiYgIW9wdGlvbnNbX2kyXS5kaXNhYmxlZCkge1xuICAgICAgICBkZWZhdWx0U2VsZWN0ZWQgPSBvcHRpb25zW19pMl07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRTZWxlY3RlZC5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHJldHVybiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcyk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxWYWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgIHdhc011bHRpcGxlOiAhIXByb3BzLm11bHRpcGxlXG4gIH07XG5cbiAge1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUubXVsdGlwbGUgPSAhIXByb3BzLm11bHRpcGxlO1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdFVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcbiAgLy8gdGhpcyB2YWx1ZSBkb3duXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgdmFyIHdhc011bHRpcGxlID0gbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO1xuICBub2RlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUgPSAhIXByb3BzLm11bHRpcGxlO1xuXG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfSBlbHNlIGlmICh3YXNNdWx0aXBsZSAhPT0gISFwcm9wcy5tdWx0aXBsZSkge1xuICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5tdWx0aXBsZSA/IFtdIDogJycsIGZhbHNlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH1cbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpIDogdm9pZCAwO1xuXG4gIC8vIEFsd2F5cyBzZXQgY2hpbGRyZW4gdG8gdGhlIHNhbWUgdGhpbmcuIEluIElFOSwgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsXG4gIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuICBXZSBjb3VsZCBhZGQgYSBjaGVjayBpbiBzZXRUZXh0Q29udGVudFxuICAvLyB0byBvbmx5IHNldCB0aGUgdmFsdWUgaWYvd2hlbiB0aGUgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBub2RlIHZhbHVlICh3aGljaCB3b3VsZFxuICAvLyBjb21wbGV0ZWx5IHNvbHZlIHRoaXMgSUU5IGJ1ZyksIGJ1dCBTZWJhc3RpYW4rU29waGllIHNlZW1lZCB0byBsaWtlIHRoaXNcbiAgLy8gc29sdXRpb24uIFRoZSB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3MgZm9yY2VkXG4gIC8vIHRvIGJlIGEgc3RyaW5nLlxuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIGNoaWxkcmVuOiAnJyArIG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWVcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCd0ZXh0YXJlYScsIHByb3BzLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUpO1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcbiAgICAgIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5pdGlhbFZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgLy8gT25seSBib3RoZXIgZmV0Y2hpbmcgZGVmYXVsdCB2YWx1ZSBpZiB3ZSdyZSBnb2luZyB0byB1c2UgaXRcbiAgaWYgKGluaXRpYWxWYWx1ZSA9PSBudWxsKSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKTtcbiAgICAgIH1cbiAgICAgICEoZGVmYXVsdFZhbHVlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogdm9pZCAwO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpID8gaW52YXJpYW50KGZhbHNlLCAnPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpIDogdm9pZCAwO1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cbiAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbFZhbHVlOiAnJyArIGluaXRpYWxWYWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgLy8gVG8gYXZvaWQgc2lkZSBlZmZlY3RzIChzdWNoIGFzIGxvc2luZyB0ZXh0IHNlbGVjdGlvbiksIG9ubHkgc2V0IHZhbHVlIGlmIGNoYW5nZWRcbiAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxuICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAvLyBUaGlzIGlzIGluIHBvc3RNb3VudCBiZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBET00gbm9kZSwgd2hpY2ggaXMgbm90XG4gIC8vIGF2YWlsYWJsZSB1bnRpbCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkLlxuICB2YXIgdGV4dENvbnRlbnQgPSBub2RlLnRleHRDb250ZW50O1xuXG4gIC8vIE9ubHkgc2V0IG5vZGUudmFsdWUgaWYgdGV4dENvbnRlbnQgaXMgZXF1YWwgdG8gdGhlIGV4cGVjdGVkXG4gIC8vIGluaXRpYWwgdmFsdWUuIEluIElFMTAvSUUxMSB0aGVyZSBpcyBhIGJ1ZyB3aGVyZSB0aGUgcGxhY2Vob2xkZXIgYXR0cmlidXRlXG4gIC8vIHdpbGwgcG9wdWxhdGUgdGV4dENvbnRlbnQgYXMgd2VsbC5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTAxNTI1L1xuICBpZiAodGV4dENvbnRlbnQgPT09IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpIHtcbiAgICBub2RlLnZhbHVlID0gdGV4dENvbnRlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcyk7XG59XG5cbnZhciBIVE1MX05BTUVTUEFDRSQxID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xudmFyIE1BVEhfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xudmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG52YXIgTmFtZXNwYWNlcyA9IHtcbiAgaHRtbDogSFRNTF9OQU1FU1BBQ0UkMSxcbiAgbWF0aG1sOiBNQVRIX05BTUVTUEFDRSxcbiAgc3ZnOiBTVkdfTkFNRVNQQUNFXG59O1xuXG4vLyBBc3N1bWVzIHRoZXJlIGlzIG5vIHBhcmVudCBuYW1lc3BhY2UuXG5mdW5jdGlvbiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdzdmcnOlxuICAgICAgcmV0dXJuIFNWR19OQU1FU1BBQ0U7XG4gICAgY2FzZSAnbWF0aCc6XG4gICAgICByZXR1cm4gTUFUSF9OQU1FU1BBQ0U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgdHlwZSkge1xuICBpZiAocGFyZW50TmFtZXNwYWNlID09IG51bGwgfHwgcGFyZW50TmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSQxKSB7XG4gICAgLy8gTm8gKG9yIGRlZmF1bHQpIHBhcmVudCBuYW1lc3BhY2U6IHBvdGVudGlhbCBlbnRyeSBwb2ludC5cbiAgICByZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT09IFNWR19OQU1FU1BBQ0UgJiYgdHlwZSA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gV2UncmUgbGVhdmluZyBTVkcuXG4gICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFJDE7XG4gIH1cbiAgLy8gQnkgZGVmYXVsdCwgcGFzcyBuYW1lc3BhY2UgYmVsb3cuXG4gIHJldHVybiBwYXJlbnROYW1lc3BhY2U7XG59XG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB3aGljaCBoYXMgJ3Vuc2FmZScgcHJpdmlsZWdlcyAocmVxdWlyZWQgYnkgd2luZG93czggYXBwcylcbiAqL1xudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuYyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbn07XG5cbi8vIFNWRyB0ZW1wIGNvbnRhaW5lciBmb3IgSUUgbGFja2luZyBpbm5lckhUTUxcbnZhciByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHZvaWQgMDtcblxuLyoqXG4gKiBTZXQgdGhlIGlubmVySFRNTCBwcm9wZXJ0eSBvZiBhIG5vZGVcbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldElubmVySFRNTCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgLy8gSUUgZG9lcyBub3QgaGF2ZSBpbm5lckhUTUwgZm9yIFNWRyBub2Rlcywgc28gaW5zdGVhZCB3ZSBpbmplY3QgdGhlXG4gIC8vIG5ldyBtYXJrdXAgaW4gYSB0ZW1wIG5vZGUgYW5kIHRoZW4gbW92ZSB0aGUgY2hpbGQgbm9kZXMgYWNyb3NzIGludG9cbiAgLy8gdGhlIHRhcmdldCBub2RlXG5cbiAgaWYgKG5vZGUubmFtZXNwYWNlVVJJID09PSBOYW1lc3BhY2VzLnN2ZyAmJiAhKCdpbm5lckhUTUwnIGluIG5vZGUpKSB7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIgPSByZXVzYWJsZVNWR0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lci5pbm5lckhUTUwgPSAnPHN2Zz4nICsgaHRtbCArICc8L3N2Zz4nO1xuICAgIHZhciBzdmdOb2RlID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHdoaWxlIChzdmdOb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc3ZnTm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICB9XG59KTtcblxuLyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguIGlubmVyVGV4dCBpcyBhIHBvb3Igc3Vic3RpdHV0ZSBmb3IgdGV4dENvbnRlbnQgYW5kLCBhbW9uZyBtYW55XG4gKiBpc3N1ZXMsIGluc2VydHMgPGJyPiBpbnN0ZWFkIG9mIHRoZSBsaXRlcmFsIG5ld2xpbmUgY2hhcnMuIGlubmVySFRNTCBiZWhhdmVzXG4gKiBhcyBpdCBzaG91bGQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIGlmICh0ZXh0KSB7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkID09PSBub2RlLmxhc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZFJvd0VuZDogdHJ1ZSxcbiAgZ3JpZFJvd1NwYW46IHRydWUsXG4gIGdyaWRSb3dTdGFydDogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZ3JpZENvbHVtbkVuZDogdHJ1ZSxcbiAgZ3JpZENvbHVtblNwYW46IHRydWUsXG4gIGdyaWRDb2x1bW5TdGFydDogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFpc0N1c3RvbVByb3BlcnR5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIShpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHJldHVybiAoJycgKyB2YWx1ZSkudHJpbSgpO1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUgPSBlbXB0eUZ1bmN0aW9uO1xuXG57XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcblxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuICB2YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSBmYWxzZTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBjYW1lbGl6ZVN0eWxlTmFtZShuYW1lKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgXCJTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb24uIFwiICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJXMnLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4lcycsIG5hbWUsIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSQxID0gd2FyblZhbGlkU3R5bGU7XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogVGhpcyBjcmVhdGVzIGEgc3RyaW5nIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZXF1aXZhbGVudCB0byB0aGUgc3R5bGVcbiAqIGF0dHJpYnV0ZSBnZW5lcmF0ZWQgYnkgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBJdCBieS1wYXNzZXMgd2FybmluZ3MgYW5kXG4gKiBzZWN1cml0eSBjaGVja3Mgc28gaXQncyBub3Qgc2FmZSB0byB1c2UgdGhpcyB2YWx1ZSBmb3IgYW55dGhpbmcgb3RoZXIgdGhhblxuICogY29tcGFyaXNvbi4gSXQgaXMgb25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhzdHlsZXMpIHtcbiAge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgdmFyIGRlbGltaXRlciA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRlbGltaXRlciArIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KTtcblxuICAgICAgICBkZWxpbWl0ZXIgPSAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVzLCBnZXRTdGFjaykge1xuICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAge1xuICAgICAgaWYgKCFpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlJDEoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgZ2V0U3RhY2spO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG4gICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgc3R5bGVOYW1lID0gJ2Nzc0Zsb2F0JztcbiAgICB9XG4gICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBmb3Jcbi8vIHRob3NlIHNwZWNpYWwtY2FzZSB0YWdzLlxuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBrZXlnZW46IHRydWUsXG4gIGxpbms6IHRydWUsXG4gIG1ldGE6IHRydWUsXG4gIHBhcmFtOiB0cnVlLFxuICBzb3VyY2U6IHRydWUsXG4gIHRyYWNrOiB0cnVlLFxuICB3YnI6IHRydWVcbn07XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3MgY2Fubm90IGhhdmUgY2hpbGRyZW4uIFRoaXMgaGFzIHRoZSBzYW1lIHB1cnBvc2UgYXNcbi8vIGBvbWl0dGVkQ2xvc2VUYWdzYCBleGNlcHQgdGhhdCBgbWVudWl0ZW1gIHNob3VsZCBzdGlsbCBoYXZlIGl0cyBjbG9zaW5nIHRhZy5cblxudmFyIHZvaWRFbGVtZW50VGFncyA9IF9hc3NpZ24oe1xuICBtZW51aXRlbTogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbnZhciBIVE1MJDEgPSAnX19odG1sJztcblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzLCBnZXRTdGFjaykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbdGFnXSkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJyVzIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJXMnLCB0YWcsIGdldFN0YWNrKCkpIDogdm9pZCAwO1xuICB9XG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MJDEgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdm9pZCAwO1xuICB9XG4gIHtcbiAgICB3YXJuaW5nKHByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyB8fCAhcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJXMnLCBnZXRTdGFjaygpKTtcbiAgfVxuICAhKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyBcXCdlbVxcJ319IHdoZW4gdXNpbmcgSlNYLiVzJywgZ2V0U3RhY2soKSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJztcbiAgfVxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIHdoaXRlbGlzdCB0b28gbXVjaCBiZWNhdXNlIHdlIGV4cGVjdCBpdCB0byBuZXZlciBncm93LlxuICAgIC8vIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byB0cmFjayB0aGUgbmFtZXNwYWNlIGluIGEgZmV3IHBsYWNlcyB3aGljaCBpcyBjb252b2x1dGVkLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxudmFyIGFyaWFQcm9wZXJ0aWVzID0ge1xuICAnYXJpYS1jdXJyZW50JzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICdhcmlhLWRpc2FibGVkJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtaGlkZGVuJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtaW52YWxpZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICdhcmlhLWxhYmVsJzogMCxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcbiAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxuICAnYXJpYS1sZXZlbCc6IDAsXG4gICdhcmlhLW1vZGFsJzogMCxcbiAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcbiAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXG4gICdhcmlhLXByZXNzZWQnOiAwLFxuICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICdhcmlhLXJlcXVpcmVkJzogMCxcbiAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAnYXJpYS1zb3J0JzogMCxcbiAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxuICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICdhcmlhLXZhbHVlbm93JzogMCxcbiAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcbiAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAnYXJpYS1hdG9taWMnOiAwLFxuICAnYXJpYS1idXN5JzogMCxcbiAgJ2FyaWEtbGl2ZSc6IDAsXG4gICdhcmlhLXJlbGV2YW50JzogMCxcbiAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICdhcmlhLWNvbGNvdW50JzogMCxcbiAgJ2FyaWEtY29saW5kZXgnOiAwLFxuICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICdhcmlhLWZsb3d0byc6IDAsXG4gICdhcmlhLWxhYmVsbGVkYnknOiAwLFxuICAnYXJpYS1vd25zJzogMCxcbiAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAnYXJpYS1yb3djb3VudCc6IDAsXG4gICdhcmlhLXJvd2luZGV4JzogMCxcbiAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICdhcmlhLXNldHNpemUnOiAwXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgckFSSUFDYW1lbCA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSgpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyQVJJQUNhbWVsLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoY29ycmVjdE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBjb3JyZWN0TmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gc3RhbmRhcmROYW1lKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5KTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtJDEoKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKSB7XG4gIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgIGRpZFdhcm5WYWx1ZU51bGwgPSB0cnVlO1xuICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBhcnJheSB3aGVuIGBtdWx0aXBsZWAgaXMgc2V0IHRvIGB0cnVlYCAnICsgJ3RvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLiVzJywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLiVzJywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoZSBIVE1MIG9yIFNWRyB3aGl0ZWxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgLy8gSFRNTFxuICBhY2NlcHQ6ICdhY2NlcHQnLFxuICBhY2NlcHRjaGFyc2V0OiAnYWNjZXB0Q2hhcnNldCcsXG4gICdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0JyxcbiAgYWNjZXNza2V5OiAnYWNjZXNzS2V5JyxcbiAgYWN0aW9uOiAnYWN0aW9uJyxcbiAgYWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsU2NyZWVuJyxcbiAgYWx0OiAnYWx0JyxcbiAgYXM6ICdhcycsXG4gIGFzeW5jOiAnYXN5bmMnLFxuICBhdXRvY2FwaXRhbGl6ZTogJ2F1dG9DYXBpdGFsaXplJyxcbiAgYXV0b2NvbXBsZXRlOiAnYXV0b0NvbXBsZXRlJyxcbiAgYXV0b2NvcnJlY3Q6ICdhdXRvQ29ycmVjdCcsXG4gIGF1dG9mb2N1czogJ2F1dG9Gb2N1cycsXG4gIGF1dG9wbGF5OiAnYXV0b1BsYXknLFxuICBhdXRvc2F2ZTogJ2F1dG9TYXZlJyxcbiAgY2FwdHVyZTogJ2NhcHR1cmUnLFxuICBjZWxscGFkZGluZzogJ2NlbGxQYWRkaW5nJyxcbiAgY2VsbHNwYWNpbmc6ICdjZWxsU3BhY2luZycsXG4gIGNoYWxsZW5nZTogJ2NoYWxsZW5nZScsXG4gIGNoYXJzZXQ6ICdjaGFyU2V0JyxcbiAgY2hlY2tlZDogJ2NoZWNrZWQnLFxuICBjaGlsZHJlbjogJ2NoaWxkcmVuJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcbiAgY2xhc3NpZDogJ2NsYXNzSUQnLFxuICBjbGFzc25hbWU6ICdjbGFzc05hbWUnLFxuICBjb2xzOiAnY29scycsXG4gIGNvbHNwYW46ICdjb2xTcGFuJyxcbiAgY29udGVudDogJ2NvbnRlbnQnLFxuICBjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgY29udHJvbHM6ICdjb250cm9scycsXG4gIGNvbnRyb2xzbGlzdDogJ2NvbnRyb2xzTGlzdCcsXG4gIGNvb3JkczogJ2Nvb3JkcycsXG4gIGNyb3Nzb3JpZ2luOiAnY3Jvc3NPcmlnaW4nLFxuICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRldGltZTogJ2RhdGVUaW1lJyxcbiAgJ2RlZmF1bHQnOiAnZGVmYXVsdCcsXG4gIGRlZmF1bHRjaGVja2VkOiAnZGVmYXVsdENoZWNrZWQnLFxuICBkZWZhdWx0dmFsdWU6ICdkZWZhdWx0VmFsdWUnLFxuICBkZWZlcjogJ2RlZmVyJyxcbiAgZGlyOiAnZGlyJyxcbiAgZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGRvd25sb2FkOiAnZG93bmxvYWQnLFxuICBkcmFnZ2FibGU6ICdkcmFnZ2FibGUnLFxuICBlbmN0eXBlOiAnZW5jVHlwZScsXG4gICdmb3InOiAnaHRtbEZvcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgZm9ybW1ldGhvZDogJ2Zvcm1NZXRob2QnLFxuICBmb3JtYWN0aW9uOiAnZm9ybUFjdGlvbicsXG4gIGZvcm1lbmN0eXBlOiAnZm9ybUVuY1R5cGUnLFxuICBmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgZm9ybXRhcmdldDogJ2Zvcm1UYXJnZXQnLFxuICBmcmFtZWJvcmRlcjogJ2ZyYW1lQm9yZGVyJyxcbiAgaGVhZGVyczogJ2hlYWRlcnMnLFxuICBoZWlnaHQ6ICdoZWlnaHQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBoaWdoOiAnaGlnaCcsXG4gIGhyZWY6ICdocmVmJyxcbiAgaHJlZmxhbmc6ICdocmVmTGFuZycsXG4gIGh0bWxmb3I6ICdodG1sRm9yJyxcbiAgaHR0cGVxdWl2OiAnaHR0cEVxdWl2JyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2JyxcbiAgaWNvbjogJ2ljb24nLFxuICBpZDogJ2lkJyxcbiAgaW5uZXJodG1sOiAnaW5uZXJIVE1MJyxcbiAgaW5wdXRtb2RlOiAnaW5wdXRNb2RlJyxcbiAgaW50ZWdyaXR5OiAnaW50ZWdyaXR5JyxcbiAgaXM6ICdpcycsXG4gIGl0ZW1pZDogJ2l0ZW1JRCcsXG4gIGl0ZW1wcm9wOiAnaXRlbVByb3AnLFxuICBpdGVtcmVmOiAnaXRlbVJlZicsXG4gIGl0ZW1zY29wZTogJ2l0ZW1TY29wZScsXG4gIGl0ZW10eXBlOiAnaXRlbVR5cGUnLFxuICBrZXlwYXJhbXM6ICdrZXlQYXJhbXMnLFxuICBrZXl0eXBlOiAna2V5VHlwZScsXG4gIGtpbmQ6ICdraW5kJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxhbmc6ICdsYW5nJyxcbiAgbGlzdDogJ2xpc3QnLFxuICBsb29wOiAnbG9vcCcsXG4gIGxvdzogJ2xvdycsXG4gIG1hbmlmZXN0OiAnbWFuaWZlc3QnLFxuICBtYXJnaW53aWR0aDogJ21hcmdpbldpZHRoJyxcbiAgbWFyZ2luaGVpZ2h0OiAnbWFyZ2luSGVpZ2h0JyxcbiAgbWF4OiAnbWF4JyxcbiAgbWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgbWVkaWE6ICdtZWRpYScsXG4gIG1lZGlhZ3JvdXA6ICdtZWRpYUdyb3VwJyxcbiAgbWV0aG9kOiAnbWV0aG9kJyxcbiAgbWluOiAnbWluJyxcbiAgbWlubGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgbXVsdGlwbGU6ICdtdWx0aXBsZScsXG4gIG11dGVkOiAnbXV0ZWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIG5vbmNlOiAnbm9uY2UnLFxuICBub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG4gIG9wZW46ICdvcGVuJyxcbiAgb3B0aW11bTogJ29wdGltdW0nLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBsYWNlaG9sZGVyOiAncGxhY2Vob2xkZXInLFxuICBwbGF5c2lubGluZTogJ3BsYXlzSW5saW5lJyxcbiAgcG9zdGVyOiAncG9zdGVyJyxcbiAgcHJlbG9hZDogJ3ByZWxvYWQnLFxuICBwcm9maWxlOiAncHJvZmlsZScsXG4gIHJhZGlvZ3JvdXA6ICdyYWRpb0dyb3VwJyxcbiAgcmVhZG9ubHk6ICdyZWFkT25seScsXG4gIHJlZmVycmVycG9saWN5OiAncmVmZXJyZXJQb2xpY3knLFxuICByZWw6ICdyZWwnLFxuICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgcmV2ZXJzZWQ6ICdyZXZlcnNlZCcsXG4gIHJvbGU6ICdyb2xlJyxcbiAgcm93czogJ3Jvd3MnLFxuICByb3dzcGFuOiAncm93U3BhbicsXG4gIHNhbmRib3g6ICdzYW5kYm94JyxcbiAgc2NvcGU6ICdzY29wZScsXG4gIHNjb3BlZDogJ3Njb3BlZCcsXG4gIHNjcm9sbGluZzogJ3Njcm9sbGluZycsXG4gIHNlYW1sZXNzOiAnc2VhbWxlc3MnLFxuICBzZWxlY3RlZDogJ3NlbGVjdGVkJyxcbiAgc2hhcGU6ICdzaGFwZScsXG4gIHNpemU6ICdzaXplJyxcbiAgc2l6ZXM6ICdzaXplcycsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3BlbGxjaGVjazogJ3NwZWxsQ2hlY2snLFxuICBzcmM6ICdzcmMnLFxuICBzcmNkb2M6ICdzcmNEb2MnLFxuICBzcmNsYW5nOiAnc3JjTGFuZycsXG4gIHNyY3NldDogJ3NyY1NldCcsXG4gIHN0YXJ0OiAnc3RhcnQnLFxuICBzdGVwOiAnc3RlcCcsXG4gIHN0eWxlOiAnc3R5bGUnLFxuICBzdW1tYXJ5OiAnc3VtbWFyeScsXG4gIHRhYmluZGV4OiAndGFiSW5kZXgnLFxuICB0YXJnZXQ6ICd0YXJnZXQnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHlwZTogJ3R5cGUnLFxuICB1c2VtYXA6ICd1c2VNYXAnLFxuICB2YWx1ZTogJ3ZhbHVlJyxcbiAgd2lkdGg6ICd3aWR0aCcsXG4gIHdtb2RlOiAnd21vZGUnLFxuICB3cmFwOiAnd3JhcCcsXG5cbiAgLy8gU1ZHXG4gIGFib3V0OiAnYWJvdXQnLFxuICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAnYWNjZW50LWhlaWdodCc6ICdhY2NlbnRIZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAnYWNjdW11bGF0ZScsXG4gIGFkZGl0aXZlOiAnYWRkaXRpdmUnLFxuICBhbGlnbm1lbnRiYXNlbGluZTogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gIGFsbG93cmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6ICdhbHBoYWJldGljJyxcbiAgYW1wbGl0dWRlOiAnYW1wbGl0dWRlJyxcbiAgYXJhYmljZm9ybTogJ2FyYWJpY0Zvcm0nLFxuICAnYXJhYmljLWZvcm0nOiAnYXJhYmljRm9ybScsXG4gIGFzY2VudDogJ2FzY2VudCcsXG4gIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRldHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvcmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogJ2F6aW11dGgnLFxuICBiYXNlZnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ2Jhc2VsaW5lU2hpZnQnLFxuICBiYXNlcHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmJveDogJ2Jib3gnLFxuICBiZWdpbjogJ2JlZ2luJyxcbiAgYmlhczogJ2JpYXMnLFxuICBieTogJ2J5JyxcbiAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gIGNhcGhlaWdodDogJ2NhcEhlaWdodCcsXG4gICdjYXAtaGVpZ2h0JzogJ2NhcEhlaWdodCcsXG4gIGNsaXA6ICdjbGlwJyxcbiAgY2xpcHBhdGg6ICdjbGlwUGF0aCcsXG4gICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICBjbGlwcGF0aHVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNsaXBydWxlOiAnY2xpcFJ1bGUnLFxuICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgY29sb3I6ICdjb2xvcicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbjogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAnY29sb3JQcm9maWxlJyxcbiAgY29sb3JyZW5kZXJpbmc6ICdjb2xvclJlbmRlcmluZycsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICBjb250ZW50c2NyaXB0dHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudHN0eWxldHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6ICdjdXJzb3InLFxuICBjeDogJ2N4JyxcbiAgY3k6ICdjeScsXG4gIGQ6ICdkJyxcbiAgZGF0YXR5cGU6ICdkYXRhdHlwZScsXG4gIGRlY2VsZXJhdGU6ICdkZWNlbGVyYXRlJyxcbiAgZGVzY2VudDogJ2Rlc2NlbnQnLFxuICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246ICdkaXJlY3Rpb24nLFxuICBkaXNwbGF5OiAnZGlzcGxheScsXG4gIGRpdmlzb3I6ICdkaXZpc29yJyxcbiAgZG9taW5hbnRiYXNlbGluZTogJ2RvbWluYW50QmFzZWxpbmUnLFxuICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gIGR1cjogJ2R1cicsXG4gIGR4OiAnZHgnLFxuICBkeTogJ2R5JyxcbiAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogJ2VsZXZhdGlvbicsXG4gIGVuYWJsZWJhY2tncm91bmQ6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ2VuYWJsZUJhY2tncm91bmQnLFxuICBlbmQ6ICdlbmQnLFxuICBleHBvbmVudDogJ2V4cG9uZW50JyxcbiAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxvcGFjaXR5OiAnZmlsbE9wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICdmaWxsLXJ1bGUnOiAnZmlsbFJ1bGUnLFxuICBmaWx0ZXI6ICdmaWx0ZXInLFxuICBmaWx0ZXJyZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RvcGFjaXR5OiAnZmxvb2RPcGFjaXR5JyxcbiAgJ2Zsb29kLW9wYWNpdHknOiAnZmxvb2RPcGFjaXR5JyxcbiAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAnZmxvb2QtY29sb3InOiAnZmxvb2RDb2xvcicsXG4gIGZvY3VzYWJsZTogJ2ZvY3VzYWJsZScsXG4gIGZvbnRmYW1pbHk6ICdmb250RmFtaWx5JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICBmb250c2l6ZTogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc2l6ZSc6ICdmb250U2l6ZScsXG4gIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAnZm9udC1zaXplLWFkanVzdCc6ICdmb250U2l6ZUFkanVzdCcsXG4gIGZvbnRzdHJldGNoOiAnZm9udFN0cmV0Y2gnLFxuICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgZm9udHN0eWxlOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQnOiAnZm9udFZhcmlhbnQnLFxuICBmb250d2VpZ2h0OiAnZm9udFdlaWdodCcsXG4gICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgZm9ybWF0OiAnZm9ybWF0JyxcbiAgZnJvbTogJ2Zyb20nLFxuICBmeDogJ2Z4JyxcbiAgZnk6ICdmeScsXG4gIGcxOiAnZzEnLFxuICBnMjogJ2cyJyxcbiAgZ2x5cGhuYW1lOiAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoLW5hbWUnOiAnZ2x5cGhOYW1lJyxcbiAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gIGdseXBocmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudHRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAnaGFuZ2luZycsXG4gIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICdob3Jpei1hZHYteCc6ICdob3JpekFkdlgnLFxuICBob3Jpem9yaWdpbng6ICdob3Jpek9yaWdpblgnLFxuICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgaWRlb2dyYXBoaWM6ICdpZGVvZ3JhcGhpYycsXG4gIGltYWdlcmVuZGVyaW5nOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgaW4yOiAnaW4yJyxcbiAgJ2luJzogJ2luJyxcbiAgaW5saXN0OiAnaW5saXN0JyxcbiAgaW50ZXJjZXB0OiAnaW50ZXJjZXB0JyxcbiAgazE6ICdrMScsXG4gIGsyOiAnazInLFxuICBrMzogJ2szJyxcbiAgazQ6ICdrNCcsXG4gIGs6ICdrJyxcbiAga2VybmVsbWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsdW5pdGxlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAna2VybmluZycsXG4gIGtleXBvaW50czogJ2tleVBvaW50cycsXG4gIGtleXNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5dGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aGFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlcnNwYWNpbmc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xldHRlci1zcGFjaW5nJzogJ2xldHRlclNwYWNpbmcnLFxuICBsaWdodGluZ2NvbG9yOiAnbGlnaHRpbmdDb2xvcicsXG4gICdsaWdodGluZy1jb2xvcic6ICdsaWdodGluZ0NvbG9yJyxcbiAgbGltaXRpbmdjb25lYW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAnbG9jYWwnLFxuICBtYXJrZXJlbmQ6ICdtYXJrZXJFbmQnLFxuICAnbWFya2VyLWVuZCc6ICdtYXJrZXJFbmQnLFxuICBtYXJrZXJoZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJtaWQ6ICdtYXJrZXJNaWQnLFxuICAnbWFya2VyLW1pZCc6ICdtYXJrZXJNaWQnLFxuICBtYXJrZXJzdGFydDogJ21hcmtlclN0YXJ0JyxcbiAgJ21hcmtlci1zdGFydCc6ICdtYXJrZXJTdGFydCcsXG4gIG1hcmtlcnVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJ3aWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogJ21hc2snLFxuICBtYXNrY29udGVudHVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2t1bml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogJ21hdGhlbWF0aWNhbCcsXG4gIG1vZGU6ICdtb2RlJyxcbiAgbnVtb2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6ICdvZmZzZXQnLFxuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIG9wZXJhdG9yOiAnb3BlcmF0b3InLFxuICBvcmRlcjogJ29yZGVyJyxcbiAgb3JpZW50OiAnb3JpZW50JyxcbiAgb3JpZW50YXRpb246ICdvcmllbnRhdGlvbicsXG4gIG9yaWdpbjogJ29yaWdpbicsXG4gIG92ZXJmbG93OiAnb3ZlcmZsb3cnLFxuICBvdmVybGluZXBvc2l0aW9uOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gICdvdmVybGluZS1wb3NpdGlvbic6ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgb3ZlcmxpbmV0aGlja25lc3M6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gICdvdmVybGluZS10aGlja25lc3MnOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICBwYWludG9yZGVyOiAncGFpbnRPcmRlcicsXG4gICdwYWludC1vcmRlcic6ICdwYWludE9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZTEnLFxuICAncGFub3NlLTEnOiAncGFub3NlMScsXG4gIHBhdGhsZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybmNvbnRlbnR1bml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJudHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm51bml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJldmVudHM6ICdwb2ludGVyRXZlbnRzJyxcbiAgJ3BvaW50ZXItZXZlbnRzJzogJ3BvaW50ZXJFdmVudHMnLFxuICBwb2ludHM6ICdwb2ludHMnLFxuICBwb2ludHNhdHg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNhdHk6ICdwb2ludHNBdFknLFxuICBwb2ludHNhdHo6ICdwb2ludHNBdFonLFxuICBwcmVmaXg6ICdwcmVmaXgnLFxuICBwcmVzZXJ2ZWFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlYXNwZWN0cmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZldW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHByb3BlcnR5OiAncHJvcGVydHknLFxuICByOiAncicsXG4gIHJhZGl1czogJ3JhZGl1cycsXG4gIHJlZng6ICdyZWZYJyxcbiAgcmVmeTogJ3JlZlknLFxuICByZW5kZXJpbmdpbnRlbnQ6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICAncmVuZGVyaW5nLWludGVudCc6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICByZXBlYXRjb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0ZHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRleHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRmZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXNvdXJjZTogJ3Jlc291cmNlJyxcbiAgcmVzdGFydDogJ3Jlc3RhcnQnLFxuICByZXN1bHQ6ICdyZXN1bHQnLFxuICByZXN1bHRzOiAncmVzdWx0cycsXG4gIHJvdGF0ZTogJ3JvdGF0ZScsXG4gIHJ4OiAncngnLFxuICByeTogJ3J5JyxcbiAgc2NhbGU6ICdzY2FsZScsXG4gIHNlY3VyaXR5OiAnc2VjdXJpdHknLFxuICBzZWVkOiAnc2VlZCcsXG4gIHNoYXBlcmVuZGVyaW5nOiAnc2hhcGVSZW5kZXJpbmcnLFxuICAnc2hhcGUtcmVuZGVyaW5nJzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgc2xvcGU6ICdzbG9wZScsXG4gIHNwYWNpbmc6ICdzcGFjaW5nJyxcbiAgc3BlY3VsYXJjb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhcmV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAnc3BlZWQnLFxuICBzcHJlYWRtZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydG9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkZGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6ICdzdGVtaCcsXG4gIHN0ZW12OiAnc3RlbXYnLFxuICBzdGl0Y2h0aWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcGNvbG9yOiAnc3RvcENvbG9yJyxcbiAgJ3N0b3AtY29sb3InOiAnc3RvcENvbG9yJyxcbiAgc3RvcG9wYWNpdHk6ICdzdG9wT3BhY2l0eScsXG4gICdzdG9wLW9wYWNpdHknOiAnc3RvcE9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdocG9zaXRpb246ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbic6ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdodGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyc6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAnc3RyaW5nJyxcbiAgc3Ryb2tlOiAnc3Ryb2tlJyxcbiAgc3Ryb2tlZGFzaGFycmF5OiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgc3Ryb2tlZGFzaG9mZnNldDogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gIHN0cm9rZWxpbmVjYXA6ICdzdHJva2VMaW5lY2FwJyxcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ3N0cm9rZUxpbmVjYXAnLFxuICBzdHJva2VsaW5lam9pbjogJ3N0cm9rZUxpbmVqb2luJyxcbiAgJ3N0cm9rZS1saW5lam9pbic6ICdzdHJva2VMaW5lam9pbicsXG4gIHN0cm9rZW1pdGVybGltaXQ6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1taXRlcmxpbWl0JzogJ3N0cm9rZU1pdGVybGltaXQnLFxuICBzdHJva2V3aWR0aDogJ3N0cm9rZVdpZHRoJyxcbiAgJ3N0cm9rZS13aWR0aCc6ICdzdHJva2VXaWR0aCcsXG4gIHN0cm9rZW9wYWNpdHk6ICdzdHJva2VPcGFjaXR5JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JzogJ3N0cm9rZU9wYWNpdHknLFxuICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLFxuICBzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLFxuICBzdXJmYWNlc2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1sYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGV2YWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldHg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0eTogJ3RhcmdldFknLFxuICB0ZXh0YW5jaG9yOiAndGV4dEFuY2hvcicsXG4gICd0ZXh0LWFuY2hvcic6ICd0ZXh0QW5jaG9yJyxcbiAgdGV4dGRlY29yYXRpb246ICd0ZXh0RGVjb3JhdGlvbicsXG4gICd0ZXh0LWRlY29yYXRpb24nOiAndGV4dERlY29yYXRpb24nLFxuICB0ZXh0bGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRleHRyZW5kZXJpbmc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgJ3RleHQtcmVuZGVyaW5nJzogJ3RleHRSZW5kZXJpbmcnLFxuICB0bzogJ3RvJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNmb3JtJyxcbiAgJ3R5cGVvZic6ICd0eXBlb2YnLFxuICB1MTogJ3UxJyxcbiAgdTI6ICd1MicsXG4gIHVuZGVybGluZXBvc2l0aW9uOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICAndW5kZXJsaW5lLXBvc2l0aW9uJzogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgdW5kZXJsaW5ldGhpY2tuZXNzOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ3VuZGVybGluZS10aGlja25lc3MnOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgdW5pY29kZTogJ3VuaWNvZGUnLFxuICB1bmljb2RlYmlkaTogJ3VuaWNvZGVCaWRpJyxcbiAgJ3VuaWNvZGUtYmlkaSc6ICd1bmljb2RlQmlkaScsXG4gIHVuaWNvZGVyYW5nZTogJ3VuaWNvZGVSYW5nZScsXG4gICd1bmljb2RlLXJhbmdlJzogJ3VuaWNvZGVSYW5nZScsXG4gIHVuaXRzcGVyZW06ICd1bml0c1BlckVtJyxcbiAgJ3VuaXRzLXBlci1lbSc6ICd1bml0c1BlckVtJyxcbiAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyxcbiAgdmFscGhhYmV0aWM6ICd2QWxwaGFiZXRpYycsXG4gICd2LWFscGhhYmV0aWMnOiAndkFscGhhYmV0aWMnLFxuICB2YWx1ZXM6ICd2YWx1ZXMnLFxuICB2ZWN0b3JlZmZlY3Q6ICd2ZWN0b3JFZmZlY3QnLFxuICAndmVjdG9yLWVmZmVjdCc6ICd2ZWN0b3JFZmZlY3QnLFxuICB2ZXJzaW9uOiAndmVyc2lvbicsXG4gIHZlcnRhZHZ5OiAndmVydEFkdlknLFxuICAndmVydC1hZHYteSc6ICd2ZXJ0QWR2WScsXG4gIHZlcnRvcmlnaW54OiAndmVydE9yaWdpblgnLFxuICAndmVydC1vcmlnaW4teCc6ICd2ZXJ0T3JpZ2luWCcsXG4gIHZlcnRvcmlnaW55OiAndmVydE9yaWdpblknLFxuICAndmVydC1vcmlnaW4teSc6ICd2ZXJ0T3JpZ2luWScsXG4gIHZoYW5naW5nOiAndkhhbmdpbmcnLFxuICAndi1oYW5naW5nJzogJ3ZIYW5naW5nJyxcbiAgdmlkZW9ncmFwaGljOiAndklkZW9ncmFwaGljJyxcbiAgJ3YtaWRlb2dyYXBoaWMnOiAndklkZW9ncmFwaGljJyxcbiAgdmlld2JveDogJ3ZpZXdCb3gnLFxuICB2aWV3dGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6ICd2aXNpYmlsaXR5JyxcbiAgdm1hdGhlbWF0aWNhbDogJ3ZNYXRoZW1hdGljYWwnLFxuICAndi1tYXRoZW1hdGljYWwnOiAndk1hdGhlbWF0aWNhbCcsXG4gIHZvY2FiOiAndm9jYWInLFxuICB3aWR0aHM6ICd3aWR0aHMnLFxuICB3b3Jkc3BhY2luZzogJ3dvcmRTcGFjaW5nJyxcbiAgJ3dvcmQtc3BhY2luZyc6ICd3b3JkU3BhY2luZycsXG4gIHdyaXRpbmdtb2RlOiAnd3JpdGluZ01vZGUnLFxuICAnd3JpdGluZy1tb2RlJzogJ3dyaXRpbmdNb2RlJyxcbiAgeDE6ICd4MScsXG4gIHgyOiAneDInLFxuICB4OiAneCcsXG4gIHhjaGFubmVsc2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGhlaWdodDogJ3hIZWlnaHQnLFxuICAneC1oZWlnaHQnOiAneEhlaWdodCcsXG4gIHhsaW5rYWN0dWF0ZTogJ3hsaW5rQWN0dWF0ZScsXG4gICd4bGluazphY3R1YXRlJzogJ3hsaW5rQWN0dWF0ZScsXG4gIHhsaW5rYXJjcm9sZTogJ3hsaW5rQXJjcm9sZScsXG4gICd4bGluazphcmNyb2xlJzogJ3hsaW5rQXJjcm9sZScsXG4gIHhsaW5raHJlZjogJ3hsaW5rSHJlZicsXG4gICd4bGluazpocmVmJzogJ3hsaW5rSHJlZicsXG4gIHhsaW5rcm9sZTogJ3hsaW5rUm9sZScsXG4gICd4bGluazpyb2xlJzogJ3hsaW5rUm9sZScsXG4gIHhsaW5rc2hvdzogJ3hsaW5rU2hvdycsXG4gICd4bGluazpzaG93JzogJ3hsaW5rU2hvdycsXG4gIHhsaW5rdGl0bGU6ICd4bGlua1RpdGxlJyxcbiAgJ3hsaW5rOnRpdGxlJzogJ3hsaW5rVGl0bGUnLFxuICB4bGlua3R5cGU6ICd4bGlua1R5cGUnLFxuICAneGxpbms6dHlwZSc6ICd4bGlua1R5cGUnLFxuICB4bWxiYXNlOiAneG1sQmFzZScsXG4gICd4bWw6YmFzZSc6ICd4bWxCYXNlJyxcbiAgeG1sbGFuZzogJ3htbExhbmcnLFxuICAneG1sOmxhbmcnOiAneG1sTGFuZycsXG4gIHhtbG5zOiAneG1sbnMnLFxuICAneG1sOnNwYWNlJzogJ3htbFNwYWNlJyxcbiAgeG1sbnN4bGluazogJ3htbG5zWGxpbmsnLFxuICAneG1sbnM6eGxpbmsnOiAneG1sbnNYbGluaycsXG4gIHhtbHNwYWNlOiAneG1sU3BhY2UnLFxuICB5MTogJ3kxJyxcbiAgeTI6ICd5MicsXG4gIHk6ICd5JyxcbiAgeWNoYW5uZWxzZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAneicsXG4gIHpvb21hbmRwYW46ICd6b29tQW5kUGFuJ1xufTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSQyKCkge1xuICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgcmV0dXJuIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnO1xufVxuXG57XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fTtcbiAgdmFyIGhhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLztcbiAgdmFyIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vO1xuICB2YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuICB2YXIgckFSSUFDYW1lbCQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5JDEuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgcmVseSBvbiB0aGUgZXZlbnQgc3lzdGVtIGJlaW5nIGluamVjdGVkIG9uIHRoZSBzZXJ2ZXIuXG4gICAgaWYgKGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBMZXQgdGhlIEFSSUEgYXR0cmlidXRlIGhvb2sgdmFsaWRhdGUgQVJJQSBhdHRyaWJ1dGVzXG4gICAgaWYgKHJBUklBJDEudGVzdChuYW1lKSB8fCByQVJJQUNhbWVsJDEudGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaW5uZXJodG1sJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdhcmlhJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIHR5cGVvZiB2YWx1ZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpc1Jlc2VydmVkID0gaXNSZXNlcnZlZFByb3AobmFtZSk7XG5cbiAgICAvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcbiAgICAgIGlmIChzdGFuZGFyZE5hbWUgIT09IG5hbWUpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgRE9NIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQgJiYgbmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpIHtcbiAgICAgIC8vIFVua25vd24gYXR0cmlidXRlcyBzaG91bGQgaGF2ZSBsb3dlcmNhc2UgY2FzaW5nIHNpbmNlIHRoYXQncyBob3cgdGhleVxuICAgICAgLy8gd2lsbCBiZSBjYXNlZCBhbnl3YXkgd2l0aCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSAnICsgJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnICsgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArICdJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlICcgKyAnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJXMnLCBuYW1lLCBsb3dlckNhc2VkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiAhc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLiVzJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcbiAgICBpZiAoaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcbiAgICBpZiAoIXNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbnZhciB3YXJuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gIHZhciB1bmtub3duUHJvcHMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5JDEodHlwZSwga2V5LCBwcm9wc1trZXldLCBjYW5Vc2VFdmVudFN5c3RlbSk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcbiAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgaXQgaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtYXR0cmlidXRlLWJlaGF2aW9yJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvciVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSk7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gZmFsc2U7XG52YXIgZGlkV2FyblNoYWR5RE9NID0gZmFsc2U7XG5cbnZhciBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCA9ICdkYW5nZXJvdXNseVNldElubmVySFRNTCc7XG52YXIgU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HID0gJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc7XG52YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSA9ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO1xudmFyIEFVVE9GT0NVUyA9ICdhdXRvRm9jdXMnO1xudmFyIENISUxEUkVOID0gJ2NoaWxkcmVuJztcbnZhciBTVFlMRSA9ICdzdHlsZSc7XG52YXIgSFRNTCA9ICdfX2h0bWwnO1xuXG52YXIgSFRNTF9OQU1FU1BBQ0UgPSBOYW1lc3BhY2VzLmh0bWw7XG5cblxudmFyIGdldFN0YWNrID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucygnJyk7XG5cbntcbiAgZ2V0U3RhY2sgPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDI7XG5cbiAgdmFyIHdhcm5lZFVua25vd25UYWdzID0ge1xuICAgIC8vIENocm9tZSBpcyB0aGUgb25seSBtYWpvciBicm93c2VyIG5vdCBzaGlwcGluZyA8dGltZT4uIEJ1dCBhcyBvZiBKdWx5XG4gICAgLy8gMjAxNyBpdCBpbnRlbmRzIHRvIHNoaXAgaXQgZHVlIHRvIHdpZGVzcHJlYWQgdXNhZ2UuIFdlIGludGVudGlvbmFsbHlcbiAgICAvLyAqZG9uJ3QqIHdhcm4gZm9yIDx0aW1lPiBldmVuIGlmIGl0J3MgdW5yZWNvZ25pemVkIGJ5IENocm9tZSBiZWNhdXNlXG4gICAgLy8gaXQgc29vbiB3aWxsIGJlLCBhbmQgbWFueSBhcHBzIGhhdmUgYmVlbiB1c2luZyBpdCBhbnl3YXkuXG4gICAgdGltZTogdHJ1ZSxcbiAgICAvLyBUaGVyZSBhcmUgd29ya2luZyBwb2x5ZmlsbHMgZm9yIDxkaWFsb2c+LiBMZXQgcGVvcGxlIHVzZSBpdC5cbiAgICBkaWFsb2c6IHRydWVcbiAgfTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCAvKiBjYW5Vc2VFdmVudFN5c3RlbSAqL3RydWUpO1xuICB9O1xuXG4gIC8vIEhUTUwgcGFyc2luZyBub3JtYWxpemVzIENSIGFuZCBDUkxGIHRvIExGLlxuICAvLyBJdCBhbHNvIGNhbiB0dXJuIFxcdTAwMDAgaW50byBcXHVGRkZEIGluc2lkZSBhdHRyaWJ1dGVzLlxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc2luZ2xlLXBhZ2UuaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoLCBpdCBtaWdodCBiZSBjYXVzZWQgYnkgdGhhdC5cbiAgLy8gV2Ugd2lsbCBzdGlsbCBwYXRjaCB1cCBpbiB0aGlzIGNhc2UgYnV0IG5vdCBmaXJlIHRoZSB3YXJuaW5nLlxuICB2YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZztcbiAgdmFyIE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHUwMDAwfFxcdUZGRkQvZztcblxuICB2YXIgbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlID0gZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBtYXJrdXBTdHJpbmcgPSB0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJyA/IG1hcmt1cCA6ICcnICsgbWFya3VwO1xuICAgIHJldHVybiBtYXJrdXBTdHJpbmcucmVwbGFjZShOT1JNQUxJWkVfTkVXTElORVNfUkVHRVgsICdcXG4nKS5yZXBsYWNlKE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCwgJycpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9yVGV4dERpZmZlcmVuY2UgPSBmdW5jdGlvbiAoc2VydmVyVGV4dCwgY2xpZW50VGV4dCkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VGV4dCk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclRleHQpO1xuICAgIGlmIChub3JtYWxpemVkU2VydmVyVGV4dCA9PT0gbm9ybWFsaXplZENsaWVudFRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLCBub3JtYWxpemVkU2VydmVyVGV4dCwgbm9ybWFsaXplZENsaWVudFRleHQpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9yUHJvcERpZmZlcmVuY2UgPSBmdW5jdGlvbiAocHJvcE5hbWUsIHNlcnZlclZhbHVlLCBjbGllbnRWYWx1ZSkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFZhbHVlID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFZhbHVlKTtcbiAgICB2YXIgbm9ybWFsaXplZFNlcnZlclZhbHVlID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclZhbHVlKTtcbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclZhbHVlID09PSBub3JtYWxpemVkQ2xpZW50VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdQcm9wIGAlc2AgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiAlcyBDbGllbnQ6ICVzJywgcHJvcE5hbWUsIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSksIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBhdHRyaWJ1dGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuICAgIHdhcm5pbmcoZmFsc2UsICdFeHRyYSBhdHRyaWJ1dGVzIGZyb20gdGhlIHNlcnZlcjogJXMnLCBuYW1lcyk7XG4gIH07XG5cbiAgdmFyIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lciA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGBmYWxzZWAuXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJXMnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGFyc2UgdGhlIEhUTUwgYW5kIHJlYWQgaXQgYmFjayB0byBub3JtYWxpemUgdGhlIEhUTUwgc3RyaW5nIHNvIHRoYXQgaXRcbiAgLy8gY2FuIGJlIHVzZWQgZm9yIGNvbXBhcmlzb24uXG4gIHZhciBub3JtYWxpemVIVE1MID0gZnVuY3Rpb24gKHBhcmVudCwgaHRtbCkge1xuICAgIC8vIFdlIGNvdWxkIGhhdmUgY3JlYXRlZCBhIHNlcGFyYXRlIGRvY3VtZW50IGhlcmUgdG8gYXZvaWRcbiAgICAvLyByZS1pbml0aWFsaXppbmcgY3VzdG9tIGVsZW1lbnRzIGlmIHRoZXkgZXhpc3QuIEJ1dCB0aGlzIGJyZWFrc1xuICAgIC8vIGhvdyA8bm9zY3JpcHQ+IGlzIGJlaW5nIGhhbmRsZWQuIFNvIHdlIHVzZSB0aGUgc2FtZSBkb2N1bWVudC5cbiAgICAvLyBTZWUgdGhlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTExNTcuXG4gICAgdmFyIHRlc3RFbGVtZW50ID0gcGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UgPyBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHBhcmVudC50YWdOYW1lKSA6IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhwYXJlbnQubmFtZXNwYWNlVVJJLCBwYXJlbnQudGFnTmFtZSk7XG4gICAgdGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gdGVzdEVsZW1lbnQuaW5uZXJIVE1MO1xuICB9O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICB2YXIgaXNEb2N1bWVudE9yRnJhZ21lbnQgPSByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERTtcbiAgdmFyIGRvYyA9IGlzRG9jdW1lbnRPckZyYWdtZW50ID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xuICBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBkb2MpO1xufVxuXG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xufVxuXG4vLyBUaGVyZSBhcmUgc28gbWFueSBtZWRpYSBldmVudHMsIGl0IG1ha2VzIHNlbnNlIHRvIGp1c3Rcbi8vIG1haW50YWluIGEgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGUgYSBgdHJhcEJ1YmJsZWRFdmVudGAgZm9yIGVhY2hcbnZhciBtZWRpYUV2ZW50cyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJ1xufTtcblxuZnVuY3Rpb24gdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQobm9kZSkge1xuICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAvLyBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAvLyBKdXN0IHNldCBpdCB1c2luZyB0aGUgb25jbGljayBwcm9wZXJ0eSBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gbWFuYWdlIGFueVxuICAvLyBib29ra2VlcGluZyBmb3IgaXQuIE5vdCBzdXJlIGlmIHdlIG5lZWQgdG8gY2xlYXIgaXQgd2hlbiB0aGUgbGlzdGVuZXIgaXNcbiAgLy8gcmVtb3ZlZC5cbiAgLy8gVE9ETzogT25seSBkbyB0aGlzIGZvciB0aGUgcmVsZXZhbnQgU2FmYXJpcyBtYXliZT9cbiAgbm9kZS5vbmNsaWNrID0gZW1wdHlGdW5jdGlvbjtcbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgbmV4dFByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBmb3IgKHZhciBwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgbmV4dFByb3AsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBdm9pZCBzZXR0aW5nIGluaXRpYWwgdGV4dENvbnRlbnQgd2hlbiB0aGUgdGV4dCBpcyBlbXB0eS4gSW4gSUUxMSBzZXR0aW5nXG4gICAgICAgIC8vIHRleHRDb250ZW50IG9uIGEgPHRleHRhcmVhPiB3aWxsIGNhdXNlIHRoZSBwbGFjZWhvbGRlciB0byBub3RcbiAgICAgICAgLy8gc2hvdyB3aXRoaW4gdGhlIDx0ZXh0YXJlYT4gdW50aWwgaXQgaGFzIGJlZW4gZm9jdXNlZCBhbmQgYmx1cnJlZCBhZ2Fpbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy82NzMxI2lzc3VlY29tbWVudC0yNTQ4NzQ1NTNcbiAgICAgICAgdmFyIGNhblNldFRleHRDb250ZW50ID0gdGFnICE9PSAndGV4dGFyZWEnIHx8IG5leHRQcm9wICE9PSAnJztcbiAgICAgICAgaWYgKGNhblNldFRleHRDb250ZW50KSB7XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQVVUT0ZPQ1VTKSB7XG4gICAgICAvLyBXZSBwb2x5ZmlsbCBpdCBzZXBhcmF0ZWx5IG9uIHRoZSBjbGllbnQgZHVyaW5nIGNvbW1pdC5cbiAgICAgIC8vIFdlIGJsYWNrbGlzdCBpdCBoZXJlIHJhdGhlciB0aGFuIGluIHRoZSBwcm9wZXJ0eSBsaXN0IGJlY2F1c2Ugd2UgZW1pdCBpdCBpbiBTU1IuXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH0gZWxzZSBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlUGF5bG9hZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICB2YXIgcHJvcFZhbHVlID0gdXBkYXRlUGF5bG9hZFtpICsgMV07XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBwcm9wVmFsdWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgIT0gbnVsbCkge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRlbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXG4gICAgICBkZWxldGVWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50LCBwYXJlbnROYW1lc3BhY2UpIHtcbiAgLy8gV2UgY3JlYXRlIHRhZ3MgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGVpciBwYXJlbnQgY29udGFpbmVyLCBleGNlcHQgSFRNTFxuICB2YXIgb3duZXJEb2N1bWVudCA9IGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCk7XG4gIHZhciBkb21FbGVtZW50O1xuICB2YXIgbmFtZXNwYWNlVVJJID0gcGFyZW50TmFtZXNwYWNlO1xuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIG5hbWVzcGFjZVVSSSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIHtcbiAgICAgIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKTtcbiAgICAgIC8vIFNob3VsZCB0aGlzIGNoZWNrIGJlIGdhdGVkIGJ5IHBhcmVudCBuYW1lc3BhY2U/IE5vdCBzdXJlIHdlIHdhbnQgdG9cbiAgICAgIC8vIGFsbG93IDxTVkc+IG9yIDxtQVRIPi5cbiAgICAgIHdhcm5pbmcoaXNDdXN0b21Db21wb25lbnRUYWcgfHwgdHlwZSA9PT0gdHlwZS50b0xvd2VyQ2FzZSgpLCAnPCVzIC8+IGlzIHVzaW5nIHVwcGVyY2FzZSBIVE1MLiBBbHdheXMgdXNlIGxvd2VyY2FzZSBIVE1MIHRhZ3MgJyArICdpbiBSZWFjdC4nLCB0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgIC8vIENyZWF0ZSB0aGUgc2NyaXB0IHZpYSAuaW5uZXJIVE1MIHNvIGl0cyBcInBhcnNlci1pbnNlcnRlZFwiIGZsYWcgaXNcbiAgICAgIC8vIHNldCB0byB0cnVlIGFuZCBpdCBkb2VzIG5vdCBleGVjdXRlXG4gICAgICB2YXIgZGl2ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSAnPHNjcmlwdD48JyArICcvc2NyaXB0Pic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8vIFRoaXMgaXMgZ3VhcmFudGVlZCB0byB5aWVsZCBhIHNjcmlwdCBlbGVtZW50LlxuICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBkaXYuZmlyc3RDaGlsZDtcbiAgICAgIGRvbUVsZW1lbnQgPSBkaXYucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyAkRmxvd0lzc3VlIGBjcmVhdGVFbGVtZW50YCBzaG91bGQgYmUgdXBkYXRlZCBmb3IgV2ViIENvbXBvbmVudHNcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSwgeyBpczogcHJvcHMuaXMgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjYXVzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdHlwZSk7XG4gIH1cblxuICB7XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIGlmICghaXNDdXN0b21Db21wb25lbnRUYWcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvbUVsZW1lbnQpID09PSAnW29iamVjdCBIVE1MVW5rbm93bkVsZW1lbnRdJyAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFVua25vd25UYWdzLCB0eXBlKSkge1xuICAgICAgICB3YXJuZWRVbmtub3duVGFnc1t0eXBlXSA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgdGFnIDwlcz4gaXMgdW5yZWNvZ25pemVkIGluIHRoaXMgYnJvd3Nlci4gJyArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgUmVhY3QgY29tcG9uZW50LCBzdGFydCBpdHMgbmFtZSB3aXRoICcgKyAnYW4gdXBwZXJjYXNlIGxldHRlci4nLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZG9tRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUkMSh0ZXh0LCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KS5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbFByb3BlcnRpZXMkMShkb21FbGVtZW50LCB0YWcsIHJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgdmFyIHByb3BzO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGV2ZW50LCBtZWRpYUV2ZW50c1tldmVudF0sIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wVG9nZ2xlJywgJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMsIGdldFN0YWNrKTtcblxuICBzZXRJbml0aWFsRE9NUHJvcGVydGllcyh0YWcsIGRvbUVsZW1lbnQsIHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcG9zdE1vdW50V3JhcHBlciQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufVxuXG4vLyBDYWxjdWxhdGUgdGhlIGRpZmYgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMuXG5mdW5jdGlvbiBkaWZmUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcblxuICB2YXIgbGFzdFByb3BzO1xuICB2YXIgbmV4dFByb3BzO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsYXN0UHJvcHMgPSBsYXN0UmF3UHJvcHM7XG4gICAgICBuZXh0UHJvcHMgPSBuZXh0UmF3UHJvcHM7XG4gICAgICBpZiAodHlwZW9mIGxhc3RQcm9wcy5vbkNsaWNrICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBuZXh0UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIG5leHRQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHZhciBwcm9wS2V5O1xuICB2YXIgc3R5bGVOYW1lO1xuICB2YXIgc3R5bGVVcGRhdGVzID0gbnVsbDtcbiAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgdmFyIGxhc3RTdHlsZSA9IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIHx8IHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBOb29wLiBUaGlzIGlzIGhhbmRsZWQgYnkgdGhlIGNsZWFyIHRleHQgbWVjaGFuaXNtLlxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gTm9vcC4gSXQgZG9lc24ndCB3b3JrIG9uIHVwZGF0ZXMgYW55d2F5LlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBmaWJlciBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFsbCBvdGhlciBkZWxldGVkIHByb3BlcnRpZXMgd2UgYWRkIGl0IHRvIHRoZSBxdWV1ZS4gV2UgdXNlXG4gICAgICAvLyB0aGUgd2hpdGVsaXN0IGluIHRoZSBjb21taXQgcGhhc2UgaW5zdGVhZC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBudWxsKTtcbiAgICB9XG4gIH1cbiAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3AgfHwgbmV4dFByb3AgPT0gbnVsbCAmJiBsYXN0UHJvcCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQucHVzaChwcm9wS2V5LCBzdHlsZVVwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcCA/IGxhc3RQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRIdG1sKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogSXQgbWlnaHQgYmUgdG9vIGxhdGUgdG8gY2xlYXIgdGhpcyBpZiB3ZSBoYXZlIGNoaWxkcmVuXG4gICAgICAgIC8vIGluc2VydGVkIGFscmVhZHkuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKGxhc3RQcm9wICE9PSBuZXh0UHJvcCAmJiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSkge1xuICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGVhZ2VybHkgbGlzdGVuIHRvIHRoaXMgZXZlbiB0aG91Z2ggd2UgaGF2ZW4ndCBjb21taXR0ZWQgeWV0LlxuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCAmJiBsYXN0UHJvcCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgcHJvcHMgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbnkgb3RoZXIgcHJvcGVydHkgd2UgYWx3YXlzIGFkZCBpdCB0byB0aGUgcXVldWUgYW5kIHRoZW4gd2VcbiAgICAgIC8vIGZpbHRlciBpdCBvdXQgdXNpbmcgdGhlIHdoaXRlbGlzdCBkdXJpbmcgdGhlIGNvbW1pdC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG4gIGlmIChzdHlsZVVwZGF0ZXMpIHtcbiAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2goU1RZTEUsIHN0eWxlVXBkYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbi8vIEFwcGx5IHRoZSBkaWZmLlxuZnVuY3Rpb24gdXBkYXRlUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMpIHtcbiAgLy8gVXBkYXRlIGNoZWNrZWQgKmJlZm9yZSogbmFtZS5cbiAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiB1cGRhdGUsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgY2hlY2tlZC5cbiAgLy8gV2hlbiBhIGNoZWNrZWQgcmFkaW8gdHJpZXMgdG8gY2hhbmdlIG5hbWUsIGJyb3dzZXIgbWFrZXMgYW5vdGhlciByYWRpbydzIGNoZWNrZWQgZmFsc2UuXG4gIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgbmV4dFJhd1Byb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmV4dFJhd1Byb3BzLm5hbWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZUNoZWNrZWQoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB3YXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIGxhc3RSYXdQcm9wcyk7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgLy8gQXBwbHkgdGhlIGRpZmYuXG4gIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgLy8gVE9ETzogRW5zdXJlIHRoYXQgYW4gdXBkYXRlIGdldHMgc2NoZWR1bGVkIGlmIGFueSBvZiB0aGUgc3BlY2lhbCBwcm9wc1xuICAvLyBjaGFuZ2VkLlxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4gICAgICAvLyBoYXBwZW4gYWZ0ZXIgYHVwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbiAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgIHVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHVwZGF0ZVdyYXBwZXIkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgIHBvc3RVcGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB7XG4gICAgdmFyIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyA9IHJhd1Byb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdID09PSB0cnVlO1xuICAgIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGV2ZW50LCBtZWRpYUV2ZW50c1tldmVudF0sIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BUb2dnbGUnLCAndG9nZ2xlJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHJhd1Byb3BzLCBnZXRTdGFjayk7XG5cbiAge1xuICAgIHZhciBleHRyYUF0dHJpYnV0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gZG9tRWxlbWVudC5hdHRyaWJ1dGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVzW2ldLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAvLyBCdWlsdC1pbiBTU1IgYXR0cmlidXRlIGlzIHdoaXRlbGlzdGVkXG4gICAgICAgIGNhc2UgJ2RhdGEtcmVhY3Ryb290JzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gSW50ZW50aW9uYWxseSB1c2UgdGhlIG9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTA2NzYuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5hZGQoYXR0cmlidXRlc1tpXS5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG4gIGZvciAodmFyIHByb3BLZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIXJhd1Byb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wID0gcmF3UHJvcHNbcHJvcEtleV07XG4gICAgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBGb3IgdGV4dCBjb250ZW50IGNoaWxkcmVuIHdlIGNvbXBhcmUgYWdhaW5zdCB0ZXh0Q29udGVudC4gVGhpc1xuICAgICAgLy8gbWlnaHQgbWF0Y2ggYWRkaXRpb25hbCBIVE1MIHRoYXQgaXMgaGlkZGVuIHdoZW4gd2UgcmVhZCBpdCB1c2luZ1xuICAgICAgLy8gdGV4dENvbnRlbnQuIEUuZy4gXCJmb29cIiB3aWxsIG1hdGNoIFwiZjxzcGFuPm9vPC9zcGFuPlwiIGJ1dCB0aGF0IHN0aWxsXG4gICAgICAvLyBzYXRpc2ZpZXMgb3VyIHJlcXVpcmVtZW50LiBPdXIgcmVxdWlyZW1lbnQgaXMgbm90IHRvIHByb2R1Y2UgcGVyZmVjdFxuICAgICAgLy8gSFRNTCBhbmQgYXR0cmlidXRlcy4gSWRlYWxseSB3ZSBzaG91bGQgcHJlc2VydmUgc3RydWN0dXJlIGJ1dCBpdCdzXG4gICAgICAvLyBvayBub3QgdG8gaWYgdGhlIHZpc2libGUgY29udGVudCBpcyBzdGlsbCBlbm91Z2ggdG8gaW5kaWNhdGUgd2hhdFxuICAgICAgLy8gZXZlbiBsaXN0ZW5lcnMgdGhlc2Ugbm9kZXMgbWlnaHQgYmUgd2lyZWQgdXAgdG8uXG4gICAgICAvLyBUT0RPOiBXYXJuIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBhIHNpbmdsZSB0ZXh0Tm9kZSBhcyBhIGNoaWxkLlxuICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIHVzZSBkb21FbGVtZW50LmZpcnN0Q2hpbGQubm9kZVZhbHVlIHRvIGNvbXBhcmU/XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gJycgKyBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICh0cnVlICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZShkb21FbGVtZW50LnRleHRDb250ZW50LCBuZXh0UHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sICcnICsgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIHByb3BlcnRpZXMgY29ycmVzcG9uZCB0byB0aGVpciBleHBlY3RlZCB2YWx1ZXMuXG4gICAgICB2YXIgc2VydmVyVmFsdWU7XG4gICAgICB2YXIgcHJvcGVydHlJbmZvO1xuICAgICAgaWYgKHN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nLiBXZSdyZSBpZ25vcmluZyBhbGwgdGhlc2Ugd2FybmluZ3MuXG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxIHx8XG4gICAgICAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgcHJvcEtleSA9PT0gJ3ZhbHVlJyB8fCBwcm9wS2V5ID09PSAnY2hlY2tlZCcgfHwgcHJvcEtleSA9PT0gJ3NlbGVjdGVkJykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICAgIHZhciByYXdIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSB8fCAnJyA6ICcnO1xuICAgICAgICB2YXIgc2VydmVySFRNTCA9IGRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICB2YXIgZXhwZWN0ZWRIVE1MID0gbm9ybWFsaXplSFRNTChkb21FbGVtZW50LCByYXdIdG1sKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkSFRNTCAhPT0gc2VydmVySFRNTCkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJIVE1MLCBleHBlY3RlZEhUTUwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleSk7XG4gICAgICAgIHZhciBleHBlY3RlZFN0eWxlID0gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKG5leHRQcm9wKTtcbiAgICAgICAgc2VydmVyVmFsdWUgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkU3R5bGUgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBleHBlY3RlZFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzaG91bGRTZXRBdHRyaWJ1dGUocHJvcEtleSwgbmV4dFByb3ApKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8ocHJvcEtleSkpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgb3duTmFtZXNwYWNlID0gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHRhZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgIGlmIChleHRyYUF0dHJpYnV0ZU5hbWVzLnNpemUgPiAwICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAvLyBGb3IgaW5wdXQgYW5kIHRleHRhcmVhIHdlIGN1cnJlbnQgYWx3YXlzIHNldCB0aGUgdmFsdWUgcHJvcGVydHkgYXRcbiAgICAgIC8vIHBvc3QgbW91bnQgdG8gZm9yY2UgaXQgdG8gZGl2ZXJnZSBmcm9tIGF0dHJpYnV0ZXMuIEhvd2V2ZXIsIGZvclxuICAgICAgLy8gb3B0aW9uIGFuZCBzZWxlY3Qgd2UgZG9uJ3QgcXVpdGUgZG8gdGhlIHNhbWUgdGhpbmcgYW5kIHNlbGVjdFxuICAgICAgLy8gaXMgbm90IHJlc2lsaWVudCB0byB0aGUgRE9NIHN0YXRlIGNoYW5naW5nIHNvIHdlIGRvbid0IGRvIHRoYXQgaGVyZS5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIG5vdCBkb2luZyB0aGlzIGZvciBpbnB1dCBhbmQgdGV4dGFyZWEuXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiByYXdQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHZhciBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgcmV0dXJuIGlzRGlmZmVyZW50O1xufVxuXG5mdW5jdGlvbiB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UodGV4dE5vZGUubm9kZVZhbHVlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSA8JXM+IGluIDwlcz4uJywgY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gdGhlIHRleHQgbm9kZSBcIiVzXCIgaW4gPCVzPi4nLCBjaGlsZC5ub2RlVmFsdWUsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEocGFyZW50Tm9kZSwgdGFnLCBwcm9wcykge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIDwlcz4gaW4gPCVzPi4nLCB0YWcsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEocGFyZW50Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAvLyBXZSBleHBlY3QgdG8gaW5zZXJ0IGVtcHR5IHRleHQgbm9kZXMgc2luY2UgdGhleSdyZSBub3QgcmVwcmVzZW50ZWQgaW5cbiAgICAgIC8vIHRoZSBIVE1MLlxuICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGlmIHdlIGNhbiBqdXN0IGF2b2lkIGluc2VydGluZyBlbXB0eVxuICAgICAgLy8gdGV4dCBub2Rlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIHRleHQgbm9kZSBmb3IgXCIlc1wiIGluIDwlcz4uJywgdGV4dCwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGRvbUVsZW1lbnQsIHRhZywgcHJvcHMpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NRmliZXJDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUkMSxcblx0c2V0SW5pdGlhbFByb3BlcnRpZXM6IHNldEluaXRpYWxQcm9wZXJ0aWVzJDEsXG5cdGRpZmZQcm9wZXJ0aWVzOiBkaWZmUHJvcGVydGllcyQxLFxuXHR1cGRhdGVQcm9wZXJ0aWVzOiB1cGRhdGVQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFByb3BlcnRpZXM6IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMSxcblx0ZGlmZkh5ZHJhdGVkVGV4dDogZGlmZkh5ZHJhdGVkVGV4dCQxLFxuXHR3YXJuRm9yVW5tYXRjaGVkVGV4dDogd2FybkZvclVubWF0Y2hlZFRleHQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxLFxuXHR3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0OiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEsXG5cdHJlc3RvcmVDb250cm9sbGVkU3RhdGU6IHJlc3RvcmVDb250cm9sbGVkU3RhdGVcbn0pO1xuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ2ID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZW1wdHlGdW5jdGlvbjtcblxue1xuICAvLyBUaGlzIHZhbGlkYXRpb24gY29kZSB3YXMgd3JpdHRlbiBiYXNlZCBvbiB0aGUgSFRNTDUgcGFyc2luZyBzcGVjOlxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICAvL1xuICAvLyBOb3RlOiB0aGlzIGRvZXMgbm90IGNhdGNoIGFsbCBpbnZhbGlkIG5lc3RpbmcsIG5vciBkb2VzIGl0IHRyeSB0byAoYXMgaXQnc1xuICAvLyBub3QgY2xlYXIgd2hhdCBwcmFjdGljYWwgYmVuZWZpdCBkb2luZyBzbyBwcm92aWRlcyk7IGluc3RlYWQsIHdlIHdhcm4gb25seVxuICAvLyBmb3IgY2FzZXMgd2hlcmUgdGhlIHBhcnNlciB3aWxsIGdpdmUgYSBwYXJzZSB0cmVlIGRpZmZlcmluZyBmcm9tIHdoYXQgUmVhY3RcbiAgLy8gaW50ZW5kZWQuIEZvciBleGFtcGxlLCA8Yj48ZGl2PjwvZGl2PjwvYj4gaXMgaW52YWxpZCBidXQgd2UgZG9uJ3Qgd2FyblxuICAvLyBiZWNhdXNlIGl0IHN0aWxsIHBhcnNlcyBjb3JyZWN0bHk7IHdlIGRvIHdhcm4gZm9yIG90aGVyIGNhc2VzIGxpa2UgbmVzdGVkXG4gIC8vIDxwPiB0YWdzIHdoZXJlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY29uZCBlbGVtZW50IGltcGxpY2l0bHkgY2xvc2VzIHRoZVxuICAvLyBmaXJzdCwgY2F1c2luZyBhIGNvbmZ1c2luZyBtZXNzLlxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZ2VuZXJhdGUtaW1wbGllZC1lbmQtdGFnc1xuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG5cbiAgdmFyIGVtcHR5QW5jZXN0b3JJbmZvID0ge1xuICAgIGN1cnJlbnQ6IG51bGwsXG5cbiAgICBmb3JtVGFnOiBudWxsLFxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxuICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXG5cbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXG4gIH07XG5cbiAgdmFyIHVwZGF0ZWRBbmNlc3RvckluZm8kMSA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcsIGluc3RhbmNlKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IF9hc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuICAgIHZhciBpbmZvID0geyB0YWc6IHRhZywgaW5zdGFuY2U6IGluc3RhbmNlIH07XG5cbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChidXR0b25TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZWUgcnVsZXMgZm9yICdsaScsICdkZCcsICdkdCcgc3RhcnQgdGFncyBpblxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBpZiAoc3BlY2lhbFRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSAmJiB0YWcgIT09ICdhZGRyZXNzJyAmJiB0YWcgIT09ICdkaXYnICYmIHRhZyAhPT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGFuY2VzdG9ySW5mby5jdXJyZW50ID0gaW5mbztcblxuICAgIGlmICh0YWcgPT09ICdmb3JtJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmZvcm1UYWcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdub2JyJykge1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdkZCcgfHwgdGFnID09PSAnZHQnKSB7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvckluZm87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGlzVGFnVmFsaWRXaXRoUGFyZW50ID0gZnVuY3Rpb24gKHRhZywgcGFyZW50VGFnKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndGgnIHx8IHRhZyA9PT0gJ3RkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JztcbiAgICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdodG1sJztcbiAgICB9XG5cbiAgICAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4gICAgLy8gd2hlcmUgdGhlIHBhcnNpbmcgcnVsZXMgY2F1c2UgaW1wbGljaXQgb3BlbnMgb3IgY2xvc2VzIHRvIGJlIGFkZGVkLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnICE9PSAnaDEnICYmIHBhcmVudFRhZyAhPT0gJ2gyJyAmJiBwYXJlbnRUYWcgIT09ICdoMycgJiYgcGFyZW50VGFnICE9PSAnaDQnICYmIHBhcmVudFRhZyAhPT0gJ2g1JyAmJiBwYXJlbnRUYWcgIT09ICdoNic7XG5cbiAgICAgIGNhc2UgJ3JwJzpcbiAgICAgIGNhc2UgJ3J0JzpcbiAgICAgICAgcmV0dXJuIGltcGxpZWRFbmRUYWdzLmluZGV4T2YocGFyZW50VGFnKSA9PT0gLTE7XG5cbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgY2FzZSAnY2FwdGlvbic6XG4gICAgICBjYXNlICdjb2wnOlxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIGNhc2UgJ3RoJzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgLy8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcbiAgICAgICAgLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuICAgICAgICAvLyBzbyB3ZSBhbGxvdyBpdCBvbmx5IGlmIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgcGFyZW50IGlzLCBhcyBhbGwgb3RoZXJcbiAgICAgICAgLy8gY2FzZXMgYXJlIGludmFsaWQuXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgPT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxuICAgICAgY2FzZSAnYXNpZGUnOlxuICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgY2FzZSAnZGlyJzpcbiAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICBjYXNlICdkbCc6XG4gICAgICBjYXNlICdmaWVsZHNldCc6XG4gICAgICBjYXNlICdmaWdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2ZpZ3VyZSc6XG4gICAgICBjYXNlICdmb290ZXInOlxuICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgIGNhc2UgJ2hncm91cCc6XG4gICAgICBjYXNlICdtYWluJzpcbiAgICAgIGNhc2UgJ21lbnUnOlxuICAgICAgY2FzZSAnbmF2JzpcbiAgICAgIGNhc2UgJ29sJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAnc2VjdGlvbic6XG4gICAgICBjYXNlICdzdW1tYXJ5JzpcbiAgICAgIGNhc2UgJ3VsJzpcbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICBjYXNlICdsaXN0aW5nJzpcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgIGNhc2UgJ2hyJzpcbiAgICAgIGNhc2UgJ3htcCc6XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB2YXIgZGlkV2FybiA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRUZXh0LCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIGlmIChjaGlsZFRleHQgIT0gbnVsbCkge1xuICAgICAgd2FybmluZyhjaGlsZFRhZyA9PSBudWxsLCAndmFsaWRhdGVET01OZXN0aW5nOiB3aGVuIGNoaWxkVGV4dCBpcyBwYXNzZWQsIGNoaWxkVGFnIHNob3VsZCBiZSBudWxsJyk7XG4gICAgICBjaGlsZFRhZyA9ICcjdGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGludmFsaWRQYXJlbnRPckFuY2VzdG9yID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG4gICAgaWYgKCFpbnZhbGlkUGFyZW50T3JBbmNlc3Rvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbmNlc3RvclRhZyA9IGludmFsaWRQYXJlbnRPckFuY2VzdG9yLnRhZztcbiAgICB2YXIgYWRkZW5kdW0gPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYoKTtcblxuICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZyArICd8JyArIGFkZGVuZHVtO1xuICAgIGlmIChkaWRXYXJuW3dhcm5LZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5bd2FybktleV0gPSB0cnVlO1xuXG4gICAgdmFyIHRhZ0Rpc3BsYXlOYW1lID0gY2hpbGRUYWc7XG4gICAgdmFyIHdoaXRlc3BhY2VJbmZvID0gJyc7XG4gICAgaWYgKGNoaWxkVGFnID09PSAnI3RleHQnKSB7XG4gICAgICBpZiAoL1xcUy8udGVzdChjaGlsZFRleHQpKSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1RleHQgbm9kZXMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnV2hpdGVzcGFjZSB0ZXh0IG5vZGVzJztcbiAgICAgICAgd2hpdGVzcGFjZUluZm8gPSBcIiBNYWtlIHN1cmUgeW91IGRvbid0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uIFwiICsgJ2VhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJzwnICsgY2hpbGRUYWcgKyAnPic7XG4gICAgfVxuXG4gICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgfVxuICAgICAgd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgY2hpbGQgb2YgPCVzPi4lcyVzJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIHdoaXRlc3BhY2VJbmZvLCBpbmZvLCBhZGRlbmR1bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LiVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCBhZGRlbmR1bSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRPRE86IHR1cm4gdGhpcyBpbnRvIGEgbmFtZWQgZXhwb3J0XG4gIHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyQxO1xuXG4gIC8vIEZvciB0ZXN0aW5nXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG4gICAgcmV0dXJuIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnKSAmJiAhZmluZEludmFsaWRBbmNlc3RvckZvclRhZyh0YWcsIGFuY2VzdG9ySW5mbyk7XG4gIH07XG59XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmckMSA9IHZhbGlkYXRlRE9NTmVzdGluZztcblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG52YXIgY3JlYXRlVGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxO1xudmFyIHNldEluaXRpYWxQcm9wZXJ0aWVzID0gc2V0SW5pdGlhbFByb3BlcnRpZXMkMTtcbnZhciBkaWZmUHJvcGVydGllcyA9IGRpZmZQcm9wZXJ0aWVzJDE7XG52YXIgdXBkYXRlUHJvcGVydGllcyA9IHVwZGF0ZVByb3BlcnRpZXMkMTtcbnZhciBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzID0gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxO1xudmFyIGRpZmZIeWRyYXRlZFRleHQgPSBkaWZmSHlkcmF0ZWRUZXh0JDE7XG52YXIgd2FybkZvclVubWF0Y2hlZFRleHQgPSB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxO1xudmFyIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQgPSB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDE7XG52YXIgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCA9IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQkMTtcbnZhciB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQgPSB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQkMTtcbnZhciB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQgPSB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQkMTtcbnZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gdmFsaWRhdGVET01OZXN0aW5nJDEudXBkYXRlZEFuY2VzdG9ySW5mbztcbnZhciBwcmVjYWNoZUZpYmVyTm9kZSA9IHByZWNhY2hlRmliZXJOb2RlJDE7XG52YXIgdXBkYXRlRmliZXJQcm9wcyA9IHVwZGF0ZUZpYmVyUHJvcHMkMTtcblxuXG57XG4gIHZhciBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyA9ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO1xuICBpZiAodHlwZW9mIE1hcCAhPT0gJ2Z1bmN0aW9uJyB8fCBNYXAucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0ICE9PSAnZnVuY3Rpb24nIHx8IFNldC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5jbGVhciAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gTWFwIGFuZCBTZXQgYnVpbHQtaW4gdHlwZXMuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cDovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICB9XG59XG5cbmluamVjdGlvbiQzLmluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQoUmVhY3RET01GaWJlckNvbXBvbmVudCk7XG5cbnZhciBldmVudHNFbmFibGVkID0gbnVsbDtcbnZhciBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IG51bGw7XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSB2YWxpZCBub2RlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGlzIGEgdmFsaWQgRE9NIG5vZGUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSAnKSk7XG59XG5cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuICEhKHJvb3RFbGVtZW50ICYmIHJvb3RFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgcm9vdEVsZW1lbnQuaGFzQXR0cmlidXRlKFJPT1RfQVRUUklCVVRFX05BTUUpKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdidXR0b24nOlxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJldHVybiAhIXByb3BzLmF1dG9Gb2N1cztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBET01SZW5kZXJlciA9IHJlYWN0UmVjb25jaWxlcih7XG4gIGdldFJvb3RIb3N0Q29udGV4dDogZnVuY3Rpb24gKHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIHZhciB0eXBlID0gdm9pZCAwO1xuICAgIHZhciBuYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgdmFyIG5vZGVUeXBlID0gcm9vdENvbnRhaW5lckluc3RhbmNlLm5vZGVUeXBlO1xuICAgIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICAgIGNhc2UgRE9DVU1FTlRfTk9ERTpcbiAgICAgIGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcbiAgICAgICAge1xuICAgICAgICAgIHR5cGUgPSBub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/ICcjZG9jdW1lbnQnIDogJyNmcmFnbWVudCc7XG4gICAgICAgICAgdmFyIHJvb3QgPSByb290Q29udGFpbmVySW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgIG5hbWVzcGFjZSA9IHJvb3QgPyByb290Lm5hbWVzcGFjZVVSSSA6IGdldENoaWxkTmFtZXNwYWNlKG51bGwsICcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckluc3RhbmNlLnBhcmVudE5vZGUgOiByb290Q29udGFpbmVySW5zdGFuY2U7XG4gICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkgfHwgbnVsbDtcbiAgICAgICAgICB0eXBlID0gY29udGFpbmVyLnRhZ05hbWU7XG4gICAgICAgICAgbmFtZXNwYWNlID0gZ2V0Q2hpbGROYW1lc3BhY2Uob3duTmFtZXNwYWNlLCB0eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICB2YXIgdmFsaWRhdGVkVGFnID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIF9hbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHZhbGlkYXRlZFRhZywgbnVsbCk7XG4gICAgICByZXR1cm4geyBuYW1lc3BhY2U6IG5hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvIH07XG4gICAgfVxuICAgIHJldHVybiBuYW1lc3BhY2U7XG4gIH0sXG4gIGdldENoaWxkSG9zdENvbnRleHQ6IGZ1bmN0aW9uIChwYXJlbnRIb3N0Q29udGV4dCwgdHlwZSkge1xuICAgIHtcbiAgICAgIHZhciBwYXJlbnRIb3N0Q29udGV4dERldiA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgICAgdmFyIF9uYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnRIb3N0Q29udGV4dERldi5uYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgdmFyIF9hbmNlc3RvckluZm8yID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhwYXJlbnRIb3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgcmV0dXJuIHsgbmFtZXNwYWNlOiBfbmFtZXNwYWNlLCBhbmNlc3RvckluZm86IF9hbmNlc3RvckluZm8yIH07XG4gICAgfVxuICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgICByZXR1cm4gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKTtcbiAgfSxcbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSxcbiAgcHJlcGFyZUZvckNvbW1pdDogZnVuY3Rpb24gKCkge1xuICAgIGV2ZW50c0VuYWJsZWQgPSBpc0VuYWJsZWQoKTtcbiAgICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCk7XG4gICAgc2V0RW5hYmxlZChmYWxzZSk7XG4gIH0sXG4gIHJlc2V0QWZ0ZXJDb21taXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXN0b3JlU2VsZWN0aW9uKHNlbGVjdGlvbkluZm9ybWF0aW9uKTtcbiAgICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IG51bGw7XG4gICAgc2V0RW5hYmxlZChldmVudHNFbmFibGVkKTtcbiAgICBldmVudHNFbmFibGVkID0gbnVsbDtcbiAgfSxcbiAgY3JlYXRlSW5zdGFuY2U6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAge1xuICAgICAgLy8gVE9ETzogdGFrZSBuYW1lc3BhY2UgaW50byBhY2NvdW50IHdoZW4gdmFsaWRhdGluZy5cbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEodHlwZSwgbnVsbCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgcHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKG51bGwsIHN0cmluZywgb3duQW5jZXN0b3JJbmZvKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgICB9XG4gICAgdmFyIGRvbUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIHBhcmVudE5hbWVzcGFjZSk7XG4gICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgZG9tRWxlbWVudCk7XG4gICAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgcmV0dXJuIGRvbUVsZW1lbnQ7XG4gIH0sXG4gIGFwcGVuZEluaXRpYWxDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfSxcbiAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW46IGZ1bmN0aW9uIChkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gICAgcmV0dXJuIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpO1xuICB9LFxuICBwcmVwYXJlVXBkYXRlOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gICAge1xuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICBpZiAodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuICE9PSB0eXBlb2Ygb2xkUHJvcHMuY2hpbGRyZW4gJiYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgbmV3UHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKG51bGwsIHN0cmluZywgb3duQW5jZXN0b3JJbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgfSxcbiAgc2hvdWxkU2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHJldHVybiB0eXBlID09PSAndGV4dGFyZWEnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9PSBudWxsICYmIHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwgPT09ICdzdHJpbmcnO1xuICB9LFxuICBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlOiBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gISFwcm9wcy5oaWRkZW47XG4gIH0sXG4gIGNyZWF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICB7XG4gICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKG51bGwsIHRleHQsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gICAgfVxuICAgIHZhciB0ZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dE5vZGUpO1xuICAgIHJldHVybiB0ZXh0Tm9kZTtcbiAgfSxcblxuXG4gIG5vdzogbm93LFxuXG4gIG11dGF0aW9uOiB7XG4gICAgY29tbWl0TW91bnQ6IGZ1bmN0aW9uIChkb21FbGVtZW50LCB0eXBlLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgZG9tRWxlbWVudC5mb2N1cygpO1xuICAgIH0sXG4gICAgY29tbWl0VXBkYXRlOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIHByb3BzIGhhbmRsZSBzbyB0aGF0IHdlIGtub3cgd2hpY2ggcHJvcHMgYXJlIHRoZSBvbmVzIHdpdGhcbiAgICAgIC8vIHdpdGggY3VycmVudCBldmVudCBoYW5kbGVycy5cbiAgICAgIHVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCwgbmV3UHJvcHMpO1xuICAgICAgLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIERPTSBub2RlLlxuICAgICAgdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgIH0sXG4gICAgcmVzZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKGRvbUVsZW1lbnQpIHtcbiAgICAgIGRvbUVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgICB9LFxuICAgIGNvbW1pdFRleHRVcGRhdGU6IGZ1bmN0aW9uICh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgIHRleHRJbnN0YW5jZS5ub2RlVmFsdWUgPSBuZXdUZXh0O1xuICAgIH0sXG4gICAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB9LFxuICAgIGFwcGVuZENoaWxkVG9Db250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkKSB7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBjb250YWluZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgIH0sXG4gICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmU6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBoeWRyYXRpb246IHtcbiAgICBjYW5IeWRyYXRlSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFIHx8IHR5cGUudG9Mb3dlckNhc2UoKSAhPT0gaW5zdGFuY2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYW4gZWxlbWVudCBub2RlLlxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH0sXG4gICAgY2FuSHlkcmF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICBpZiAodGV4dCA9PT0gJycgfHwgaW5zdGFuY2Uubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgICAvLyBFbXB0eSBzdHJpbmdzIGFyZSBub3QgcGFyc2VkIGJ5IEhUTUwgc28gdGhlcmUgd29uJ3QgYmUgYSBjb3JyZWN0IG1hdGNoIGhlcmUuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhIHRleHQgbm9kZS5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9LFxuICAgIGdldE5leHRIeWRyYXRhYmxlU2libGluZzogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICB2YXIgbm9kZSA9IGluc3RhbmNlLm5leHRTaWJsaW5nO1xuICAgICAgLy8gU2tpcCBub24taHlkcmF0YWJsZSBub2Rlcy5cbiAgICAgIHdoaWxlIChub2RlICYmIG5vZGUubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSAmJiBub2RlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UpIHtcbiAgICAgIHZhciBuZXh0ID0gcGFyZW50SW5zdGFuY2UuZmlyc3RDaGlsZDtcbiAgICAgIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gICAgICB3aGlsZSAobmV4dCAmJiBuZXh0Lm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgJiYgbmV4dC5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfSxcbiAgICBoeWRyYXRlSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGluc3RhbmNlKTtcbiAgICAgIC8vIFRPRE86IFBvc3NpYmx5IGRlZmVyIHRoaXMgdW50aWwgdGhlIGNvbW1pdCBwaGFzZSB3aGVyZSBhbGwgdGhlIGV2ZW50c1xuICAgICAgLy8gZ2V0IGF0dGFjaGVkLlxuICAgICAgdXBkYXRlRmliZXJQcm9wcyhpbnN0YW5jZSwgcHJvcHMpO1xuICAgICAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIH0sXG4gICAgaHlkcmF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHRleHRJbnN0YW5jZSwgdGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dEluc3RhbmNlKTtcbiAgICAgIHJldHVybiBkaWZmSHlkcmF0ZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgfSxcbiAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0ZXh0KSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrOiBySUMsXG4gIGNhbmNlbERlZmVycmVkQ2FsbGJhY2s6IGNJQyxcblxuICB1c2VTeW5jU2NoZWR1bGluZzogIWVuYWJsZUFzeW5jU2NoZWR1bGluZ0J5RGVmYXVsdEluUmVhY3RET01cbn0pO1xuXG5pbmplY3Rpb24kNC5pbmplY3RGaWJlckJhdGNoZWRVcGRhdGVzKERPTVJlbmRlcmVyLmJhdGNoZWRVcGRhdGVzKTtcblxudmFyIHdhcm5lZEFib3V0SHlkcmF0ZUFQSSA9IGZhbHNlO1xuXG5mdW5jdGlvbiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjb250YWluZXIsIGZvcmNlSHlkcmF0ZSwgY2FsbGJhY2spIHtcbiAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAge1xuICAgIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciAmJiBjb250YWluZXIubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGhvc3RJbnN0YW5jZSA9IERPTVJlbmRlcmVyLmZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyLmN1cnJlbnQpO1xuICAgICAgaWYgKGhvc3RJbnN0YW5jZSkge1xuICAgICAgICB3YXJuaW5nKGhvc3RJbnN0YW5jZS5wYXJlbnROb2RlID09PSBjb250YWluZXIsICdyZW5kZXIoLi4uKTogSXQgbG9va3MgbGlrZSB0aGUgUmVhY3QtcmVuZGVyZWQgY29udGVudCBvZiB0aGlzICcgKyAnY29udGFpbmVyIHdhcyByZW1vdmVkIHdpdGhvdXQgdXNpbmcgUmVhY3QuIFRoaXMgaXMgbm90ICcgKyAnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnICsgJ1JlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUgdG8gZW1wdHkgYSBjb250YWluZXIuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QgPSAhIWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShyb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCkpO1xuXG4gICAgd2FybmluZyghaGFzTm9uUm9vdFJlYWN0Q2hpbGQgfHwgaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCwgJ3JlbmRlciguLi4pOiBSZXBsYWNpbmcgUmVhY3QtcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG5ldyByb290ICcgKyAnY29tcG9uZW50LiBJZiB5b3UgaW50ZW5kZWQgdG8gdXBkYXRlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsICcgKyAneW91IHNob3VsZCBpbnN0ZWFkIGhhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHVwZGF0ZSB0aGVpciBzdGF0ZSAnICsgJ2FuZCByZW5kZXIgdGhlIG5ldyBjb21wb25lbnRzIGluc3RlYWQgb2YgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIuJyk7XG5cbiAgICB3YXJuaW5nKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFIHx8ICFjb250YWluZXIudGFnTmFtZSB8fCBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQk9EWScsICdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgaWYgKCFyb290KSB7XG4gICAgdmFyIHNob3VsZEh5ZHJhdGUgPSBmb3JjZUh5ZHJhdGUgfHwgc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcik7XG4gICAgLy8gRmlyc3QgY2xlYXIgYW55IGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgaWYgKCFzaG91bGRIeWRyYXRlKSB7XG4gICAgICB2YXIgd2FybmVkID0gZmFsc2U7XG4gICAgICB2YXIgcm9vdFNpYmxpbmcgPSB2b2lkIDA7XG4gICAgICB3aGlsZSAocm9vdFNpYmxpbmcgPSBjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXdhcm5lZCAmJiByb290U2libGluZy5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RTaWJsaW5nLmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSkge1xuICAgICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChyb290U2libGluZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChzaG91bGRIeWRyYXRlICYmICFmb3JjZUh5ZHJhdGUgJiYgIXdhcm5lZEFib3V0SHlkcmF0ZUFQSSkge1xuICAgICAgICB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSB0cnVlO1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ3JlbmRlcigpOiBDYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIHRvIGh5ZHJhdGUgc2VydmVyLXJlbmRlcmVkIG1hcmt1cCAnICsgJ3dpbGwgc3RvcCB3b3JraW5nIGluIFJlYWN0IHYxNy4gUmVwbGFjZSB0aGUgUmVhY3RET00ucmVuZGVyKCkgY2FsbCAnICsgJ3dpdGggUmVhY3RET00uaHlkcmF0ZSgpIGlmIHlvdSB3YW50IFJlYWN0IHRvIGF0dGFjaCB0byB0aGUgc2VydmVyIEhUTUwuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBuZXdSb290ID0gRE9NUmVuZGVyZXIuY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lciwgc2hvdWxkSHlkcmF0ZSk7XG4gICAgcm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbmV3Um9vdDtcbiAgICAvLyBJbml0aWFsIG1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbiAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgbmV3Um9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gRE9NUmVuZGVyZXIuZ2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lcikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuICAvLyBUT0RPOiBwYXNzIFJlYWN0RE9NIHBvcnRhbCBpbXBsZW1lbnRhdGlvbiBhcyB0aGlyZCBhcmd1bWVudFxuICByZXR1cm4gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lciwgbnVsbCwga2V5KTtcbn1cblxuZnVuY3Rpb24gUmVhY3RSb290KGNvbnRhaW5lciwgaHlkcmF0ZSkge1xuICB2YXIgcm9vdCA9IERPTVJlbmRlcmVyLmNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIGh5ZHJhdGUpO1xuICB0aGlzLl9yZWFjdFJvb3RDb250YWluZXIgPSByb290O1xufVxuUmVhY3RSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5fcmVhY3RSb290Q29udGFpbmVyO1xuICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIHJvb3QsIG51bGwsIGNhbGxiYWNrKTtcbn07XG5SZWFjdFJvb3QucHJvdG90eXBlLnVubW91bnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIHJvb3QgPSB0aGlzLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihudWxsLCByb290LCBudWxsLCBjYWxsYmFjayk7XG59O1xuXG52YXIgUmVhY3RET00gPSB7XG4gIGNyZWF0ZVBvcnRhbDogY3JlYXRlUG9ydGFsLFxuXG4gIGZpbmRET01Ob2RlOiBmdW5jdGlvbiAoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gICAge1xuICAgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBvd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyO1xuICAgICAgICB3YXJuaW5nKHdhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgICAgb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgaW5zdCA9IGdldChjb21wb25lbnRPckVsZW1lbnQpO1xuICAgIGlmIChpbnN0KSB7XG4gICAgICByZXR1cm4gRE9NUmVuZGVyZXIuZmluZEhvc3RJbnN0YW5jZShpbnN0KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCBhcHBlYXJzIHRvIGJlIG5laXRoZXIgUmVhY3RDb21wb25lbnQgbm9yIERPTU5vZGUuIEtleXM6ICVzJywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSk7XG4gICAgfVxuICB9LFxuICBoeWRyYXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IHRocm93IG9yIHdhcm4gaWYgd2UgY291bGRuJ3QgaHlkcmF0ZT9cbiAgICByZXR1cm4gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCB0cnVlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCBmYWxzZSwgY2FsbGJhY2spO1xuICB9LFxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcbiAgICAhKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIGhhcyhwYXJlbnRDb21wb25lbnQpKSA/IGludmFyaWFudChmYWxzZSwgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB2YXIgcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0ID0gcm9vdEVsICYmICFnZXRJbnN0YW5jZUZyb21Ob2RlJDEocm9vdEVsKTtcbiAgICAgICAgd2FybmluZyghcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0LCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpO1xuICAgICAgfVxuXG4gICAgICAvLyBVbm1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbiAgICAgIERPTVJlbmRlcmVyLnVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBudWxsLCBjb250YWluZXIsIGZhbHNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLy8gSWYgeW91IGNhbGwgdW5tb3VudENvbXBvbmVudEF0Tm9kZSB0d2ljZSBpbiBxdWljayBzdWNjZXNzaW9uLCB5b3UnbGxcbiAgICAgIC8vIGdldCBgdHJ1ZWAgdHdpY2UuIFRoYXQncyBwcm9iYWJseSBmaW5lP1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIF9yb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEoX3Jvb3RFbCAmJiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEoX3Jvb3RFbCkpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuICAgICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXIubm9kZVR5cGUgPT09IDEgJiYgaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIucGFyZW50Tm9kZSkgJiYgISFjb250YWluZXIucGFyZW50Tm9kZS5fcmVhY3RSb290Q29udGFpbmVyO1xuXG4gICAgICAgIHdhcm5pbmcoIWhhc05vblJvb3RSZWFjdENoaWxkLCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG5cbiAgLy8gVGVtcG9yYXJ5IGFsaWFzIHNpbmNlIHdlIGFscmVhZHkgc2hpcHBlZCBSZWFjdCAxNiBSQyB3aXRoIGl0LlxuICAvLyBUT0RPOiByZW1vdmUgaW4gUmVhY3QgMTcuXG4gIHVuc3RhYmxlX2NyZWF0ZVBvcnRhbDogY3JlYXRlUG9ydGFsLFxuXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcblxuICB1bnN0YWJsZV9kZWZlcnJlZFVwZGF0ZXM6IERPTVJlbmRlcmVyLmRlZmVycmVkVXBkYXRlcyxcblxuICBmbHVzaFN5bmM6IERPTVJlbmRlcmVyLmZsdXNoU3luYyxcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIC8vIEZvciBUYXBFdmVudFBsdWdpbiB3aGljaCBpcyBwb3B1bGFyIGluIG9wZW4gc291cmNlXG4gICAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLFxuICAgIC8vIFVzZWQgYnkgdGVzdC11dGlsc1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50UGx1Z2luUmVnaXN0cnksXG4gICAgRXZlbnRQcm9wYWdhdG9yczogRXZlbnRQcm9wYWdhdG9ycyxcbiAgICBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQ6IFJlYWN0Q29udHJvbGxlZENvbXBvbmVudCxcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWU6IFJlYWN0RE9NQ29tcG9uZW50VHJlZSxcbiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXI6IFJlYWN0RE9NRXZlbnRMaXN0ZW5lclxuICB9XG59O1xuXG5pZiAoZW5hYmxlQ3JlYXRlUm9vdCkge1xuICBSZWFjdERPTS5jcmVhdGVSb290ID0gZnVuY3Rpb24gY3JlYXRlUm9vdChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgaHlkcmF0ZSA9IG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmh5ZHJhdGUgPT09IHRydWU7XG4gICAgcmV0dXJuIG5ldyBSZWFjdFJvb3QoY29udGFpbmVyLCBoeWRyYXRlKTtcbiAgfTtcbn1cblxudmFyIGZvdW5kRGV2VG9vbHMgPSBET01SZW5kZXJlci5pbmplY3RJbnRvRGV2VG9vbHMoe1xuICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGJ1bmRsZVR5cGU6IDEsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ3JlYWN0LWRvbSdcbn0pO1xuXG57XG4gIGlmICghZm91bmREZXZUb29scyAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcbiAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG4gICAgICBpZiAoL14oaHR0cHM/fGZpbGUpOiQvLnRlc3QocHJvdG9jb2wpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnJWNEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyArIChwcm90b2NvbCA9PT0gJ2ZpbGU6JyA/ICdcXG5Zb3UgbWlnaHQgbmVlZCB0byB1c2UgYSBsb2NhbCBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBmaWxlOi8vKTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzLWZhcScgOiAnJyksICdmb250LXdlaWdodDpib2xkJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG52YXIgUmVhY3RET00kMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdERPTVxufSk7XG5cbnZhciBSZWFjdERPTSQzID0gKCBSZWFjdERPTSQyICYmIFJlYWN0RE9NICkgfHwgUmVhY3RET00kMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3REb20gPSBSZWFjdERPTSQzWydkZWZhdWx0J10gPyBSZWFjdERPTSQzWydkZWZhdWx0J10gOiBSZWFjdERPTSQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0RG9tO1xuICB9KSgpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF9oeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanNcbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9